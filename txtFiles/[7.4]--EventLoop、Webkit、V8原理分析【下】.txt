1

噔噔噔噔噔噔噔噔噔噔噔噔噔噔噔噔

2

嗯

3

What

4

人都到齐了没

5

怎么就这么几个人儿

6

还没一半儿呢

7

这

8

这家伙得

9

你们真够意思

10

别急

11

能不急吗这

12

咱们那个准备了开始啦

13

今天呢

14

是那个什么什么人人干啥呢

15

这莫名其妙的

16

咱们开始啦

17

不等他们那个

18

这节课呢

19

咱们讲那个V8V8引擎

20

然后那个V8引擎源码

21

还有那个上节课咱们提到过的那个lab的那个源码

22

一个是C的源码

23

一个是C加加的源码

24

那个你还替五个点到这个这个这个不许替

25

咱们先先说这个V8引擎V8引擎呢

26

这个玩意儿

27

是个好东西

28

那个这个东西可以说这个这个就不用夸他了

29

好到咱们都知道

30

像那个

31

像这个这个V8引擎呢

32

浏览器里

33

那个Chrome浏览器里边儿嵌嵌入这个东西

34

另外呢

35

像那个note JS也嵌入了

36

这是咱们知道的

37

实际上还有好多咱们不知道的

38

不知道的那种那种那个系统里边儿

39

也欠了这个V8这个V8是欠欠的V8干什么

40

拿它当解释器有一些那个嵌入式的那种系统

41

比如说像像一些那个嵌入式的板子

42

那种那种开发板那种板子上像做开发版的那些厂商呢

43

它在里边儿

44

就加了他

45

他在他给那个他给那个板子呢

46

就开就开发出那个

47

开发出那个一个定制出一个专专用的系统来然后呢

48

你可以用这个JS

49

你可以用JS去去去给那个板子去去去做开发这JS那种嵌入式那个里边儿他也那个系统里边他也给你欠了这个V8引擎

50

但只不过他他欠的他他那个他欠的方式就不一样了另外还有好多的那种那些像像像一些那个可以用这种脚本驱动的一些一些系统

51

你你比如说用用那个JS脚本驱动的内这种系统就太多了

52

他里边儿也欠这个V8所以说这个这个V8

53

他是一个神器如果说我们去去去研究一下他这个源码

54

比如说像像这个是是是在哪儿呢

55

一我那个那个那个

56

我这个目录哈

57

在这儿呢

58

比如说我们看一眼那个V8的这个这个源码

59

去找他的那个simple

60

就是他的例子

61

我们就可以看到

62

像像这些用C加加写的

63

用C加加写的这些这些源码

64

他就是给你做了一个样子告诉你

65

怎么在你自己的程序里边儿把这个把这个V8给嵌进去所以说

66

这这这个东西

67

这个东西的出现

68

那那简直是绝了

69

这这这这这就是整个的那个嵌嵌进去的流程

70

倩倩进去之后你就不用管它了

71

所以说呢

72

那个no的

73

所以说那个note JS呢

74

它里边儿一个核心

75

这这东西他都根本就不用写

76

对吧

77

直接拿过来往里一倩行了

78

弄得JS有了

79

然后一问他了

80

把那个lab Le拿过来往里往里一塞

81

剩下的就是他去写那个班钉子

82

把benz写写

83

然后把周围的一些那个库还有接口设计一下

84

弄的JF就出来了

85

那这个在讲那个这个微吧之前

86

咱们先回顾一下原来给大家讲过的这个web kit这个web kit呢

87

再讲那个浏览器渲染机制的时候

88

给大家讲过

89

当时那个图呢

90

不如这个图的

91

这个不如这个图复杂

92

这个图东西更多

93

当时给大家看的就就那么几大块儿

94

那么这个渲染引擎里边儿

95

像那个web k啊

96

这个渲染引擎里边

97

他欠的这个JS引擎叫JS号

98

这个JS靠的是是苹果的

99

是那个Apple他他们开发的

100

当然这个Apple开发的这个JS扣呢

101

它也是开源的

102

他也开源

103

但是呢

104

当时啊

105

当时那个他他开源晚了

106

开源的比较晚

107

V8先开源

108

然后那个Apple他也开源

109

所以那个V8有先发优势

110

当然JS扣和那个V8它们有各自的

111

他们各自有各自的这个这个特点

112

他们内部实现的

113

内部的在在内部这个实现当中呢

114

也有很多差异

115

但是呢

116

他们这个语法支持都都是一样的

117

都是按照那个规范走的

118

就是那个JS的那种提案

119

GS提案一旦一旦去敲定了

120

一旦敲定了

121

然后然后大家都都去按照那个提案去去实现

122

那么这个在Chrome

123

Chrome这这这这个这个浏览器里边儿

124

它的这个渲染引擎就是脱胎于web kit这个框架

125

这个大框架是一模一样的

126

但是呢

127

但是呢

128

他的那个把里边好多东西全都给替换了

129

内内代码一点一点替换

130

这这已经十多年了

131

这这十多年这十多年替换来替换去的

132

现在原来的代码基本上没什么了那咱们今天那个重点就是就是这一块儿不当然不讲这个JS

133

靠

134

是给大家讲那个这个微吧那一块儿的

135

然后

136

JS引擎

137

JS引擎和那个渲染引擎

138

那在浏览器里边儿

139

它结合的是非常的

140

它结合的是非常非常紧密的那他紧密到它紧密到什么程度呢

141

可以说

142

是你中有我

143

我中有你因为咱们再给大家讲那个浏览器渲染机制的时候

144

咱们去给大家讲那个流程不知道大家还记不记得讲那个流程那个那个页面儿

145

进入到浏览器里边儿去

146

进入到这个渲染引擎先干什么

147

那他先去解析到母解析到母如果说遇到了JS

148

遇到了JS怎么办

149

他会暂停解析盗墓当时给大家讲为什么会这样呢

150

对吧

151

为什么会会暂停

152

因为当时给大家给大家说

153

这是由于这两这两个引擎

154

JS引擎和那个和盗墓解析内两块儿他们的

155

这个他们之间这个同步的这个

156

同步的机制造成的

157

至于那个同步机制是咋回事呢

158

咱们现在给大家说这个那么那个渲染引擎

159

实际上渲染引擎他是依赖这个JS引擎的

160

要要注意

161

渲染引擎是依赖JS引擎

162

那是内内上节课

163

咱们不是给大家讲那个那个那个异步机制的时候

164

给大家提了一下那个UML对吧

165

简单的给大家讲了一下那个那个那个类图

166

实际上这种这两个引擎

167

这两个引擎他们之间的关系

168

如果说用那个用那个类图画怎么画呢

169

咱们画两个框

170

画两个框

171

然后呢

172

这个是这个是渲染引擎render对吧

173

咱们用R来表示

174

然后这个是JSJJJS引擎咱们用G来表示

175

然后它们之间的依赖

176

是渲染引擎

177

他依赖JS引擎

178

是是这么一个关系

179

那是这么关系

180

并不是说这个JS引擎就就就是是并不是说JS引擎属于这这个这这个渲染引擎一部分不是不是这样

181

就是两个独立的

182

那也就是说呢

183

既然渲染引擎要要依赖

184

JS引擎

185

那就是渲染引擎

186

它要去掉JS引擎的接口

187

这是直接掉

188

直接去调这个接口是吧

189

那么

190

在咱们最最开始

191

我把原来那个PPT也打开

192

咱们对照着看那个PPT

193

那个那个渲染机制的那个PPT

194

渲染机制

195

渲染机制呢

196

坏了

197

找不着了

198

显然

199

这俩不在一个地方

200

等等我想想

201

那个那个PPT放在哪儿了

202

渲染机制

203

找不见了

204

稍等一分钟

205

我我我那个找一下

206

嗯

207

在性能优化这

208

在这儿

209

在这个地方

210

在这个地方

211

那么那个渲染在在那个

212

咱们将刚才讲到讲到这儿

213

渲染引擎它是直接调JS引擎的这个接口儿来处理那个来处理里边儿那个那个结果

214

然后呢

215

然后呢

216

在咱们的这个图里边儿

217

咱们当时还给大家说过

218

像那个AJS的这个解释器和

219

到母树这个数据

220

他们之间哈是个双向箭头

221

对吧

222

这是个双向箭头

223

那说明什么呢

224

也就是说JS引擎他还会反过来影响这个盗墓数咱们在解析盗墓的时候

225

遇到JS这样去掉

226

按照这个方向就过来

227

然后呢

228

当这个JS代码

229

JS代码需要用到

230

需要用到那个这个这个这个盗墓的结构的时候

231

就要这样去回去那么这时候

232

咱们在编码的时候

233

这种情况咱们在编码的时候就会就会遇到一个麻烦这个麻烦叫什么

234

叫循环调用

235

他叫循环调用

236

也就是说你掉我

237

然后我再调你

238

我调了你

239

你再回来调我这叫双方互双方互相去掉

240

那么这种循环调用将会导致一个非常严重的后果

241

这个后果呢

242

就是死锁

243

就会死住了

244

那它就相当于什么呢

245

那

246

它就相当于什么呢

247

渲染引擎调调这个JS

248

然后JS直接接口去掉

249

然后JS反过来再去

250

调这个渲染引擎里边的东西

251

那这样转了一个圈

252

那转圈的时候

253

如果说JS在正在吊着这个渲染引擎的时候

254

渲染引擎又回来去再去调这个JS反复的多次去掉这个JS2JS呢

255

这这这一块儿还没调完呢

256

然后渲染你又来调

257

这个时候必定产生死锁必定产生死锁

258

所以呢

259

要解决这个问题

260

要要那那怎么去解决呢

261

在这个这在这个这个浏览器里边儿

262

它用了一个特殊的这么一个方式这个方式是什么

263

就是桥街街口

264

桥接接口

265

那么这个桥接接口是什么意思呢

266

并不是说渲染引擎然后直接过来

267

并不是说JS引擎直接过来去去去改这个渲染引擎里边东西

268

而是呢

269

中间来一个中间商

270

来个中间商

271

然后这个中间商干什么呢

272

JS引擎像这个条街街口去发消息

273

我要去改

274

我要去改动哪一个

275

到这个盗墓节点

276

然后呢

277

我不亲自改

278

你给我把这个话传过去

279

传到渲染引擎

280

让渲染引擎去去给我处理a

281

通过这种方式

282

通过这种方式咱们就可以

283

咱们就可以避免这个循环调用的这个问题

284

那他的这个流程是是是是怎么样的呢

285

首先渲染引擎它就解析到母解析盗墓的

286

解析到JS的时候

287

通过JS的调用接口

288

然后呢

289

把这个JS代码传给JS引擎这是

290

这是这是在这儿对吧

291

这是向下的那个箭头

292

到亩数和这个解释器

293

JS解释器向下的这个箭头

294

然后呢

295

JS引擎他就要执行这段代码了

296

那你要用这段代码去操作一个到目的节点呢

297

那那你你去操作到我们节点的话

298

那好

299

你把这个操作

300

操作的这个规则

301

通过桥接接口儿传回来再传回来

302

那实际上呢

303

这是发了一个数据过去

304

或者说发了一个命令

305

发了一个指令过去

306

并不是直接通过

307

并不是直接通过那个接口去掉的那这样呢

308

咱就

309

这样咱就不会死所了

310

那么这个调用方式它究竟是怎么实现的呢

311

还还记不记得上节课上节课给大家给给给大家讲讲那个疑问句luck的时候

312

给大家提到了这个东西MFC

313

对吧

314

给大家提到了这个MFC

315

那么这个MFC他用的是消息传递机制

316

那么实际上这一套规则和那个消息传递机制

317

有点儿像有点儿像

318

但不完全像那个消息传递机制他是个大消息循环

319

它里边儿她她她她也跟那个跟那个F的那个机制类似

320

但是呢

321

这个地方呢

322

它它没有那个消息循环了

323

你就直就直接消息传过来

324

他在这儿被动的去被动的去那个去接收指令

325

然后然后去做事儿就行了

326

就按照按按和这个

327

消息是差不多

328

那么他传的消息是什么呢

329

怎么操作什么分仍然是分两块儿

330

一个是指令部分

331

一个是指令部分

332

一个是数据部分就是干什么

333

删除节点对吧

334

或者说移动节点

335

或者说增加节点

336

这是那个指令

337

那么你要删除删除哪个节点

338

这是数据

339

对吧

340

然后移动节点

341

你要把哪个节点移动到什么地方

342

这也是数据

343

你要你要你要那个增加结点

344

增加的节点增加到哪儿那增加的那个节点他长什么样

345

这这也是数据

346

所以说呢

347

所以说呢

348

用这种方式

349

用这种方式并不是JS引擎直接去调渲染引擎的接口了

350

而是走这个桥街中间搭了个桥

351

中间搭了个桥

352

我不直接去掉这这叫桥接那么这种这种东西是咱们那个在各种系统里边

353

在这个底层开发里边儿

354

各种系统里边都是都是比较常见的

355

比如说在Linux里边儿也有类似的这个

356

也有类似的这个机制

357

他叫什么

358

他叫slot

359

这这这这种Linux

360

你去做这个

361

你去做那个界面儿

362

界面儿那个开发

363

他没有消息循环对吧

364

他给你提供这个slot

365

他叫什么槽他叫曹

366

这个东西在在在哪儿呢

367

就是QT哈内那个QT

368

QT呢

369

这这这这个开发工具里边给给提供的

370

它也是封装的

371

也是封装的这个东西

372

实际上他底层它底层是恶风

373

装的是啥啥啥玩意儿信号

374

通过信号去那个啥桥接会有就会有啥作用

375

我刚讲完

376

我刚讲完你就问桥接会有啥作用

377

桥接就是你不用为了防止这个死锁

378

你在调用的时候死所

379

你渲染引擎掉了JS引擎的API

380

然后你在这个APIJSAPI里边儿

381

你在反过来调渲染引擎

382

这必定死所不信

383

你自己写写个代码

384

是是你写两个函数

385

函数一调函数二

386

然后函数二再调函数一

387

你试试呢

388

必定你的程序就不动了

389

那100%它不动了

390

你这这这这这这活是不能这么干的

391

有会有啥作用呢

392

就是这作用

393

防止这种防止这种情况

394

那因为这种这种工作

395

是是有有两个模块儿配合

396

有两个模块配合去完成的

397

你你你还要防止这个恶锁住

398

那那不得了

399

你你等我做完

400

我也等你做完来互相等

401

那那就那就玩不了了

402

这就是为了这个

403

那么这个JS引擎

404

JS引擎和那个

405

渲染引擎他们之间的这个调用关系

406

咱咱们咱们聊聊解了之后

407

然后呢

408

咱们看咱们就到那个JS引擎内部

409

看看它内部的那个

410

它内部的工作流程

411

这个渲染引擎

412

咳咳

413

这个这个JS引擎

414

那他原来

415

最很早之前那个JS引擎

416

他和现在他那个内部实现机制是完全不一样的

417

那在V8出现之前

418

也有很多的这个JS引擎的

419

比比如说像那个像那个华为华为那个鸿蒙对吧

420

原来也给大家也给大家提过

421

那个鸿蒙系统呢

422

他做他做那个界面的

423

他他他他他自己提供的那个做做界面的那个那个功能它实际上和和那个小程序是类似的

424

对吧

425

和小程序那个和小程序的那个内套机制是类似的

426

那是类似的

427

你你就你就只能用JS去给他写界面

428

那么那个鸿蒙再再再那个发布的那天

429

发布的那天

430

然后我去研究它的代码

431

研究到那个凌晨一点

432

我在干什么

433

我就在在找她那个我我就看他一个模块一个模块地看然后呢

434

就看到他那个UI部分

435

UI部分一看

436

赫赫小程序的架构是是类似的

437

那他肯定肯定需要JS引擎

438

然后我就找他那个JS引擎

439

我看他引的是哪一个库

440

我看了半天

441

发现不是note JS啊

442

而是一个叫什么quick JS叫quick JS

443

那个东西

444

像这种这种JS引擎特别特别特别多

445

非常非常多

446

但是那个quick JS比那个代码量是非常非常少的

447

比这个VBA的代码量呢

448

那少的不少的呢

449

可能是那可以说是两个数量级

450

那可以可以说俩数量急了

451

那但是那个quick he s he hev8比起来

452

她差在哪儿呢

453

那他差在哪儿呢

454

他就差在内存内存管理上

455

那个quick JS的内存管理

456

他恶他可以交给别人去做

457

他可以教给别人

458

他他自己不去管

459

它就是实现什么

460

它就是实现语法的解释

461

他也没有字节码

462

KGS他他也不弄字节码

463

那个是一个比较简陋的

464

实际上那个KDS

465

你你把那个包下载下来

466

你看那个

467

你你看那个

468

你看一下它的大小

469

压缩包就几十K

470

那么这个V8的这个源代码呢

471

VBA源代码呢

472

那可大了去了

473

对吧

474

H我那个那个咋又没了

475

又找不着了

476

V8的源码我们看V8

477

看一下微微吧

478

源码有有多大

479

31兆

480

31压缩包

481

31赵

482

Quick quick he s就几十K这这差了四四个数量级

483

对吧

484

X的四个数量级也就是差了四个零的

485

所以呢

486

就看它的功能看它的功能

487

那么JS引擎发展到今天

488

它在虚拟计划

489

他像虚拟机那个方向发展

490

那虚拟机话

491

它就像啥了

492

它就像Java了

493

那咱们那个去去做那个Java开发的时候

494

实际上Java它本身是跨平台的

495

那对吧

496

当然JS他也是跨平台的

497

但是早期JS跨平台和Java跨平台

498

他们的实现机制是不一样的

499

那JS这个Java跨平台

500

他是给你弄出一个虚拟虚拟机来

501

然后他有自己的那个

502

Java他有自己的那个虚拟机的质量

503

那么JS呢

504

JS就是个解释器

505

那么这个解释器它就直接去调用底层的相关的这个函数

506

它就给你隔了一层

507

就给你隔了这么一层

508

那这这样这这这两种在初期看上去a都是跨平台

509

但是呢

510

底层实现不一样

511

但是现在呢

512

JS引擎越来越像那个Java虚拟机

513

Java虚拟机叫什么

514

叫GM对吧

515

那JS引擎哪像Java虚拟机了

516

她也加上了这个字节码

517

也有了自解码

518

那么Java虚拟机在很久之前

519

它的性能是比较低的

520

所以说要性能的那种那种系统还是用

521

用C加加做的多

522

后来呢

523

Java不断的去不断的去那个

524

Java不断的去进行优化优化以后呢

525

Java把j it加上了

526

那加上j it它的那个性能就和C加加的那个性能就差不多了

527

对吧

528

就他他就差不多了

529

而这个JS呢

530

A发展到了今天

531

JS发展到了今天

532

然后呢

533

他也把那个玩意儿给夹上了

534

也把JSJS也加上了

535

然后呢

536

在JS引擎里面

537

他也有这个字节码

538

这两个东西

539

他他们这是这个这他们他们之间这个这个实现

540

这个实实现机制是越来越像

541

所以说呢

542

这个到今天这个JS

543

这个JS这个解释器

544

他就不能叫解释器了

545

越看越像虚拟机

546

那么在这个JS解释器里边儿

547

它究竟是究竟是怎么个处理方式呢

548

他怎么他他是他他是那个流程是个什么样的呢

549

那首先呢

550

我们JS也好

551

Java也好

552

对吧

553

像像像像这些东西呢

554

你都必须有原代码

555

Java还有C语言这些源代码

556

你必须得编译

557

那编译成那个过对应的那个机械码或者字节码

558

但是JS呢

559

直接扔进去

560

扔进去最早是交给解释器的

561

那么解释器这一步他得做一个动作

562

做什么动作呢

563

做

564

生成抽象语法树

565

生成这个东西

566

那么这个东西是啥呀

567

它是属于编译原理里边的东西呢

568

那么它干什么用呢

569

我们写的这个源代码

570

源代码就是就就就就这个样子一行一行的

571

那么这个编译器

572

他怎么把你的源代码给你转换成a

573

转换成那个解释器

574

还有虚拟机能够理解的东西呢

575

怎么去转得

576

经过经过一个中间的数据结构

577

这个数据结构就是抽抽象语法树

578

那么这个抽象语法树它究竟

579

是什么样的呢

580

那他树结构它是个树结构

581

但是呢

582

和我们平时所想象的那个树结构不一样

583

我们平时所看到的树结构是啥样的

584

比如说二叉树

585

对吧

586

二叉树是这样的二叉树

587

这这这画了一个那个平衡二叉树

588

玩画画一个完全二叉树

589

然后这这是个满二叉树对对吧

590

二叉树这样的

591

那那你那个这个N叉树对吧

592

N叉树咱咱咱咱咱咱就这么就这么分差去

593

这是咱们一般

594

这是咱们一般的那个

595

一般理解的那个那个那个二叉树

596

那这个抽象语法树

597

他他长得

598

尽管他也是个数

599

但是它长得和我们平时所想的这个

600

这个结构差区别还挺大

601

他更像个什么

602

他更像一个鸡毛掸子鸡毛掸子什么样

603

中间一根棍儿对吧

604

大家应该都见过鸡毛掸子中间一根棍儿

605

然后呢

606

上面有好多那个羽毛

607

好多好多羽毛这这这这这样的

608

然后弄成这些鸡毛掸子

609

那个抽象语法树更像个这个东西

610

那也就是说那个抽象语法树它长成这样有根节点

611

然后呢

612

又又有那个下级节点

613

下节点a分两叉分若干个差

614

对吧

615

分若干个差

616

然后还有下级节点a

617

然后下级节点

618

下节点它是有一条链儿给串下来

619

这个鸡毛掸子是有一条链儿给串下来

620

自始至终给串下来

621

然后呢

622

中间的这些节点

623

他给你分差这就像这是不是就像那个鸡毛掸子了对吧

624

他和咱们平时所想的那个数他是不一样的

625

它是有很大的那个在在这个形状是有很大的区别

626

但它仍然是个数对吧

627

仍然是个数这这这个是没问题

628

那么生成这种结构干什么

629

那这种结构

630

就要从那个编译原理开始开始说起了那么这种东西实际上涉及到一种那个逻辑

631

涉涉及到这个语法上的一个逻辑

632

实际上这种这种语言上的一种逻辑

633

在两千两三千年之前就有哲学家在考虑比如说像那个古希腊西方那些哲学家

634

他们在他们在2000多年前就开始就开始思考这个

635

然后呢

636

一直发展到今天

637

就是就生成就就就形成这么一套体系

638

形成了这么一套那个语言学上的这种逻辑体系

639

它那他们是想干什么

640

他们研究这个干什么

641

因为人的语言

642

它是会产生歧义的

643

对吧

644

它会产生歧义

645

比如说你去算个命

646

你去算命

647

那个算命的看看你一眼

648

然后呢

649

说你你你说那个你你算算我

650

哥几个算命的说什么

651

桃园三结义孤独一支对吧

652

这是有歧义的

653

那你怎么理解

654

你要说你你就搁一个对吧

655

他说什么

656

本来应该有撒

657

但是呢

658

就孤独初拟一个来

659

这是一种解释

660

你要说搁俩呢

661

本来要要有撒

662

但是呢

663

给孤独下一个去

664

你要说有哥仨呢

665

哥仨呢

666

就是这不桃园三结义

667

全在一个根儿上

668

你要哥四个呢

669

本来是哥仨

670

然后又孤独出一个来对吧

671

这是自然语言

672

咱们咱们这个自然语言的一个一个问题呢

673

它会产生歧义

674

但是你让机器去执行这种东西的话

675

是不能有歧义的

676

尤其是这玩意儿它是底层的

677

所以呢

678

就

679

必须得用那种逻辑

680

用那种逻辑方式去生成这个语法树是吧

681

那么这个语法树

682

生成了以后

683

他应该是非常严密的

684

算命的都是大忽悠

685

那可不都是大忽悠吗

686

对吧

687

你要听听那个啥

688

这这个段子是是那个侯宝林说的

689

侯宝林的那个相声里边儿的

690

桃园三结义孤独一支

691

还有还有什么呢

692

还有就是那个什么负债母先死

693

就是说那个家里家里老人谁还在

694

对吧

695

那个是是是老爷子在还是还是老太太在父在母先死

696

这也有歧义

697

对吧

698

所以说就要

699

所以说就要就要消除这些奇异

700

生成这个语法抽象树

701

就是消除歧义

702

然后呢

703

给下一步去做准备

704

那么生成这个东西

705

生成的语法抽象树

706

它是按照一个什么样的规则

707

规则去去生成的呢

708

比如说咱们咱们到这个代码这儿

709

咱们到这个代码这

710

咱们随便儿找那么一个函数

711

随便找个函数找个长点的函数

712

比如说这这个函数

713

这个函数体在这儿

714

这个是C语言风格的缩进这个这这是那个

715

在这儿

716

然后呢

717

比如说咱们一行一行的

718

一行一行的那一行语句

719

咱们要注意一行语句一条语句就带他就对应着啥呀

720

他就对应着这上面的一个节点

721

一条语句就对应一个节点

722

然后呢

723

又一条语句又一个节点

724

又一条语句又一个节点如果说你这里边儿

725

这语句这语句里边儿

726

你你是在这儿赋值的负值的

727

那这个副职

728

这个变量你就要挂在这个之上

729

这个变量就要挂在这个之上

730

你要判断

731

这是一个节点

732

然后判断

733

一个变量你挂在这个之上

734

另一个变量挂在挂在另外一个之上

735

然后一个操作挂在一个之上

736

一条语句它就是其中一个节点

737

然后语句里的细节就在这儿开始分叉

738

然后啊

739

然后如果说你有循环对吧

740

你有循环

741

那你有循环的话

742

那好

743

那这个节点它就复杂一点

744

然后这个节点它在分支

745

他在分好多叉

746

又分好多叉

747

但是呢

748

他不是主干

749

主干仍然是要回到这儿来

750

实际上这个这这个循环对吧

751

这个循环这是一个大循环语句

752

这是个大循环语句

753

那么大循环语句里面有好多好多好多赋值语句

754

还有判断语句那赋值语句

755

那这个大循环语句在整个的这个在整个的这个主干上

756

他分出一个大分支来那么这个大分支

757

然后它里边再分出一个那个稍微小一点儿的大分支

758

这个对应谁对应对应条件判断a

759

然后条件判断里边它它又分好多支

760

然后这个一幅这个for循环这段代码块儿执行完了

761

他处理完了

762

然后再回到这个主干上

763

然后继续往下走

764

实际上这个数

765

这个数就是就是为了去把这些代码

766

给换个形式

767

把这个东西给换个形式

768

换个形式

769

然后呢

770

让给下一步去处理

771

你不这样去做

772

你不这样去做

773

计算机它是一它它是它是理解不了这种语法的

774

那他只能与理解什么

775

只能理解那种汇编那种形式的哈语法要先把这个东西转成

776

转成那种转乘这个数

777

然后呢

778

再由这个数这种这种结构按照规则在在转成汇编那种形式这样一来呢

779

这样一步一步的去走

780

一步一步的去走

781

这这这样

782

这样咱们这样才行哈那

783

咳

784

那接下来

785

咱们把这个语法抽象数

786

把他给把他给那个搞清楚了

787

搞清楚了之后呢

788

接下来干什么呢

789

接下来现在

790

就是现在的那个

791

就是现在的这个微吧

792

现在的这个JS引擎

793

那你把抽象出数弄好了

794

那就转成字节码转成字节码

795

你转成字节码

796

实际上现在V8他就是个虚拟机

797

V8就是个虚拟机

798

现在呢

799

要不然你要字节码干什么

800

对吧

801

之前他是没有字字节码的

802

那些那些那个老引擎它是没有这个字节码的

803

那实际上字节码是在干啥呀

804

他是为了隐藏底层特性

805

为了隐藏底层特性

806

他就不直接去去掉谁调操作系统的那些API

807

对吧

808

它隐藏在那个虚拟机层之下

809

然后这样他他好划分

810

字节码就跑在这个虚拟机层然后呢

811

虚拟机层之上

812

你你就去去就去做那个那个编译过程

813

对吧

814

他的那个内部编译过程然后虚拟机之下呢

815

你再去你再去分别针对不同的这个操作系统

816

你在统一封装什么

817

再统一封装这个调用接口

818

是吧

819

这样呢

820

分层很清晰

821

而且能把这个能把这个活儿分给不同的

822

这个分给不同的人去做去这个这样分活儿也好分这这是属于那个软件

823

这个这个这个

824

内内叫那个项目管理里边儿的那个那个东西了

825

然后咱们把那个生成语法抽象树生成字节码

826

这个字节码就是跑在V8救救它就相当于跑在V8这个虚拟机里的汇编不是会边跑在V8虚拟机里的那个机器指令

827

虚拟机是什么

828

跟你虚拟出一个CPU来

829

这叫虚拟系那字节码

830

它就相当于跑在这个虚拟出来的这个CPU上的那个机器质量然后然后干什么呢

831

然后解析器然后解析器V8这个恶微吧

832

里边儿用这个解析器去他去执行了

833

在在这儿去执行那个

834

去去执行你的这个源代码是实际上在这儿呢

835

这这是解析器

836

那么在之前只有这个解析器

837

这是之前是直接这样抽象语法树

838

然后交给解析器

839

这是之前

840

现在呢

841

交给自己生成字节码

842

再交给解析器

843

解析器在在虚拟机里

844

把它包在虚拟机里去了

845

这是那个流程

846

那么这个JS

847

你在创建新对象的时候吧

848

创建新对象的时候

849

那那

850

那是怎么弄的呢

851

他那内存它是怎么管理的呢

852

这个时候是是有什么

853

有垃圾回收机制

854

就是那个GCGC在这个地方

855

是吧

856

那这个GC它是一个独立的这么一个东西

857

他不他不搀和这个解析器的工作

858

当进行GC的时候

859

那么这个解析器他的工作就要暂停

860

那他就要暂停

861

同样是防止内啥

862

防止那个死锁或者是产生脏数据

863

然后咱们再看

864

咱们再看另外一个

865

再看另外一个分支

866

现在又加上什么了

867

又加上几

868

又加上这个j it了

869

It是什么意思

870

Just in time

871

没有啊

872

它的全称是Justin time

873

其实就是即时编译

874

那这个即时编译是什么

875

直接把这个东西

876

直接把这个这个源代码编译成机器的本地代码

877

我们要注意字节码和本地代码这俩是什么区别

878

字节码是什么

879

他是跑在那个虚拟机里的

880

他是跑在虚拟机里的那个东西

881

这是字节码

882

那本地代码呢

883

他是跑在

884

CPU上的

885

这是本地代码

886

是吧

887

这个就快多了

888

对吧

889

他是直接直接给直接给直接给CPU了

890

而这个字节码呢

891

中间还隔着一层的

892

中间还隔着一层那个虚拟机呢

893

是吧

894

本地当然是真实的啦

895

就是二进制

896

就是二进制代码

897

就和你C语言的那个代码

898

C语言编译出来的那个代码

899

他他性质是性质相同的

900

是吧

901

所以说j it它最快

902

J it TE他是他是最快的

903

那现在好多这种脚本语言

904

好多脚本语言都都用上了这种it技术

905

比如像像那个JS算一个

906

还有那个Python

907

Python他也有这个j it娜扎瓦就更不更不用提了

908

Java用这个阶梯式是相当是相当相当早的

909

嗯

910

嗨

911

嗯

912

那么这个j it啊

913

我们看看一下这个j it

914

这个j it呢

915

我们发现了两条路径

916

我们这儿发现了

917

你去你去生成这个GT的时候呢

918

这儿有两条路径呢

919

一条路径是直接语法抽象数直语法抽象数直接生成了j it

920

另一条路径呢

921

是这个解析器解析器生成的这个阶梯

922

那么在V8引擎里边儿

923

那在V8引擎里边

924

它是有两种产生j it的机制

925

一种一种机制是什么呢

926

一种机制是简单的产生j it啊

927

快速生成j it

928

另外一种机制呢

929

是优化性地生成j it

930

那么这个就是快速生成j it快速生成

931

那快速生成他要先扫描一下你的代码

932

扫描你的代码

933

你他会他会发现

934

他会发现哪一块代码Xu re有可能会被频繁调用

935

那我就直接那我就直接

936

那个

937

那我就直接就就给他j it当然这种呢

938

这种直接产生j it的它的它的这个性能比较低

939

性能不太高

940

那么另外一种呢

941

就是优化性的j it

942

优化性的这个机制全都封装在这个微吧里边儿

943

那么这个微吧

944

他在执行你代码的过程当中

945

随着你代码的执行

946

它会逐渐的嗨

947

逐渐的意识到

948

你这段代码是需要进行j it的

949

需要进行j it的

950

那这实际实际在静态分析的时候和动态静态分析和动态分析这两种产生的结果是不一样的

951

对吧

952

这两种产生的结果不一样

953

这这个大

954

这这个大框里边都是V8

955

这个大框里面都是V8

956

都是V8在干的事儿

957

不是吧

958

当然这个快速生成也是V8了

959

他就是微吧里边儿两种两种产生GT的机制吗

960

那么动态产生的这种动态产生的这种

961

它产生它生成的j it性能更高

962

这是两种产生j it的方式

963

那么这个具体的

964

具体的有一些这个机制呢

965

在在咱们这个公众号儿里

966

咱们公众号好像是那个三月份儿

967

今年三月份我我我那个翻译了一篇文章

968

就是那个j it

969

那就是j it

970

这就是就是这个JTJJJ2种这这这这两种处理方式

971

大家可以去找一找

972

在公众号里

973

你去翻一翻这这两种

974

那么这个

975

当然GT最最终的目的就是生成可以直接跑在CPU上的

976

跑在CPU上的那个代码

977

那么垃圾自动回收机制呢

978

它既管你解析器这一块儿的这个内存

979

也管这个本地代码他所需要的那个内存

980

这两块儿都要管

981

那么接下来就有一个问题

982

接下来就有一个问题

983

当垃圾回收的时候

984

当进行GC的时候

985

为什么这个代码的执行他要暂停

986

这是下一个问题

987

那么这个问题

988

这这这他这个问题怎么解释呢

989

怎么解释呢

990

实际上

991

咱们要

992

咱们得从

993

这个微吧

994

他在实例化的时候说起V8

995

你比如说你的程序里边儿嵌入了这个微吧

996

就拿note JS来说

997

Note JS里面欠了这个微吧

998

然后

999

当no de JS执行的时候

1000

No de JS他要像操作系统

1001

要一大块内存

1002

这个no的JS

1003

他要像操作系统要一大块内存过来

1004

那么这一大块儿内存

1005

全都归谁管

1006

全都归弄得JS管

1007

那都归他管

1008

然后呢

1009

后续的运行

1010

后续的执行就不再像操作系统要要内存了

1011

就直接说操作系统你给我1G的内存

1012

这1G的内存我我干什么

1013

你就不用管了

1014

我完全自己管理

1015

这这这弄的自己管的

1016

然后1G的内存来了

1017

然后弄的呢

1018

他会把其中的一部分

1019

生成

1020

把它生成这个堆区

1021

把其中一部分生成堆区

1022

然后这个堆区给谁用给V8用

1023

这个堆区给V8用

1024

你在创建新对象的时候

1025

新对象就要就要创建在这个堆堆里边儿那么在这个堆区里边儿

1026

你在创建

1027

你在不断的创建这个对象

1028

不断创建对象

1029

然后对象越来越多

1030

对象你不要了

1031

你就要去删除这些对象

1032

对吧

1033

这是一个内存

1034

内存他是个一维的结构比如说你一开始创建了这么多对象

1035

然后呢

1036

中间某些对象不要了

1037

你按照顺序去创建

1038

它会从前往后去

1039

从前往后去去往里边儿补

1040

但是你但是你去

1041

但是你不要他了

1042

对吧

1043

但是你不要他了

1044

你不要他

1045

他里边儿会产生什么

1046

产生碎片

1047

它会产生碎片

1048

你这些对象按顺序创建

1049

但是你不用它的时候

1050

它可未必是按顺序不用他

1051

对吧

1052

所以你你一些对象

1053

你你你不需要了

1054

他他就要把这个

1055

把这个对象释放掉

1056

释放掉以后

1057

内存里面就产生碎片了

1058

那么GC在回收这些碎片的时候

1059

也就是说把这些把这些

1060

不要的这些

1061

不要的这些对象

1062

把它给释放掉的时候

1063

内存里边这一小块儿它是可用的

1064

这一小块又是可用的

1065

这一小块儿还是可用的

1066

但是啊

1067

他可用空间看得挺多

1068

但实际上呢

1069

那但实际上呢

1070

实际上你你真正能用的空间就少了

1071

为什么呀

1072

你想要创建一个大对象

1073

你看着一个

1074

你看着空间挺多

1075

但是这些空间散落在不同的地方

1076

那你就

1077

放不进去了

1078

对吧

1079

这个东西挺多

1080

但是你愣是地方挺多

1081

但是你硬是放不进去

1082

这时候该怎么办整理就要整理一下

1083

那整理的时候呢

1084

就要把这些全都往前移动对吧

1085

就得往前移动了

1086

你要把这些碎片全都给消除掉

1087

你把它消除掉

1088

后边儿不就有大空间了吗

1089

大块空间了吗

1090

有了大块空间你就能放进去了

1091

那么问题在哪儿呢

1092

问题就在这儿

1093

当你这个GC

1094

当你GC回收之后

1095

他要进行整理

1096

整理的时候你

1097

实际上在干什么

1098

在移动这个内存里的数据

1099

换句话说就是把这个数据

1100

把它复制到这个位置上来

1101

来这个数据来复制到前面这个位置上来

1102

再改他们的地址

1103

是在改他们的地址

1104

那么再改地址的过程当中

1105

你V吧正好用到其中一个数据

1106

然后你然后你下次在用的时候呢

1107

这个地址变了

1108

那你肯定要报错的

1109

对吧

1110

为了防止这种情况

1111

为了防止这种情况

1112

实际上这种情况叫什么叫脏数据

1113

叫脏数据

1114

数据数数据被损坏了

1115

那为了防止这种情况

1116

那GC在在在进行工作的时候

1117

那V8引擎他就要暂停

1118

微微吧

1119

他就他就不能执行了

1120

Java也是这种

1121

Java也是这种东西

1122

也也是这这一套机制你地址

1123

他不是他不是代码地址

1124

他不是代码

1125

它是数据的地址

1126

其实你对象你对象都是数据

1127

你要注意对象是数据

1128

他在数据空间里

1129

他不在代码空间里咱们王了吗

1130

咱们这个程序两大块儿两大块儿的那个程序的内存空间分两大块儿

1131

那一个是

1132

一个是代码空间

1133

一个是一个是那个

1134

一个是那个这个这个这个这个数据空间老袁讲的新生代老生代那是GC的策略

1135

那是GC的管理策略

1136

和我讲的不是一回事儿

1137

老袁那个新生代

1138

老生代那是GC的那个管理策略

1139

我讲的这个是什么

1140

讲的是GC在工作的时候

1141

你的虚拟机或还有这个微吧

1142

他又要停顿

1143

明白了吧

1144

新生代老生代试剂C具体怎么去工作

1145

他具体怎么去管理内存是吧

1146

实际上实际上这个GGC他在工作的时候

1147

他这个内存

1148

它这个内存它它这个堆内存

1149

不是一一个一个往往后排的

1150

他是干什么

1151

往这儿放

1152

还要往这儿放

1153

往中间挤的

1154

他是要往中间挤的

1155

中间是空的

1156

两头往两头放数据

1157

这是真正的那个

1158

这是真正它的那个操作模式

1159

我在这儿给你讲

1160

给你们讲是按照顺序讲

1161

这是为了说明说明道理

1162

说明这个道理

1163

好

1164

然后呢

1165

这个这是那个JS引擎

1166

它内部的这个内部的这个工作机制

1167

那么这个工作机制

1168

这个工作机制呢

1169

全都是在实现的代码里

1170

之后咱们再再接着看

1171

再接着看V8和JS号

1172

他们俩之间的这个他们俩之间的这个区别

1173

JS Qu ER a它是默认的

1174

他是web的默认的

1175

而那个现在现在那个Chrome里边儿

1176

它不叫它不叫那个web kit啦

1177

他叫blink啦

1178

那GS ku他也是他也是那个

1179

他也是那个恶这这个开源的

1180

它它也是这个开源的

1181

然后呢

1182

一开始它的性能并不好

1183

那么就是因为

1184

一开始JS靠的性能不好

1185

然后Google他才开始开开始打算把它给替换掉

1186

要不然他就在那个JS号上去去做分支了

1187

对吧

1188

那威吧

1189

他可不是GS ku的分支

1190

不令格式是web kit的分支

1191

蛋蛋V8 he和那个外盒这个JS可是完全不一样的

1192

那么这个玩意儿它它也是有什么

1193

它里边也是有这个

1194

这个字节码的这个解释器

1195

实际上V8和GS号是越来越像了

1196

这他们的这个实现机制是越来越像了

1197

这这个技术路线

1198

走着走着就走到一起去了一开始他们还有差异

1199

按照自己的思路去走去去实现

1200

但是实现呢

1201

实现都都就走到一个走到一条路上来了

1202

因为他们分别证明了

1203

那个方向不行

1204

那个方向走不通能走通的方向

1205

然后别人然后那个对方就学了去了

1206

所以这这这这俩东西

1207

最终啊

1208

最终这个技术电视就就会那个就会趋同的

1209

那么那个JS Qu而他这个JS扣呢

1210

到今天

1211

它的性能也是也是很不错了

1212

但是呢

1213

他他后发

1214

他他他他没有先发优势了

1215

那个V8

1216

他那个那个V8已经那个弄的JS已经用用这个V8了

1217

还有好多好多东西也已经习惯用V8了

1218

所以GS靠现在现在比较

1219

现在性能好了

1220

但是呢

1221

很少有有用有趣欠这个JS号的这这个引擎的了所以说他他那个先发优势

1222

没有然后呢

1223

这个note JS里面V8NOTE JS里面这个V8呢

1224

咱们那个上节课给大家

1225

上节课给大家讲过这个东西了

1226

No的JS

1227

他里边儿两个重要的重要的模块儿是啥呀

1228

一个是V81个是事件循环

1229

对吧

1230

这这俩东西都不是弄的JS他自己实现出来的

1231

No的JS他自己实现的是个啥东西呢

1232

就是这个弄得buildings

1233

哈哈

1234

这这是那个note JS他自己的东西

1235

那他他就是把这些东西往里插

1236

这是V8在弄的JS的这这个地位

1237

这个东西咱们上节课讲过了

1238

这节课就不多说了

1239

然后弄得JS这这些东西咱就不多说了之后呢

1240

咱们就要涉及到这个源码了

1241

就涉及到这个源码

1242

那么这个VBA源码

1243

VBA源码他在

1244

他在那个

1245

他在他是那个

1246

Chromium就是古这个它不叫谷歌浏览器

1247

他是那个开源版的谷那个谷歌浏览器开源版的谷歌浏览器

1248

它不叫浏览器叫谷歌浏览器

1249

那么它是那个开源版的那个谷歌浏览器里边的一个子项目这个微吧

1250

那咱们要找它的代码

1251

就是到他的官网上去

1252

官方网站上去找那但是这个东西呢

1253

得得得需要一些那个技术手段呢

1254

你你要想你要想去想去那个

1255

看他的画得得需要一些技术手段

1256

这个技术手段咱别别说话别别别别说别说

1257

你要说你要说了

1258

那个咱咱容易被封

1259

咱这课堂被封现在现在管的挺严的

1260

对

1261

那么这个在那个Chrome的源码

1262

Chrome的源码

1263

还有V8的源码都放在一起了

1264

但是咱们

1265

这个Chrome的源码相当大

1266

科普源码相当大的

1267

但是呢

1268

那个V8的这个代码呢

1269

就就30多兆

1270

它压缩以后就30多兆然后咱们咱们那个先看一下先那个先不看他源码了

1271

先看一下它这个V8的这个官网V8的这个官网

1272

如果说我们要想学他的这个代码的话

1273

V8官网它这个博客和文档是必不可少的

1274

那么这个博客

1275

这个博客你看他这都是release对吧

1276

各种release各种发版

1277

但是你不要看他这个各种发版

1278

各种发版只是告诉你这个新特性

1279

那他里边儿是什么呢

1280

它里边儿是有好多这个开发团队他们写的文章

1281

开发团队写的文章就是说这个V8哪一块儿我做了什么优化了

1282

这个优化的这个方向

1283

这个优化的这个实现细节是什么

1284

原理是什么

1285

我为什么要这样优化

1286

比如说像像这个对吧

1287

一个那个这个正则表达式引擎

1288

它给它给那个

1289

他给那个优化了

1290

对吧

1291

他那个这叫这叫这这这这叫那个back tracking啊

1292

这这个non bank transfer这这个模式的那个是正则

1293

这个模式的政则它它开始支持了

1294

就是那个回溯那就是这个正则回溯那个玩意儿

1295

他他这里他的那个实现实现原理

1296

乱七八糟的

1297

这这都是这都是人家团队的那个人加团队作者弄的

1298

然后那个之前给之前那个翻译过一个

1299

之之前翻译过一个就是那个压缩指针的那个

1300

他把64位指针压缩拆成那个两个32位指针他他他他进行他他进行那个处理

1301

原来我翻译过那个在后后边找不到了

1302

然后还有什么G类似j it类似微吧

1303

这是这是什么

1304

不用j it的V8

1305

去掉JJH的微博所有的机制

1306

就是所有的那个机制

1307

还有各种各种各样的测试

1308

这个这个这个这个这个测试结果

1309

乱七八糟的

1310

实际上要想把这个VBA学好

1311

就就看这个

1312

就看这个他的这个博客就就是人家那个东西

1313

就是人家做的这个开发团队弄的

1314

然后这个还有他的这个他的这个文档

1315

它的文档就是详细详细说了这个微吧

1316

你在基于这个VBA进行开发的时候

1317

这个东西咱们不用

1318

咱们就没没有什么必要看了

1319

这个这个文档是你要想把这个V8引擎嵌入到自己的系统里边儿去就就好像是你在做一个漏的对吧

1320

你你做个单呢

1321

你去内内内那个作者他做完弄得他他在做呆着

1322

就是干这种干这种活的

1323

干这种事儿的人

1324

他们要看这个

1325

看那个文档

1326

你或者说你把它放到那个嵌入式

1327

这个啊

1328

这这这个字

1329

DEMO啊

1330

就把note给倒过来

1331

一个作者

1332

一个作者写的单都是用那个rust写的

1333

他不用C加加写了

1334

一开始用go写

1335

后来发现那个勾的那个勾

1336

勾的那个GC会和那个会和那个V8

1337

会会和他这个单独的这个DJ冲突

1338

它它会产生那个双击C这种问题

1339

所以他就放弃了勾

1340

然后直接用那个rust完全完全自己去管理内存了

1341

他冲先用勾写了

1342

一写了一半儿发现不对劲儿

1343

然后就就改成rush了

1344

这个人真是个大牛

1345

什么都能干

1346

什么语言都拿得起来

1347

说换就换

1348

架构能力也好

1349

然后呢

1350

这这个这这个官网

1351

不要那个不要忘了去去去那个去看的那个我去那个还没打开

1352

然后我们看一下

1353

看一下这个

1354

看一下那个cur name

1355

这个V8的这个源代码

1356

那这个这个chromium chromium这这个地方在在这个地方它是

1357

他这个就是一个SVN

1358

它它就相当于一个那个SVN啊

1359

然后一个web版的那个SVN

1360

就是一个代码管理器

1361

像这个这这这这这这个里边呢

1362

也以所有的代码你都能看得到

1363

现现在打不开

1364

打不开就先先不管他了

1365

那么接下来呢

1366

咱们得搞清楚

1367

咱们要学这个微吧

1368

学的是什么东西

1369

你并不是为了看代码儿

1370

看代码咱们要朝这么几个方向去看

1371

第一个是什么呢

1372

JSJS的理解

1373

增加G对JS的理解

1374

你比如说像他那个object

1375

对吧

1376

JS的那个object

1377

它究竟是怎么回事儿

1378

他是他他是怎么实现的

1379

还有那个原型链

1380

它究竟是怎么回事儿你通过你在代码底层那个代码层面上去理解它

1381

还有一些呢

1382

就是它里边有好多各种各样的那个算法

1383

通过那个东西去去学算法还有就是内存管理

1384

内存管理还有他那个GC

1385

还有这个编译原理

1386

投进代码去

1387

然后生成生成啥呀

1388

就是这个东西投进代码去生成抽象语法树

1389

这个是编译原理的

1390

然后呢

1391

还有啥呀

1392

操作系统方面的知识

1393

操作系统方面的东西

1394

这怎么去怎么去那个怎么去向向向外去去传递东西

1395

对吧

1396

最最终就是就是面试

1397

就最终就是面试

1398

人家要问你看过VBA的代码吗

1399

你说看过

1400

你就可以说看过

1401

人家会问你看过哪部分

1402

然后你就说你最熟的那一部分是吧

1403

这一部分是它是怎么实现的她用的什么数据结构

1404

一个什么样的处理机制

1405

他先先干什么再干什么然后这个数据结构上有什么东西

1406

哪个东西是干什么用的

1407

你你你你就能你就能说出来了

1408

那那就说这那那你就牛了

1409

那就工资也就有了

1410

对吧

1411

然后那个

1412

那么那个接接着呢

1413

就是那个图这个V8引擎

1414

V8引擎里边咱们需要着重看的

1415

着重看的比如说像那个数据类型

1416

对吧

1417

里边儿实际上这个JS它是它是弱类型语言

1418

咱们要是要说它没有类型也未免太偏颇了

1419

还是有一还是有那么几种类型的

1420

当然他不是真正的类型

1421

它那个数据

1422

它那个数据它是它是它那个类型究竟是怎么样的

1423

对吧

1424

它是怎么实现出来的

1425

另外呢

1426

它里边儿内存还有那个绑定机制

1427

它还有还有那个JS那个绑定机制

1428

最后呢

1429

就是这个字节版

1430

还有j it它这个处理过程

1431

就就就主要是看看这些东西

1432

然后然后又又现在又多了什么呢

1433

多了一个SM

1434

WSM现在已经那个正式的支持了

1435

他他就他比那个它比那个GT比比的更近了一步GT是把你里边的代码片段变成什么

1436

变成CPU可以执行的那个代码儿

1437

那个WSM呢

1438

把你一个模块儿

1439

把一个模块完全变成CPU可以执行的代码

1440

这样效率更高了对吧

1441

那那个更进一步

1442

后边儿后边的课会给下个星期应该是下个星期给大家讲这个WSM啊

1443

好

1444

那然后这个这个PPT这一块儿就就就给大家这个说完了

1445

然后这节课剩下的部分就全全都是代码

1446

带着带带着大家的去去看那个去去做这个代码分析

1447

然后再做代码分析的时候呢

1448

还也会还会给大家去讲一些那个语法

1449

C语言

1450

还有C加加的这个语法

1451

让让大家能够看懂

1452

现在的目标是能看懂

1453

不是不是去写好咱们先休息五分钟

1454

接下来就是代码部分

1455

Miss me like I was made for you

1456

and you re you re you can I stay for me that I would just mi you cannot escape from me that I was just a Li

1457

阿狸

1458

阿狸阿狸

1459

阿狸阿狸

1460

阿狸

1461

When I started its next to him and him

1462

in the

1463

giving you my long

1464

beach

1465

hello hello

1466

hello

1467

A group of rock and roll all night and sat down just a little bits of the group and

1468

好

1469

咱们开始看代码

1470

咱开始看代码

1471

这玩意儿打不开

1472

我去

1473

QQ打不开

1474

嘿嘿嘿

1475

这抽什么疯了不知道

1476

那个任务代码呢

1477

一般那个

1478

不敢下载

1479

我这儿下载了这个web kit

1480

把这个web下载下来发

1481

后悔了

1482

呵呵

1483

Web kit这个包太大了

1484

而且里边儿那个代码是极其的那个啥恶

1485

而且我下载下载完了以后呢

1486

发现下载错了

1487

下载的是那个工具

1488

下载试试一套工具

1489

不是那个源码就下载了这个lab we note

1490

还有这个V8

1491

这这三个东西

1492

先说这个阿赖屋

1493

这个lab Le

1494

这个lab we是C语言的库

1495

那么这个C语这这个裤呢

1496

它是一个底层互

1497

那咱们拿到这个C代码的话

1498

怎么看

1499

怎么去看

1500

咱们这个C代码

1501

先给大家说一下这个C代码你怎么去编译他

1502

C代码咋编译他C代码呢

1503

它里边儿这个背的时候

1504

有这个GCC

1505

有这个GCC先

1506

这GCC呢

1507

属于C语言编译链

1508

属于它编译链

1509

它里边呢

1510

有一有一有一整套的这个工具GC是其中一个

1511

那么GCC编译完了以后呢

1512

那GCC然后后边就是你的那个什么什么什么什么点C

1513

点C

1514

然后杠o

1515

杠o呢

1516

就是

1517

你要输出到什么文件上

1518

输出到什么文件上

1519

比如说a点a

1520

你输出的这个可执行文件和或者点o

1521

这只output文件就是输出文件

1522

这就是CPU可以执行的代码了

1523

但是呢

1524

咱们执行咱们是咱们在写这个C代码的时候呢

1525

这些代码是有好多的一个C一个C代码

1526

你就得执行一下这个GC

1527

然后生成一个点o文件

1528

这样呢

1529

效率太低了

1530

对对吧

1531

你你要执行好多次这个GCC

1532

那怎么办呢

1533

就要涉及到这个编译链儿里边儿第二个工具

1534

第二个工具叫什么呢

1535

叫makefile

1536

他叫美卡

1537

是make文件

1538

是这个make命令

1539

Make命令它是一个脚本解释器

1540

这个脚本解释器干什么用呢

1541

他去处理那个makefile

1542

她处理这个文件

1543

那么这个makefile这当然他不是正规的那个makefile

1544

正正常的那个过程

1545

正常的那个边这个编译过程应该是

1546

应该是啥样呢

1547

先找一个脚本

1548

就是config来这个脚本

1549

先找这个脚本

1550

这个脚本干什么

1551

他先去扫描你的操作系统

1552

那看你的操作系统里边有没有装那个对应它所依赖的那些库

1553

还干什么呢

1554

还去看

1555

还去检查你的操作系统版本

1556

你的CPU等等

1557

他去干这个

1558

然后生成一个makefile文件

1559

就生成这个东西

1560

它生成的makefile文件呢

1561

是不带后缀的

1562

没有后缀

1563

就是直接一个makefile

1564

那个L还是大写

1565

然后呢

1566

Makefile里边儿就是编译脚本呢

1567

它自动的帮着你去写这些GC什么什么杠o什么什么

1568

而且它还支持通配符之类的

1569

那我们自己去写这个CC项目的时候呢

1570

我们也可以自己去去编辑这个makefile文件

1571

也自己去写这个脚本

1572

然后呢

1573

用make直接敲make

1574

那在当前在在这个makefile当前目录下悄悄这个make

1575

然后他就帮你去编译

1576

去编译了来这是这是那个编译过程

1577

编译出来以后给你放到一个目录里边儿

1578

就好像是咱们用那个web pack打包一样

1579

或者说咱们用那个TS的编译器去去进行那个转码一样

1580

这个这个道理是道理是一样的

1581

把一种把一种形式的代码转换成另外一种形式的代码

1582

这个过程就叫编译

1583

那咱们C语言呢

1584

是把这个文本代码转化成这个机器代码

1585

TS编译器呢

1586

是把TS代码转化成JS

1587

转化成JS这个编译器

1588

这JS代码

1589

这这尽管说目标不一样

1590

目标代码不一样

1591

但是呢

1592

他们做的事儿是一样的

1593

就是转

1594

就是转换代码形式

1595

这是编译链儿

1596

然后呢

1597

咱们看看这个C语言

1598

这个C语言里面这些代码

1599

咱们再看代码的时候

1600

主要看两个

1601

主要找两个目录

1602

一个目录是include

1603

一个目录是这个SRC

1604

先说这个include include里边放的什么点H

1605

这个点H叫什么呢

1606

他是头文件

1607

那C语言的头文件

1608

那么这个头文件里是什么

1609

他是告诉这个编译器

1610

告诉编译器我要编译的那些函数

1611

都有哪些

1612

还有一些什么全局变量

1613

乱七八糟的

1614

他是干它是用来定义这个的

1615

那咱们在写代码的时候

1616

有两实际上是在做两件事儿

1617

一件事儿是做声明一件事声明一件事实现

1618

那JS实际上也是这样

1619

只不过呢

1620

JS把声明和实现给放在一起了

1621

而那个C语言

1622

还有C加加语言声明和实现

1623

是分开的

1624

当然你也可以放在一起

1625

也可以放在一起

1626

你要分开的话

1627

声明写在哪写在这个头文件里

1628

比如说像像这个东西

1629

这是一个函数

1630

对吧

1631

这是一个函数

1632

但是函数体没有

1633

这叫声明了一个函数

1634

这是在声明函数

1635

那么这个函数的实现在哪儿呢

1636

在点C文件里把声明和实现给分开

1637

那他为什么要这样做呢

1638

这个要取决于

1639

取决于这个壳

1640

取决于这个C语言的这个编译形式

1641

C语言在编译的时候

1642

不仅仅是编译出那个可执行程序来

1643

他还要编译出来什么

1644

编译出库来

1645

他还要编译出库

1646

那个酷也是二进制文件

1647

他和咱们JS的库是不一样的

1648

JS的库是什么

1649

他就是代码纯JS代码儿

1650

这个C语言的库呢

1651

C语言的库它就是二进制

1652

然后呢

1653

二进制配一个头文件

1654

有头文件

1655

你就在你在那个连接的时候

1656

就能把那个库里的代码

1657

把他给抽出来

1658

然后然后嵌入到你自己的程序里边儿这是C语言的东西

1659

那JS那个库呢

1660

JS库他没有

1661

他他不去抽

1662

你默认情况下

1663

它是不是它是不往外抽这个代码的

1664

所以JS写的代码很大

1665

对吧

1666

你要发布的时候

1667

那些库

1668

乱七八糟的是什么东西呢

1669

他连着一块儿发不

1670

而那个CC你可以把库里的东西给抽出来

1671

放到你的程序里边

1672

你发布的时候只发布那个程序就行了

1673

不用带那个库

1674

后来JSAJSJ这这这这这个恶越搞越大

1675

JS程序会越搞越大

1676

你这个库的依赖也是非常复杂

1677

后来出现什么web packweb pack你打包的时候

1678

他把里边儿的有用的代码给你抽出来

1679

生成那个新的代码文件

1680

然后用不到的那些代码

1681

他就他他他就给你扔掉了

1682

这是减少那个代码体体积

1683

这是JS的那个JS那个套路那么这个C语言

1684

C语言里面这个库分两种

1685

C语言里的库分两种

1686

一种是静态库

1687

静态库什么后缀呢

1688

点儿

1689

这是静态库

1690

第二种库是动态库

1691

动态库

1692

那动态库在不同的操作系统下

1693

它是不一样的

1694

在Linux下

1695

动态库试点so

1696

在Windows下试点DLL

1697

这是动态库

1698

Windows下的

1699

Linux下的静态库和动态库有什么区别呢

1700

静态库是编译时用

1701

只在编译时候用

1702

然后程序运行的时候

1703

程序运行的时候就不需要了

1704

因为你把代码从静态库里抽出来了

1705

放到了你的这个exe里边儿去

1706

他你需要什么代码

1707

这个你就抽什么代码

1708

恶把它打成一个包

1709

这是静态库

1710

而这个动态库呢

1711

动态库是编译的时候要用

1712

运行的时候也要用na动态库

1713

他不往外抽代码

1714

不往外抽代码儿是干什么

1715

当你的程序在执行的时候

1716

在运行的时候从现从这个动态库里边儿找代码

1717

找代码以后去执行这个代码

1718

那你要是要用到了这个动态库的话

1719

你的程序在发布的时候

1720

就要把程序和动态库放在一起打包

1721

那咱们在用一些Windows程序的时候

1722

咱们会咱们有时候会会遇到这种问题

1723

对吧

1724

有一些那个什么绿色软件

1725

所谓的绿色软件

1726

它是把内衣一把一些有用的东西给抽出来

1727

没用的东西是给去掉有的那个绿色软件他做的不好

1728

有的动态库他没有打包进来

1729

他会给你什么提示

1730

就是那个某某某DLL没找到

1731

他他就会

1732

他就会给你提示这个东西这这就是少了一个动态库

1733

另外还有很很久以前

1734

用温度在Windows下

1735

很久以前在在那个Windows下

1736

那个很久以前的Windows呢

1737

他有一段时间是有好多用c sharp写的程序

1738

那所以说你要用c sharp写的程序恶要运行那种程序的时候呢

1739

你得装那个点net frame works啊

1740

就当net frame works你要不装那个

1741

它会提示你缺少什么什么DLL

1742

这样就就就就就是这个原因

1743

那么静态库和动态库的这个区

1744

这个区这个区别在这儿

1745

那么为什么要有这两种库呢

1746

那静态库

1747

静态库适合什么呢

1748

适合这种小规模的这个代码

1749

你你用的时候这小规模的

1750

代码没法复用代码没法服用

1751

你

1752

你产生一生成一个点exe

1753

你就要你就要你就要把这个复制一份代码出来

1754

而那个动态库是可以复用

1755

动态库可以服用你

1756

比如说你把一些公共逻辑

1757

一些公共的这个业务逻辑

1758

你把它封装到这个动态库里边

1759

然后呢

1760

你整个的这个大系统里边儿

1761

你有不同的这个点exe

1762

然后这些点exe都要去掉

1763

用相同的功能

1764

这叫什么

1765

这叫组件化

1766

实际上这个DLL它里边有一种这种那个动态库

1767

它里边有一种组件化的这种思想这这是那个软件

1768

软件设计层面涉及到软件设计层面上来

1769

那这个问题在哪儿呢

1770

问题是动态库执行效率要比静态库代码执行效率的

1771

因为你有好多你你你打开你你去你去一个点XG

1772

用用这个动态库

1773

他就要把这个动态库整体的把他给宰入到内存里去

1774

然后呢

1775

在内存里面去进行这个内存映射

1776

在内存里面内存空间做一个映射

1777

然后你exe需要用的时候

1778

在这个映射空间里面去找

1779

实际上这两个内存空间

1780

Exe的内存空间和DLL内存空间

1781

他不在一起要通过这个映射关系去找

1782

这样就性能会性能会给会给脱下来会降下来

1783

但是呢

1784

它的好处是什么

1785

它的好处是复用度很高

1786

尤其是你做一个比较复杂的这种系统

1787

里边有好多的这个点exe

1788

像像有好多那个程序

1789

有好多程序一启动启动一串对吧

1790

内内那种东西最适合用这个DLL

1791

还有Windows里边好多DLL

1792

都都是用的这种这种思想

1793

好的

1794

那这这个是他的那个酷

1795

这个C语言

1796

还有C加加做出来的东西都都是这种都是这种类似的这种套路

1797

后来呢

1798

微软啊

1799

后来微软在这个动态库上就大做文章

1800

他他就他就干什么

1801

他在这个恶

1802

因为动态库他就有还有组建思想嘛

1803

后来他微软他就一直不停的去发展这个组件

1804

这个组件的这种设计思想

1805

后来又生成什么

1806

就有了那个OL技术

1807

OL技术实际上就是那个容器技术

1808

然后呢

1809

LOL技术基础之上又加了好多东西

1810

也是什么

1811

就是com技术

1812

全都是大写

1813

这个com这这这三个都是都是大写

1814

就是Windows组件

1815

Windows的组件系统

1816

后来又出现什么

1817

又出现了这个康佳

1818

然后com加还能你还能当成服务给拉起来

1819

但这位这这是那个十多年前

1820

十多年前

1821

那个微软的那个那个技术套路

1822

但是现在呢

1823

现现在现在很现在很少有人用用用这个东西了因为那个桌面的

1824

像现在跑在Windows上这个J这个在Windows上做服务器的这个市场的事儿是越来越小了可以说这个Windows差不多差不多丢掉了这个服务器的这个市场大不丢掉了

1825

大部分的服务器市场都跑到这个limit上去了

1826

这是温这这这是一些那个他背后的一些花絮

1827

然后咱们再回到这个C语言这儿来

1828

C语言这儿来注释的注释

1829

这个规则之类的

1830

He和咱们那个JS是一样的

1831

然后咱们看这

1832

看这这这这个defy衣服恩的饭

1833

然后的饭

1834

然后什么恩的衣服

1835

这是什么

1836

这是红

1837

这是红

1838

那么这个红是这个红

1839

红就是一组一组指令就就就就红的意思就是一组指令

1840

红啊

1841

这个红

1842

那么这个红呢

1843

是由编译器是编译器

1844

他是他是部编不把它编译成代码的咱们要注意

1845

这个红编译器是不把它转成机器代码的

1846

他是干什么

1847

它是用来控制你的编译逻辑的

1848

那什么叫编译逻辑呢

1849

比如说我们要跨平台

1850

哼是吧

1851

我们要跨平台

1852

跨平台的时候

1853

Windows的API和Linux API不一样

1854

这个时候呢

1855

就要去检查什么

1856

检查操作系统平台

1857

比如说这一块儿

1858

衣服的饭

1859

如果说你要你要去给Windows windows32位系统下去去编译这个程序的话

1860

你就需要在一个头文件里面去定义这个定义这个宏

1861

要定义一下这个红

1862

就是下划线WEN32

1863

然后呢

1864

编译的过程当中发现你定义了这个红了

1865

那就走哪儿走这个分值

1866

就走这个分值

1867

这是编译逻辑

1868

然后如果说你如果说你定

1869

如果说你你你你不是那个没有定义温三儿没有没有定义这个东西那个内怎么办

1870

那就走尤尼克斯那就走尤尼克斯的那个那个套路

1871

Unix和Linux的套路

1872

如果说你要走unix和Linux的套路呢

1873

这你还要检查什么

1874

检查这个C编译器

1875

GOC啊

1876

看他的版本是不是大于四

1877

大于四就支持什么东西

1878

不大于四它它它它它要做什么反应这里是各种各样的定义

1879

各种各样的红那么大家看到像这些东西的时候就忽略他就行了

1880

大家看代码的时候

1881

看到这些东西的时候

1882

什么if defyf def

1883

然后什么if

1884

像看到这一块儿的时候

1885

你你你你注意他就是他就是检查你的这个环境的

1886

检查你这个编译环境的

1887

你你不用去管他

1888

那么这个东西是干什么

1889

这个东西你你问这个是吧

1890

衣服衣服的饭下滑两个下划线c plus plus然后呢

1891

Ex tens a这是在干什么

1892

这是

1893

这不是C代码

1894

我告诉你

1895

这不是这不是C加加代码

1896

这是C代码

1897

这是C代码

1898

纯粹的C代码

1899

纯粹代码他是干什么

1900

他这个东西

1901

它是为了做函数入口的导出

1902

这是给C加加

1903

这是给C加加编译器去导出C语言库的调用

1904

这个函数调用

1905

函数调用入口儿

1906

因为C和C加加这两个这两个编译器套路是不一样的编译套路是不一样的

1907

所以你CC加加是可以调C语言库的

1908

但是怎么让他掉呢

1909

按照C加加的那个规则

1910

去做这个函数调用导出

1911

这个就这他就是干这个用的

1912

他是干这个

1913

所以它是C语言代码

1914

就是告诉CC加加编译器

1915

这是一个C语言的库

1916

你你你在你在那个往外抽抽代码的时候

1917

你要注意它里边没有没有这个类

1918

没有什么乱七八糟的

1919

不要按C语言的套路去去做处理

1920

按C语言的套路去处理这事

1921

告诉C加加编译器的

1922

所以他不是C加加不是C加加代码你你这儿别美

1923

你还哈哈你你你你还你还哈你你还哈你你哈哈什么

1924

你哈哈哈哈错了

1925

所以咱们看看这些东西

1926

另外还有这个

1927

UT下划线杠H

1928

这是干什么

1929

防止头文件被反复引用

1930

防止被反复引用

1931

因为这个C加加编译器

1932

你要是它不像咱们JSJS你你在你在import一个包的时候

1933

它在它在内存里面是全局唯一的

1934

对吧

1935

那么这个C加加他不是这样的

1936

C加加编译器

1937

他他他他不做那个什么全局唯一的这个玩意儿

1938

它这个关联是极其复杂的

1939

它它并不是放在这个全局这个全局里边儿

1940

所以为了防止你重复去导入这个头文件

1941

你导入一份

1942

你就就要多多号一份内存

1943

是吧

1944

然后你在你

1945

你你你你在那个编辑的过程当中呢

1946

那性能就低了

1947

C语言追求的是性能

1948

防止反复的去导入

1949

因为一个头文件会在多个点C文件里边儿去include

1950

包含在多个点C文件里边儿

1951

所以防止头文件你你被多次导入

1952

那就用这个宏来控制if if迪犯了这个洗这个

1953

没有没有底范这个红

1954

那就底范那个红底犯了这个红

1955

然后就

1956

然然后在在哪儿呢

1957

在在这儿

1958

他那个最终结果在在文件的后边儿

1959

在文件后面这个NF啊

1960

在这儿这是那个大分值

1961

如果说定义了UT下划线H

1962

如果定义了UD下方H

1963

那么这些代码它就不再再次处理了

1964

如果没有定义这个UT下划线H呢

1965

它就要处理这这一大堆代码防防止防止被重复处理

1966

那他他并不像JS

1967

因为JS他是他是个动态语言

1968

对吧

1969

JS动态语言

1970

边边解释边运行

1971

边边处理边解释边解释边运行的

1972

这这个C呢

1973

是一次处理

1974

一下子全都处理完

1975

处理完以后再去再再去运行

1976

套路不一致

1977

然后后边儿就接着看后边儿这个东西是什么

1978

就是去引那个头

1979

引那个头文件了

1980

去引入那些头文件

1981

那些都有哪些函数

1982

你不去引那些头文件那些函数你没法用但是呢

1983

我们要注意

1984

在include的时候呢

1985

有的头文件是放在双引号里的

1986

有的头文件是放在尖括号里的

1987

这有什么区别呢

1988

那先说这个尖括号放在尖括号里边呢

1989

这个是系统的库

1990

就是编译器给你提供的库

1991

他放在那个系统文件夹里

1992

那也就是说他的那个语言的那个语言的标准库

1993

就放在尖括号里

1994

而这个双括号呢

1995

双这个双引号呢

1996

双引号就是你自己写的头文件你自己的头文件找

1997

这个头文件的位置不一样

1998

这个在系统在系统的那个目录底下找

1999

这个呢

2000

在你项目项目的目录底下找

2001

这是引那个引那个头文件

2002

那记住

2003

我们要注意

2004

这个头文件

2005

当我们在这个代码里面去去去分析的时候

2006

去分析这些代码的时候

2007

如果说我们看到一个函数

2008

那么这个函数不知道是她她再想想再跳到那个函数里边

2009

再再再去看它是怎么实现的

2010

那你怎么去找那个函数实现在哪儿呢

2011

看着头文件

2012

这些头文件

2013

他这个看文件名儿对吧

2014

比如说这个是错误

2015

这是版本

2016

然后这个是标准库的定义

2017

这是标准标准库输入输出

2018

当然我们看代码不会看标准库的代码

2019

要看这个项目的代码比如说你看到了一个错误

2020

我要看看这个错误他是怎么定义的

2021

它它它它它定义的是是什么东西

2022

定义的那个细节是什么

2023

那我们就就从这个L的H里面去找那个那个错误定义去

2024

这是咱们在文件之间

2025

文件之间来回来回那个跳代码的时候就要用到这个东西了

2026

然后在后边呢

2027

我们看这个这个东西又又是个红这又是个红

2028

咱们反复的看到这些红在C语言里边儿这个红

2029

它有一个它有一个名字

2030

有一个专用的名字

2031

这专用名字叫什么

2032

教育处理代码

2033

这个红教育处理代码

2034

是预处理

2035

预他预的是谁

2036

玉是什么意思

2037

预先处理教育处理

2038

那么在什么之前他预处理呢

2039

就是处理真正的这些代码真正的这个C语言代码

2040

处理真正C语言代码之前

2041

先去处理那个红那个红叫

2042

所以他叫什么

2043

叫预处理代码

2044

是吧

2045

那么这个预处理代码他是不会生成那个二进制代码的

2046

只是告诉编译器你按照一个什么样的逻辑来进行编译这是红的

2047

这是那个红的意义

2048

然后咱们再接着往下看

2049

我们看这儿

2050

看这儿这个后边儿

2051

这这些东西都是红都是红

2052

实际上我这这些东西

2053

我们把它当成这个脚本

2054

我们把它当成脚本看就行了

2055

这是

2056

这些这些玩意儿

2057

他他都是在定义一些那个定义一些东西

2058

对吧

2059

把这两个做一个映射咱们看名字就看得出来

2060

Error number map做的是什么

2061

做的事

2062

这个是哪一个那个number这是这是一个编号然后这个呢

2063

就是那个编号所对应的那个文本信息

2064

这他他在这里定义了好多红

2065

它把它做一下映射

2066

然后再往后呢

2067

再往后这这些东西都都是类似的东西

2068

都是类似的这个映射过程

2069

然后呢

2070

咱们往后看

2071

看的时候呢

2072

看到这儿

2073

有他的肺

2074

Type def这是tap的饭

2075

那么C语言里边你是可以定义自己的这个类型的

2076

那定义自己的类型

2077

你你你实际上就是这块数据

2078

它在内存里什么样

2079

你看它不像咱们JSJS是什么JS

2080

你你去弄那个object

2081

它实际上都是挂在挂在那个那个object object那个类上的

2082

不断的往那个object那个对象上往上加东西

2083

是吧

2084

那那呢

2085

那是那个咱们JS的那个那个累

2086

那所以JS那个累

2087

他不是一个真正的类型

2088

你没有办法真正的去确定他她它在内存里面什么样

2089

全都归那个object呢

2090

他去管

2091

基于原型链儿是吧

2092

在那个原型链它实际上就是个数结构

2093

那个树结构就完全归那个JS自己去管了

2094

你没有办法去控制他的那个真正的结构

2095

那么C语言你可以去控制它的这个结构

2096

比如说这是一个什么

2097

这是一个枚举类型

2098

一个枚举类型

2099

那枚举类型

2100

那我们这这儿就给他给去太不敌范一个新的枚举类型这个新的枚举类型它是什么名字

2101

是这个名字

2102

那type DeFined

2103

然后在这个差不的饭type DeFined后边呢

2104

就是这个类型的这个结构

2105

他究竟是什么样的

2106

然后最后呢

2107

就是定义出来这个类型

2108

他他叫什么名字按照按照这个套路

2109

后边儿我们也可以看到好多

2110

比如说type DeFined

2111

这是个结构体

2112

这这是这咱们自自己定义的这个结构体

2113

这个结构体有点儿像累

2114

但是它里边儿没有没有没有那个没有没有韩束

2115

没有没有那个方法

2116

那么这个tempe饭structure

2117

这个struck是谁

2118

是这个

2119

这这这是一个结构体

2120

这是个结构体

2121

然后把这个结构体把它定义成把它给定义成这个类型

2122

这是你去定义自己的类型的

2123

实际上这个结构体在干什么

2124

就是在就是在定义你的这个数据在内存里面什么样的然后咱们后边去找一个那个结构体

2125

这就是一个结构体这就是一个结构体

2126

这个结构体是什么

2127

里边儿64位整型放这个又一个64位整型

2128

若干个64位整型

2129

然后呢

2130

这是另外一个类型UV time SPY杠T

2131

实际上它是什么

2132

它是一个重新定义的类型

2133

它的它的那个

2134

他的那个最根本的类型也是也是一个那个他的根本的类型是一个32位的整型

2135

这这这里边好都都是钉钉一一堆整数

2136

然后这个结构体在内存里面是什么样的

2137

这个结构体在内存里边

2138

他要站一块连续内存

2139

然后这块儿连接内存a

2140

按照顺序

2141

这是第一个

2142

这是第一个ID

2143

第一个那个结构体的那个成员然后呢

2144

第二个结构体的成员

2145

按照顺序一个一个放放下来

2146

然后这一整块内存苗就是这个结构体

2147

那结构体结构体放在内存里边儿什么样儿

2148

这一整就是这一整块的一层

2149

他们是挨在一起的在内存里面是挨在一起的

2150

当然这个这个这个结构体

2151

前面还有个前缀这个前缀呢

2152

这个前缀呢

2153

它是不计入这个结构体的整个大小的不记不记住结构体整体大小

2154

结构体的整体大小

2155

实际上就是把这些东西把这些东西加起来

2156

把这些把这些数据

2157

它们所占的内存

2158

内存大小把它给加在一起

2159

那这就就就就加在一起

2160

就是结构体的大小

2161

但是结构体它在内存里边儿有一个前缀

2162

一个前缀数据

2163

那么这个前缀数据

2164

这个前缀数据加上前缀数据是结构体真正的内内存占用

2165

在很久以前

2166

在很久以前去面试的时候

2167

就就就有人问这个问题有人问过这个问题

2168

就就就就就考我你你你你懂不懂这个这个内存

2169

然后我是怎么答的呢

2170

比如说他问的是一个结构体

2171

我定义了一个整型定义的一个字符型的

2172

还还地还里面还有一个那个单精度浮点型问这个结构体实际占用内存是多大是吧

2173

然后我是怎么答的呢

2174

我是我我这么说

2175

看上去看上看上去这个结构体是整形四个字节再加一个字符型一个字节再加单精度浮点型四个字节看上去是九个字节但实际上呢

2176

它还有一个前缀前缀数据

2177

前置数据再加一个字节

2178

那么实际它占的内存

2179

也不是这也不是这这这这十个字节

2180

因为在在这个操作在在这个计算在操作系统里边儿还有一个内存对齐机制内存对齐机制它必须得是它必须得是二的二的N次方

2181

你占用的这个内存块

2182

必须得是二的N次方

2183

所以他实际在内存里边儿是16个字节

2184

所以这样才这样才代表

2185

你是真正的明白这个东西

2186

所以说那个去去去这么答去你面试的时候

2187

你也按照这种套路去答满分儿对吧

2188

说明你都知道

2189

而且呢

2190

你一步一步的给他往网往深入里边儿去

2191

往深入里面去进行探讨这怎么叫卷王呢

2192

这不叫卷王这不叫这不叫卷

2193

这叫什么

2194

这这不叫内存对齐内存对齐

2195

因为你在寻址的过程当中

2196

二的整数倍它是最好算的

2197

对吧

2198

他是最好算的

2199

二的整数整数倍是最好算的

2200

所以他在他在那个使用内存的时候

2201

他必须得他他放到二的整数倍的那个那个空间

2202

那个位置上

2203

他在寻址的时候是最快的

2204

这是这是一种那个系统优化

2205

所以他是他16

2206

这这叫内存

2207

这叫内存的那个内存对齐机制

2208

这这这非常底层了

2209

那他要不够16个字节

2210

他要凑够16个字节明白了吧

2211

还有啊

2212

大家大家别以为这样就是卷

2213

这不叫卷

2214

那这叫这叫什么

2215

这叫这叫竞争手段

2216

这叫这叫有效竞争手段

2217

那怎么叫什么叫什么叫卷

2218

大家知道吗

2219

卷的定义是什么

2220

就是毫无意义的竞争

2221

毫无意义的竞争

2222

这个池子就这么大对吧

2223

这个公司他的工资预算就是100万

2224

然后十个人分

2225

一个人分多少

2226

正常情况下一个人分10万对吧

2227

然后这个老板说了

2228

老板说大家努力一下

2229

大家努力一下

2230

然后呢

2231

努力一下儿

2232

我给大家多分点儿

2233

然后你努力了

2234

你得到20万

2235

对吧

2236

你得到了20万

2237

其他人不努力呢

2238

把这个钱

2239

给他减了5万

2240

两个人少了5万来给你凑齐你这个20万

2241

实际上他的支出是没变的

2242

甚至可能会更少是吧

2243

如果说有三个人不努力呢

2244

那剪了撒捡了仨5万呢

2245

实际上它是它实际支出是95万

2246

这叫什么

2247

这叫内卷前前提是资源

2248

资源是有限的

2249

而且呢

2250

你你这种竞争在整体来看

2251

它是毫无意义的

2252

对吧

2253

这叫卷

2254

那这这你去把这个东西搞深入了

2255

搞深入了以后意味着什么呢

2256

这儿有一个职位

2257

这儿有一个职位

2258

这个职位

2259

这个职位是什么

2260

你够格你才做

2261

你不够格你都摸不着

2262

这叫什么

2263

这叫竞争

2264

这叫真正的竞争

2265

你能做才让你做

2266

你不能做就门儿也没有这个职位他就年薪100万

2267

那对吧

2268

你能不能做

2269

能做给你100万

2270

是吧

2271

不能做

2272

你你摸不着

2273

你你去摸那个下级那个次一点的职位

2274

去那个五

2275

你去摸那个50万的

2276

50万你摸不着

2277

你去摸那个20万的

2278

对吧

2279

这这这这就不叫这这这玩意儿不叫卷

2280

另外什么内卷外卷

2281

这这叫是什么乱七八糟的这新名词越来越多了

2282

这个东西

2283

你不要不要那个啥

2284

不要不要总是那个

2285

那个

2286

不要总是那个啥

2287

不要总是总总是那个看那些乱七八糟的东西

2288

实际上这叫什么

2289

这叫应

2290

要么你就是啥

2291

要么就是吃存量

2292

要么就是吃增量

2293

吃存量这叫卷

2294

明白了吧

2295

吃存量较卷吃增量

2296

这不叫卷

2297

所以说什么

2298

封闭系统是最容易卷的

2299

呵呵

2300

那那那那你要那啥

2301

你要吃增量吃增量

2302

那那无非就是就就是那个

2303

你要吃增量的话呢

2304

那那就呢

2305

那就那个

2306

两个两个方式对呢

2307

你要吃增量怎么增量

2308

要么你就抢别人的

2309

要么呢

2310

你去你去那个把这个蛋糕做大

2311

是吧

2312

你这个封闭系统资源不够了

2313

你去你去抢那个系统外的东西

2314

你去把那个抢过来

2315

这是帝国主义

2316

这叫外卷

2317

你把这个蛋糕做大

2318

把这个市场做大

2319

或者把这个职位做多

2320

这这就不叫卷了

2321

这叫丰富多彩是吧

2322

这叫扩张把这个千万不要看到一个卷

2323

然后大家就就说卷卷卷

2324

怎么我我不想卷

2325

我想去躺平等等等等等

2326

实际上咱不应该这样

2327

对

2328

开疆扩土

2329

这叫帝国主义

2330

应该什么

2331

应该应该

2332

那个应该是星辰大海

2333

应该星辰大海

2334

不应该

2335

不应该开疆扩土

2336

开疆扩土

2337

那那是那个西方列强

2338

对吧

2339

他给你去弄殖民地

2340

让你殖民地去卷

2341

然后他去抢你的东西

2342

那个不行

2343

你

2344

你要那个星辰大海

2345

星辰大海怎么样

2346

把眼光离开地球

2347

地球就这么大是吧

2348

你去火星吧

2349

哈哈

2350

以前是leader

2351

当然是leader了

2352

带过团队

2353

带个团队做个大项目

2354

那是过去了

2355

这个东西在于积累

2356

这这玩意儿在于积累

2357

并并不是说那个

2358

这都是平时点点滴滴点点滴滴的积累

2359

你你遇到什么事儿

2360

你要去

2361

你要去思考

2362

要要去反省

2363

然后咱们接着看下一个下一个下一个点

2364

下一个点是这个

2365

下一个点是这个

2366

我我很有钱

2367

我我很有我我偷偷的告诉你们

2368

我要很有钱

2369

我就不跟着老袁干啦

2370

我就我我就多买几套房子

2371

我就收租去啦

2372

我就不讲课了

2373

哎呀

2374

咱都是穷人

2375

咱都是穷人

2376

对

2377

老袁比我有钱

2378

不说这个了

2379

时间

2380

时间不够了

2381

时间不多了

2382

都快十点了

2383

不说笑话了

2384

然后看那个看那个

2385

这个是什么呢

2386

这个是

2387

咱们不看前面的captain了

2388

看就看那个这是什么

2389

函数指针

2390

这个东西是函数指针

2391

那么这个函数指针它是指向代码的指针

2392

咱们咱们前面那节课给大家讲的是那个指向数据的指针

2393

对吧

2394

指向数据的指针

2395

数据也好

2396

代码也好

2397

它都在内存里边儿

2398

那你都在内存里边儿

2399

那都可以找到它的地址

2400

能找到他的地址就可以用指针来

2401

就可以用指针来只那么这个东西

2402

这个东西就是指向代码的指针

2403

咱们写的那个函数

2404

他就是个他就是代码

2405

实际上咱们写的那个C语言函数

2406

C语言函数的那个实现

2407

咱们再打开一个文件

2408

再打开一个

2409

比如说像这个

2410

打开这个timer

2411

这个timer的这个代码少一点

2412

这是一个静态函数

2413

不管他什么静态

2414

不含静态不静态了

2415

这是一个C语言函数的实现呢

2416

C语言函数的实现

2417

它也有函数名来

2418

然后有这个

2419

行程表儿

2420

有形参表

2421

这是形式参数表简称形参这然后后边儿这个东西是实现

2422

实际上这个玩意儿函数名告诉你们一个秘密

2423

C语言里面函数名本身就是一个函数指针

2424

它本身就能当函数用

2425

当本身就能当指针用

2426

然后咱们再回到这个函数指针这儿来

2427

再回到这个函数指针这儿来

2428

这个函数指针实际上它就是一种声明

2429

声明了什么函数的原型

2430

什么叫函数原型

2431

这个函数长得什么样咱们JS里边儿很少提这个概念

2432

咱们JS里边儿也有函数原型这个东西

2433

但是咱们咱们在JS里面根本就不提这个东西

2434

根本不提这个概念

2435

因为这个函数的声明和和和实现都都在一起啦

2436

甚至有匿名函数对吧

2437

所以就匿名函数就跟根本就没没声明了

2438

就直接代码块儿了

2439

就没有这个这个这个这个函数名那这个是啥意思这个

2440

这是函数指针这是函数指针

2441

那么函数函数名可以当函数指针去用

2442

反过来也行

2443

反过来也一样

2444

函数指针你把它指向那个代码以后

2445

函数指针就可以当成函数去用

2446

当初函数去掉

2447

实际上这就是CC语言的那个灵活性在这儿

2448

咳

2449

那么在这儿

2450

为什么要声明这个函数指针呢

2451

因为C语言里边儿是没有多肽的

2452

对吧

2453

C语言里边没有多肽

2454

C语言它它不是面向对象语言

2455

什么叫多肽

2456

一个函数

2457

一个函数它有多种实现实现形式这叫多肽

2458

对吧

2459

在面向对象里面

2460

面向对象的语言里面

2461

这种这种东西是司空见惯的

2462

函数长得一模一样

2463

但是它是但是它里边的这个代码是是完全不一样的

2464

这是多肽

2465

但是C语言里面没有这个东西

2466

那那怎么去解决这个问题用函数指针

2467

函数指针他只要是这个函数的原型是一样的

2468

函数的原型是一样的

2469

就可以让函数指针去只

2470

那你只上去以后它就变成函数了

2471

这个这个指针名就变成函数了

2472

那直接当成函数去用

2473

是吧

2474

那么前面这个前面这个是海是指真名儿

2475

然后这个呢

2476

是声明指针的方式声明函数指针的方式

2477

后边儿呢

2478

是你这个函数指针要指向的那个函数

2479

它的它的那个形参

2480

它的形参是什么样儿

2481

前边儿别忘了有返回值

2482

咱们JS里面是没有返回恶

2483

那个没有声明这个返回值的

2484

这这这这这个这个概念的

2485

对吧

2486

C语言里边儿你要声明这个函数参数表函数名

2487

再加上返回值都得写出来

2488

这个JS里面的JS

2489

他返回的就是个对象

2490

是吧

2491

JS就是返回就是个对象

2492

你你能带啥呀

2493

你你你你这个返回值你能有啥类型对吧

2494

函数指针是这个

2495

函数指针是是这一块儿

2496

不带前面那个型号儿

2497

但是咱们看到这个形式的时候

2498

咱们要知道它是生命的一个函数指针

2499

那函数指针是这个东西

2500

那那么前面加一个星号

2501

加小括号

2502

这是它的语法规则声明函数指针时候的语法规则

2503

用的时候是不能加这个星号的

2504

用的时候直接拿这个拿这个

2505

直接用这个就行

2506

这是函数指针

2507

然后呢

2508

咱们接着

2509

这个结构体说过了

2510

当然这个C语言里边还有一个比较奇特的这个结构

2511

还有一个奇特的这个类型叫叫联合叫联合

2512

那么这个联合

2513

和那个TS里面联合有点类似

2514

只不过那个联合你是规定不了内存里边儿长什么样儿

2515

C语言里边这个联合呢

2516

他他就是复用复用这块儿同一块内存的这是联合

2517

那个联合呢

2518

你你大家去看那个回头把那个手册

2519

或者是去看那个上次给你们的那个网站

2520

去看一下那个联合

2521

那个联合是是挺有意思的

2522

那就是就是你在同样一个一块大一块内存里边

2523

你可以你可以保存不同不同类型的这个数据

2524

一个内存里边保存不同类型的数据

2525

你可以保

2526

比如说一个八个字节的内存

2527

你可以放放一个整形

2528

那可以当成一个整形去用

2529

也可以当成一个a字符型去用

2530

也可以当成一个双精度浮点型去用

2531

那就是去服用这个内存的

2532

随意操作内存

2533

非常非常灵活

2534

然后这这就是那个一些基本的这个语法

2535

这个C语言的这个这个语法

2536

然后咱们看这个代码这哈在看到这个代码

2537

那么这个C代码这前边儿要药引这个头文件不引头文件

2538

你在代码里边去去调用相对应的那个函数

2539

你是调不了的

2540

编译器会给你报错

2541

就相当于咱们去在JS里面去import一样一个道理的之后呢

2542

这个东西是什么呢

2543

这个玩意是什么呢

2544

这是变量

2545

这个变量它是个指针

2546

通过指针去找这个结构体里的

2547

属性

2548

通过通过指向结构体的指针去找结构体里的属性

2549

就是这个东西

2550

这个小箭头

2551

是吧

2552

咳咳

2553

A是指向结构体的指针

2554

通过指针找结构体里的

2555

成员就用就用箭头儿相当于什么

2556

相当于咱们JS里面那个点儿

2557

对吧

2558

你要找object里边那个属性

2559

那你得把它点出来你在C语言里边儿

2560

你用的是指针

2561

就用小箭头儿

2562

如果是一个结构体的变量呢

2563

她不是她不是指针

2564

它不是结构体的指针

2565

它是它就是这个结构体变量本身

2566

在这种情况下才用那个点儿

2567

这这是那个区别这是区别P2P也是箭头是吧

2568

P2P他那不是指针

2569

批十批不是指针内内不是指针

2570

它它都是引用

2571

别别别那个啥别那个整错了

2572

咳

2573

嗯

2574

好

2575

这是那个C的

2576

这是C的一些那个前面没有讲到的那个语法

2577

然后呢

2578

咱们再回到这个

2579

这个鼠标怎么不动了

2580

再回到这个源码

2581

这那么咱们再看这个源码的时候

2582

望文生义

2583

望文生义

2584

什么叫望文生义这个代码这个文件是干什么用的

2585

对吧

2586

文件干什么用的

2587

看它的文件名

2588

这是个啥呀

2589

这是个队列

2590

对吧

2591

这是个队列

2592

实际上它是声明了一个什么

2593

声明了一个队列

2594

生了一个队列的这个数据结构这这这就是队列

2595

只不过他这个队列是用红血的用用红血的

2596

他他那个编译出来的那个去用红处理

2597

处理之后

2598

他他生成的那个代码更加紧凑一些

2599

但是这个红容易造成混乱

2600

能不用还是不用

2601

那么这个呢

2602

STRCCPY是什么

2603

字符串拷贝

2604

他他他实现的就是去去拷贝字符串

2605

他他就是一拷贝字符串的功能

2606

望文生义

2607

看到这个名字咱就知道他干什么

2608

另外还有这个东西

2609

Keep对吧

2610

Keep是什么

2611

堆堆恶食这个堆怎么去实现呢

2612

实实现那个堆的那个定义

2613

然后呢

2614

C代码

2615

C代码也是这样

2616

C代码也是这样

2617

他他这里封装的封装的各各种各样的那个C

2618

你可以看到它的那个根据名字知道他是干什么

2619

比如说这个call是什么

2620

就是它的核心

2621

它的核心代码

2622

根据这个去看

2623

然后呢

2624

咱们再看一下note

2625

看一下note的那个带note JS的代码

2626

V8的咱就V8V8弄的实际上差不多

2627

都是C加加的

2628

算了

2629

还是看V88上节课

2630

上节课那个看了一眼

2631

看了一眼那个弄的

2632

看V8 v8也是

2633

看到看先看什么

2634

先看include

2635

还有s r c INC Lu的决定了你这里边有什么东西

2636

你的代码有什么东西

2637

SRC是实现它这个微吧

2638

东西挺多的

2639

按照模块儿分成了不同的这个目录

2640

比如说他对外提供的API

2641

你要把它给嵌到这里边

2642

你要把这个VV8000到你自己的那个程序里边儿

2643

那你你你对这块儿的代码感兴趣

2644

就看它

2645

它是对外提供的那个接口

2646

八对外提供的接口

2647

然后呢

2648

咱们看ADUI是吧

2649

实际上咱们最感兴趣的就是内存管理

2650

还有他的那个类型等等类型的这个实现

2651

如果说你对他的那个这个堆内存来感兴趣

2652

那就转到这个堆这儿来

2653

然后看什么

2654

看它里边的这个相关的东西

2655

那他从哪开始看

2656

直接看这个heap

2657

直接找这个heap

2658

然后找到这个hip以后呢

2659

再看

2660

这个C代码

2661

它实现的是这个堆的哪一部分这个这个命名

2662

这个命名命名规则是命名规则是很重要的

2663

那么它的这个堆

2664

比如说我们看一下这个heap.cc这是对这是那个堆的实现呢

2665

那么这个堆的实现

2666

在在在在哪儿呢

2667

在在这儿初始化这个堆是吧

2668

这这是堆的堆

2669

这是那个hip那个累

2670

这是hip类

2671

类类的结构定义在头文件里

2672

那那么累的那个实现呢

2673

是这个

2674

这是实现的时候累的名字双冒号后边是

2675

类方法的名字

2676

这是里边那个里边那个实现

2677

那这这这这一块儿都是都是这个堆都是堆的那个实现代码了

2678

咱们要感兴趣的话

2679

就就就看这一块儿

2680

那如果说咱们看这一块儿想一一直往下看

2681

比如说这个hip hip的构造函数

2682

对吧

2683

你要看一个累的话

2684

先看它的构造函数

2685

看他做了哪些初始化

2686

看他做哪些初始化

2687

这个是什么的

2688

Tek EQ啊

2689

他在干什么呢

2690

去检查他去检查一个东西

2691

这个东西是啥呀

2692

EQ实际上就是这个队列

2693

相当于恶劣检查一个队列

2694

他他在这儿去做那个初始化

2695

初始化了好多个结构

2696

两个list

2697

然后这个是什么

2698

这个是

2699

这个是那个映射页面

2700

内存的那个页面映射映射规则

2701

这是什么map I map的配置就是没有印社的那些页面

2702

这是内存管理的一个一个算法

2703

就是那个内存你要你要给人家分配内存的话

2704

内存内内存分配算法

2705

你不能一块儿一块儿给

2706

你不能恶那个

2707

内存里边儿切一块儿就给他

2708

你不能这样

2709

你先得把内存分成若干个小单元

2710

这若干个小单元叫什么

2711

就叫页面就是内存页面是吧

2712

你他要多少内存

2713

你你比如说你一个一个内存页面儿是是那个4K

2714

对吧

2715

他要想要7K

2716

他要想要7K的内存

2717

你就得你就得给他分两个页面

2718

是吧

2719

这这这么一个东西

2720

这么一个套路

2721

那这个在CC语言里边

2722

在C加加语言在C加加里边呢

2723

实际上它里边这个看这个C加加的话

2724

先看累

2725

先看先找到这个对应的类

2726

然后呢

2727

再再找这个类

2728

类方法类方法搞清楚他是干什么的

2729

再去分析他那个类方法的实验比如说要找那个hip类B类C类都在这儿呢

2730

在这儿声明了这么多这么多累对吧

2731

这是命名空间

2732

就相当于咱们那个JS里面那个包名儿

2733

这这个包里边有这么两个有有这么两个类

2734

然后这个这这还有一个这个B类这这这是那个在这个heap包底下有一个hip类

2735

就就是咱们JS里面那个包路径

2736

相当于那个东西

2737

之后在后边呢

2738

这是这是累的定义

2739

类里边儿有多少个成员属性有多少个都有什么那个方法

2740

类方法先看类定义

2741

然后呢

2742

再看类方法里边儿那个实现就就就是按照这种顺序

2743

然后这个这个C加加里边儿有一个东西是啥

2744

就是这个东西

2745

这是最后最后一点

2746

大家要注意这个东西是什么呢

2747

是饭行

2748

这叫梵行

2749

就是模板类

2750

咱们TS里边儿好像也有犯行

2751

对吧

2752

JS这个Java里边也有饭行JS没有

2753

那么这个模板类

2754

它就是这个代码模板

2755

相当于代码模板

2756

那么这个泛型它也是一种预处理代码

2757

但他不是红蛋

2758

它归入那个预处理代码里面去呢

2759

这种东西呢

2760

就是啊

2761

就是更加紧凑了

2762

他他不是那个对象实际上这个这个模板

2763

模板看上去和那个和那个对象是挺像的呢

2764

对吧

2765

和那个对对象挺像

2766

但实际上不是

2767

不是他他就是给你搭一个架子

2768

然后然后把你这个架子里边儿给你做好了

2769

各种各样的那个各种各样的那个处理机制

2770

然后把你要

2771

把你要那个

2772

把你要放入这个处理机制里边儿那个数据

2773

给他传进去

2774

到时候直接编译成代码

2775

就可以少写好多代码

2776

比如说有那个list

2777

比如说有那个list泛型

2778

泛型那边有list list泛型类

2779

那你要想用这个list这个结构

2780

但是呢a list里边儿那个放的那个元素

2781

元素类型你是各种各样的

2782

你可以把元素类型传给那个类似的类似的模板

2783

然后就专编辑代码的时候生成的就是专门针对你那个数据类型的那个list

2784

那这这个东西就属于属于代码代码复用的好

2785

那么这个

2786

C语言代码呢

2787

其他的东西

2788

其他的东西没有什么没有什么这个太多好说的那个因为在这个在这种代码里边

2789

像什么有缘之类的

2790

这这些特性一般是比较少用的

2791

还有什么操作符承载之类的

2792

在这种引擎里边也不多见

2793

更别说那个多继承呢

2794

那个多继承一般都是尽可能的那个去尽可能的去那个避免去使用的好今天呢

2795

这个课

2796

就先给大家讲到就先给大家讲到这儿了

2797

实际上这个因为这个时间关系

2798

像这个C语言

2799

还有这个C加加语言这方面的这些这些东西

2800

这这些这些东西是是挺多的

2801

咱们就分步骤走

2802

如果说你对这个C语言或者C加加感兴趣

2803

第一步就是先能看懂代码

2804

是吧

2805

然后呢

2806

再去写一些简单的东西这是按按分步骤走

2807

那如果说你你不想学这个C语言

2808

以后也不打算用这个C和或者是C加加写代码

2809

但是它的语法也得搞清楚

2810

你搞清楚你你就能看看懂它底层的那些机智了

2811

这这是有很大好处的实际上多这个多学一点东西

2812

他也没什么坏处的

2813

像那些你你咱们做JS的

2814

你要会C

2815

你要会C

2816

你这个系你要走技术路线的话

2817

你是相当占便宜的

2818

就好像是做Java的一样

2819

做Java的他要会C

2820

加加他的

2821

他是很很占便宜的

2822

为什么做Java的会C加加很占便宜

2823

他可以写那个

2824

他可以写那个JNA层那个JN是什么

2825

就是就等于用C加加给他

2826

用C加加给他给给他写扩展你你要想给note写扩展

2827

那就是C加加吗

2828

你你是很占便宜的

2829

看了又好像什么都没看这个这个你需要时间去磨

2830

这个你需要去时间去磨

2831

你要先把语法搞懂

2832

然后才能去看懂他这个代码不是看不是为看代码看代码

2833

而是看他那个机制看流程

2834

那你怎么去看人家JS代码

2835

你就你就怎么去看C代码

2836

但是但是呢

2837

前提前提千万别忘了

2838

好了

2839

今天呢

2840

就先给大家讲到这儿了

2841

然后那个下周

2842

下周给大家讲那个WSM之类的WSM也也咱就用C去写

2843

WSM咱们用C去实现那个DEMO

2844

用C实现的

2845

这C你是躲不掉的

2846

你要你要做这个性能优化

2847

你你你优化到极致

2848

你可不是得写WSM吗

2849

对吧

2850

那你不会塞也不会C加加你怎么写

2851

你没法写

2852

这个活你就干不了

2853

那你就去卷吧

2854

是吧

2855

哈哈

2856

这这这就真正的给这就真的给见到那个卷里边儿去了

2857

好

2858

今天就先到这儿

2859

咱们那个下周再见

