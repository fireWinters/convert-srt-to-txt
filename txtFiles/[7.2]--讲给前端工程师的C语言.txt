1

哼哼哼哼

2

蹦蹦蹦蹦蹦蹦蹦蹦蹦蹦蹦蹦蹦蹦

3

嗯

4

人都到齐了没

5

你不困了

6

我能解困是吧

7

一看到我就瞬间不困了你这

8

你们吐完了就不困了是吧

9

好

10

咱们开讲

11

这节课呢

12

咱们是这个前端前端跨界

13

前端跨界是啥玩意儿呢

14

就是和咱们前端相关的

15

咱们前端能做的

16

咱们用JS能写的

17

还有咱们前端相关底层的东西

18

看着看着和前端不搭边儿

19

但是呢

20

和这个前端

21

但是前端你你要说管他吧

22

他咱们前端也能管呢

23

这就是那个前端跨界

24

比如说像什么这个给弄的

25

用C语言

26

给给弄的写个什么

27

写个扩展

28

你你说算不算前端

29

你说算

30

他不是他不是咱们印象里边儿那种

31

你说不算吧

32

他还他还和咱们前端有关系对吧

33

这个

34

另外呢

35

还有那个比如说像那种物联网

36

物联网咱们也能拿JS去写

37

还有呢

38

就是像那个华为的那个操作系统

39

那个鸿蒙

40

那个鸿蒙呢

41

他那个UI就是纯JS的

42

对吧

43

不知道你们研究过没有

44

实际上这个鸿蒙

45

这个那个鸿蒙用JS写一写的那个UI呢

46

那个套路和小程序是非常像的

47

咱们那个所以说呢

48

咱们那个什么时候那个前端

49

他不火了

50

咱们还可以去干点别的

51

尤尤其是那个

52

尤其是那个赚钱多的那种

53

你们这个你你啥啥玩意儿

54

你这个你这是人话吗

55

这个什么什么老师您贵姓

56

你不知道我谁

57

你你这这这这这这过分了

58

我是不是进错

59

我我是不是进错教室了

60

你们那个

61

我我没进错吧

62

没进错吧

63

拿

64

没进错

65

这这这家伙你吓我一跳

66

你说我记错了教室

67

你说这尴尬了

68

咱们那个

69

呵呵

70

别闹

71

都别闹

72

这个来得有点晚

73

你这饿得有点晚

74

但是好好听

75

咱们这个实际上呢

76

咱们咱们做前端

77

有同学可能会说做前端这个C语言呢

78

那个这个学C语言干啥呀

79

学习语言很重要

80

和这个和那个底层相关的这些这些东西

81

你都逃不出这个C语言去

82

所以说这个C语言呢

83

学这个C语言不是学这个语言本身

84

对吧

85

不是不是语言本身

86

而是呢

87

是和这个和底层相关的C语言

88

他现在C语言所用的这个领域

89

他就是他就是那个和底层

90

这和底层这个关联特别大

91

还有和这个硬件和这个硬件关联特别大的这种

92

那么咱们学C语言呢

93

不讲这个语法层面上的东西

94

实际上这个语法是很简单的

95

除了那个结构体和指针

96

这这两块儿

97

咱们JS里没有其他的那个语法

98

和JS很像

99

而且这个C语言呢

100

他没有面向对象的一些东西

101

C语言理事他是没有对象的

102

只要咱们学了C语言

103

主要是为了让大家帮助大家去了解这个底层

104

还有这个内存内这个内存是怎么回事儿

105

这究竟是怎么内存管理究竟是怎么做的

106

它那个自动垃圾自动回收

107

他和那个纯手动的这个回收

108

这究竟是怎么回事儿

109

咱们是为了了解这个东西

110

还有呢

111

后边咱们

112

这个下面这两节课呢

113

咱们还会去看一下他们那个弄得JS

114

还有这个微吧

115

还有还有那个web kit的之类的这些源码是吧

116

咱们dei dei能看懂这个语法

117

至于说咱们去写个插件儿啥的

118

这个你需要去下点功夫好好好好好的那个好好的那个学一下

119

咳

120

好

121

咱们那个就开始

122

那么这个这节课呢

123

咱们主要呢

124

先去讲那个CPU和内存

125

这个这个就是纯纯粹的这个计算机的这个底层层面上的东西然后呢

126

咱们再再再讲一讲那个汇编

127

还有这个C语言

128

让大家了解一下

129

并不是说去学这东西

130

去去学这个汇编

131

还有这机器语言

132

不不是学这东西

133

实际上这个这个玩意儿

134

去去去那个了解一下

135

帮助咱们去更更好的去理解这个C语言是她是她是怎么回事儿

136

然后就是然后就是主要是这个指针

137

指针和内存咱们前边儿咱们后边还要去讲那个数据结构呢

138

实际上这个数据结构一一一方面是逻辑上的结构

139

一方面是实现上的结构那么这个不不这个不了解这个内存这个内存机制咱咱们那个实线是比较实现是比较麻烦的

140

好

141

然后呢

142

咱们先看这个学C语言

143

学这个C语言这个

144

到底要要要学什么东西实际上咱们这个C语言呢

145

在前端这一块儿呢

146

用的是用的还是相当的那个广泛的

147

那么咱们C语言

148

有的时候咱们在那个Linux的服务器上的

149

在Linux服务器上去装一些这个环境的时候

150

他没有他是没有那个安装包的

151

他需要需要咱们直接从那个源码去安装

152

咱们去编译那个源码一编译完了源码以后

153

然后然后用那个脚本去装这这这就和那个C语言就相关啦

154

这涉及到那个C语言的那个编译链

155

那么咱们那个C语言的基本语法和JS挺非常像

156

也因为那个JS他出现的这个时间

157

就他他这个出现的时间就很很靠前啦

158

就就很很久了

159

那那么那个实际上那个时候的语言呢

160

基本上都是仿照的这个C语言的语法

161

另外还有另外一个

162

还有另外那么一个方向

163

就是仿照

164

仿照那个Python语言的那种语法

165

反正仿照C语言语法的语言是相当多的

166

之后呢

167

就是这个指针

168

指针和C语言里边内内内那些东西了

169

这个玩意是重中之重

170

当初我在学那个C语言的时候呢

171

有那么一本非常薄的那么一本儿书

172

那本书就就100多页

173

不到200页

174

内内叫什么来着

175

C语言指针陷阱

176

实际上这个C语言它难吗

177

它一点儿都不难

178

难就难在这个指针和内存上

179

Nei nei内本书是相当经典的

180

现现在都绝版了

181

你想买都买不到

182

那个另外呢

183

咱们在搞懂这个V8内存管理的时候

184

他在C语言啥C语言嗨

185

就是那个指针陷阱C语言指针陷阱这本书

186

咱们再再那个研究V8的时候

187

研究V8底层机制的时候

188

咱们需要去从从那个源码开始看起那个微吧里边儿实际上呢

189

有好多都是这个数据结构和处理机制

190

数据结构和处理机制

191

那个玩意儿咱们得得能读懂它的原码吧

192

对吧

193

咱咱咱咱用C语言写不出来的

194

但是咱得能看懂所以这个玩意儿是那个你你对你这个长城长是非常有帮助的

195

那么咱们闲话就不多说了

196

先从这个CPU开始

197

咱们这CPU

198

它是怎么回事儿呢

199

咱们这个计算机里面最重要的两个部件

200

最重要的两个部件就是CPU和内存呢

201

那么这个CPU呢

202

咱们先简单的了解一下

203

首先呢

204

这个CPU

205

它的指令集

206

不同啊

207

什么叫指令集

208

不同啊

209

比如说咱们那个PC上

210

或者是那个台机或者普通的那个Windows Windows本儿

211

那种指令集叫什么呢

212

他叫X86杠X64指令集

213

这个就是英特尔的那种指令集

214

另外还有另外一种

215

还有另外一种CPU呢

216

他叫啥呀

217

他是ARM

218

它用在咱们这个手机

219

或者是平板儿等等

220

还有一部分

221

一少部分那个笔记本儿也在用那个ARM

222

另外呢

223

比如说像那个呢

224

Apple啊

225

那个苹果的那个M1

226

对吧

227

M1那个那个那个CPU

228

他也是ARM指令集的

229

那么这个指令集和指令集

230

她是不通用的

231

那也就是说你编译出来的那个二进制的那个程序

232

你是不能跨CPU去用的

233

那当然你的代码是可以重新编译的

234

你你的代码可以针对针对这个X86去编译

235

也可以针对这个ARM去编译

236

这叫什么

237

这叫交叉变异

238

你在比如说你在Windows平台上

239

你去编译那个ARM平台上的这个源代码

240

ARM平台上的这个程序

241

这叫交叉编译

242

所以那么这种这种交叉编译呢

243

可就可以让我们去

244

可以让我们去跨跨平台那么这个另外还有

245

比如说像这个map

246

这个map咱们咱们很少接触了呢

247

一般用在那个服务器上

248

还有呢

249

就是那个龙欣那个隆鑫哈那个

250

那个龙心内那种芯片

251

这这这个这个也比较老了

252

就国产的一国产的一种芯片

253

他用的也是这个maps这个MIPS指令集

254

他他这个知识版权比较好搞一些

255

所以那个隆鑫就用了maps

256

后来后来龙心就就专攻这个服务器了

257

他他他就不管他他就不去搞这个个人桌面这这个方向了

258

另外还有一种叫瑞克瑞斯科教精简指令集

259

这种指令集是开源的主要的指令集是是是这四种咱们实际上咱们用的咱们用的那个普通的麦克

260

还有那个Windows本Windows电脑

261

都都是X86的

262

那么这个

263

指令集啊

264

他就他这个指令集就决定的

265

就决定了你这个跑的这个系统

266

他跑跑决定你跑这个系统的主要系统是什么比如说手机上

267

安卓对吧

268

他跑跑着Android

269

只要安卓它底层就是Linux那么这个CPUCPU它的组成是什么样的呢

270

CPU主要是三部分

271

咱们是一层一层的往下抽象那么这个图呢

272

是最简单的一个模型

273

CPU最简单的一个模型

274

那这在CPU里边呢

275

三部分

276

一个是控制单元是控制单元

277

控制单元干什么

278

他就是负责

279

他就是负责调度的

280

那控制单元就是就就是这来调度

281

他调度什么呢

282

他调度

283

从存储单元把数据或者是指令拿出来

284

然后呢

285

放到晕

286

然后发给这个运算单元

287

让运算单元干活运算单元干完了活儿以后呢

288

控制单元a再把这个数据再放回这个存储单元去呢

289

他他就是负责来调度这个东西

290

那么调度这个东西

291

那么除了去去调度这些去搞调度

292

实际上他还搞搞其他的一些

293

还还做其他一室

294

比如说这个存储单元

295

它是在CPU的内部

296

他不是内存

297

咱们要注意

298

存储单元它不是内存

299

内存它在CPU的外边儿呢

300

对吧

301

除了这个内内存

302

除了这个内存

303

它还有一个存储器

304

存储器叫什么

305

叫外存那个外存就是咱们咱们那个硬盘

306

U盘啊

307

光盘等等这些东西

308

实际上这个数据是它是怎么流的

309

他是怎么流动的呢

310

从硬盘拿出来放到放到内存里

311

再从内存放到把这个数据放到存储单元之后呢

312

再把这个存储单元的数据交给运算单元去处理

313

那运算单元处理完了以后

314

再把结果放回到存储单元来

315

存储单元是因为CPU里边这个存储单元它是很小的

316

他他非常非常小

317

那不不可能总是在这个存储单元这儿放着

318

如果说暂时用不着或或者是她

319

他就是最终结果

320

再把这个结果再放到内存里边儿去最后呢

321

再把这个结构保存到硬盘上

322

他是这么一个流程那那么这个CPU

323

可以说这个CPU就是咱们这个计算机的这个核心了那么在CPU

324

这个CPU主要这这三大块儿

325

看着挺简单

326

实际上内部是相当那个

327

内部是相当复杂的

328

那么它内部是什么样的

329

咱们把这个咱们把这个简单的这个模型

330

把它放大放大以后呢

331

就变成这样了

332

那么第二个图咱们就加了点东西

333

对吧

334

加点儿东西是CPU在这一块儿这这是把控制单元

335

控制单元里边儿这给放大了

336

那大家肯定会会会会想

337

那么那个数据和指令是怎么拿到CPU里去的

338

大家肯定会对这个有疑问

339

对吧

340

那么在这个图呢

341

除了把这个CPU这这这个控制单元放大

342

咱们把这个内存也

343

也加进来

344

在之前

345

咱们给大家讲那个Linux的时候给大家讲过

346

那么咱们的那个程序放在硬盘上

347

它是那个点exe对吧

348

他是个静态的然后呢

349

把这个点exe放到内存里边儿

350

它就变成动态的了

351

那么动态的它叫什么名字

352

他叫进城对呢

353

它变成动态的

354

他就要进他他就要进城了

355

那么这个进程a

356

咱们当初也给大家说过

357

在进程里边儿它分

358

两块儿呢

359

一块儿就是指令

360

那这个指令就是咱们这个程序的代码

361

对吧

362

咱们不管是用C写的

363

用Java写的

364

用JS写的

365

只要你扔到这个内存里边

366

他必定他要转成这个指令另外一部分呢

367

就是这个数据

368

那么在这个进程里边

369

在这个进程的内存空间里边儿

370

这个把把进程放到内存里边儿去之后

371

操作系统会给这个进程分配内存空间

372

那么这个内存空间

373

它会主要分成两段儿

374

分成两块儿

375

分成两块儿

376

那么放指令的这一块儿

377

他叫代码段

378

放数据的那一块儿呢

379

它叫数据段

380

比如说那个这这个代码段

381

就是程程序本身

382

比如说你写的什么if else啊

383

还有什么for

384

For well哈什么阿之类的这些东西

385

就都都是这个指令

386

还有什么函数

387

你实现的一些函数等等都在这一块儿

388

都都在这个地方

389

它要执行的是东西

390

那么数据呢

391

比如说你那些变量

392

你什么局部变量

393

全局变量

394

还有什么字符串

395

你的对象

396

乱七八糟的全都在数据段这

397

在这儿来的

398

那么CPU它是怎么处理的呢

399

首先呢

400

当这个进程

401

将这个进程内加载到内存里边儿去以后

402

操作系统他来调度

403

对吧

404

操作系统来调度

405

那么Linux它本身是一个

406

本身它是一个那个多任务系统

407

什么时候轮到这个进程去跑了

408

然后操作系统就把控制权

409

就把这个控制权就交给了这个进程

410

交给进城以后

411

接下来干什么呢

412

接下来干什么呢

413

接下来

414

那么就要从这个进程的代码段这把指令给取出来取出来以后交给控制单元交给控制单元

415

那么交给控制单

416

他怎么知道从哪儿去取呢

417

操作系统它会得到这个进程的第一条指令所在的地址

418

那也就是说它在内存当中的那个位置

419

然后那么这个地址他放在哪儿就放在指令寄存器里边儿

420

那么CPU他再执行下一条指令的时候

421

这个指令寄存器

422

这个指令计数器

423

她永远她永远是保存的是永远保存的是下一条指令所在的位置在内存当中所在的位置呢

424

然后根据这个指令寄存器找到这个指令的位置

425

找到以后把指令拿过来

426

拿过来放到哪儿呢

427

放到CPU里的这个指令寄存器里边儿

428

这个指令寄存器

429

它就是下一条下一个要执行的这个CPU质量呢

430

然后根据这个指令来控制

431

到底是把这个到底是拿数据

432

还还是还是那个告诉预算单元来来处理数据它根据这条指令来来决定

433

如果是

434

要取数据呢

435

如果他要取数据的话

436

那么这条指令就要根据根据这个

437

数据在

438

这个内存当中的地址

439

去找到这块数据

440

那么这个数据的地址在哪儿呢

441

A也在一个寄存器里

442

也在CPU的一个寄存器里

443

CPU里边是有好多寄存器的

444

这些寄存器还有存指令的

445

有存数据的

446

还有那个这个还有找那个下一条指令是什么呢

447

还有什么预处理指令的一个现代CPU里边大概有会有上百个寄存器

448

那么那这个数据的这个数据的这个操作

449

这个数据的这个地址就放在放在另外一个寄存器里

450

根据另外一个寄存器里找到数据的地址

451

就从就从这个对应的内存当中拿出来了

452

拿出来以后扔给存储单元

453

那么把数据拿过来了

454

接下来就要处理数据对吧

455

咱们程序的本质是什么呢

456

程序的本质就是数据加操作

457

数据加操作对吧

458

就是数据结构加算法对吧

459

数据结构就是数据

460

算法就是操作那么数据有了

461

下一个就是操作

462

那么操作谁来操作

463

当然是运算单元来操作

464

实际上计算机里边他怎么操作

465

他就是他就是加减乘除实际上他到到最终

466

到最后他就是个加法CPU里边所有的内那些那个运算指令

467

都是基于加法来都是基于加法来来来那个组装出来的

468

那么这个这种这种那个处理指令这种处理

469

全给预算单元去做

470

那好

471

那么第一条指令取数据

472

那第二条指令再娶个数据

473

比如说一加一等于二

474

对吧

475

他的取两个数据

476

取两个数据都放到放到存储单元这儿

477

下一个指令就就该干活了

478

一加一对吧

479

一加一

480

那那那加法谁做

481

当然让预算员做

482

那么你加法做完了以后

483

得出一个结果来

484

这个结果放在哪儿放在存储单元里

485

你不能总是发

486

总是让预算单元帮你保存

487

你你把结果放到存储单元

488

那么放到存储单元里好

489

那么这个值有了

490

这个只有了

491

那那这个值不能总是在存储单元这儿放着

492

它的容量是有限的

493

那怎么办

494

把这个存储单元的这个数据

495

再回写到这个内存当中去

496

最后呢

497

再根据需要

498

如果说你这个数据需要保存到文件

499

那在那再把这个数据把它保存到这个硬盘上去

500

是这么这么一种流程

501

所以说这个CPU当中的这个CPU当中的

502

这三个东西

503

这三个东西就是最主要的核心

504

那最主要的三个那个核心单元

505

一个是控制单元

506

一个是存储单元

507

一个是运算单元这

508

就这就这仨

509

那么这三个

510

把这三个再放大

511

把这三个再放大又是什么样的呢

512

就是这样的

513

就是这样了

514

那么这个

515

咱们就咱们就不去

516

咱们就不去讲这个流程了

517

他不是那个123级缓存

518

存储单元不是123级缓存

519

那个缓存它有自己的用处

520

他是那个做那个数据域

521

做那个数据预加载的那个缓存

522

因为你从

523

你从那个内存这儿

524

实际上啊

525

咱们再再再多说两句

526

你把数据从内存这儿来

527

把它拿到这个CPU

528

这实际上这个效率是比较低的

529

这个数据传输的效率是比较低的

530

那么这个传输效率

531

传输效率从高到低它是怎么样呢

532

在CPU内部

533

在CPU内部传输数据是最快的然后呢

534

从内存把数据拿过来拿到CPU里

535

这个其次呢

536

然后从硬盘或者是其他的这个外存a把数据拿到内存里边儿

537

这个这个最慢

538

那为什么会这样呢

539

因为在CPU内部处理

540

这就是他自己的东西

541

如果说要从CPU

542

外部去拿数据的话

543

要走IO

544

那么这个IO指的是什么东西

545

到底IO针对的是CPU

546

IO是什么东西

547

IOI是什么

548

Input o呢

549

Output

550

对吧

551

输入输出输入输出是针对谁来说

552

针对CPU来说的呢

553

从外部设备把数据拿过来

554

或者是把内部的数据交给外部数据都要走IO

555

我看那么对于这种IO

556

对于内存到CPU走的是主板上的那个线路

557

实际上他是实际上他是那个

558

实际上它是那个

559

那个速度比CPU内部要要慢很多

560

那么从

561

硬盘把数据扔给这个内存

562

那它就不是在主板上了对吧

563

他他他要你硬盘要接到那个主板上的一个接口上

564

这个速度更慢

565

这速度就更慢了

566

所以呢

567

就需要当你数据再进行这个

568

部件和部件之间进行移动的时候需要干什么

569

需要缓存

570

对吧

571

咱们之前

572

咱们之前再给大家讲那个

573

之前在给大家讲那个HTP协议的时候

574

大家还记得吧

575

讲HDP协议的时候

576

咱们讲那个缓存

577

对吧

578

那个缓存当时我给大家说过

579

当时给大家怎么说的

580

这个缓存

581

它各有它在什么地方都会出现

582

那么缓存的意义在哪儿呢

583

就是为了去减少

584

就是为了去减少这个数据来回倒腾的时候

585

来回倒腾的时候

586

你所消耗的那个时间

587

他他就是一个

588

他就是一个这暂存区

589

他就是一个暂存区

590

哈恶

591

所以说

592

这个这个内存不但在HDP那儿有

593

在网络的底层的那个套接字那儿也有

594

在CPU内部也有

595

那个缓存它不是存储单元

596

他是他是他是为了防止

597

防止你这个数据来回倒腾

598

她她那个对时间的这么一个耗损

599

他干这个用

600

好

601

那么咱们接下来

602

就再看下一个图

603

再看下一个图

604

那么这个图

605

咱就不仔细的去讲他了不仔细的讲了

606

为什么不仔细讲

607

因为这个东西

608

讲起来就太复杂了咱们就了解一下

609

刚才咱们所说的那个寄存器

610

刚刚才所说的这个指令G指令寄存器

611

还有保存数据的寄存器

612

她在什么地方他在这里

613

这些这这里属于那个通用寄存器组

614

那么这个图是是是哪种CPU的图

615

他是一个非常非常古老的CPU

616

就是那个叉八六那个CPU的那个第二代

617

可也可以说是第一代

618

一袋半是8086

619

实际上第一代CPU

620

英特尔第一代CP第一代CPU是什么型号4004

621

然后是8008

622

8008

623

这这是那个英特尔的第一代CPU

624

然后就然后第二第二代是什么呢

625

8080

626

还有呢

627

8086

628

这是这是第二代CPU

629

这个就是第二代

630

像像这个CPU现在已经很现现在已经很那个啥了

631

像这种CPU现在现在是已经看在在理论上来说是非常简单的

632

非是非常简单的这么一种一种CPU了

633

尽管说简单

634

但是咱们自己也做不出来那么它

635

像这个玩意儿呢

636

也很便宜

637

也就是现在这个8086这种CPU

638

他是另外一个型号了

639

反正那个型号我王乐

640

反正国内的国国内的那个半导体这个厂家

641

也是很很轻易的能够把它给做出来

642

那么这种东西

643

这种东西大概是那个一两块钱一片现现现在这个8086

644

在当初可是好几百美元一片

645

那么这这个东西呢

646

这个图是从哪儿找的呢

647

就是当初

648

当初我在学汇编的时候

649

他在学那个汇编语言的时候a有一本儿有一本儿教材叫什么

650

叫80868088088086汇编语言这这这这是那本书里边儿的

651

他就是为了去去告诉你

652

这个指令它到底是怎么走的那么在这一块儿

653

这一块儿就是咱们刚才所说的那个寄存器

654

然后在这一块儿呢

655

也是寄存器

656

那么这一块儿他就释放指令和数据的这一块儿是CPU内部

657

CPU内部在模块和模块之间进行通信的时候

658

它用的那么在CPU内部里边儿

659

像像像像像这些东西

660

有控制单元

661

有什么运算单元

662

另外呢

663

还有这个寻寻址单元

664

寻址单元

665

那个寻址单元就是用来那个操作内存的那么在这

666

这些单元

667

这些这些模块之间

668

他怎么去传输数据呢

669

由内部总线

670

由由内部总线来来来负责

671

这是在全都封装到这个CPU恶CPU的内部里边儿了

672

所以说所以说在在那个CPU内部呢

673

那个在在CPU内部呢

674

它的速度是很快的

675

全都封装到一起了

676

那么这个这个图

677

咱们就那个了解一下

678

了解一下就够了不不不用去那个深究他深究它也没什么意思对吧

679

嗯

680

刚才有同学说哈

681

你打错字了

682

那个刚才有同学说

683

想着自己焊一个对吧

684

学着自己焊一个

685

实际上这种事儿

686

非非得不讨好

687

对不对你可以用那个半导体元件儿可以用那个半导体元件儿可以自己攒但是呢

688

那个玩意儿是没有意义没没有太大意义

689

你又不是学这个东西的

690

你除了除除非你用来消磨时间

691

你你有这么几年的业余时间

692

你拿那个玩意儿去消磨时间

693

这可以

694

好

695

然后接下来

696

接下来咱们CPU

697

CPU给大家那个说完了之后呢

698

就是这个计算机

699

计算机语言它的本质是什么

700

计算机的本质就是二进制

701

就是二进制数据

702

那么这个二进制数据

703

他要对应的那个

704

他要对应那个CPU的指令

705

这这个数据它对应的是那个CPU的指令

706

那么这个指令它这个指令它是什么样的呢

707

实际上那个CPU的指令

708

她就是0101

709

他有自己的这么一套编码方式

710

这个编码方式呢

711

有兴趣有兴趣的同学

712

可以去百度一下

713

内那个咱就不详细说了

714

一一说那个大家都都晕了

715

只要在CPU内部

716

它的编码

717

它的编码方式是有好好多种的

718

比如说什么什么那个什么什么什么那个反码补码儿

719

还这是给数据编码的

720

还有还有什么BDC码等等

721

另外这个指令

722

怎样让这个怎样让这个指令他不产生歧义

723

对吧保证它的唯一性

724

而且呢

725

让他的处理更快

726

它有自己独特的这么一套指令编码

727

这个咱们不深究

728

感兴趣的同学可以自己去百度一下

729

然后呢

730

然后这种指令

731

这种指令它它叫什么呢

732

它叫机器指令

733

这种二进制数据

734

他就是机器质量

735

大家看到后边儿这个痛苦指数了

736

对对吧

737

他不是那个图零机

738

他不是那个图灵机

739

图灵机是一种计算机模型

740

等一会儿给大家说一下这个图零机是怎么回事儿如果说你感兴趣

741

感兴趣的话可以给你说一下

742

那么这个机器指令本身就是那个0101

743

就是就是他CPU内部他他所做的那个编码

744

你要用这个东西去去编码的话

745

你要用这个玩意儿去去编程的话

746

那你就那你估计你你脑袋上那个头发

747

是一根都不剩

748

为什么一根都不剩

749

很容易出错

750

你0101满满眼都是这个

751

要么是个圈一

752

要么是个一

753

对吧

754

肯定啊

755

肯定让人崩溃

756

那么最早给计算机去编程

757

最早给计算机编程

758

他是怎么编程

759

就是这么一条这么一条纸带

760

在这个纸袋上干什么

761

打孔在纸带上打孔

762

这个打孔的位置就是一

763

没打孔的位置就是零

764

然后呢

765

专门有那么一排

766

专门有一排那个其他的那个孔是是为了让齿轮

767

把这个纸

768

把这个纸袋往机器里去送的

769

送进去以后用光电设备去照射这些

770

照射这些位置

771

固定的位置

772

能够接收到信号的

773

那就是一接收不到信号的就是零

774

就这样通过这种方式

775

把这个程序给输入到计算机里

776

当初就就是就就是在这上面打孔

777

所以说这个非常非常痛苦

778

不建议

779

这个不建议让大家去

780

不建议用这种方式去去那个编程

781

然后呢

782

就是那个

783

然后呢

784

这种方式很很很麻烦

785

也也很容易出错

786

那怎么办

787

用这个汇编指令

788

汇编指令是什么呢

789

汇编指令就是机器指令助记符汇编指令的汇编的这个中文完整的中文叫机器指令助记符

790

实际上它和机器指令比起来是换汤不换药

791

怎么叫换汤不换药呢

792

就是每一个机器指令它都对应着

793

他都对应着这么一个这么一个单词

794

一个单词的缩写

795

比如说你做加法

796

做加法的指令是什么

797

ADD对吧

798

然后你把一个数据

799

你把一个数据把他一把

800

把他放到内存当中的某一个位置

801

用什么指令mov

802

对吧

803

这是木对吧

804

MV啊

805

还有什么你在

806

你你要是跳转到某一条某一条指令的位置

807

你想执行某一条指令呢

808

对吧

809

比如说像那个像那个放循环

810

循环他怎么回到那个放循环那儿去

811

是GMP

812

DMP对吧

813

就是这个玩意儿

814

就就就这东西

815

实际上这个东西

816

和那个机器指令是一一对应的

817

这些东西一一对应

818

仍然是按照CPU的思思路

819

按照CPU的思思思路来做说到这儿呢

820

给大家介绍一个好玩的游戏

821

给大家介绍一个好玩的游戏

822

这个好玩儿的游戏叫什么

823

叫那个我看一下手机

824

这这个游戏

825

这个游戏我当初那个花钱买

826

这个游戏当初当初花了花了六块钱

827

好像是我找一下

828

这个叫那个叫叫啥来着

829

我打开

830

我看一下这个实际上这个游戏呢

831

就是叫程序员升职记这这个游戏

832

程序员升职记

833

那个回头我那个截个图

834

回头我那个截个图发到那个群里

835

程序员升职记呢

836

这个这谁用iPhone的同学

837

去去搜一下就能找到它里边用这个东西去去学算法是是是非常好的

838

那个程序员升职记用用它来学算法

839

特别好

840

你你用那个东西

841

就是就是让你完成一个任务

842

然后就用几条那个指令

843

由内几条指令去去完成那个任务

844

这你既要顾及到那个空间复杂度

845

也要顾及到这个时间复杂度时间复杂度就是操作步骤

846

操操作次数空间复杂度

847

空间复杂度就是那个你你用的那个质量指令的数量

848

那个挺好玩儿的

849

大家大家有时间去去下载下来玩玩呢

850

实际上这个汇编指令

851

汇编和机器指令就是一一对应

852

换汤不换药啊

853

那么唯一的好处是什么

854

就是不是零一啦

855

不是零一了

856

就就是和就就是那个英文缩写了

857

但是呢

858

仍然很难不不是人类的这个思维

859

那么这个东西那

860

刚才有同学问

861

汇编是国产的吗

862

你别开玩笑

863

别开玩笑

864

这个汇编

865

这个汇编

866

除非你的CPU是国产的那那个那那个CPU专用的那个语言

867

那个专用的那个语言那个它它是国产的对吧

868

别开玩笑

869

然后这这俩这俩东西

870

就因为这两种语言

871

他非常的反人类

872

所以呢

873

后边就出现了啥呀

874

就出现了不那么反人类的语言

875

就是高级语言

876

那么这个高级语言它有一个主要特征是什么呢

877

面向过程

878

面向过程

879

这种高级语言的典型代表是什么

880

就是C语言

881

就是C语言

882

还有什么Pascal等等等这些语言

883

这些语言是相对来说还是比较古老的

884

另外还有一个非常非常古老的叫什么叫fortune

885

叫fortune

886

那个东西现在几乎没人用了

887

只是非常老的那个系统里边有

888

比如说银行对吧

889

内银行那个系统非常非常老

890

那可能可能比咱们这个年龄也要要要大一倍是吧

891

那种系统

892

那种老系统跑的还是fortune

893

那个非常老了

894

应该就是上个世纪的

895

70年代

896

上个世纪70年代那个时候的这个语言

897

当当时那个当时咱还没出生呢

898

对吧

899

当时还没出生呢

900

那么这种高级语言它的特性就是面向过程

901

面向过程那么高级语言

902

那到从到了高级语言

903

它是一个跨越

904

那也就是说这个门槛儿就这个门槛就降低了

905

们这个这个编程的门槛就降低了

906

他不是不不要求不是那么高了

907

但是仍然是是要专业人员对吧

908

然后最后后来又出现了第四代语言

909

第四代语言是面向对象语言呢

910

比典型代表就是C加加

911

C加加Java

912

Java还有什么go语言等等这些东西

913

这这这属于这个第四代语言

914

实际上这个go语言

915

他应该属于四代半

916

Go语言应该算是四代办了

917

他更他更往前那个走了一步

918

典型代表是C加加和Java

919

他是怎么典型的面向对象有同学说

920

有同学说

921

那那那JS呢

922

JS不算

923

JS不算

924

JS应该可以算到第五袋里面去了

925

JS可以算到第五代了JS它是基于对象

926

他他他不是面向对象另外第五代呢

927

像那个拍萨拍撒

928

还有这个JS

929

可以算是第五代了

930

那么这种第五代语言它的特性是什么

931

对普通人友好

932

普通人友好

933

那第三代第四代是对专业人专业程序员友好

934

那JS和Python呢

935

对对那个普通人就有好了

936

尤其是Python

937

由Python就就就跟你用英用英语去纯粹就是在用英语去写代码更加友好

938

那么这这种语言

939

他弟弟五第四代语言

940

第四代语言他就是

941

它有内置的酷

942

像这个面向互联网天然支持数据库

943

它都是依赖他那内置的那个内置的那个语言库

944

他的那个什么包儿

945

对吧

946

咱们JS里边儿那个包儿

947

他的那个库来来提供的

948

那么第五代的那个包就更丰富了

949

而且对普通人更加友好

950

当然第五代这种这种断代方式呢

951

在在业内

952

没有一个严格的说法

953

有有说有有有的那个有的人用有的资料上说用第五代

954

但是有的资料呢

955

把这个JS拍上仍然是算在第二

956

仍然是算在这个第四代里边的这个这个这个业内呢

957

还没有完全统一

958

那么接下来呢

959

咱们先了解一下这个汇编

960

先了解一下这个汇编语言

961

那么这个汇编语言就知知道一下就行了有兴趣的话呢

962

你有兴趣的话

963

你可以把这段代码的录入进去录入进去试试

964

那么这个汇编它是最贴近底层的这个不用多说

965

那么这个汇编语言它是直接操作硬件

966

它就是CPU自己的语言CPU的语言

967

那其他语言呢

968

其他语言你需要去进行那个编译

969

尔这个汇编当然也需要编译

970

但是这个编译就是一个简单的转换

971

把汇编的这个东西转

972

把汇编的这个这个英文

973

直接转成那个机器指令

974

这直接转成这个二进制

975

她就是做一步转换就行了

976

那其他的语言呢

977

那需要编译

978

需要需要真正的编译

979

先把那个先把那个比如说C语言

980

先把C语言要把它转成那个汇编

981

然后汇编再再变成那个机器指令这这这那个就复杂了

982

当然JS就不是这样了

983

这JS他有自己的那个字节码

984

他就不是这个套路了

985

然后这个汇编语言呢

986

就是纯粹的就是指令和数据

987

没有语句

988

它它是没有雨具的

989

什么是语句

990

比如说像那个VAR a等于十这是语句

991

对吧

992

还有什么fall

993

然后小括号什么什么什么

994

这这也叫语句

995

像像那个汇编里边是没有这种东西的

996

他很不直观

997

那就就是等于你手把手的告诉这个CPU

998

你该怎么去做手把手的告诉CPUCPU里边有有内存

999

有寄存器

1000

有有有有啥的

1001

你就告诉CPU

1002

首先你抬起左手

1003

然后张开张开这个手势是是张开的一个手指

1004

然后呢

1005

放到杯子旁边儿

1006

然后呢

1007

再把这个杯子握住

1008

然后向上抬

1009

再向左边儿这边儿移动

1010

然后稍微倾斜一点儿

1011

张嘴

1012

然后把水倒灌到嘴里

1013

然后你然后你把这个水往肚子里咽

1014

实际上你让你让计算机去去做这个喝水

1015

要完成喝水这个动作

1016

你就得这样

1017

事无巨细

1018

每一个动作你都得描述清楚

1019

如果是高级语言呢

1020

高级语言就发一个指令

1021

就就一条语句

1022

拿起杯子

1023

然后呢

1024

喝水呢

1025

就这这就是语句

1026

所以说汇编

1027

汇编是非常非常繁琐的另外还有一点我们要注意

1028

汇编他受到硬件平台的限制

1029

也就是说一种CPU

1030

比如说咱们前面给大家说的这些指令集

1031

一个指令集

1032

每种指令集它都有自己的呢

1033

他都有自己的这个汇编

1034

那因为这个指令集

1035

他的这个二进制的指令

1036

它它是不一样的

1037

每一种CPU他都得每一种指定机

1038

它都有自己的这个汇编

1039

所以他是真专门针它是针对这个特定硬件儿的

1040

那可一致性是很低的你你8086的这个汇编你是放不到

1041

你你是很难移植到这个ARMARM上边儿的

1042

因为你的寄存器它都不一样对吧

1043

当然大多数指令是是类似的

1044

大多数指令是是一样的

1045

但是寄存器的不一样

1046

那么这种东西

1047

了解这个会编

1048

对咱们了解这个理解运算运这个计算机的这个内存

1049

是非常有好处的

1050

那怎么有好处呢

1051

看一下

1052

看一下这段程序这段程序当初我在打字的时候

1053

因为有自动补齐

1054

这多了个一木这个J语法

1055

这多了个一

1056

如果说你感兴趣的话

1057

你可以把这段程序把它复制一下

1058

保存成文本

1059

然后呢

1060

在Linux下编译一下

1061

编译一下他他干什么

1062

就是个hello world

1063

咱们用JS去输出j hello word

1064

就是抠点lock

1065

然后hello word

1066

玩了对吧

1067

那么这个汇编去去hello world得事无巨细

1068

咱们咱们逐条给大家讲一下

1069

逐条给大家讲一下那个这这段代码究竟怎么回事儿

1070

那么在计算机里边儿

1071

计算机这个程序前面咱们说了

1072

咱们再回到前面这个图这儿来

1073

再再回到这儿来

1074

这个程序它是分两段的

1075

对吧

1076

一段是代码段

1077

一段是数据段儿

1078

那么咱们用这个汇编去写去写去写这个代码的时时候呢

1079

也得给它分成两段

1080

手动给它分成两段儿

1081

纯粹的是手动去管理你的内存

1082

也就是说当你的这个程序

1083

当你的这个程序放到内存里边儿的时候

1084

这个程序它是什么样的

1085

你也得手动去指定

1086

你就告诉他这这这一块儿是数据段

1087

这一这这一块儿呢

1088

是那个是那个代码段

1089

你得手动给他分段

1090

飞非常那个非常非常贴近底层了

1091

那么先看那个数据段

1092

数据段里面放的是什么呢

1093

放的是一个字符串

1094

在数据段里面放的字符串

1095

放的什么字符串

1096

Hello word

1097

咱们console log点儿

1098

扣点log点儿

1099

acouncil.log啊

1100

抠点log

1101

然后呢

1102

Hello word啊

1103

那个hello word实际上你要放到里边儿去

1104

在计算机里边儿

1105

在这个计算机里边这个字符串

1106

只要这个字符串儿你在代码当中给他指定了

1107

实际上在内存里边儿

1108

当那个程序它在启动的时候

1109

在内存里面它就有

1110

那它是一个静态的

1111

那他是个静态的数据

1112

只要程序一启动

1113

内存里面就有这个字符串了

1114

只要你指定了它呢

1115

那么在这个地方我们要指定

1116

这个hello冒号是什么呢

1117

这是伪指令

1118

像这个section.data这也是伪指令

1119

伪指令哪个伟

1120

不是尾巴的尾

1121

是这个伟

1122

真伪的为

1123

这叫伪指令

1124

这个伪指令干什么用

1125

告诉汇编的编译器

1126

你要做一个这告诉汇编的编译器

1127

恶来标注

1128

标注这个行号儿

1129

或者说标注这个代码结构

1130

它不是它不是真正的这个汇编

1131

他不是真正的汇编指令

1132

那么这些东西section.data

1133

这是干什么

1134

这是一个这是一个内存区域的一个标标记

1135

数据段内存区域起始位置是data

1136

这个点儿data对应的是一个地址

1137

然后呢

1138

A section点儿taxi text a这又是一个

1139

这又是内内存区域里面一个一个区域这个区这个区域是在干什么

1140

是是那个变量是这个这个变量

1141

是这个字符串这个变量

1142

用用一个什么样的

1143

用一个内存空间来保存这个字符串的那个那个那个那个不不是

1144

这是那个这这这这这个变量这个变量就是告诉告诉CPU

1145

这个程序第一条指令在什么地方

1146

那么这个global girls chart

1147

是什么意思

1148

下划线starch他就是这个

1149

代码起始的这个位置

1150

他也是个地址

1151

也是个内存地址

1152

那么CPU在执行的时候

1153

就从starch来对应的这个内存地址开始执行

1154

这是分段

1155

后边儿这个这个东西就是来这这一块儿

1156

他就是那个代码段

1157

这一块儿

1158

这一块儿是那个数据段其他的其他的这这些玩意儿

1159

这这些玩意儿

1160

都是那个为指令

1161

然后这个hellohello是什么

1162

是一个地址

1163

这这是一个地址用实际上它是一个标签

1164

这个标签就对应了一一个地址

1165

还有hello re

1166

这也是一个地址也是一个地址

1167

这个只带标签的这么一个地址后边儿呢

1168

Hello word

1169

这是这是要把它放到内存里面的东西

1170

这是放到内存里面字符串

1171

然后这个东西呢

1172

这个东西呢

1173

这个东西是字符串的长度

1174

字符串的长度

1175

因为计算机不知道你这个字符串到底有多长

1176

所以说你得你得把这个字符串长度得放到内存里边儿要你要

1177

要不然呢

1178

这你再拿这个字符串的时候

1179

究竟拿多少个字节不知道

1180

CPU不知道你得告诉他

1181

这就拿就就就拿这么几个字节

1182

告诉CPU

1183

你不告诉CPUCPU不知道

1184

不知道究竟拿几个

1185

拿十个不够对吧

1186

拿50个超了他就不是这个字符串了所所所以说

1187

必须得详细地去描述这个去描述这个

1188

这个数据是什么样的然后后边儿

1189

程序执行的时候从这儿执行

1190

那么他在干什么呢

1191

先看哈这段代码

1192

这段代码先看MVMVX4

1193

这是什么意思呢

1194

就是把四这个把四这个数放到AX寄存器里

1195

那么这个四代表什么呢

1196

四代表操作系统的一个API

1197

也就是系统调用

1198

四代表的是操作系统的一个API

1199

实际上咱们什么也没写

1200

调用的是什么

1201

调用用汇编

1202

咱们调用操作系统的那个console log

1203

调用操作系统的console log

1204

咱们看那得用多少条儿

1205

你的那个操作系统的那个API

1206

也就是系统调用

1207

它究竟是哪个

1208

他是以编号为

1209

用编号来区分的四号对吧

1210

四号API

1211

先把它放到寄存器里

1212

然后来

1213

然后又一个

1214

又一个MV

1215

把一放到1BX啊

1216

这是另外一个寄存器

1217

这个一是什么呢

1218

依旧是

1219

文件描述符

1220

那么计算机里边儿几个基本的描述符是什么呢

1221

01234

1222

他们分别代代表什么呢

1223

标准输入标准输出

1224

标准错误等等等等这些东西这代表这些标准输入是是那个键盘

1225

标准输出就是显示器

1226

标准错误就是那个就是那个错误处理用的你看

1227

那么标准输出他输出到哪儿

1228

就是输出到显示器里告诉告诉这个头

1229

这这个API你吧

1230

我我要往这个显示器去输出

1231

要输出东西

1232

那输出什么东西呢

1233

那再往后看

1234

又是一个MOVMOV把hello

1235

放到e c X Li hello是个什么东西在这儿

1236

对吧

1237

Hello

1238

他是个标签儿

1239

这个标签儿它对应的是个地址

1240

也就是说把这个字符串的地址

1241

把字符串的首地址放到XX里

1242

然后呢

1243

又一个MV

1244

放到了

1245

放到了又一个

1246

放到了又一个寄存器里

1247

是总共用了四个寄存器

1248

这个第四个寄存器放到什么

1249

字符串的长度告诉这个操作

1250

告诉这个操作系统的这个API

1251

这你呢

1252

我要把这个字符串

1253

在这个位置上的字符串要输出这个字符串多长输出到这个显示器上

1254

相当于这个操作系统的这个这个系统调用的这个三个参数呢

1255

这是这是准备

1256

那这是准备然后干什么呢

1257

然后告诉操作系统

1258

你去调用

1259

调用告诉操作系统你去吊用

1260

他怎么调用去

1261

去调用这个软中断

1262

他不是整形的意思

1263

在汇编里边这个ENT它不是整形的意思

1264

在C语言里边儿

1265

Inch是Intel

1266

对吧

1267

它是整数类型那么在汇编里边

1268

这个这个N它是软中断

1269

它实际上就是干什么在干什么

1270

告诉操作系统呢

1271

我这儿准备好了

1272

然后你调一个函数

1273

我按你的要求

1274

按你的规格把这些

1275

把这个数据都填进去了

1276

然后你就你你就执行函数吧

1277

就是告诉操作系统这个这个ins是什么恶

1278

他对应的单词是什么呢

1279

是interrupt

1280

Interrupt就是中断

1281

就是中断的意思

1282

这个中断分软中断和和那个硬中断

1283

这个感兴趣你可以百度一下

1284

咱在这儿步步深入去解释了

1285

实际上就是两种调用方式

1286

这是这是在干什么

1287

这是hello word啊

1288

这是hellowordcouncil.log然后hello word写了这么多行

1289

然后干什么呢

1290

后边儿还有又掉了一个函数

1291

这个函数是什么

1292

这个函数是退出

1293

退出程序就是告诉操作系统

1294

我这个程序结束了

1295

你可以把资源回收掉回收什么资源包括

1296

这个数据

1297

包括这个他他自己本他自己这个指令本身呢

1298

告诉操作系统我结束了

1299

你内存里边不要不要再保存我的数据你你回收吧

1300

这这就是这三个那么这个是是在调什么

1301

调CCS exit这个系统调用这这就是一个函数

1302

然后呢

1303

这个是返回值

1304

这个返回值返回给谁

1305

返回给操作系统

1306

就是说我这儿正常结束

1307

然后在INTERRUPT80H

1308

又interact巴黎

1309

又是又是告诉操作系统

1310

你你去调用

1311

然后这个hello word

1312

这么长这么麻烦

1313

每一步都很每一步都很都很繁琐

1314

而且他还而且这段这段代码

1315

而且这段代码就是调了操作系统的两个函数

1316

还没有说你这个字符串我怎么从内存里去取

1317

对吧

1318

我我然后我这个字符串我怎么处理

1319

然后怎么一个一个的输出到这个这个显示器上还没有涉及到这些东西呢

1320

你你就可以看到

1321

汇编是多么繁琐

1322

实际上咱们写的那些程序

1323

不管你是用什么语言写的

1324

在CPU里边儿

1325

他都是按照这种套路去做的

1326

只不过咱们的那些语言呢

1327

更加贴合咱们这个更加人性化

1328

所以咱们那个更加人性化

1329

咱们还掉头发是吧

1330

您让咱们这样去写呢

1331

那真的是一根头发都没了呢

1332

肯定那个脑袋是锃光瓦亮

1333

如果说你要想想想执行一下

1334

想执行一下这个

1335

你你把我这个抄错的这个单词把它把它改掉

1336

把它改掉

1337

然后干什么呢

1338

在Linux下去去安装这个NSNSM啊

1339

然后呢

1340

用用这个

1341

用这条命令去去编译然后呢

1342

这个是连接

1343

这是编译过程

1344

连接过程

1345

然后呢

1346

输出的这个程序

1347

输出的这个程序名就是a

1348

你可以去改这个名字

1349

然后然后干什么呢

1350

然后执行

1351

就就就这么一行忙活了半天对吧

1352

忙活了半天

1353

就就这么个

1354

这么就这么个玩意儿

1355

现在当然有汇编了

1356

当然有汇编工程师了

1357

只不过这种工程师很少了

1358

现在很少在在那个整体的这个在整体的这个比例当中占比很少

1359

但是那个数量

1360

但是这个绝对数量比以前会多一些

1361

比很久以前会多一些

1362

因为这个活儿多了吗

1363

活儿多了

1364

但是整从整体上看

1365

这个这个比例是很小很小的

1366

应该是1万个里边也找不到一个估计

1367

也算是比较高吧

1368

会汇编工程师也算是比较高

1369

但是但是你不好跳槽

1370

反正就是那么几个公司

1371

就是那么几个公司

1372

你跳来跳去

1373

你没地方跳

1374

你要真想那个

1375

你要真想跳

1376

你你跳那个什么地方

1377

你你去跳那个硬件厂商

1378

比如说啊

1379

比如说那个恶英伟达哈

1380

英特尔

1381

AMD

1382

还有一些那个做那个底层设备的

1383

你你你就这么几个选择

1384

你就就这么几个选择

1385

而且这这这些公司互相还是竞争关系

1386

你还不好跳

1387

对吧

1388

你想从华为跳四颗

1389

或者说或者说思科跳华为还真不好跳

1390

不好跳

1391

这真的不好跳

1392

这是过去

1393

过过去

1394

这个过去这个圈子里边儿都这个圈里的人都知道你你你原来思科的

1395

你想去华为

1396

人人不要

1397

人怕你是间谍

1398

还有华为的想去思科人也不要

1399

好

1400

咱们不说这个了

1401

刚才有同学就问

1402

问那个图灵机

1403

问那个图零机是怎么回事儿

1404

那个图零机

1405

那个图零机

1406

他不是会编

1407

它是一种计算机模型

1408

模型什么样的模型

1409

就是当初图灵在设计

1410

他当初图灵他在思考

1411

他在考虑这个计算机能不能

1412

能不能人类能不能造出一种能够思考的机器

1413

他在他在想这个问题的时候提出的这个概念

1414

提出的图灵机这个概念

1415

那么图灵机是什么样的

1416

图灵机很简单

1417

很简单

1418

单是什么

1419

他就是个这东西

1420

就是一个

1421

就是一个

1422

非常非常长的这么一个存储器

1423

一个纸条简单一点

1424

这个纸条纸条上干什么

1425

写满了写满了指令

1426

那写满了指令

1427

然后还有一个东西是专门儿在纸条上读指令的

1428

这这么一个小部件儿

1429

然后这个读这个指令

1430

根据这个指令去做一个操作这个指令比如说你跳到什么地方去

1431

然后再再去读这个指令

1432

然后再跳到什么地方去

1433

在在干什么

1434

当然背后封装的就是那个封装的就是那个CPU里边的东西

1435

就是那个前面给大家讲nei nei nei nei3个模块那么这个纸条呢

1436

实际上就是内存

1437

是这个图零机就是

1438

描述的是CPU和内存他们之间的这个工作

1439

他这个工作工作原理

1440

那么这个图灵机面临的一个问题是什么呢

1441

停机问题

1442

什么叫停机问题

1443

就是它执行了若干步以后

1444

要么就停止执行了

1445

要么就舍陷入到一个死循环里

1446

这叫图灵机的停机问题

1447

实际上这个问题要讲起来

1448

这个问题要要要要说起来

1449

它涉及到哲学层面上的东西了

1450

这就涉及到这个封闭系统

1451

或者还有这个开放系统等等这些东西

1452

比如说还有涉及到这个这个熵增问题

1453

涉及到好多东西了

1454

有兴趣有兴趣的同学可以去看一看这看一看这方这方面的资料

1455

好

1456

然后前面咱们给大家讲的就是那个CPU

1457

还有这个汇编

1458

实际上就是最底层的东西

1459

然后后边儿呢

1460

就是这个C语言了C语言这一块儿呢

1461

咱们着重给大家讲这个指针

1462

着重讲指针

1463

然后告诉大家怎么去学这个

1464

怎么去学这个C语言

1465

只要学这个C语言的话呢

1466

也不难

1467

难的就是在那个内存内存操作这一块儿好然后咱们那个先先休息五分钟

1468

休息五分钟以后呢

1469

就是这个C语言的1C语言的一部分

1470

What

1471

我的国

1472

国国

1473

What

1474

我我我

1475

Miss me like I was made for you stand in your in your

1476

eyes get for me because of an I was just mi you cannot escape from me that when I was just mi hello

1477

hello

1478

Once the size of its next thing anymore dream

1479

I started

1480

reading

1481

that always b

1482

好

1483

咱们继续

1484

大家都回来了吗

1485

好

1486

咱们接着来

1487

滑板鞋

1488

你别滑板鞋

1489

滑板鞋呢

1490

属于精神污染

1491

熵增

1492

你这个这个熵增是那个啥

1493

化学里也有

1494

物理学里也有

1495

可以说那个化学是浅层的物理学

1496

物理学那个物理学那个是深层的化学

1497

哈哈

1498

浙商

1499

这个商指的是什么

1500

伤指的是混乱程度

1501

在一个封闭系统里边儿

1502

这个混乱程度总是趋近于混乱的

1503

这个混乱程度总是那个趋近于最高

1504

这是在胡说八道

1505

物理的尽头是宗教

1506

这是胡说八道

1507

只不过是那个啥

1508

只只不过为什么有这句话

1509

只不过是因为因为这个当前的这个技术水平还还理解不了

1510

还理解不了

1511

所以他就认为是是宗教了

1512

为理解不了了

1513

所以说就是上帝阿

1514

上帝设计的对吧

1515

所以就出这个

1516

然后现在人就把这句话开始滥用

1517

说什么说什么引力波儿

1518

人人家那个佛教里边很久很早之前就就就就说过这个引力波怎么怎么地了这纯粹就是那个牵强牵强附会

1519

这纯粹是扯纯粹就是扯淡

1520

在封闭系统里边儿伤伤伤增不可逆

1521

咳

1522

物理

1523

物理的镜头不是也不是数学和物理的劲头儿

1524

物理的尽头就是是那个啥

1525

是那个死记

1526

是死记

1527

就是那个是是非常混乱非常混乱的这么一个

1528

除非你证明这个宇宙它它不是封闭的

1529

咱不提这个了

1530

咱们说这个C语言

1531

这个C语言呢

1532

这个C语言呢

1533

是那个一种是一种比较古老的

1534

比较古老的这么一种语言了

1535

最早呢

1536

它是用来写操作系统的

1537

用来写那个unix

1538

那么这个unix最早是那个贝尔实验室两个两个人

1539

他们写出来的最早是用什么语言写的

1540

用B语言写的B语言你看后来发现用B语言写出来这个东西太大哈

1541

你操作系统这玩意写出来这么大

1542

这这玩意咋整

1543

后来他们又他们又在B语言的基础之上

1544

重新设计了一下

1545

产生的这个C语言这这这意思就是说这个C语言势必语言的那个下一代

1546

这这么个意思

1547

然后就拿这个东西来写unix

1548

那最早呢

1549

可以说

1550

可以说这个C语言是最流行的

1551

原来我就是做这个C语言

1552

就是就是就是写这个C语言的

1553

后来后来写这个Java

1554

后来跟老袁来了

1555

来讲那个前端

1556

实际上这个JS到现在我我我我仍然学的不深入

1557

也也也是懒得去懒得去深入的去搞那个

1558

深入的去看那个JS了

1559

因为那个JS的封装了风

1560

他那个隐藏了太多的细节

1561

是那个JS隐藏了太多的细节

1562

而且是也是有大量的坑

1563

那个内很多坑都是匪夷所思的

1564

像那个C语言里面有坑吗

1565

有坑

1566

C语言里面坑也挺多的

1567

但是C语言里边的坑

1568

他不是天生的坑

1569

而是因为这个C语言太灵活了

1570

你想怎么

1571

你想怎么用就怎么用

1572

就是因为太灵活了

1573

缺乏一种规范

1574

所以说很容易很容易用错

1575

像那个Java语言呢

1576

坑就很少

1577

坑就相当少

1578

因为他他的规范性是很强的

1579

Go语言那个坑就更少了

1580

越往后这个语言里边坑就越少

1581

因为规范

1582

就是因为规范

1583

那么那个这个C语言现在好像是那个一九

1584

一九版

1585

那个这这个东西也一直在更新

1586

这C语言的这个它的这个规则

1587

他的那个语言规范

1588

也在也在不同不停的更新

1589

但是一直到现在更新只是更新你这个编译器应该怎么去怎么去写语法层面上的东西也就几乎没什么更新

1590

根本就没好像是从那个从那个从一零版还是还是还是哪一版王乐还是九八版开始这个语法就语法本身他就不更新了

1591

更新的就是编译器内部实现的时候

1592

按照一个什么样的规则去实现

1593

都变成这个了还有这个C加加也是这样不添加新语法了

1594

还有就是

1595

这个库你可以加一个什么样的函数

1596

加个什么样的功能

1597

现在那个都变成这样了

1598

那么

1599

JSJS的这个规范

1600

仍然是在那个语法上

1601

语法上仍然仍然是在仍然是在发展

1602

那么这个咱们在这张图上

1603

可以看到很多其他的语言

1604

比如说这个前面所说的这个fortune

1605

很很少见了

1606

还有这个Pascal

1607

实际上pasco也是一种非常优秀的这个语言了

1608

那么这个pass Co

1609

后来呢

1610

后来就衍生出了这个带飞

1611

那这个德尔菲也也是非常非常优秀的

1612

就是从命令行

1613

这种编程

1614

从字符界面这种编程

1615

一直到这个图形界面

1616

到图形界面上出现的那个

1617

一种语言

1618

就是戴妃

1619

戴妃用的就是Python语法

1620

那么这个basicbasic不用多说了

1621

最最早微软

1622

微软就靠这个

1623

就是靠这玩意儿起家的

1624

对吧

1625

微软靠两个东西起家

1626

一个是boss

1627

一个是basic

1628

然后呢

1629

他他就在Windows时代就就就出现了这个VD啊

1630

Visio basic

1631

那么C语言

1632

C语言这这个东西

1633

后来后来衍生出来的这个语言呢

1634

都是以C语言的语法为基础

1635

比如说C加加

1636

C加加扩展的C语言的语法

1637

然后加了这个面向对象

1638

Java呢

1639

Java实际上是那个C加加的恶侄外甥

1640

可以说是是C加加的外省

1641

实际上归根结底也是也是用的C语言语法

1642

包括咱们

1643

包括咱们JS

1644

包括咱们JS

1645

像那个C加加

1646

C加加语言没有垃圾自动回收机制

1647

Java里边儿加上这个喇

1648

垃圾回收了C加加呢

1649

仍然是需要手动去管理内存的但是呢

1650

它里边也有一种东西叫什么呢

1651

叫智能指针

1652

也就是说呀

1653

它可以在一定程度上用智能指针来帮助你去管理内存

1654

比如说你脱离了作用域了可以帮助你去释放这个释放这个内存

1655

或者是说你的这个或者说你的J这块内存是他的引用数

1656

变成零了

1657

它可以帮助你去释放当然这种释放

1658

它是实时的

1659

它是实时的释放

1660

而这个Java还有这个JS的这种释放内存的机制

1661

它是隔一小段时间他去释放一遍

1662

隔一小段时间是放一遍这样能够这样会导致导致这个程序的这个暂停

1663

你你在清理内存的时候

1664

这个程序它是不能走的

1665

那么C加加的这个智能指针

1666

实际上就在这个程序的这个这个这个他工作的时候就在程序的主线程里

1667

而这个Java还有JS等等这些动态这些那个带有GC的这种语言

1668

他们在进行这个垃圾回收的时候呢

1669

垃圾回收再一个独立的线程里

1670

所以说垃圾回收的时候

1671

你程序

1672

必须得暂停

1673

回收完了你程序才能继续运行

1674

所以呢

1675

这个GCRGCGC策略是有很多种的

1676

看你的这个程序

1677

看你的程序的要求

1678

如果说你要求实时性高

1679

用用一种策

1680

略实时性不高

1681

用另外一种策略

1682

这是根据十根

1683

根据那个实际情况

1684

你来选择这个GC的这个

1685

GC的这种策略

1686

这种东西咱们那个知道就行

1687

然后呢

1688

然后JS

1689

C语言和JS他们的这个相同点和区别呢

1690

首先第一个区别

1691

C语言是编译型的语言

1692

而这个JS呢

1693

它是解释性语言

1694

那当然咱们不说那个啥

1695

不说那个j it啊

1696

咱们咱不提这件事儿

1697

如果说你要提这个的

1698

他就不是纯粹性解释语言了

1699

他不是纯粹性的解释型语言了

1700

它有一部分是编译型的

1701

有一部因为它有一部分要编译成了字节码

1702

游戏那么的其他部分呢

1703

其他部布一部分编译成字节码

1704

另外一部分仍然是解释的呢

1705

现在这个JS

1706

也是比较复杂了

1707

那么C语言呢

1708

就是纯粹型的编译语言

1709

什么叫纯粹型的编译型语言呢

1710

咱们JS代码

1711

咱们去写代码的时候

1712

JS代码写出来以后

1713

直接扔给no的

1714

或者直接扔给那个浏览器

1715

它是可以直接直直接执行的

1716

你不需要对代码本身进行任何处理

1717

但是C语言不行

1718

C语言不行

1719

C语言怎么办呢

1720

C语言你先写代码

1721

写完代码以后

1722

你必须得用编译器来进行编译

1723

编译器是什么东西呢

1724

是GC语言的编译器

1725

是GCC

1726

编译出来以后是目标程序

1727

那目标程序他就是那个二进制

1728

但是呢

1729

因为咱们写程序是要按照模块化去做的模块的话呢

1730

最简单的模块的话就是有好多这个点C文件

1731

对吧

1732

那你一个点C文件就要生成一个点OBG啊

1733

你两个点C文件呢

1734

就要产产生两个点OBD

1735

那么这两个点OBD他都是二进制代码

1736

但是你你没法执行

1737

对吧

1738

你得把这两个二进制代码得合并成一个

1739

那你合并的过程叫什么呢

1740

叫连接

1741

连接是什么呢

1742

叫link

1743

连接连接这个程序是link用在用先用GCC处理产生二进制

1744

然后呢

1745

用link把产生了好多二进制

1746

给合并成一个

1747

就是咱们最终的那个点exe

1748

这是C语言的那个

1749

这是C语言的那个过程

1750

它的那个编译过程

1751

那么这个C语言

1752

因为它是很古老的

1753

他比较古老

1754

你要这样去做

1755

有一个问题

1756

问题是什么

1757

跨平台

1758

那跨平台问题

1759

你挎一个平台

1760

你就要重新编译一次

1761

再跨一个又要程序编译一次

1762

比如说Windows和Linux

1763

这两种操作

1764

这两种操作系统

1765

你同一套代码

1766

你得针对两个操作系统分别进行编译

1767

你在你在那个8086这个CPU上

1768

这个程序

1769

8086的Linux这个这个程序和那个ARM上的那个那个程序

1770

和那个R上的那个程序

1771

这你你你你又要编译两次

1772

所以说它的跨平台

1773

你想让它跨平台那是比较麻烦的

1774

那么这个JS的JS

1775

他就根本就没有这个跨平台问题对吧

1776

因为跨平台谁帮你跨了

1777

浏览器帮你跨了

1778

弄得JS帮你跨了只要有这个环境

1779

那你同一套代码

1780

你在什么操作系统都弄好

1781

这是JS的那个优势那这个

1782

C语言这个C语言说到C语言就不能不说C加加

1783

咱们说这个东西

1784

也是要放一块儿说的

1785

对吧

1786

放一块儿说

1787

那么你放一块儿说

1788

那C和C加加他们有什么区别

1789

他们区别在什么地方呢

1790

咱们不能简单的是简单的认为C加加是C

1791

带类的C

1792

你不能这样简单的去恶简单的这样的认为带类的C另有语言

1793

那种语言叫什么

1794

叫object c

1795

叫面向对象C就是OC就是那个在那个给给那个苹果

1796

给给那个苹果设备

1797

他他原来用的是用来他原来用的是这这个套路

1798

那么那个C语言和C加加

1799

是两种完全不同的语言

1800

他不是他不是扩展

1801

这这点一定要注意C加加

1802

C加加

1803

当然C加加的编译器

1804

是可以编译C语言

1805

是可以编译C语言代码的

1806

但是你不能把这两种东西等同起来

1807

因为C加加它比C语言更复杂很多C加加

1808

C加加复杂到什么程度呢

1809

C加加这个语言

1810

它的作者曾经说过

1811

尽管说C加加是我发明出来的

1812

是我那个造出来的

1813

但是可以说

1814

我也不是完全理解

1815

我也不是完全的这个精通这个C加加

1816

哈哈

1817

就连作者他都说不完全精通

1818

就可见C加加是多么的复杂

1819

那么JC加加它复杂到什么地方

1820

就是它的面向对象特性复杂

1821

你看比如说什么

1822

多继承

1823

对吧

1824

他不是多重继承

1825

多重继承是什么样儿的

1826

多重继承是比如说有一个类a

1827

然后呢

1828

有一个类B呢

1829

你要继承的时候由B继承自a

1830

然后呢

1831

再在CIC在继承自毙

1832

这叫多重继承

1833

你分了好几个层次

1834

这叫多重继承

1835

多继承是什么意思

1836

有一个A1

1837

有一个A2

1838

然后呢

1839

B这个类同时从A1和A2继承过来

1840

这叫多继承

1841

这叫多继承

1842

现在面向对象语言里边儿

1843

你见不到这种多继承

1844

见不到多继承那种

1845

盖着这这种概念

1846

比如说Java

1847

什么勾这之类的

1848

JS更不用说对吧

1849

JS根本就没有继承

1850

JS他他就不是面向对象的

1851

那么这个多继承很容易引发混乱多继承很容易

1852

也也很容易混乱

1853

但是多继承这种特性也需但有时候也也需要用到

1854

也需要用到

1855

那怎么办

1856

有一个拐弯儿

1857

有一个拐弯儿的这么一种方法

1858

拐弯怎么拐弯儿

1859

你可以多继承

1860

但是你从哪儿继承

1861

从接口继承

1862

比如说一个接口a一个类a

1863

然后这个B你具备的特性

1864

也具备a的特性

1865

但是这个接口里面它不实现代码

1866

不实现代码

1867

这样就就不会产生这种多继承的这种东西

1868

TS也可以多继承吗

1869

这个我倒不知道

1870

TS我不熟

1871

我就简单的看了

1872

我就简单的看了看

1873

TS不熟

1874

这真的真的TS可以多继承吗

1875

回头我得看看

1876

既然你这么说了

1877

实际上那个TS是一个非常奇怪的语言

1878

Ts of ts非常非常的奇怪

1879

对那个前端非常不友好的

1880

那么那个C语言

1881

面向过程

1882

C加加面向对象

1883

而且这两种语言都有标准库

1884

C语言用在什么地方呢

1885

C语言现在用的这个用的这个领域

1886

比较窄了

1887

原来用的非常非常宽

1888

比如说原来

1889

比方说很久以前写那个啥

1890

写那个超市用的那个POS系统

1891

就是用那个C写的

1892

写业务

1893

可以用用C写那个业务对吧

1894

现在很少用C去写写业务了

1895

那么那个C语言一般用在这个底层

1896

底层网络或者是嵌入式

1897

比如说像那个X对吧

1898

X你你去下载下来这个源码

1899

它就是C语言还有还那么这个C加加呢

1900

C加加写这个引擎

1901

写这个引擎和和那个应用软件呢

1902

比如说像引擎是什么

1903

比如说V8

1904

对吧

1905

V8V8就是那个JS解释引擎吗

1906

AC加加血

1907

还有很多那个游戏引擎

1908

比如说什么Unity

1909

这样一些东西也是用用用那个C加加去写

1910

还有那个应用软件

1911

比如说什么Photoshop

1912

对吧

1913

还有什么autocad

1914

这这这些玩意儿应用软件

1915

那么这个C语言

1916

那C语言咱们必须得学

1917

学一学

1918

必须得学一学

1919

恶语法你必须得会

1920

简单的小程序你能写出来

1921

那么咱们写这个C语言的那个环境

1922

咱们要注意就写环境Windows上

1923

用最好的环境是VCWINDOWS10

1924

最好的环境是VCVC的编译器叫什么呢

1925

叫EMSVC

1926

VCVC的编译器那个程序的名字叫MSVC就是微软的

1927

微软的那个C编译器

1928

那么Linux下呢

1929

就就是GC啊

1930

Unix下也是

1931

苹果下也是

1932

那么那个unix下的C加加编译器呢

1933

就是记加加GC是C编译器

1934

G加加是

1935

C加加编译器

1936

那么在Windows下有没有GCC呢

1937

可不可以用GCC呢

1938

可以啊

1939

他不叫GC

1940

它叫什么呢

1941

它叫明哥为

1942

明隔壁室温度下的这个GCGCC编译器是开源的

1943

他是他是那个遵循那个go规范的go是那个一个开源组织

1944

它遵循那个go

1945

他就是开那个go组织他们弄出来的

1946

那么那个麦克呢

1947

麦克他本身就是unix

1948

对吧

1949

所以他也用GCC

1950

那么这个插扣的呢

1951

插扣的他就是个ID

1952

相当于那个studio

1953

那咱们学学这个C语言的话呢

1954

就就是在那个link或者是麦克下去学就行了

1955

为什么不在Windows下学呢

1956

Windows那个那个VCVC那个环境配置起来很复杂

1957

内内比较简单的就是VC6

1958

但是VC6不好找了

1959

你要装那个video内装老半天

1960

而且你平时还不一定用得着

1961

占好大的那个硬盘空间

1962

给你装一堆乱七八糟的库

1963

那个没必要

1964

还是Linux

1965

LYNX或者麦克用用那个GC

1966

然后咱们把这个环境

1967

咱们解决这个环境问题以后

1968

之后呢

1969

先不说这个指针和和那个内存

1970

这个咱们稍后再说

1971

先说一下这个语法C语言的语法

1972

C语言的语法是啥样儿的呢

1973

我浏览器呢

1974

C语言的语法是吧

1975

我那个

1976

因为咱们是有这个JS还有TS的这个基础

1977

对吧

1978

有这个基础

1979

更何况咱们一开始还学过这个批只批

1980

所以呢

1981

咱们所以咱们那个

1982

学这个C语言呢

1983

就就容易一些

1984

容易到什么地步呢

1985

给大家看一份文档

1986

这个文档就是给大家先给大家推荐一个网站叫learn

1987

嫩

1988

X

1989

因

1990

X in

1991

Y

1992

In one minute

1993

是这么写吗

1994

拼错了

1995

可能是

1996

还是百度一下吧

1997

这个

1998

另外minutes不是minute minutes

1999

少写S

2000

这个网站

2001

这个网站是非常非常好的

2002

强烈强烈强烈强烈

2003

我这强烈

2004

这墙给列了

2005

原来引用了那个Google的Google的CDN了

2006

这个网站这个网站是什么呢

2007

这个网站就是快速入门编程语言的

2008

不要提那个事儿不要提那个事儿不要提这个东西

2009

你那个J容易被平台封

2010

千万不要提

2011

那么这个这个网站

2012

Learn X in y minutes啊

2013

单位是分钟

2014

他干什么

2015

他就是咱们去学

2016

去学任意一种语言

2017

这语言很多很多的

2018

咱们可以看这么多

2019

包括什么HTMLCS啊

2020

还有什么Java go r c c啊

2021

C加加等等

2022

而且这里边儿这个语言我们可以选啦

2023

对吧

2024

选什么

2025

选CH杠CN

2026

选这个

2027

选这个

2028

网址啊

2029

网址发给你们

2030

有人发出来了是吧

2031

然后这个咱们就找啥呀

2032

找C

2033

找CC在这儿

2034

然后咱们就直接CH杠CN

2035

还有后边还有C加加也恶这个c h Gang cn

2036

这两个

2037

这玩意儿太讨厌

2038

你把人CDN疯了干啥呀

2039

这是吃饱撑的

2040

太慢

2041

这个这个网站

2042

最适合咱们最适合咱们用

2043

咱们会了一种语言

2044

然后通过这这这在这个上面去去学那个去去快速的入门一种语言先从C开始

2045

C语言它是以什么形式

2046

他就是以代码形式来来教我们告就是教我们这些语法还有语句

2047

教我们这些东西

2048

比如说啊

2049

我们开始a柱是对吧

2050

注释还有看到的那些什么defy是什么意思对吧

2051

这是干什么

2052

定义一个宏

2053

后边咱们再给大家讲代码的时候

2054

我会给大家在再去讲一些这个相关的这个语法

2055

一边讲这个VBA的代码或还有note的代码

2056

一边给大家再讲这个C加加的C加加的语法咱们先先看一下

2057

那么这个在这个里边

2058

C语言里边儿它的基本数据类型

2059

要要注意在JS里面它是它它是没有类型的

2060

对吧

2061

这里边没有类型

2062

有同学说

2063

他不是有类型吗

2064

有有什么字符串

2065

有有什么数字等等这些东西

2066

那不是类型

2067

那不是个类型

2068

那是个对象

2069

他不是类型

2070

真正的类型是什么样的

2071

真正的类型这是C加加里边儿类型

2072

它里边儿有啥呀

2073

它里边有枚举

2074

哪枚举是它的

2075

它它里边儿就是这么一种类型了

2076

另外还有什么

2077

就是整形

2078

还有什么字符型

2079

整型又分好多个种类

2080

短整型长整型

2081

还有那个F64等等

2082

还有有符号儿无符号儿

2083

还有什么浮点型

2084

单精度浮点型

2085

双精度浮点型等等这些东西

2086

第一步先把这些类型搞清楚

2087

那么这些类型代表什么呢

2088

这类型代表你在你的数据在内存当中是什么样的

2089

你要你要记住

2090

类型本质上的

2091

本质上就是在描述你的数据在内存里边儿是什么样儿的

2092

梦回大一

2093

你们大学的时候老师肯定不这么说

2094

老师肯定不不不说这个

2095

他就是说什么

2096

就是说这个类型

2097

有哪几种类型这就是强类型语言C加加就是强类型语言

2098

那类型的本质就是你的数据在内存里边儿

2099

它是什么样

2100

它长什么样呢

2101

它长什么样呢

2102

比如说一个整形

2103

一个整型占四个字节

2104

那那么它在内存里边儿

2105

内存是什么

2106

内存咱们前面给大家讲过是吧

2107

给给大家讲过多次

2108

那么在内存里边儿

2109

它是一个又一个的小格子

2110

对不对一个小格子是多大

2111

一个字节

2112

一个字节是八个比特是吧

2113

那么内存的基本单位实际上就是字节

2114

他不是他不是比特是字节

2115

因为操作的时候就按字节拿的那一个整形它就是连续的这么四个

2116

四个字

2117

四个字节

2118

这四个字节他就是去一个数

2119

代表一个数

2120

那么这个

2121

整形那么浮点型呢

2122

又分单精度浮点

2123

双精度浮点

2124

那么单精度浮点

2125

双精度浮点它是什么意思浮点是什么意思

2126

浮点就是小数点是浮动的咱们咱咱们往后看

2127

A到H哪去了

2128

那个那个浮点呢

2129

浮点浮点

2130

浮点

2131

这个浮点

2132

浮点的特性了

2133

浮点的类型呢

2134

查找一下吧

2135

那

2136

浮点在这儿

2137

Float是单精度浮点数双

2138

那么W呢

2139

是双精度浮点数

2140

单精度浮点数是四个字节

2141

双精度是八个字节

2142

那么浮点是什么意思

2143

夫夫点是什么意思

2144

咱们回想一下

2145

回想一下在上中学的时候吧

2146

对吧

2147

初中的时候

2148

咱们学过什么

2149

科学计数法

2150

科学计数法是什么样的

2151

比如说比如说510

2152

510用科学计数法是什么

2153

是是怎么表示5.1乘十的二次方

2154

对吧

2155

5.1乘十的二次方

2156

这是科学计数法

2157

它写成他还有一种表示方法是什么呢

2158

不写十的二次方a写成什么呢

2159

5.1

2160

然后呢

2161

一二

2162

这个一二代表就是十的二次方

2163

这是科学计数法

2164

那么五点儿510可以写成5.1乘十的平方

2165

也可以写成什么

2166

也可以写成51

2167

然后呢

2168

一

2169

对吧

2170

也可以写成五十一五一一

2171

他变成科学计数法

2172

就是51乘十的一次方

2173

还可以写成什么

2174

零点儿五一乘十的三次方

2175

来科学计数法回想起来了吧

2176

那么咱们看

2177

500亿用科学计数法可以表示成这么多种方式

2178

对吧

2179

那么这个小数点儿

2180

他在一直在动

2181

对不

2182

小数点儿一直在动

2183

这叫什么

2184

这叫浮点浮点浮点小数点在浮动浮动的小数点儿

2185

那么这个浮点数在计算机里边儿表示

2186

在在计算机里面表示他是什么样的

2187

在内存里面什么样的

2188

比如说啊

2189

比如说这个

2190

浮点数

2191

浮点数在内存里边儿站

2192

四个字节

2193

四个字节它占32位32个比特位

2194

那么这32个比特位

2195

第一个比特位干什么用表示

2196

正负号

2197

第一个比特位是正还是负然后第二个到第多少个我王乐

2198

他这个

2199

这个区域怎么那个那个标准

2200

我王乐到第若干位

2201

它代表什么呢

2202

它就代表

2203

这个

2204

他就代表这个

2205

不是一前面这个数字

2206

他就代表一前面这个

2207

然后后边儿剩下的代表什么呢

2208

后边儿代表IE后边这个数字

2209

全都是按二进制去表示

2210

那这是浮点数在内存里边儿的样子

2211

先是正负号

2212

然后是一前边儿的二进制表示

2213

然后示意后边的二进制表示

2214

那么一后边儿的二进制表示

2215

那么在这个里边

2216

这个这个一它不是石蜡

2217

对吧

2218

在计算机里边

2219

这个一它不是时

2220

他是什么

2221

它是二

2222

它是二

2223

那这个就是

2224

一个数字

2225

这个a是这这一段

2226

然后乘以什么呢

2227

乘以二的

2228

B次方

2229

那么这个B

2230

它在这儿表示

2231

正负号呢

2232

正负号在这儿表示来

2233

这是计算机里边儿去表示小数点儿代表是小数这浮点数那么

2234

这个double呢

2235

Double占的内存更长

2236

它的精度更高

2237

因为你能表示的数字它就这么长

2238

对吧

2239

超过这个范围

2240

它它就不准了

2241

她就表示不出来了

2242

那么64位呢

2243

它它它这个数可表能够表示有效数字

2244

能够表示的这个有效数字他更多

2245

他更多这个a它就是个整数二进制的整数

2246

二进制的整数后边儿这个事儿是指数

2247

这是指数

2248

它可以表示

2249

它可以表示它可以表示所有的数字

2250

表示可以表示所有的数字

2251

好

2252

然后呢

2253

咱们那个这是那个浮点数浮点数这个类型呢

2254

那么这个这个什么长整型

2255

短整型

2256

还有字符型等等

2257

这些都是整形的一种

2258

它们的区别呢

2259

就是占用内存的大小不一样

2260

正常的整型占四个字节

2261

短整型占两个字节

2262

短整型占两个字节

2263

那那么那个字符型呢

2264

字符型占一个字节

2265

那字符型占一个字节

2266

你不能不能不能一副数

2267

你负数你复述不就变成分数了吗

2268

对吧

2269

你复数就变成分数了吧

2270

就就就哈哈

2271

具体有那个规范

2272

有那个规范

2273

在那个公众号里边儿发过这个东西

2274

发过这个浮点数相关的东西

2275

那个那个叫啥规范

2276

叫IE1多少多少编号儿王乐

2277

就是这个

2278

具体的咱们看那个看那个规范

2279

浮点数

2280

阿琪是这个

2281

754IE754他他就是浮点数的这个规范

2282

就是这个东西

2283

具体他怎么弄的仔细看那个

2284

具体怎么具体具体看这个了

2285

好

2286

然后咱们再回来

2287

再回到回到这儿来

2288

回到这儿来

2289

然后是整形

2290

Inch型

2291

Short型

2292

Char型

2293

还有long

2294

Long呢

2295

具体的具体的都都在这说明了

2296

他都在这儿有所说明

2297

另外还有长长整型

2298

朗朗啊

2299

朗朗是64位的

2300

占八个字节

2301

那么后边儿还有什么呢

2302

有符号整型和无符号整型有符号整型就是表能够表示正负数儿

2303

这个无符号整型呢

2304

就是不能表示负数

2305

他这个C语言这些那C语言里边这这这些类的类型分的是很细的

2306

非常非常的非常非常的细

2307

那么当然我们还可以去创建自己的类型后边咱们那个下节课

2308

下节课给大家去讲怎么去创建自己的类型

2309

自己的类型是你什么花样都有

2310

还有呢

2311

各种各样的

2312

各种各样的这个语句

2313

还有怎么去声明这个字符串

2314

怎么去声明数组

2315

这这这些东西

2316

基本的语法有点耐心

2317

把它给看完半小时半小时就看完了

2318

然后后边儿呢

2319

后边儿需要后边需要咱们去那个啥的

2320

需要咱们去那个稍微费点儿时间呢

2321

就是那个指针

2322

而这个指针呢

2323

它可以指向

2324

指向那个可以指向数据

2325

也可以指向函数

2326

可以指向数据

2327

也可以指向函数

2328

TS跟他可不一样

2329

TS跟他可一点儿都不一样

2330

就是就是语法上看上去看上去像

2331

实际上TS是啥呀

2332

TSTS就是一种编译型的脚本语言

2333

他是编译成另外一种脚本的

2334

脚本

2335

He

2336

他

2337

他就在那儿拐弯儿

2338

那个实际上那个这个这个指针部分

2339

指针部分是是比较难以理解的

2340

但是咱们了解了内存以后呢

2341

去学这个指针

2342

那就轻松

2343

那就会轻松很多那么轻松

2344

那这个指针主要就是两种

2345

一类是指向

2346

指向函数的一类是指向数据的

2347

指向数据咱们好理解对吧

2348

这个数据在内存里面什么位置

2349

那指向函数是什么意思呢

2350

函数本身它就是代码

2351

对不对函数本身是代码a

2352

那么指向函数的指针实际上就是指向代码的指针那个指针

2353

有了指针

2354

你可以随意的去操作这个内存呢

2355

在很久以前

2356

那个程序员很无聊

2357

无聊的时候干什么

2358

他们他们还写代码

2359

只不过他们用这个代码去去那个去去去做游戏

2360

他们用代码做游戏呢

2361

游戏是什么

2362

叫代码大战

2363

叫叫内存大战不要代码大战

2364

叫内存大占

2365

内存大战是怎么玩儿的

2366

就是这么一块内存

2367

让操作系统分出一块内存来之后

2368

之后两个人写两段代码

2369

写两段代码

2370

然后这两段代码干什么呢

2371

这两段代码干什么

2372

比如说a代码还有B代码

2373

这么两段两个人

2374

然后他们要想办法让自己活下来

2375

然后呢把对方搞死

2376

怎么把对方搞死

2377

就是操作内存

2378

去找到对方所在的内存

2379

然后把这个内存把它改掉

2380

然后就把对方搞死了

2381

同时呢

2382

要保护自己

2383

他怎么保护自己

2384

要把自己移动到内存的其他方式呢

2385

其他的位置

2386

那这就产生了好多策略呢

2387

比如说有的代码它干什么

2388

去他去在他给自己去复制

2389

他就他把自己复制复制多份复制多份

2390

然后呢

2391

他要保存它要保存自己在这多份当中的这个位置

2392

然后别人去去覆盖它

2393

覆盖了这个

2394

然后其他的还活着这是一种策略

2395

还有这是保存

2396

这是那个存活策略

2397

还有一种策略就是攻击策略

2398

攻击策略怎么攻击

2399

随机随机去把自己写到内存当中的某一个位置

2400

当然不能把自己覆盖掉这这这这是那个内存大站

2401

那你玩内存大战就得去就得去把这个指针玩的溜溜的

2402

那就得把指针玩的溜溜的

2403

这是C语言的

2404

这C语言的C加加C加加玩儿不了这个

2405

C加加完这个比较难

2406

这叫内存大战

2407

有这个模拟器

2408

很久以前我还玩儿过

2409

有模拟器

2410

现在不好找了

2411

内存大战的模拟器不好找了

2412

这个玩意儿

2413

真的是不好找了

2414

这这玩意儿以前那个一搜一搜都是

2415

现在都是什么都是什么东西

2416

不找了

2417

回来回到这个C语言这儿来呢

2418

那么这个指针

2419

咱们咱们这节课呢

2420

先给大家讲一下这个指针

2421

指针的这个二级指针

2422

一级指针和二级指针然后下节课呢

2423

详细给大家去讲

2424

详细给大家去讲那个指向指向函数的指针

2425

还有那个结构体那个结构体

2426

有点儿像对象结构体有点儿像对象

2427

但是呢

2428

和那个对象有着本质的区别对象里边是可以有数据又可以可以有函数的

2429

但是结构体里边儿只能有数据不能有函数

2430

你非要让里边有函数怎么办

2431

你在里边儿

2432

得去加上一个特殊数据

2433

特殊数据就是指向函数的指针用用那个东西去模拟

2434

这是C语言的

2435

而这个C加加呢

2436

C加加就很复杂了

2437

语法和C差不多

2438

但是呢

2439

多了好多面向对象的特性这这些特性呢

2440

咱们那个也是后边的课给大家说

2441

然后咱们那个先说啥呢

2442

先说这个内存和指针那么这个指针是什么东西呢

2443

只真是个什么东西这个指针分广义的

2444

解释和狭义的解释

2445

指针分广义的解释和狭义的解释

2446

狭义的解释是什么呢

2447

狭义的解释指针它实际上就是一个变量

2448

这个变量里面保存的是内存地址

2449

这是狭义的解释

2450

那么广义的解释呢

2451

广义的解释就直接认为

2452

指针就是地址

2453

这是广义解释

2454

那么狭义解释更能体现出它的这个特性来这个指针的特性来

2455

只要那个指针指针他确实是个地址没错但是呢

2456

这个地址你把它保存在哪儿呢

2457

你得把它保存到指针类型的变量里

2458

这是指针

2459

这这是狭义呢

2460

必须得了解这个狭义呢

2461

这个狭义的概念那么这个内存

2462

内存他要有内存地址对吧

2463

内存它是什么样

2464

非常非常长的这么一个纸条儿

2465

原来给大家做过这个相关的这个比喻

2466

内存是一个非常非常长的纸条

2467

上面有好多好多的小格子

2468

一个小格子就是一个字节

2469

那么我们要找这个小格子里边的数据

2470

必须先得找到这个格子是吧

2471

找数据必须得找到这个格子

2472

你怎么找到这个格子

2473

从你得数数

2474

从前往后数第几个格子

2475

ID几个格子

2476

第100个格子是吧

2477

然后呢

2478

这是第这是第210个格子这是第250个格子对吧

2479

这个一百二百一二百五

2480

这是什么

2481

这是那个地址

2482

他是第几个格子

2483

它就是这个地址

2484

这个内存地址是是是这么回事儿

2485

那么接下来呢

2486

是指针地址和引用这三个概念是什么东西

2487

这三个概念

2488

指针刚才说了对吧

2489

地址刚才也说了

2490

指针狭义的解释

2491

狭义的解释就是一就是这个保存这个地址的这么一个变量

2492

那么饮用呢

2493

引用是什么东西

2494

引用他是一个高级特性

2495

在C语言里面是没有用的

2496

大家要记住

2497

C语言里边儿是没有用的

2498

在C加加里用引用

2499

C语言里没有

2500

在JS

2501

Java啊

2502

什么乱七八糟的

2503

这些语言里边有

2504

为什么要引用呢

2505

因为指针

2506

他非常的强大

2507

也非常的灵活

2508

但是随之而来的问题是什么

2509

非常容易出错

2510

实际上你在用指针的时候

2511

你是在计算这个地址

2512

你在计算这个地址

2513

究竟我下一个内存的地址

2514

我该操作操作哪一个地址啦

2515

我得算出来给算出来

2516

那么

2517

这块数据

2518

如果说你是动态申请的内存

2519

你用完了这块儿

2520

这块内存用完了

2521

你得释放掉

2522

你得还给操作系统

2523

要不然就会造成内存泄漏

2524

就是因为他有这么多特性

2525

所以很容易出错

2526

那怎么办

2527

用引用把这个指针给封装起来

2528

那那么引用把地址封装起来以后

2529

你就不用去算这个地址究竟是什么了

2530

究竟是在在什么地方了

2531

直接

2532

通过引用

2533

它自动就给你算出来

2534

在什么位置

2535

然后你就找到这个数据了

2536

所以饮用是对指针的封装

2537

高级语言里边儿就不让你动指针

2538

很多高级语言里边儿不让你动指针呢

2539

只有少量的语言

2540

只有少数的语言里面还保存着指针

2541

但是呢

2542

人家不建议你去乱用

2543

能用引用就用引用

2544

为什么呢

2545

很容易出错

2546

对吧

2547

但是你你要操作一些

2548

你要写一些偏底层的东西

2549

要效率的东西

2550

你还得用指针

2551

这是为了这事

2552

为了平衡这是为了平衡

2553

但咱们JS一般都是写应用

2554

对吧

2555

JS一般写应用所所以说你就根本就不让你用指针你用了指针呢

2556

那鸡怎么办

2557

对吧

2558

你你只针把把那个内呢

2559

把那个数据移了位置了

2560

JC不知道

2561

GC到时候他释放不了

2562

这这就乱套了

2563

那么这个接着呢

2564

就是这个指针的

2565

这个指针的类型了

2566

指针的类型

2567

三种指针的类型有主主要是三种

2568

第一是指向变量的指针

2569

只要这个变量就是数据

2570

对吧

2571

变量就是数据然后呢

2572

第二种是指向指针的指针

2573

这个指针他也是一个变量

2574

对吧

2575

狭义的解释里边

2576

指针它也是一个变量

2577

这是指向指针的指针

2578

第三个呢

2579

是指向函数的指针

2580

A指向函数的指针

2581

它就是指向代码

2582

因为代码也在内存里边儿那么咱们就先先干什么

2583

这节课先把这俩搞清楚

2584

下节课再给大家说这个指向函数的指针

2585

咱们看代码是不是看到这个再给大家讲

2586

然后咱们就看右边这个图

2587

看右边的右边的图

2588

那么左边

2589

然后看右边

2590

分成了两半儿分成两半儿

2591

那么右边这个就是内存

2592

右边这个是内存

2593

只不过他被竖起来了

2594

然后左边儿

2595

有一个变量P有一个变量P

2596

这个变量里面保存这个变量P

2597

它是一个啥呀

2598

他就是一个指针变量

2599

它是个指针变量

2600

这个指针变量里边保存的就是

2601

数据在内存当中的地址

2602

是吧

2603

这个这个指针这个指针

2604

P这个指针

2605

它保存的这个变量

2606

它的值

2607

是用P来表示

2608

用这个用这个P来表示

2609

这个P实际上就是一个数字

2610

数字就是对内存的编号那么这个这一块内存

2611

这个内存它前边儿的这个

2612

这个内存他的地址是什么呢

2613

就是PI减一

2614

那P减一

2615

那地址减一对吧

2616

它后边儿往后边儿隔着一个是什么

2617

七加二

2618

ID只加二这是

2619

这就是那个指针的运算

2620

指针只能加和减

2621

那指针运算只能加和减

2622

其他的运算是完全没有意义的

2623

就好像是什么

2624

就好像是那个

2625

门牌号

2626

对吧

2627

你一条大街上面有好多有好多这个房子

2628

每一个房子给他编一个门牌号

2629

那么你要找

2630

比如说你要找12号

2631

对吧

2632

你走到十号了

2633

你你再往前

2634

你在往前走两号儿这是加你你你你走到14号了

2635

你走过了

2636

你你得往回走两号

2637

这叫简你要乘是什么意思

2638

程他是没有意义的

2639

对吧

2640

你要歪打正着

2641

你可能你大概能够找到那个位置

2642

有可能能够找到位置

2643

但是大部分时间是找不到的除就更没意义了

2644

那么这个地址

2645

他是从零开始的

2646

我们要我们要注意

2647

地址他没有付他没有付的

2648

所以这个指针它的本质是个什么

2649

它的本质是个无符号整数

2650

无符号整数

2651

指针它的值是一个无符号整型这么一个这么一个变量

2652

但是他是但是但是他

2653

是指针

2654

但是它是指针类型

2655

这是指针的那个

2656

表示还有指针的运算加或者是减

2657

然后咱们接着往后看

2658

接着往后看那么这个指针

2659

那么这个指针首先呢

2660

咱们先说指向变量的指针

2661

先说指向变量的指针

2662

比如说呀

2663

咱们这张图是什么意思呢

2664

这张图咱们写代码是这样

2665

In TEin TE

2666

In TE还还写的太

2667

我直接在那儿写吧

2668

我直接在这儿写吧

2669

比如说啊

2670

咱们那个写一行

2671

写一行代码

2672

写一行代码

2673

咱们有一个变量

2674

变量是a in TE a

2675

等于十

2676

这是这是那个这是一行语句啦

2677

C这C的语句

2678

然后写完了这一行

2679

那在内存里面是什么样呢

2680

这个a这个变量

2681

它会在内存里边儿找一个位置

2682

找一个位置

2683

然后呢

2684

这个位置它的值给它设定成什

2685

那么这个位置谁说了算呢

2686

谁说了算呢

2687

咱说了不算

2688

谁说了算

2689

编译器还有操作系统说了算

2690

编译器他

2691

他会他会干什么

2692

在你的代码里边儿

2693

某一行

2694

代码里边这个二进制这个代码

2695

二进制的这个代码

2696

某一个位置给你设定成这个时儿

2697

操作系统呢

2698

操作系统把你的这个代码装到内存里边儿

2699

装到内存里边儿去

2700

装到内存里边儿

2701

他不可能顶着你这个内存头儿这儿开始它会在内存中间找一个位置

2702

这这是这是你这是你这个代码在在内存当中的位置

2703

然后呢

2704

他会给你计算出一个偏移量来

2705

给你算出这个这个位置真正的这个偏移量

2706

来算出这个偏移量

2707

他就是真正内存的位置

2708

那这一行咱们把这一行代码写完了

2709

在内存里边儿某一个地址

2710

这个就是内存的地址

2711

他是16进制的

2712

要注意这个地址16进制标志

2713

然后这个呢

2714

就是变量付给便赋给变量a的值

2715

然后然后咱们该该用那个指针了

2716

用指针怎么去用呢

2717

咱们得有一个整数类型的指针P

2718

那前面ins星黛表示整型指针

2719

那整型指针这是一个类型

2720

这是C

2721

这是C语言里面一个类型

2722

这个类型就是整数指针类型这个这个

2723

变量P就是整数只新指针类型的一个变量

2724

然后

2725

这个有了这一行

2726

在在内存里边儿也会有这个P的位置

2727

也会有这个指针P的位置

2728

那么指针P的位置有了

2729

指针P里边它保存的值是谁

2730

保存的值咱们看这个图

2731

指针P它保存的这个值

2732

那是变量a的地址

2733

对吧

2734

这两个值是一样的这而这个而这个指针P这个值

2735

而且就是就是他

2736

那后边的代码怎么写呢

2737

后边儿代码是这样

2738

你得给这个指针变量赋值

2739

给它赋值怎么赋值P等于

2740

那这个地址怎么来

2741

从哪儿来的

2742

咱们得找变量a的地址

2743

得找变量a的地址

2744

但是这样写是不行的

2745

你不能让他等于爱

2746

你等于爱

2747

实际上是把这个值

2748

是把a里边的值给父

2749

给这个指针了

2750

这就错了

2751

编译器会给你报错的

2752

它会告诉你类型

2753

类型不匹配

2754

那怎么去找他呢

2755

怎么去找他

2756

要取变量I的地址

2757

那怎么取呢

2758

用爱的符号

2759

再一个变量前边儿用and的符号

2760

它是取这个变量的地址

2761

当然这一个APP

2762

他还有其他的用法

2763

其他的用法

2764

比如说呀

2765

在两个变量中间儿

2766

这两个变量或者两个两个这个常量中间

2767

比如说一

2768

AND2这是在干什么

2769

这是在做被运算

2770

但是呢

2771

你在一个变量的前边儿用这个and

2772

它就是取这个变量的地址

2773

所以说这一行代码

2774

就是把变量a的地址取出来

2775

然后呢

2776

把这个地址赋值给指针P来在内存里边儿就是这个样子了

2777

这是蜜

2778

这是指向变量的指针

2779

那指向变量的指针

2780

那指针在内存里面是这样

2781

在内存里边儿这样表示

2782

这个好理解

2783

对吧

2784

这个好理解

2785

就是在内存里边儿

2786

我给你找一个变量

2787

在内存里边儿有一个变量

2788

这个变量它是一个整数的变量

2789

然后呢

2790

在内存另外一个地方还有一个变量

2791

那个是指针的变量

2792

然后指针变量它

2793

通过指针变量找到那个那个那个那个那个普通的那个变量

2794

找到它的位置

2795

这是这这是那个普通的指针

2796

指向变量的指针

2797

那么这种指针它还有另外一个名字叫叫一级指针

2798

指向变量的指针

2799

它叫一级指针呢

2800

另外还有什么呢

2801

指向指针的指针

2802

指向指针的指针指向指针的指针叫二级指针

2803

那么这种二级指针是怎么回事儿

2804

仍然是

2805

咱们这儿这J这张图上就有代码了

2806

前面in a等于十

2807

对吧

2808

A和前面是一模一样的

2809

和刚才那个指向变量的指针试一试是一模一样的

2810

然后呢

2811

我们这儿有了一个一级指针

2812

这是一级指针对吧

2813

印特星P这是一级指针

2814

它是指向的是a

2815

他

2816

它里面保存的是一个变量的地址

2817

这个变量a把它给放到这儿了

2818

然后呢

2819

我们后面又有一个ins星星屁ins星星PF星星P是什么

2820

指向指针变量的指针

2821

指向指针变量的指针

2822

那么这个P1这个ins星星PE这个指向指针的

2823

指向指针变量的这个指针

2824

他的名字是P1

2825

那么这个P1它里边儿只能放屁的地址

2826

那么这个P本身也是一个变量吗

2827

通过N的符号把这个P的变量拿出来

2828

把它放到这儿

2829

那这个是P内存

2830

这个是这个是P这个变量内存的样子

2831

PP1

2832

这个是P1这个变量内存里边的样子

2833

那么PE的地址是她

2834

PE的地址是她

2835

PP的地址呢

2836

P的地址是这个

2837

那么PE的值呢

2838

就是PD值

2839

然后P的值

2840

P的值是谁是变量a的地址

2841

这是通过二级指针

2842

然后去指向一级指针

2843

一级指针再指向这个变量

2844

中间跨了这么一下

2845

中间跨了一下

2846

那有同学说了

2847

那你这么弄他多麻烦

2848

这能干什么用

2849

对吧

2850

这能干什么用

2851

这要就要回到哪儿了

2852

回到计算

2853

回到那个计算机

2854

基本原理呢

2855

Na在计算机里边儿

2856

你去在内存

2857

你去在内存当中去找数据

2858

依靠的是什么

2859

依靠的是寻址方式

2860

寻址方式

2861

什么寻址方式

2862

这几个字

2863

寻址那么在前边儿

2864

在前面咱们给大家看了这个

2865

看到这个东西

2866

这个这个图从哪出来的

2867

还记得吗

2868

给大家说过

2869

叫什么

2870

8088杠8086汇编

2871

那这本书这本教材里边儿是吧

2872

非常经典

2873

清华大学出版社的

2874

当时我学的就是这本

2875

在那本书里边就讲那个808086的这个

2876

8086这个CPU的寻址方式讲了多少种

2877

讲了多少种讲了16种

2878

讲了16种寻址方式

2879

有什么

2880

有机制有立即寻址

2881

现在这16种

2882

我我记不得多少个了

2883

哈哈

2884

已经亡了很多了

2885

我就记住几个就记住几个

2886

第一个就是立即寻址

2887

立即寻址就是这个

2888

就是通过变量a

2889

那就是通过变量a去得到去得到这个值

2890

立即寻址

2891

第二种呢

2892

是间接寻址

2893

第二种是间接寻址

2894

间接寻址是啥呀

2895

就是一级指针

2896

先通过先找到变量的地址

2897

再通过变量的地址去拿这个变量的值这是间接寻址

2898

然后这个二级指针它也是间接寻址

2899

但是呢

2900

他是做的是两次

2901

他做的是两次间接寻址

2902

第一次间接寻址找的是指针P的地址

2903

对吧

2904

通过地址找比指针P的值

2905

第二次间接寻址是通过指针P的值去找变量a的值

2906

这是两次间接寻址

2907

另外还有什么呢

2908

基址寻址基址寻址

2909

什么叫基址寻址几指就是找一个基础地址基础地址是不变的

2910

然后去算偏移量

2911

机制

2912

这个机制寻址实际上就是指针的运算

2913

一开始这个P指针

2914

P指向的是这对吧

2915

指向这个地址

2916

然后在这个地址上进行加或者是减运算

2917

那就在这个实际上算的就是这个

2918

这个内存的这个数据在内存里面的偏移量

2919

这这这叫机智

2920

其他的我全都忘了

2921

我就记住这么几种

2922

当初也没当初也没好好学

2923

就就学会了前面这么几种

2924

后边儿的越学越饿

2925

越学越越那个越麻烦

2926

干脆就那啥了

2927

干脆看一看

2928

直直接翻了翻就就过去了

2929

好歹那个考试过了

2930

这就是二级指针了

2931

然后下节课呢

2932

给大家敲代码

2933

下节课给大家敲代码帮助理解最后呢

2934

就是这个内存

2935

这个内存的这个

2936

东的这个内存动态分配

2937

内存动态分配

2938

咱们要先了解C语言的内存分区

2939

C语言的内存分区是啥样儿的

2940

C语言内存分区

2941

前面咱们说了程序的程序

2942

程序在内存里边儿

2943

它是分两段儿

2944

一个是代码段

2945

一个是数据段

2946

那么C语言的这个内存

2947

它分几段呢

2948

分四段

2949

C语言的内存分四段

2950

但是呢

2951

它仍然是基于代码段和数据段去分的

2952

那那么代码段是什么呢

2953

是程序代码区

2954

它对应的是代码段儿

2955

数据段呢

2956

对应的是这三个区

2957

这三个区全都释放数据的

2958

那这三个区

2959

一个区是战区

2960

一个趋势堆区

2961

还有一个是全局区

2962

全局区也叫静态区

2963

那么全局区就放全局变量

2964

静态变量等等这些地方还有一些常量

2965

比如说字符串呢

2966

属于常量

2967

所以放在这个全局区里

2968

那战区呢

2969

战区他就是

2970

函数调用栈

2971

那函数调用栈他在韩

2972

他在那个进行函数调用的时候

2973

得把当前作用域里边的局部变量的保存起来

2974

对吧

2975

保存在哪儿保存在站上

2976

那咱们平时说一个函数调用栈

2977

这个变量在调用函数的时候

2978

那个变量保存在哪儿

2979

保存在站上那个站指的是这个战区

2980

另外还有一个呢

2981

就是堆取

2982

这个堆呢

2983

就是用于内存动态分配那么对内存动态分配在C语言里边儿呢

2984

用这个关键字malloc

2985

又买lock

2986

这个关键词看上去是个函数

2987

看上去是个函数

2988

实际上它是一个与她是一个关键字

2989

他不是那个函数

2990

那你这个就是告诉操作系统我要多么大的它的参数

2991

在这个参数这儿填一个数字

2992

必须得是个这必须得是个这个正整数

2993

不能是零告诉操作系统我要多大

2994

然后返回了

2995

返回是个指针

2996

返回一个指针

2997

这个指针就是操作系统给你分配的这个内存

2998

他在内存当中的位置是吧

2999

返回值是个内存

3000

它看上去像个函数

3001

用上去也

3002

用上去也是按照函数这个样子去用

3003

但实际上它是C语言的一个关键字

3004

那你用完了你得释放

3005

对吧

3006

你这个数这块内存你不要了

3007

你得释放怎么释放free用free

3008

这个关键字

3009

那么福瑞里边就得放指针了

3010

那么这个指针这个指针

3011

是哪儿来的

3012

从马唠嗑这儿的返回值

3013

你用完了就要把这个地址

3014

用free去释放

3015

释放多大呢

3016

操作系统知道

3017

操作系统给你记下来

3018

操作系统知道你所有请求的这个内存

3019

你去free什么地方

3020

操作系统就给你释放那么这一块儿是最容易出错的

3021

在编码的时候最容易出错

3022

因为你因为你这个指针是要经过运算的

3023

如果说你经过运算了

3024

你把原来的那个那个地址给丢了

3025

你去福瑞的时候

3026

操作系统肯定给你报错对吧

3027

那么这一块儿

3028

动态分配就是malloc free

3029

那么C加加呢

3030

C加加用的是new关键字

3031

去申请动态申请内存是new关键字

3032

那你是放就是迪丽特迪丽她

3033

New关键字一个一个类对吧

3034

New关键字一个类

3035

比如说类a

3036

然后返回值就是这个类a在内存里面的位置

3037

那你砥砺他呢

3038

砥砺他要要砥砺他这个地址

3039

那保存这个地址的变量

3040

和这这俩套路是一样的

3041

就是关键字不一样

3042

那么做这种操作

3043

做这种操作他的数据在哪操作

3044

就在堆区操作

3045

那咱们JS里边呢

3046

JS里面也有new关键字对吧

3047

New关键字

3048

那么你JS new关键字

3049

他也是

3050

在堆上只不过V吧

3051

只不过V8的内存管理和CC语言的内存管理套路是不一样的

3052

咱们后边儿

3053

后边的课给大家讲他们的内存管理区别在哪儿

3054

这个全局区或者静态区

3055

这个就不用多说了

3056

你程序初始化的时候

3057

内全局变量等等就在这个地方

3058

他只他只初始化一次这是C语言的内存的这个

3059

这个内存的这个结构

3060

那下节课呢

3061

给大家咱们咱们那个带着大家去去那个

3062

去去去去分析一下那个note JS的那个世界循环

3063

那个世界循环的代码

3064

然后呢

3065

再分析那个代码的时候

3066

再给大家去奖励

3067

再深入的去讲这个

3068

去讲一下这个指针还有呢

3069

就是C语言的这个结构体

3070

那那么在在那个时候给大家讲

3071

C的内存管理和那个弄得JS的这个内存管理

3072

他们之间的这个区别是什么

3073

实际上弄得JS这个内存管理

3074

他是直接向操作系统要来一大块内存

3075

这一大块内存

3076

然后就是弄的JS自己玩儿

3077

他他需要什么内存呢

3078

它它需要变量的时候

3079

需要创建变量的时候

3080

他就在他就直接在

3081

内内那块儿地存里去去去折腾

3082

他的堆也在这块儿大内存里

3083

它就不持续地向操作系统内存了

3084

而C语言呢

3085

他要持续不断的向操作系统要内存

3086

用完了以后要还给操作系统这这是他们两个

3087

这是他们的这个区别那么在操作系统层面上呢

3088

就更加复杂了

3089

比如说操作系统为了高效的去给程序分配内存

3090

他必须对内存进行一个分页

3091

进行分页

3092

然后呢

3093

还要给这个程序去去那个去做一个那个需去映射一个虚拟地址空间让程序看起来它的它的这个成他的这个内存是连续的实际上操作系统给给内存分配的内存是不连续的

3094

但是要让要要让程序看起来自己的成自己的内存是连续的

3095

那就要做这个地址

3096

空间的这么一个映射

3097

这这就涉及到那个操作系统的具体实现上了

3098

这这就很复很复杂了

3099

好

3100

今天的内容

3101

就先讲到这儿

3102

咱们这个明天后天都是这都是这个相关的内容明天呢

3103

就是那个世界循环事件循环相关的

3104

后天呢

3105

就是那个V8V8的那个代码

3106

好

3107

今天啊

3108

咱们先到这儿

3109

今天先到这儿都是我讲

3110

都是我讲

3111

反正是我原来一开始不是给你给你说了嘛

3112

也那个一开始不是跟你们说了吗

3113

就是那个操作系统的网络的协议的

3114

后端的还有底层的都是我讲

3115

对吧

3116

钱反正是前端的

3117

真正涉及到前端的呢

3118

那就是老袁了

3119

那个明天是event

3120

这就是那个明天是那个那个那个那个我想想

3121

我课件儿呢

3122

那个V8

3123

V8引擎

3124

就是那个V8和异步机制那个PPT

3125

明天是那个

3126

VBA宏任务鸿威任务这个咱们这个咱们暂时先不涉及是这个红任红什么红微任务这个V8这个宏威这个红这个微任务这个这个东西

3127

在咱们公众号里都有文章

3128

你可以去翻

3129

咱们公众号里面啥都有

3130

就是就是你你们就是不看

3131

哈哈哈

3132

对

3133

明天讲那个

3134

V8与异步极致

3135

V8引擎羽翼不极致

3136

明天讲这个

3137

好

3138

今天就先到这儿

3139

明天咱们继续

3140

拜拜

