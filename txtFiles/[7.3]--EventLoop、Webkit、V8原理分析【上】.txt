1

It is said to answer my

2

ways steps more time with the nineteen ninety

3

one the

4

way it used tobe what you want to

5

talk to cool an t

6

snow if there is something

7

and

8

gone so long ago

9

that the first

10

The

11

face that you

12

can live without the stay

13

at home home kit mi

14

get money

15

pay

16

into my day

17

changed

18

his

19

The

20

the the the now that would keep on making

21

kitchen

22

卡林卡林卡林卡妈撒都咖喱咖喱咖喱咖喱咖喱咖喱嘎咖喱咖喱咖喱咖喱咖喱咖喱咖喱咖喱咖喱

23

卡林卡林卡林卡林卡林卡林卡林卡林卡林卡林卡妈

24

咔喱咖喱咖喱咖喱

25

好

26

咱们准备开始啦

27

咳

28

上节课呢

29

给大家讲的是那个计算机的底层原理

30

还有C语言

31

C语言重点就是那个指针和内存那一块儿

32

那咱们今天呢

33

就接着接着来上上一节课呢

34

给大家推荐的是这个网站

35

不知道大家那个C语言的这个东西

36

看了没有

37

像那个C加加

38

还有还有C语言

39

先看C语言

40

然后再看C加加比这个顺序别乱了

41

那这个基本语法先把它掌握住

42

那之后呢

43

咱们那个回头

44

我会给你们往群里边发传一本那个电子书

45

那个电子书呢

46

就是那个学C语言比较合适

47

有空了呢

48

就去看看

49

想深入的去学的就就看那个电子书就行

50

实际上这个C语言呢

51

把把这个东西学会了

52

你去掌握其他的语言

53

那个是相当相当容易的

54

那掌握了C加加看其他语言

55

那几乎就是没有什么障碍了

56

不过那个掌握C加加还是需要一些时间

57

当初我刚入行的时候呢

58

就是就是做C加加

59

当时用的是那个visio studio啊

60

那当时还用的是那个VC6

61

那个那个版本是相当老了

62

VC6是那个上学的时候就用VC6

63

后来工作了好多公司当时还在用VC6

64

然后呢

65

那个后来才改成那个这个visual studio202005

66

才改成那个版本

67

那那个像像那个恶CC加加这这一块儿

68

原来是有很多公司都在用这个东西在在Java

69

在Java还没有普及的时候

70

好多公司都在用这个C加加

71

当然呢

72

当时呢

73

还是以这个桌面儿为主

74

不像像当时呢

75

互联网也不像现在这么发达

76

当时的互联网呢

77

就是P值P还有ASP啊

78

就就这两个屁另外呢

79

还有还有一部分是JSP

80

但是但是大大部分的那个软件呢

81

仍然是那个C端的

82

就是CS结构

83

现在呢

84

当然当然现在好多系统都是BS结构了

85

甚至更早的时候呢

86

还有还有一种更加奇怪的结构

87

那种奇怪的结构我也不知道叫什么名字

88

就是在unix上

89

在unix上那个终端上面就写好多的那个脚本

90

然后你登陆上去以后

91

那个那个终端它自动就给你调起那个脚本

92

然后就给你这就是用脚本写的那个界面

93

内那种程序我是没写过

94

但是我用过

95

那个那个那个就相当老了

96

实际上那个时候

97

这个信息这个信息管理系统之类的

98

他差不多都是这

99

模式啊

100

要么就直接在unix上玩儿

101

在终端下边儿文本文本的界面儿

102

要么呢

103

就是写一个C端

104

然后那边弄一个服务端

105

所以那时候用C加加写呢

106

那个那个人挺多的

107

那么用C加加去用C加加去这个

108

去去去写这个程序的话呢

109

是相当不容易的呢

110

尽管说他是面向对象的

111

但是呢

112

你要完全的把它给掌握住

113

起码起码三年对这是C加加

114

你真正了解他这真正理解这个面C加加的这个面向对象至少三年

115

就是得得干三年活儿

116

你就可见

117

这个C加加是多么的复杂

118

但当然你去掌握它的语法还是还是很简单的

119

实际上C加加他有了这个面向对象以后

120

最早那个设计模式

121

设计模式就是用C加加去描述你像像那个有一个有一本书叫设计模式

122

那本书也不太也不是特别厚

123

大概两三百页

124

就是就是提出设计模式的内内四个人写的

125

那四个人就简称四人帮

126

他不是那个四人帮

127

哈哈

128

是写写设计模式内四人帮内四个人写的

129

只要那本儿书里边儿都是C加加去描述的

130

那C加加他不好学

131

不好学在哪儿呢

132

就在那个设计模式这儿是吧

133

他他里边弄弄的

134

它它里边弄了好多这个这这这个这个模式

135

尤其是去写那个复杂的那种那种引擎

136

还有呢

137

就是一些比较为了代码复用

138

为了代码复用恶有很多公司自己就封装了好多库

139

然后呢

140

就用了好多这个设计模式方面的

141

当时那个去内那个开发软件开发公司

142

不是互联网公司

143

当时的软件开发公司

144

如果说你自己有一套酷

145

那就是你的核心竞争力

146

当然那个库是绝对不可能开源的

147

当当当时那个开源也不像现在那么发达

148

那是零几年的时候

149

所以说这个CC加加

150

C语言也好

151

C加加也好

152

把它的语法掌握住

153

咱们能够看懂他的那个代码

154

知道这是怎么回事儿就行了

155

你要真的想用它去写

156

那就先从C开始

157

是啊

158

所以就用先别陷陷入到那个面向对象的那些复杂特性里边儿去呢

159

那个估计你头发就不剩几根儿了

160

好的

161

那那咱们呢

162

就接接着讲今天的东西

163

金奖今天的东西呢

164

那个如这个后边儿呢

165

会涉及到一个这个引擎的这个代码是那个代码就是C语言写的讲到最后的时候

166

咱们看一下那个这个这个这个就是lab Le这个库的lab Le这个库

167

是C语言里边非常著名的一个库

168

他把底层的网络进程管理什么事件

169

事件循环全都给封装了

170

实际上大家在大大家觉得那个V8对吧

171

大家觉得那个V8很牛不是是不是还有那个note JS也很牛对吧

172

那no de JS

173

Linus不是前端的东西

174

你要注意

175

Linus不是前端的

176

它是C语言库

177

大家都觉得

178

弄的JS很牛

179

一开始是就是就是内一个人写的

180

对吧

181

就就觉得这个人很牛

182

实际上他真正写出来的代码

183

没有多少

184

那他的代码它它的代码量

185

那么大家一看这弄的这么厉害

186

对吧

187

代码量肯定很多

188

实际上它真正的那个用C写的代码不是特别的多

189

他那个底层的这个异步IO

190

还有事件循环

191

还有那个V8的这个

192

还有这个node JS的这个进程

193

它内部的一些那个工作线程等等

194

都是基于lives实现的

195

那可以说它就是一个底层互

196

这个底层护士非常非常优秀的

197

原来写C语言的时候我还用过这个东西

198

相当好用

199

而且呢

200

这个东西

201

累不

202

还还腐恶

203

还是跨平台的

204

你看他怎么

205

跨平台呢

206

他把Linux和Windows底层API给封装了

207

封装成了一个统一的接口儿

208

然后你就掉就行了

209

你也不用再编

210

再在那个跨平台编译的时候呢

211

也不用去写那么多开关

212

是是非常的那个是非常的那个容易的

213

那么咱们

214

那么咱们那个接着就正式开始了

215

首先呢

216

咱们先看一看那个绿的JS和V8的这个引擎结构这个引擎结构呢

217

原来老袁也给大家讲过

218

那么我给大家讲的时候呢

219

更加深入底层

220

告诉大家底层它究竟是怎么回事

221

从从那个县城

222

从这个线程和操作系统的这个角度上来来分析这个弄得JS他是怎么回事儿

223

然后呢

224

咱们a最后一次讲Linux相关的东西

225

你看

226

这节课是最后一次涉及到Linux相关的

227

那么涉及到什么呢

228

就是Linux的IO模型

229

林克斯到迄今为止

230

总共有五种IO模型

231

Link现在总共有五种IO模型

232

那么这五种其中有四种

233

是基本模型

234

其实是基本模型

235

还有一种是是IOIO模型的一种比较复杂的这么一种解决方案这是最后最后一次涉及到利克斯了

236

然后呢

237

就是那个这个echo

238

就是其中的那个解决方案

239

那就是第五种然后再给大家稍这个简单的介绍一下这个IOCP啊

240

就是Windows里边儿的那个一不那个异步机制

241

实际上这些东西

242

咱们这节课讲的东西是非常非常底层的

243

不仅仅是C语言

244

我不仅仅是讲C语言

245

因为你去面试的时候

246

人家不人家不问你C语言怎么写

247

对吧

248

人家会问你那个源代码看过没有

249

弄的JS源代码看过没

250

V8的源代码看过没有

251

他那个世界循环机制是怎么回事儿

252

你得能说出来对吧

253

咱们dei dei能去看懂那个东西实际上note JS的核心功能

254

Note JS的核心功能就俩

255

就俩

256

而且这俩

257

都不是那个弄的JS作者是实现出来的

258

哪两个呢

259

一个是V8引擎对吧

260

是Google的另外一个呢

261

就是那个那个世界循环加一不机智那个那俩东西异步循环和这个世界循环和异步机制

262

就是内部这边东西

263

没有一个是他写的

264

就是他呢

265

就是他他搭了个框架出来当然这个框架也是很牛逼的

266

我也不是很我也不是否定人家的那个工作

267

能把这个东西设计出来的人那是非常牛逼的

268

他他不一定非要从底层去实现这个玩意儿

269

那咱们看一下这个note JS的这个系统体系

270

实际上在这个图里边儿

271

相当大一块儿就在这儿

272

对吧

273

相当大一块儿就在这儿

274

就是那个世界循环

275

那么这个世界循环就是基于lab UV的

276

咱们目光一下就被吸引到这儿来了

277

对吧

278

因为它地方大哈

279

那么这个玩意儿底下是个什么东西

280

这底下写的是什么

281

它是异步IO

282

什么叫一部

283

和异步相对的又是什么

284

那一步相对的是同步

285

等一下详细给大家解释这个同步和异步究竟是怎么回事儿

286

然后呢

287

另外一块儿就是V8AV吧

288

就是JS引擎

289

然后其他的东西呢

290

我们看

291

我们看那么其他的东西

292

真正这个node JS作者写出来的东西是什么

293

是这个框架

294

是这个note JS ban Ding SI框架

295

实际上它是一个什么

296

它就它就相当于一个插件儿系统

297

相当于一个插件系统

298

或者说一个那个扩展系统

299

那你写了什么新的东西

300

什么新的功能往这个上面去接接到这个上边儿

301

他这个模块化设计的这个这个思想是是是相当高明的

302

等一下咱们挨个的去挨个的去分析好

303

然后咱们先整体先按照流程看一下

304

按照流程看一下这个图

305

那么这个怎么按流程呢

306

就按照咱们JS

307

就按咱们JS在执行时候的那个流程

308

JS他是怎么执行的呢

309

我们写出来了那个JS的文件之后干什么呢

310

之后把它扔给这个引擎

311

霸对对吧

312

那咱们扔给这个引擎以后

313

咱们的这个JSJS这个代码就被实例化啦

314

咱们JS代码被实例化了

315

它就变成啥了

316

变成application

317

就是这个应用

318

那么这个应用他是要依赖V8的

319

依赖这个V8

320

所有的东西你得经过微吧去解释

321

包括他你你要有什么东西

322

你要转成什么字节码

323

这这些乱七八糟的

324

也都归他管

325

这么这个微吧

326

他干什么呢

327

他只管

328

他只管JS

329

只管JS的解释和运行

330

别的什么也不干

331

那么我们要想我我们要想用一些这个网络的功能

332

对吧

333

我们发一个请求

334

发一个像后端服务器发一个请求过去

335

或者是说像文件

336

去写点东西

337

写点数据进去

338

那V8管不管

339

他不管

340

那谁管

341

依靠操作系统

342

要依靠要要靠一操作系统管

343

那么在这个操作系统这儿

344

我们看操作系统

345

操作系统它是个虚线框

346

把操作系统放在这儿

347

那实际上这个操作系统它不属于漏的JS

348

那只是用到了操作系统的API

349

那么这以后

350

我就不说操作系统的API了

351

是说操作系统的API他不专业

352

他不专业

353

那为什么不专业呢

354

它有专门的名词叫系统调用

355

上节课咱们讲汇编的时候

356

对吧

357

A说说的就是系统调用

358

那个是专业词汇

359

然后

360

咳

361

然后呢

362

那么怎么用到的这个操作系统的东西

363

那操作系统它是以接口给你提供的

364

那你怎么去用呢

365

你得去用操作系统提供的那个那个那个接口去那怎么去用

366

我们得把这个操作系统接口封装起来

367

那封装起来封装成插件儿

368

这是其中一个用法

369

这是其中一个用法

370

要注意

371

把操作系统的一些功能加上自己的一些功能

372

把它封装成一个一个扩展或者是插件儿来先接到这个弄得JS单顶上

373

接到这儿

374

那么我们要自己

375

我有的时候我们需要用node JS去写一些自己的扩展

376

那那也是接到no de JS丹顶瓷这儿都是接到这儿

377

那什么时候需要写扩展

378

比如说你觉得哪哪一个库

379

那么JS哪一个库

380

JS时间的库

381

它效效率太低

382

你想让它更快一些

383

要高性能的东西

384

或者说某些支持

385

它它不支持

386

某些东西它不支持

387

比如说你要操作串口

388

呵呵

389

对吧

390

你要操作串口儿

391

你想你想用note JS去写一个小服务

392

然后呢

393

给给嵌入式什么板子

394

或或者说服务器上去操作那个串口打印机

395

你要你要操作串口

396

它不支持不支持你就自己写和串口通信的一个东西

397

就就就就就就接在这儿

398

那些功能都都都在这里呢

399

如果说

400

那么问题就来了

401

那么你串口也好

402

还有调用这个操作系统

403

调用操作系统的那个

404

功能也好你

405

它有很多操作

406

他是独占的

407

那什么叫独占

408

就是你一个进程去操作一个文件

409

那个进程就不能被那个文件就不能被其他进程打开

410

对吧

411

那么在你的自己的进程里边

412

你还要去考虑这个同步问题

413

那什么叫同步问题

414

再给大家讲Linux进程的时候

415

还记不记得给大家讲的那个笑话

416

哪个笑话

417

就是几个人聚餐对吧

418

几个人聚餐去吃熊掌那个

419

开着灯大家不敢拿

420

关着灯

421

然后呢

422

大家去抢这这这会造成争抢

423

因为这种资源它是独占的

424

你一去争抢

425

他必定被锁住

426

你锁住了

427

那谁也动不了

428

这这这就麻烦了这

429

所以说呢

430

得有一种机制

431

得有几得有一种机制去解决这个问题

432

那么弄的JS他是怎么解决的呢

433

依靠事件循环

434

专门有人去做那个去操作那些IO那些操作那些IO由谁去做呢

435

由工作线程

436

比如说你要读写文件

437

还有呢

438

请求网络这些操作

439

并不是你通过这个

440

并不是你在在并不是你通过接接到这个benz上的

441

这这这个

442

拓展直接去操作的

443

你JS不是直接去操作这个扩展

444

你要注意

445

就是IO操作

446

涉及到IO的不是直接去操作

447

那怎么办

448

要专门有一个工作线程

449

他来管他来管这个他来管理这个IO操作

450

那么这个工作线程就是相当于专专人专职

451

他是专门操作文件

452

或者他专门操作网络

453

这这样呢

454

你

455

就不会就就不会

456

大家都去操作同一个IO

457

然后呢

458

造成这个拥堵

459

那么这个工作线程

460

比如说去操作文件的

461

比如说你要把数据写到文件上

462

或者是说你把这个数据发到这个网络上

463

那么在做这些事儿的时候呢

464

有专门的一个县城

465

一个工作线程

466

或者如果说你开了多个端口儿呢

467

对吧

468

那就是多个那那就是多个这个工作现场呢

469

那么你要想把这个你的你的这个JS代码

470

要把这个IO操作要要要发送到工作线程这儿来

471

工作线程它它帮助你去发

472

他给你发出去

473

那么响应回来以后呢

474

来再由这个工作线程再传回给你的这个你的这个程序上来

475

那么这就相当于什么

476

就相当于这一个人去干这件事儿

477

如果说你的这个程序里边儿

478

你的这个程序里边儿

479

你要想实现异步的一个功能

480

比如说你把这个请求发出去

481

这个响应不会马上回来

482

对吧

483

不会马上回来

484

那你是等还是不等呢

485

你要等

486

那你干不了别的

487

你要不等

488

你要不等那那个响应你你你怎么接得到

489

这是一个矛盾

490

对吧

491

因为这个V8

492

V8引擎它这个咱们弄的JS

493

把它扔到这个微

494

扔给这个微吧

495

他就是个单任务

496

他就是个单任务程序

497

人家所有的那个操作

498

他就在一个县城里边

499

而且而且是在这个主线程里边儿

500

是吧

501

所以呢

502

所以怎么办

503

得有一种机制来解决

504

把这个任务传给工作线程

505

然后工作线程做完了以后要返回来通知

506

要有这么一种机制

507

那么这种机制依靠什么解决呢

508

就依靠这个事件循环

509

就就是这个东西

510

所以说这个lab屋里边儿的

511

这个世界循环

512

它是no de JS的核心

513

那他是一个核心功能

514

那么这个世界循环它是怎么

515

它是怎么工作的呢

516

你看咱们咱们接着看

517

看这个这个大框里边儿

518

那如果说我们的程序需要去发一个请求

519

发一个请求之后

520

好

521

那么这个请求就入到事件队列里

522

那咱们去依靠这个事件对吧

523

实际上这个事件事件的

524

本质是个什么东西

525

在咱们代码层面上

526

事件的本质是个什么东西

527

事件的本质它是一个

528

有条件的回调函数

529

他是一个有条

530

那刚才那个矛盾问题

531

咱们现在不就解决这个问题吗

532

那解决这个矛盾就依靠这个世界循环你你你走神儿了是吧

533

那么那个我刚才讲到哪儿了

534

我一分神儿

535

一分儿不知道讲到哪了那个狐那个事件

536

JS里面那个事件

537

它的本质是个什么东西

538

但他是一个有条件的回调函数

539

什么叫有条件的回调函数呢

540

就是满足某种条件的时候

541

你才去回掉那个函数

542

这叫有条件的回调

543

那你咱们在写那个

544

咱们在写那个事件的时候

545

用用那个JS去去去去去写一个事件

546

咱们要先去干什么

547

要先有一个事件

548

对吧

549

然后呢

550

再有一个函数之后呢

551

把这个事件和那个函数把它给关联起来

552

然后再处理它的时候

553

还要再处理它的时候

554

有了结果要reject对对吧

555

那那个事情就要返回来

556

就就是告诉你要回调所以说那个事件的本质

557

事件的本质就是一个有条件的

558

就是一个有条件的回调

559

那那好那些事件

560

咱们JS的那些事件

561

那都放到这个事件

562

队列里边儿去

563

都放到这个事件队列

564

那么这个队列那它是一种数据结构

565

那么这种数据结构

566

它有什么特点

567

队列的结构是什么特点

568

先入先出

569

对吧

570

先入先出

571

嗯

572

那么先进去的那个事件就要先被拿出来

573

这是那个这个数据结构

574

具体的东西

575

咱们讲到那个数据结构的时候再详细

576

再再再那个详细给大家说

577

然后

578

咳咳

579

然后这个事件入了队列以后怎么办

580

来这里有一个循环

581

这里有一个循环

582

那个循环是啥呀

583

For循环

584

或者是那个while循环不管是什么什么东西

585

他是个死循环

586

这个世界循环它是个死循环

587

他一直要在那儿转

588

一直要在那儿转呢

589

他不能他他不能那个这个循环N次就退出

590

你必须得是告诉他

591

媳妇儿你别转了

592

他在他在那个退出来

593

你你不告诉他

594

你你不让他停他就不停

595

他一直在那转

596

那么他一直在那儿转

597

他在干什么呢

598

做两件事儿

599

那做两件事儿

600

第一个呢

601

处理咱们这个队列

602

他不断的去便利这个队列

603

队列里边有了任务了

604

有了任务了就是咱把那个事件给加进去了

605

对吧

606

有了事件加进去就是有了任务了

607

那么那个任务接下来干什么

608

这个任务他就是IO操作的任务如果是看到有这个任务

609

那就拿出来交给谁呢

610

交给工作现场

611

Na交给工作线程

612

那么交给工作线程以后

613

那工作线程就去干活了

614

对

615

那么工作线程干完了活呢

616

比如说你发一个请求

617

发一个网络请求过去

618

然后呢

619

网络请求也回来了

620

回来了以后

621

干什么呀

622

通知你

623

要通知你

624

那么通知你的话不是通知你的这个程序了

625

不是让你的程序去做回调儿

626

是谁回掉

627

而是事件循环帮你回掉

628

那事件循环帮你回掉

629

那

630

是这个回调干什么

631

就是你数据回来了

632

对吧

633

数据回来了

634

我该怎么去处理这个

635

我该怎么去处理这个

636

这个数据咱们再咸度的

637

咱们再行动的程序的时候

638

那这个模式可是司空见惯的

639

对吧

640

咱们就是直接用那个就就就直接用那个箭头函数

641

咱们总是写那个喜喜欢写箭头函数

642

然后在箭头函数里边儿一再再去实现函数

643

那样写起来非常方便为什么要那么写呢

644

就是方便回掉

645

你把一个函数

646

那你把一个函数的参数

647

你把一个函数当成一个参数交给另外一个函数

648

那就是在做回调

649

那么那个函数呢

650

那那个被当成参数传进去的那个那个回调函数

651

谁去帮你

652

谁去帮你回掉世界循环帮你回掉掉回掉完了以后接着干啥呀

653

接着呢

654

找对应的那个事件

655

找对应的这个事件调完了以后再恶就就就把这个世界给给拿出来拿回来

656

把他从队列里面拿出来就不要他了

657

因为你是干完了

658

然后把结果再回交回到咱们的这个程序这

659

你是事儿做完了

660

你结果也有了

661

你结果有了你不得返回给你的程序吗

662

那然后你的程序再进行后续处理

663

他是这么一个流程

664

那么这个图实际上讲的是什么

665

就是讲咱们再进行IO操作的时候

666

再进行这个IO操作的时候

667

咱们

668

再进行IO操作的时候

669

这个操作顺序他是怎么走的

670

那并不是说直接

671

因为你看

672

因为这些IO操作它都是谁提供的功能IO操作都是操作系统内核的功能

673

是吧

674

你要想操作一个硬件

675

比如说网卡

676

你IO ni ni ni ni发射网络

677

发送网络请求

678

你必须走网卡

679

你要想操作网卡

680

你必须让内核帮你去操作

681

你别人你你的note JS是不行的你你你他你没有权限做这件事儿

682

操作系统就不让你干

683

那所以说呢

684

咱们并不是说直接通过班订四对吧

685

并不是说直接通过binding思去去掉穿透这个benz

686

去掉这个操作系统内核的这个这个东西呢

687

而是干啥呀

688

而是让

689

而是交给这个事件循环

690

然后呢

691

事件循环交给工作线程

692

交给工作线程

693

让工作线程去去掉

694

去掉完了以后

695

再通过事件循环

696

再把结果给你这么一个这么一个流程

697

咱们背后背背后那个内内套机制

698

就是这么个玩意儿

699

那么平时

700

咱们对这个JS

701

是有一个误解的

702

咱们总是说这个JS

703

他是单任务语言对吧

704

JS是单任务语言

705

它是个它不支持这个多任务

706

实际上呢

707

不

708

不全对不全对

709

实际上其他的语言

710

比如说C语言

711

他也是个单任务语言

712

你要注意

713

C语言也是个单任务语言

714

那么那个C加加他也是个单任务语言

715

他为什么他们能写这个多任务

716

实际上多任务是实现在什么地方的

717

多任务实现在哪儿

718

实现在操作系统里

719

多任务是在操作系统里不是模拟出来的不是模拟出来的

720

他是在操作系

721

你要自己要模拟那个那个多任务

722

那那就累死了你只能做什么

723

你你只能做那个

724

你你只能做携程

725

你只能用携程

726

携程是在是在语言层面上

727

是在语言层面上实现的

728

那么线程和进程这个东西

729

你要想你要想用它必须得通过操作系统去操作呢

730

那么为什么JS不让你去不让你去那个实现这个多多任务呢

731

不让你实现这个多任务呢

732

不让你实现多任务是怕引发混乱

733

实际上这个多任务分两个层面

734

你这个是错了

735

你你那个你这个你这个这个理解是错的单线程它不是单任务这个单线程和单任务你是不能挂

736

你你是不能那个挂挂起钩来的

737

这个多任务

738

咱们先把这个多任务搞清楚

739

多任务是分两个层面的

740

第一个层面在哪儿呢

741

在晋城层面上

742

你只有一个进程

743

这一个进程就做一件事儿

744

这这是丹丹进城

745

也是单任务

746

如果说你有多个

747

你有多个进程

748

对多个进程做同样的事儿

749

这这就是多任务

750

对吧

751

那弄的JS支持支不支持多任务支持

752

弄的JS支持多任务

753

比如说咱们再启动一个

754

咱们咱们再启动一个那个弄的服务的时候

755

通过PM to的帮助

756

咱们用用用那个cluster模式

757

也就是那个集群模式

758

那就是多任务

759

对吧

760

那就是个多任务

761

那么第二个层面

762

就是县城层面

763

实际上这个no de JS呀

764

他是一个单线程的

765

他是一个单线程的语言呢

766

那么在弄的JS里边儿

767

你是不能去

768

你是不能去创建线程的

769

对吧

770

No de JS是创建不了现成的

771

也不允许你去调

772

也不允许你去调那个创建线程的那个系统调用

773

C语言就能对吧

774

C语言可以可以创建线程

775

它它它它像这个操作系统去去要一个现成资源就有了实实际上它是不允许你JS去掉的为什么为什么不允许引发混乱

776

但实际上哈no de JS它是支持多线程的

777

Nah no de JS它是支持JS多线程的

778

他是怎么支持JS多线程

779

有一个主线程

780

这个主线程就是你的

781

就是你的程序

782

就是你的JS程序

783

那么其他线程呢

784

你自己

785

去写no de JS的工作线程

786

那这个工作线程no de JS有内置的

787

也给咱们开发人员留了个口子是吧

788

你可以写这个worker

789

哈哈

790

你可以写这个沃克

791

那么在在那个浏览器里边儿

792

浏览器里边儿也一样

793

浏览器里边儿咱们不是可以写

794

这个思维思沃克马

795

是吧

796

那就在浏览器的那个背后呢

797

你去去执行你的那个JS代码和页面的那个JS代码

798

他他互不冲突

799

对吧

800

实际上它是同一个道理JS

801

语言本身你是写不出这个多线程的这个程序来的

802

但是呢

803

你依靠跑JS的这个环境是可以写出来的

804

把这个环境一个就是node JS

805

另外一个呢

806

那就是浏览器

807

他不是V8

808

V8本身它它恶

809

V8本身它就是受这个

810

线程限制了

811

你一个县城里边儿只能跑一个V8

812

V8是要依赖到县城上的

813

而不是现成由VBA创建

814

千万不要把这个因果关系给搞反哈之

815

VBA要依赖到县城上

816

V8要依赖到县城上

817

实际上咱们写一个工作线程

818

那么这个工作线程里边儿

819

它就有一个V8的实力

820

他和你主线程的这个程序主主线程这个程序里边这个V8他是两份儿

821

那他可是两份儿

822

那两个实例

823

是吧

824

并不是说你在JS里边儿去甩一个去create一个a thread对吧

825

Create thread这就是那个系统调用的名字创建创建线程的那个系统调用名字

826

你JS你是create不了

827

你是create不出thread的线程

828

不能游

829

不能在V8这个层面上去创建

830

那这所以说呢

831

这个JS哈JS他在依赖外部环境的前提之下

832

他是可以

833

它是可以有多线程的

834

是吧

835

多线程就是worker threads啊

836

就是工作线程

837

那web worker service worker啊

838

都是这么回事儿

839

都是这个

840

都是用的同样的原理

841

Web web worker

842

就是浏览器那边的

843

浏览器那边就是web worker he service worker

844

就就这俩沃克是吧

845

好

846

然后咱们把这个图

847

这个图和那个操作系统这个层面上的这个联系

848

咱们把它搞清楚了

849

搞清楚之后

850

然后咱们再深入到这个node JS里边儿去呢

851

那么这个图

852

就是一个简图落

853

后边这个图就是一个简图

854

那么这个简图是什么呢

855

就是啊

856

就是no de JS非阻塞事件驱动IO

857

非阻塞事件驱动

858

实际上关键词是什么

859

非阻塞非阻塞

860

等一会儿给大家讲这个非阻塞

861

咱们还没说这个非阻塞阻塞和非阻塞和非阻塞是怎么回事儿呢

862

等一会儿再再再什么地方讲在

863

在这儿讲

864

在这儿讲四种

865

四种基本模型

866

就是两两组合出来的阻塞非阻塞

867

同步异步阻塞非阻塞在在那儿讲然后呢

868

这个接下来呢

869

咱们再看一下这个no de JS这个结构no de JS它是一个引擎

870

对吧

871

那么咱们再上节课给大家说过

872

C语言他适合去做啥

873

去做底层库

874

去做那个网络

875

做嵌入式

876

做这方面的

877

C加加呢

878

适合做应用软件

879

复杂的应用软件

880

还有就是引擎

881

所以这个node JS它是用C加加写的

882

那当然他对C加加调的库

883

C加加是可以调用C语言库的

884

C语言

885

能调C加加库吗

886

再恶也可以

887

在某些在某些前提之下是可以的

888

还得看你那个怎么做导出

889

怎么把那个库的那个接口做导出

890

那样去做做导出就就比较麻烦了

891

先看左边这个图

892

左边这个图我们的程序跑在哪

893

我们的我们的JS代码跑在这儿主线程

894

JS代码跑在这儿

895

然后我们的我们的JS代码需要用到一些

896

那需要用到一些这个操作系统功能的时候

897

那怎么去怎么去用API对吧

898

通过这个API

899

再给大家讲那个再给大家讲那个Linux进程的时候

900

这这个Linux进程的时候

901

还记不记得给大家讲了

902

讲了一下那个PM to对吧

903

咱们是讲PM to的时候呢

904

咱们还写了还还还还还实现了一个那个PM to的那个多多任务管理的那么一个

905

那么一小段代码

906

一个极简版的PM图

907

对吧

908

就是那个那个克拉斯特模式

909

PM to的那个克拉斯特模式

910

极简版的PM To Class的模式

911

就那么几行

912

咱们在那里边儿

913

去掉的那些API你还记得吗

914

就是OS那个那个那个包里的

915

OS里面那个去去去看那个CPU个数

916

去掉CPU个数

917

然后呢

918

去创建进程那些东西

919

那些东西谁提供

920

API提供

921

在这儿去提供

922

那么在这儿也不是由也不是由由这个玩意儿去提供的

923

实际上那个API它就是一薄薄的一层封装

924

它封装的是什么呢

925

它封装两种

926

它封装两种

927

第一种是什么呢

928

第一种是

929

在这个no de JS里边儿

930

它内部实现的另外一种呢

931

就是通过

932

通过这个班顶note ban Ding SI接入进来的一些东西

933

他他就就封装的是这这两种呢

934

那就是就是通过封装的那个操作系统的那个系统调用

935

咱们才能在JS那个层面上去去用

936

对吧

937

那你你要用JS

938

你要用JS去打开一个串口呢

939

你要用JS打开串口

940

那也得去通过操作系统的那个文件操作

941

通过那个文件操作

942

但是呢

943

文件操作他是受限制啦

944

你不能直接去打开串口

945

不能直接打开

946

你没有办法枚举硬件

947

对吧

948

你JS你JS代码没没举不了硬件

949

他他他没有开这个口子

950

所以你得去干啥呀

951

自己去写扩展

952

自己去写扩展

953

然后帮你把那个串口儿那个硬件把它枚举出来

954

然后你从里面拿出来拿出来什么叫枚举硬件

955

就是所有的这个硬件全都列出来

956

我要枚举这个串口

957

枚举串口就是看你这个这个机器上有几个串口

958

然后你去从里边挑一个

959

这叫枚举硬件

960

那么咱咱咱再接着看

961

再接着看下边儿是什么呢

962

A note ban Ding

963

那note ban Ding z啊

964

然后又恶正是另外一块儿呢

965

就是这个插件

966

另外一块儿差价

967

那么这个note ban Ding和插件儿这俩东西

968

各司其职吧

969

Note ban Ding撕它干什么

970

往里边儿接一些复杂的机制

971

Note ban Ding SI往里边儿

972

适合往里边接复杂机制

973

那么这个插件儿呢

974

插件儿他就是直接往里边儿去接这些库

975

对这些库做一个简单封装

976

然后恶封装成API

977

你你就掉就行了

978

咱们先看一下这个插件儿

979

插件儿这儿提供的是什么功能

980

加密功能对吧

981

还有呢

982

HDP的这个协议

983

HDP的这个协议封装

984

当然这个HDP协议封装

985

他更底层是socket

986

那socket呢

987

就就就要去去钓操操作系统了

988

那那个ADP协议本身那个协议头

989

这还有那个什么body等等

990

这这个应用层的这这个东西呢

991

就在这儿

992

你要往外发

993

那那对不起

994

你得去找saki的另外还有呢

995

就是解压缩

996

对吧

997

C lab解压缩这些都是功能性的东西

998

没有什么处理机制

999

然后还

1000

那么这个note ban Ding

1001

他接进来的是啥呀

1002

就是引擎加处理机制

1003

一个就是V8

1004

还有就是lab屋里边儿的这个异步IO机制

1005

他是异步IO机制

1006

还有一个呢

1007

就是事件循环机制

1008

还有就是DNS的这个解析机制

1009

这是几个主要的机制

1010

因为这些东西它是要有有自己的这个流程的

1011

你用一行代码是钓不完的

1012

你得通过几次

1013

同时还要经过什么等待哈他

1014

你才能把这个功能去去做完

1015

这种就是涉及到复杂基质了

1016

这种东西就接到这个诺搬凳子

1017

你要简单的东西

1018

我就调一个加密救救我

1019

我就把这个数据给加密啦

1020

对吧

1021

这这个我就把这个数据加密了呢

1022

我就调一个就调一个函数就行

1023

那么那个函数

1024

就封装到这个插件儿

1025

那么刚才有同学问

1026

Note就是note findings啊

1027

这个owns是是那个是是是啥

1028

不是advance

1029

你

1030

你

1031

你敲错了

1032

是ADD on hard on

1033

这还而且是个负数

1034

你这个句话就没说明你没理解

1035

No的不是note般的

1036

No的不是伴奏的颁奖词

1037

No的颁奖词是no的当中的一部分

1038

No的是啥呀

1039

No的是把这些东西打个包

1040

这是no的

1041

把这些所有的东西打个包是no的

1042

而这个note ban Ding子他是其中的一个框架

1043

他是里边的一个接入框架儿

1044

这个插件儿

1045

他是另外一个接入框架

1046

这两种框架的机制是不一样的

1047

那么这个note ban Ding SI

1048

它是有涉及到复杂机制的这种接入

1049

而这个插件呢

1050

是简单

1051

是简单功能的接入

1052

明白了吗

1053

这就是一个函数调完了就完的事儿

1054

一个函数调完了就完了这这些东西比较简单

1055

那么这一块儿呢

1056

这一块儿你你要发

1057

你你要去走一个网络

1058

或者写一个文件

1059

这个时候

1060

你就要涉及到操作系统这个层面

1061

你和操作系统进行通信

1062

那就要等操作系统

1063

对吧

1064

你把任务交给操作系统

1065

操作系统去做了

1066

等他做完了以后

1067

他还要回来通知你

1068

你一次是做不完的

1069

所以说这个机制就复杂

1070

复杂的东西放在这儿

1071

然后咱们接着看

1072

然后咱们接着看看右半边儿

1073

右半边儿

1074

右半边儿是什么呢

1075

就是就是那个一个框架图

1076

就是note JS这个框架图最上边这一行

1077

我们看一下最上边儿这个是啥呢

1078

是GS的

1079

纯粹用JS写的

1080

包括no的标准库

1081

多少啊

1082

咱们要是看一下note JS的那个源代码的话

1083

Note JS的源代码里

1084

不完全都是C加加代码

1085

那那个代码在哪儿呢

1086

我找一下

1087

代码呢

1088

在这儿呢

1089

不是

1090

错了

1091

不是这个

1092

在这儿呢

1093

咱们先简单的看一下node JS代码

1094

No的JS代码在这儿

1095

对吧

1096

它里边儿都是点儿hr.c等等

1097

点cc.cc就是那个C加加的那个后缀

1098

C加加源文件后缀

1099

也有点CP

1100

也有点CXCXCCXX啊

1101

这些都是那个C加加的那个程序的那个代码的代码文件的后缀

1102

点h.c.CC啊

1103

点那个CP

1104

点CXX都是C

1105

都是C加加的这个文件

1106

那么C的文件呢

1107

一个是点C一个试点

1108

一个是H

1109

那咱们看这个代码里边

1110

好多都是CC加加的

1111

但是呢

1112

我们啊

1113

但是呢

1114

我们在里边儿翻

1115

我们在里边乱翻

1116

这些在在这儿都是那个

1117

都是那个大家写的

1118

但是咱们在这儿再再去翻的时候

1119

看咱们再看这个目录

1120

这个目录里边儿再翻的时候

1121

这些全都是JS代码

1122

那么好多好多的那个

1123

弄的JS的那个标准库

1124

都是在都是在这个带这些代码里边封装出来的

1125

所以说呢

1126

咱们这个no de JS里边儿除了C加加代码

1127

还有JS代码

1128

他他是那个相当多的东西都是JS实现的之后

1129

中间儿这一块儿

1130

中间这一块儿主要就是note ban Ding the

1131

主要是note ban Ding SI

1132

然后这个node findings

1133

它里边儿三大三大模块儿

1134

一个就是V81个是异步IO

1135

一个是事件循环

1136

那这是这是那个note JS的这个系统框架图系统框图一层一层往下走

1137

实际上咱们编码的时候涉及到的就是这一层

1138

涉及到这一层

1139

你要想写扩展

1140

那就涉及到哪儿了

1141

就涉及到这个涉及到这个地方了

1142

然后把他往note顶上街就行了

1143

哈哈

1144

那么这个这节课的那个一个重要部分弄重要部分就是异步IO加事件循环

1145

实际上这两个东西

1146

都是lab屋里边儿给咱们提供的

1147

那接下来咱们就要给大家讲一讲这个一不这个异步异步机制

1148

同步机制究竟是怎么回事儿

1149

那么在讲之前

1150

要先讲一些需要先讲一些那个

1151

这个这个基础知识

1152

基本的知识咱们先先了解一下

1153

那么Linux操作系统它本身是个多任务的

1154

那么这个多任务

1155

他是怎么进行协调和调度的呢

1156

对吧

1157

因为你的程序要和内核进行通信的

1158

内核他做完了事儿怎么通知你的程序

1159

然后让你去回去拿呢

1160

这个时候咱们就要涉及到

1161

就要涉及到Linux当中一个重要的机制叫信号信号机制

1162

Linux信号机制

1163

那么这个Linux信号它是个什么东西首先呢

1164

什么是信号

1165

列那个寺里边定义了64种信号

1166

那么这个信号和消息有什么区别呢

1167

咱们要注意信号它不是消息

1168

前面咱们实际上这个东西

1169

这个世界循环用的是用的是一种消息传递机制

1170

事件循环内部用的是一种消息传递机制

1171

如果说你写过那个

1172

你用你写过那个VC的那个程序

1173

比如说那个VC

1174

你你上大学的时候

1175

你要学过这个C语言

1176

那肯定肯定肯定会涉及到那个MFC

1177

那个MFC是什么东西

1178

就是VC里边封装的那么一套裤一套内裤

1179

那内套内裤里边最重要的一个就就是那个消息循环机制

1180

实际上消息循环机制是Windows操作系统的

1181

是Windows操作系统的一套机制

1182

那咱们要那咱们咱们比如说咱们打开一个窗口儿

1183

比如说像这个XAMPP这个窗口这个窗口儿

1184

他是在这个程序的主线程里边儿

1185

窗口在程序的主线程里边儿

1186

那么这个窗口他为什么能在这儿一直显示的呢

1187

一直显示呢

1188

实际上是在主线程

1189

它有一个循环

1190

这个循环它一直在那儿转转转

1191

然后保持住这个窗口不消失他反复的在渲染这个窗口

1192

那如果说咱们在这个窗口上去点击一下按钮儿

1193

R点点一下按钮

1194

那么就要触发到背后的

1195

触发到背后的一些函数

1196

你比如说我们点那个start

1197

点那个stop

1198

在按钮后边儿他都挂着一个事件

1199

哪哪个事件

1200

On click事件

1201

你点击它之后

1202

背后的事件就被触发

1203

那么问题就来了

1204

问题就来了那

1205

这个事件你触发了以后

1206

然后干什么

1207

然后去掉事件和事件绑定在一起的那个回调函数

1208

那回调函数去干干活

1209

你点击starch点击start

1210

就要就要像像那个某一个服务去去去发一个命令过去

1211

服务启动了

1212

结果要给你要回来

1213

对吧

1214

结果要回来那

1215

这一套

1216

这一套机制Windows它是怎么实现的

1217

就是消息传递机制

1218

他用的是消息传递机制

1219

消息传递机制它上边儿带数据

1220

它上边儿挂着数据

1221

比如说你点了starch

1222

那点starch他背后的那个函数干什么

1223

要

1224

把这个数据传传过去

1225

传给那个消息循环

1226

那传过去

1227

上边儿带数据还有这个消息是这个消息是发给谁的

1228

目的地是谁要要带这两个东西

1229

那么信号呢

1230

信号儿他是没有数据的

1231

他是不带数据的

1232

信号是不带数据的

1233

那我给大家打个比方

1234

消息是什么呢

1235

消息就是那个你帮我传个话

1236

传过去

1237

这个话传过去

1238

这叫消息

1239

消息你帮我传话传给谁

1240

这是你的目的地

1241

那这个传这个话是内容是什么

1242

你欠我2万块钱

1243

你该还了

1244

这是那个内容对吧

1245

你替我传个话过去

1246

你的船告诉告诉那个谁

1247

他欠我2万块钱

1248

欠了好久了

1249

你该还给我了

1250

这是一个消息

1251

有目的地有内容

1252

这个内容就是数据呢

1253

那么信号是什么呢

1254

信号

1255

他就是一个非常简单的这么一个

1256

状态描述一种状态

1257

信号是描述一种状态

1258

什么样的信号

1259

比如说咱们去看一些那个抗日剧

1260

看抗日剧当然不是现在的抗日神剧了

1261

是是过去的那个抗日电影

1262

实际上是过去上个世纪的五六十年代拍的那些那些那个那些电影

1263

那些电影那个比如说那个鬼子要进村儿

1264

鬼子进村扫荡

1265

对吧

1266

鬼子进村扫荡

1267

那为了防止这个鬼子扫荡怎么办

1268

在高处那儿有一棵树

1269

然后有那个小孩儿在那儿放哨

1270

那小孩儿看到鬼子来了

1271

把这个数推导

1272

这叫什么

1273

消息树

1274

他只是表明一种状态

1275

那只是表示一种状态

1276

鬼子来了就就就就传就传的这种状态

1277

那么鬼子有多少个人呢

1278

她有没有大炮带着一袋大炮开没开汽车

1279

对吧

1280

有没有汉奸领路这些不知道

1281

只是告诉你鬼子来了

1282

这J这件事儿发生了

1283

这叫信号

1284

哼对吧

1285

就好像刚才有同学也说吹喇叭对吧

1286

就是冲锋号

1287

你在冲锋的时候就吹冲锋号

1288

还有呢

1289

就是信号弹

1290

发那个信号弹

1291

在几点几

1292

在午夜12点就要发起总攻是吧

1293

你的信号弹打出去一看

1294

这个红色信号弹

1295

咱们就打

1296

那个绿色信号弹咱就撤就是信号

1297

就是一种状态指示性的

1298

另外还有这种信号还有什么呢

1299

就就是那个红绿灯

1300

就是红绿灯

1301

红灯亮

1302

他就是你你你你不能走

1303

对吧

1304

这这就是信号

1305

它承载不了更多的附加信息

1306

只是告诉你这件事儿发生了或者说

1307

他处于这种状态

1308

这叫信号

1309

那么Linux丝他里边儿这种东西

1310

它里边这个信号呢

1311

他就是

1312

操作系统内核用来通知你的这个程序

1313

这个处理状态的

1314

Linux里边儿有64种信号

1315

麦克上麦克是unix

1316

麦克上面有32种信号是吧

1317

那么这个信号怎么看有有有多少信号儿过原来咱们给大家讲过Q是吧

1318

咱们说咱也也给大家说过

1319

Linux里边儿这个Q命令

1320

这个K有命令

1321

Linux这个Q命令他不是杀

1322

而是在发信号过去

1323

就是告诉

1324

告诉你要停止的那个程序说你给我停了

1325

实际上是发了一个停止信号

1326

实际上这个Q命令它就是用来发信号的

1327

如果说咱们要强制让一个程序退出怎么办

1328

K5杠九

1329

对吧

1330

K杠九杠九是什么意思

1331

发九号信号

1332

九号信号就是强制退出

1333

不管你在干什么

1334

你就给我退

1335

不管你活干完没干完

1336

你给我退

1337

就是你非常强势的

1338

那么这个咱们怎么看

1339

Linux里边多少信号呢

1340

杠L哈a

1341

列出来我现在这个终端

1342

我现在的终端打开的就是那个Mac的终端

1343

现在就显示出来的是麦克的信号呢

1344

那个unix信号

1345

那么Linux信号呢

1346

Linux信号咱们

1347

那个嗨

1348

这字儿太小

1349

咱们登录到那个Linux上

1350

咱们看一眼

1351

对

1352

Linux下的信号

1353

总共是64种

1354

哈哈

1355

这是64种

1356

那么咱们发的那个杠九

1357

实际上是发的这个东西CQ啊

1358

Sig是什么意思

1359

就是signal

1360

信号的意思塞个Q

1361

你给我

1362

你给我在这儿吧

1363

你你给我杀杀了

1364

那么平时发的那个

1365

一般咱们让这个程序退出

1366

让这个程序退出让他去

1367

咱们给他发的是哪个信号

1368

发的是这个

1369

这个QQ

1370

你给我正常退出

1371

正常退出

1372

实际上那个

1373

为什么要有这种机制呢

1374

防止程序

1375

它在处理一些数据的时候没处理完

1376

然后呢

1377

导致这个工作工作流程被打断

1378

比如说正正正写文件呢

1379

你啪叽一下给他强制停止了

1380

那个文件费了

1381

对吧

1382

你正在写数据库呢

1383

写到写到一半儿

1384

这个数据表写到一半儿

1385

你啪叽一下给他停了

1386

数据库飞了呢

1387

为了防止出现那种事儿所以呢

1388

就要发

1389

一般情况下发这个quit

1390

那么Linux的程序收到这个quit的

1391

收到这个quit的

1392

以后啊

1393

收到这个quit以后

1394

他要干什么呢

1395

他要先把手头的工作做完

1396

如果说正在处理事务对吧

1397

正在处理事务

1398

他要把这个事务进行回滚

1399

事务处理了一半儿

1400

他要把这个事物回滚

1401

所有事物全都回滚

1402

该回血的回血

1403

该把这个缓存里边的数据把它回写到硬盘上

1404

把这些活儿全都干完了之后他才停止

1405

这是这是正常的流程

1406

你要直接杠九

1407

杠九杠九的话

1408

那就直接

1409

那就直接完蛋啦

1410

直接完蛋了

1411

这是强制退出

1412

不管你在干什么

1413

你就直接给我退出来

1414

那么在列罗斯里边儿

1415

在Linux里边儿这个信号儿

1416

在这个Linux里面

1417

这个信号怎么去处理呢

1418

有专门的信号处理函数

1419

那么那个信号处理函数他就是个回调

1420

他就是个回调函数

1421

那个回调函数给谁回掉给操作系统内核回调

1422

那在你的程序里边儿去写一个回调函数

1423

然后呢

1424

设当你收到哪一个这个收到哪一个信号的时候

1425

你你就要回调对应这个这个这个信号对应的那个回调函数

1426

然后回调函数里边儿恶在在干什么

1427

在收场回调函数里边收场

1428

那么这个Linux信号主要分两种

1429

主要分两种

1430

一种是可屏蔽信号

1431

一种是不可屏蔽信号

1432

那可屏蔽信号是什么

1433

就是你收到了这个信号

1434

你可以忽略它

1435

收到了信号可以忽略

1436

你可以不去不去给他做相应的这个信号处理函数

1437

也就是那个回调函数

1438

比如说这个quit

1439

对吧

1440

恶意程序在收到这个secret以后

1441

他不去退出

1442

而是把自己切到后台上去了

1443

让你也看不到窗口儿

1444

是吧

1445

恶意程序

1446

对吧

1447

那么不这事可屏蔽信号

1448

不可屏蔽信号呢

1449

那就是Q

1450

那就是think you

1451

还有一个呢

1452

就是think stop啊

1453

这个stop在哪儿呢

1454

我找找

1455

乱七八糟的

1456

还有一个是single stop啊

1457

你们自己找吧

1458

我我这儿也花了

1459

找不着了

1460

找不见了

1461

在这儿呢

1462

这两个九号和19号信号

1463

九号和19号信号

1464

它是不可屏蔽信号

1465

也就是说啊

1466

你遇到恶意程序了

1467

或者是你的程序忙死了忙死了

1468

来不及去处理这个think you to

1469

你的程序在那儿在那儿给忙死了

1470

她她也就没有办法去掉这个信号处理函数了

1471

内那就失效了

1472

对吧

1473

那那这个信号就失效了

1474

相当于被屏蔽了

1475

那怎么办

1476

那你就要发这个不可不可屏蔽信号think q和这个think stop

1477

不管你有没有实现

1478

不管你有没有实现

1479

相相对应的这个这个回到

1480

这个处理回调

1481

操作系统要先去掉这个处理回调

1482

然后呢

1483

你要实现的话

1484

你要实现的话先调用处理掉

1485

然后呢

1486

直接把你程序给你干掉

1487

那就这样

1488

你就这这样

1489

你就做了坏事了

1490

这是林格斯那个信号

1491

Linux信号是林尼克斯吏部机制里边儿的这个基础

1492

你咱们一定要要要注意

1493

一定要记住一点

1494

信号儿是从哪儿产生的

1495

信号儿是从哪儿产生的

1496

信号儿是从内核产生的

1497

咱们在用这个Q的时候

1498

比如说QQ杠九

1499

然后一个PID

1500

对吧

1501

实际上这个命令是什么意思

1502

就是告诉内核

1503

你像PID某某某号进城去发一个杠九信号

1504

那么这个杠九信号不是你Q产生的

1505

那而是这个K

1506

我告诉内核

1507

让内核像这个进程发一个九九号信号

1508

所有的信号都是内核发出的

1509

内核去通知程序

1510

那么这个信号除了刚才所说的这些东西有什么用

1511

对吧

1512

实际上在这这些里边

1513

还有好多自定义信号

1514

我们可以看到这些东西这些东西这都是差不多的

1515

看着差不多的

1516

对吧

1517

这些是育有一部分是预留的

1518

预留给用户自定义的

1519

用给给自定义的自定义信号

1520

那么这些信号干什么

1521

比如说你让操作系统去做做什么活儿

1522

然后呢

1523

操作系统把这个活儿做完了

1524

做完了以后

1525

他要把结果放到一块儿内存里

1526

那放到一块内存里

1527

然后操作系统把恶在过来通知你的程序

1528

说你在某某某内存那儿去拿数据

1529

你在某某某内存那儿拿数据这这这这样去通知你

1530

通过共享内存的方式

1531

那那个共享内存是个特殊的

1532

是个是一块特殊数据操作系统内核也能操作你的程序

1533

也能操作这是通过内共享内存的共享内存模式去去河内内这个内核交换数据

1534

这个时候就要就要干什么

1535

有了数据的通知你去拿

1536

没有数据你不要乱拿

1537

这是直接

1538

这是非常贴近那个

1539

非常非常贴近那个操作系统层面上的这个处理机制了哈好

1540

然后呢

1541

咱们再看那个当我们

1542

当我们的这个程序

1543

当我们的这个程序

1544

在这儿那个内核空间和用户空间原来给大家讲过对吧

1545

这这个咱就咱就在这儿就不就就不多说了在在一开始奖励那个词的时候就给大家讲过了

1546

就是跑你自己的代码的时候

1547

内教用用户空间

1548

然后你去调调Linux内核的那个AJ那个系统调用的时候

1549

这个时候呢

1550

他就是那个内核空间

1551

那用户空间和内核空间再反复反复切换

1552

比如说你要发一个发一个网络请求

1553

发网络请求这个这个操作在哪儿坐

1554

当然是在内核空间去做

1555

你要写一个文件

1556

写文件这种操作也在内核内核去做

1557

如果你算一个一加一等于二

1558

是吧

1559

这个操作在哪儿

1560

这个操作就在你用户空间做

1561

你要是你要是那个写一行代码

1562

写一个console log hello word

1563

那么恶

1564

这个在哪做

1565

在内核空间做

1566

因为它涉及到IOLA

1567

你要把那个hello word输出到显示器上

1568

显示器是输出设备

1569

涉及到IO了

1570

所以就是内核空间的事儿

1571

然后咱们街这

1572

然后啊

1573

然后就是那个信号

1574

刚才给大家讲的这个

1575

讲的就是这里边的这个内容啦

1576

对于对于这个信号的处理

1577

信号的处理

1578

咱们进程可以指定这个处理函数

1579

就他这个处理函数就是我刚才所说的那个回调函数是吧

1580

一个信号儿就带对应一个处理函数是吧

1581

信号呢

1582

可以忽略也可以也可以不忽略

1583

也有的信号可以被忽略有

1584

但是呢

1585

那个q he stopped是不能被忽略的

1586

那要不然操作系统玩不转了

1587

他这个控制权就拿不回来了

1588

也就是说你听话对吧

1589

你服从我的调度

1590

那你就好好运行

1591

如果说你不服从我的调度

1592

那你就给我去死就就就就就是这么一套规则

1593

好

1594

咱们前面呢

1595

就是那个no的no的结构

1596

还有这个Linux这个信号

1597

然后呢

1598

就是Linux的四种IO模型

1599

这四种IO模型哪四种同步

1600

阻塞

1601

异步阻塞

1602

同步非阻塞和异步非阻塞这个时候呢

1603

咱们就要给大家去解答阻塞和非阻塞是什么意思

1604

好

1605

那咱们再讲这个四种模型之前

1606

咱们先休息五分钟先休息五分钟

1607

然后呢

1608

五分钟之后咱们继续

1609

Sorry

1610

Those just need a place

1611

What

1612

It is always green around the other side

1613

Gentle

1614

Three

1615

Every birthday

1616

Never

1617

seen

1618

好

1619

咱们都继续

1620

继续是那个IO模型

1621

Linux的IO模型

1622

那么在这个IO模型开始之前呢

1623

要给大家解释四个概念

1624

四个概念一个是同步和异步

1625

一个是阻塞和非阻塞

1626

那么那个同步和异步是是

1627

是怎么回事儿呢

1628

同步

1629

当你在同步异步

1630

这是在在实现

1631

在实现一些那个机智的时候

1632

这个是基质层面上的

1633

在实现一些机制的时候

1634

你是同时做

1635

还是还是那个分别做

1636

这是同步和异步

1637

那么阻塞和非阻塞呢

1638

那这是这是一个实现层面上的东西实现层面上是啥呀

1639

阻塞

1640

当你要做什么事儿的时候

1641

当你把一个工作

1642

把一项工作交给别人去做的时候

1643

那别人在做那件事的时候

1644

比如说a这是a

1645

一个人两个人两个人

1646

一个a一个要求必去打印一篇文档出来

1647

他a要用

1648

那么a让B打印文档的时候

1649

B就去打印了

1650

B在打印文档的过程当中

1651

A在干什么

1652

等着

1653

A在这儿等

1654

而且B在这儿

1655

B在这儿打印文档的时候

1656

打印的时过程怎么样

1657

打印到什么地步了

1658

你比如说你给我打打100页

1659

打印100页

1660

你是打了50页了

1661

还是打了80页了

1662

不知道

1663

而且呢

1664

那必须的等臂把这所有的文档都打完

1665

挨一块儿

1666

一块儿交给谁一块儿交给一块儿交给AA这叫阻塞

1667

这叫阻塞式

1668

那么非阻塞式呢

1669

非阻塞是是这样

1670

A把工作交给B

1671

同样打100页文章

1672

然后呢B这哈正在打折呢

1673

然后a去问

1674

打多少页了

1675

打了50页啦

1676

然后打了一会儿打多少页了

1677

打80页了

1678

他有反馈

1679

你去问他做完了没有

1680

然后这个B就告诉你我做到什么地步了

1681

这种机制叫什么

1682

他叫非阻塞呢

1683

阻塞非阻塞

1684

她是那个API那个层面上的

1685

而同步和异步呢

1686

她是整个大机制上的

1687

那么这个咱们把这个一同步异步和阻塞非阻塞这四个东西组合起来

1688

两两组合同步异步这是一个维度

1689

那么阻塞非阻塞这是第二个维度

1690

把这几个维度

1691

每个维度上两个东西

1692

对吧

1693

把他两两组合

1694

组合出四种模式来

1695

那那四种模式

1696

四种模式同步阻塞是同步非阻塞式

1697

两种异步呢

1698

异步阻塞式

1699

异步非阻塞式

1700

那么这个阻塞是取出阻塞和非阻塞取决于谁

1701

取决于底层的API

1702

他的工作方式

1703

同步和这个阻塞

1704

非阻塞取决于底层API的工作方式呢

1705

比如说咱们那个原来都用过那个这个东西

1706

对吧

1707

都用过这个Sam

1708

我给大家去敲一些简单代码

1709

用sublime

1710

那么你用sublime去打开一个文本文件

1711

打开一个小文本文件很快

1712

你要打开一个100兆的文本文件

1713

你就要等一会儿

1714

对吧

1715

你要打开一个一

1716

你要打开一个G的文件呢

1717

等等半天

1718

那么这个模式是什么

1719

他必须得把所有文件全都全都读完了

1720

然后才能给你显示出来

1721

这种IO操作他就是阻塞式的

1722

而那个一步呢

1723

尔那个非非阻塞式呢

1724

非阻塞式你会你会看得到

1725

他在读文件的时候

1726

你会看到这些文件一一行一行的给你显示出来读一点给你展示一点

1727

读一点窄一点

1728

这这这是那个非阻塞的

1729

他不是一一下子给你读完

1730

而是那个读读一点给点反馈

1731

这这这是那个非阻塞

1732

那在API层面上的

1733

那么咱们底层的这个IO

1734

IO操作

1735

有这么两种

1736

就是这么两种模式

1737

那在Linux系统上

1738

Linux的操作系统上

1739

再过去还只有阻塞式操作

1740

像这个socket

1741

过去这个socket Linux socket只有阻塞式操作

1742

后来加上了非阻塞式操作

1743

那个是什么时候

1744

那是将近20年前了

1745

那个原来我在上上大学的时候

1746

去学这个Linux的源码

1747

那个时候我去查资料

1748

查资料查来查去

1749

就就就看那个就就学这个socket的这方面的东西

1750

资料上怎么说的

1751

资料上就是说LISTESIA只提供了阻塞式的这个套接字

1752

而Windows呢

1753

提供了阻塞和非阻塞

1754

特别是套结字

1755

这么两种模式

1756

然后呢

1757

给给就给了几个例子

1758

那是很久很久以前了

1759

后来啊

1760

后来尼克斯就加上了这个非阻塞式

1761

那么这个阻塞是主色是它适合什么呢

1762

它是它它那个实现起来比较简单

1763

调用起来也简单

1764

他的问题呢

1765

就是你必须得等他一下子做完

1766

等他全部做完

1767

然后你才能去去去把数据拿出来

1768

而非阻塞呢

1769

非阻塞你可以分批的拿

1770

而且知道他的这个这个这个状态

1771

知道他的这个操作状态

1772

那非阻塞的问题在哪儿呢

1773

操作起来比较复杂

1774

他他这个操作流程就比较复杂呢

1775

这这是他们的那个特点

1776

那么那个接接着呢

1777

咱们分别的

1778

分别的给大家讲这四种

1779

讲这四种模式

1780

那么第一种呢

1781

就是最简单最基础的IO模型

1782

这个就是同步阻塞式的IO模型

1783

那么这个模型

1784

咱们就看这个图

1785

看右边这个图

1786

这个图叫什么图呢

1787

这个图它叫活动图

1788

活动图

1789

实际上就是两个两个角色

1790

这是一个角色

1791

这是一个角色

1792

这两个角色它们在

1793

他们在那个

1794

配合工作的时候

1795

这个流程是个什么样的

1796

平时咱们画的流程图

1797

那就是一个角色的流程图

1798

对吧

1799

又是三脚儿

1800

又是那个菱形

1801

又是那个方块儿的那种流程

1802

那种流程图只能去描述一个角色它内部的他是个他他是个那个

1803

单任务的

1804

而这个活动图它能够描述多任务的

1805

多任务的这个恶这种人

1806

这种活动

1807

而且这个多任务它是涉及到多个角色的

1808

他们之间是怎么交互的

1809

这这叫活动图

1810

那么这个活动图

1811

这个活动图

1812

它属于哪个范畴呢

1813

它属于

1814

这个

1815

UML

1816

大家抽空

1817

大家抽空去去去简单的去学一学这个UMLUML是什么

1818

统一建模语言

1819

他是统一建模语言UML

1820

它是一种设计工具

1821

他是个设计工具

1822

那么暗用这种设计工具呢

1823

它可以去做

1824

他可以给各行各业去

1825

去设计这个业务还有流程

1826

那比如说咱们百度一下

1827

UML呢

1828

统一建模工具统一建模语言是设计工具

1829

那么这个UML里边是有很多种图的

1830

比如说这个那个用力用力图

1831

用力涂什么样一个角色对吧

1832

一个业务角色而刚才那个那个活动图

1833

它是个恶

1834

那个活动图它是多个业务角色

1835

一个业务角色

1836

这个业务角色他能做他能做哪些事儿

1837

这这叫啥

1838

这叫用力

1839

这叫用力

1840

另外还有呢

1841

就是类图

1842

类图它描述什么

1843

描述这个类的

1844

继承关系

1845

类图

1846

咱们去看那个设计模式

1847

实际上看到的就是这个类图

1848

继承关系还有什么

1849

还有这个依赖关系

1850

这种箭头儿是依赖关系

1851

而这种三角箭头呢

1852

他是个继承关系另外还有什么

1853

聚合关系聚合关系有箭头儿

1854

还有建委这个建委这个这是个菱形实心菱形

1855

而另外一个就是这个这种箭头

1856

单薄的这个箭头

1857

这这叫聚合

1858

这叫聚合什么叫巨恶巨核什么意思

1859

比如说这这这个类是a是吧

1860

这个累是避而这个a类里边儿

1861

它包含着B

1862

B在这个类a里边儿

1863

这叫聚合

1864

依赖呢

1865

这个是依赖a要调用C这个类里边的东西

1866

这叫依赖

1867

那么继承地ID继承自a这叫继承咱们去看那个设计模式

1868

你看四人帮内四人帮那本儿

1869

四人帮那本儿那个设计模式里面就是这东西

1870

所以说这个UML它是很有很大用处的

1871

那么另外里边儿还有什么甬道图

1872

什么乱七八糟的

1873

各种各样的图的咱就不提了

1874

回回回头那个回头自己去研究

1875

还还可以用来什么话

1876

那个架构

1877

去设计时序等等四人帮前面不是给大家说了吗

1878

四个人写的你是不是刚来

1879

刚开始上课的时候

1880

你你你你来晚了

1881

四个人

1882

你不要说那个敏感词

1883

你说什么敏感词

1884

内内捣乱

1885

那个

1886

四个人写的那本书

1887

设计模式经典

1888

你你这

1889

干扰我思路

1890

现在现在不这么叫了

1891

作者是四个人喝

1892

嗨

1893

我说咋找不到呢

1894

是这个是这个这个这个

1895

这个这个F

1896

简称四人帮

1897

简称DF4个人

1898

这本书

1899

面向纯粹的面向对象的

1900

对对对这个

1901

这啥呀

1902

这都是这这百度根本没法用

1903

还有下载呢

1904

还有下载呢

1905

这这这么有名的书不知道

1906

那么这个图是啥呀

1907

这个图就是那个时序图

1908

这个图是时序图

1909

两个角色

1910

这个是程序

1911

这个是操作系统内核

1912

那么程序需要进行IO操作的时候

1913

你必须得让内核去做而这个呢

1914

就是同步的

1915

又是同步是同步阻塞式的同步阻塞是同步阻塞是什么意思呢

1916

那他他是这他是这么回事儿最简单最常见的

1917

IO模型

1918

同步阻塞是各行各业都能用

1919

你去射

1920

你去给其他的行业设计一个流程

1921

比如说工业流程a也能用那个UML

1922

你自己去百度吧

1923

我我在这儿不多说了

1924

当然国内现在用用用这个的很少啦

1925

现在现在用用这个M去做做设计的很少

1926

水平太低

1927

你你碰到你碰到那个真正的那个高手

1928

真正的那个大佬

1929

人家就是人家就得用这个MUML

1930

那那个东西设计出来以后

1931

那个思路是非常清晰的

1932

不光是it用

1933

自自己去百度

1934

就看百度百科就行

1935

你看那个维基百科也行

1936

维基百科说的那个更加详细

1937

然后咱们实际上这个这个图描述的是什么呢

1938

用户空间和内核空间

1939

他们之间是怎么配合的

1940

怎么配合的呢

1941

先看

1942

他这是个二维的对吧

1943

他有两个维度

1944

横着这个维度就是角色维度

1945

纵着的这个维度是时间维度是T时间维度

1946

然后呢

1947

这个从上往下这是

1948

流程

1949

这是流程横着

1950

这是两个角色之间的这个交互

1951

那么我们比如说我们要要要去读一个文件

1952

那我们要读一个文件

1953

那怎么去读

1954

我们要调用什么

1955

Fell open对吧

1956

那个弄的JS的那个file open

1957

那要调这个a

1958

要调这个函数

1959

这个函数它就是阻塞式的

1960

他是阻塞式的

1961

那在调的时候怎么去掉

1962

我们在这儿在这儿呢

1963

从这儿开始掉这个fell l

1964

这个PHY open

1965

然后掉以后这个时候呢

1966

就要把这个工作

1967

交给内核

1968

内核收到这个任务以后

1969

他帮着你去读硬盘去

1970

他给你读硬盘

1971

那么他读硬盘是需要时间的

1972

尤其是这个数据量比较大的时候

1973

时间更长

1974

那么他一直读一直读a这一这一段时间

1975

这段时间对吧

1976

纵轴是纵轴是时间嘛

1977

这段时间是他读文件的那个时间

1978

那么内核在读文件的时候

1979

你的程序在干什么

1980

你的程序

1981

就在那儿等着

1982

就在那儿等着

1983

什么时候

1984

继续往下走呢

1985

当文件读完了

1986

返回值回来了

1987

Fell open他返回了

1988

来继续往下走

1989

那如果说一直在这儿读

1990

你这儿就一直等着这个for open读完

1991

这种机制是同步阻塞

1992

同步阻塞简单的写一下代码写一下伪代码

1993

那伪代码就是这样的伪代码是这样

1994

比如说我们这儿有一个八法

1995

对吧

1996

我们这儿有一个buffer

1997

这个bug我就用C语言写了

1998

这有一个八分儿

1999

呢

2000

就是这个缓冲区

2001

缓冲区那个就这样

2002

比如说那个

2003

1K的1K的这么一个缓冲区然后呢

2004

我们要干什么

2005

要要open

2006

我我就掉那个C语言的

2007

调那个C那个C语言的那个API

2008

相当于咱们那个file open啊

2009

那我们接着呢

2010

就是就是那个一个指针

2011

对吧

2012

我们得有一个指针

2013

差被他

2014

IE这个一个指针

2015

这个指针干什么呢

2016

Openopen open那个

2017

是

2018

File name来接着干什么

2019

接着我们要把那个数据复制到这个八分里

2020

把这个读出来的数据复制到这个八分里边

2021

那怎么复制呢

2022

用妈妈copy

2023

妈妈copy

2024

这是复制

2025

再在内存之间进行复制圆圆圆地址目的地址

2026

就是这个八分

2027

那么复制多大呢

2028

100这个1024A1K的

2029

1K的这个1K的字节呢

2030

之后呢

2031

在那个在那个把它

2032

显示到这个显示器上去对吧

2033

把这个buff的内容把它输出到显示器上去

2034

这个代码

2035

这种代码就是啥呀

2036

就是

2037

就是这个同步阻塞是

2038

那么他在做的时候

2039

他在干活的时候

2040

他再怎么干

2041

你在open的时候

2042

Open错了

2043

不不是这样

2044

应该是open

2045

然后那个

2046

返回一个那个巨屏

2047

返回一个文件句柄

2048

然后呢

2049

在red在在那个read

2050

这才是读

2051

刚才只是打开文件

2052

那是那个

2053

简单的

2054

简单简单的伪代码了

2055

这这是那个这是那个完整的流程

2056

那么这个流程

2057

首先先执行这一行

2058

然后执行这一行

2059

这两行执行在在哪执行在这儿在这儿

2060

对吧

2061

前面的代码在流程在那儿

2062

然后然后接着干啥呀

2063

接着我们就该瑞的了

2064

就要读了

2065

就要读这个文件

2066

那读文件的时候

2067

这个函数瑞的函数

2068

他干活的时间

2069

是这个时间

2070

那是内核在干活的一个时间

2071

那么你的程序

2072

在干什么

2073

他在等着

2074

他在等着

2075

这段时间你什么也干不了

2076

他在

2077

等着你这个返回值返回来

2078

等他做完了返回值才有这一段时间都是在等这个

2079

等他执行完

2080

这是阻塞

2081

等这题的函数执行完了

2082

等这个函数执行完了

2083

接下来我们进行数据复制

2084

然后把数据呢

2085

把它给

2086

然后把它给那个

2087

输出到显示器上

2088

这个这两个代码他在哪儿执行在在后边执行

2089

在这儿执行

2090

只要是那个函数

2091

只要是这个函数瑞的函数你执行不完

2092

换句话说

2093

只要内核儿他的活儿没干完

2094

你的程序就得在那儿停着

2095

等着

2096

这叫同步阻塞模型

2097

这种是咱们最简单的

2098

直接就顺下来了

2099

直接直接就是一个就是一个那个这个顺序流程

2100

对吧

2101

咱们程序的三种基本三种基本结构大家还记得吗

2102

制基础

2103

程序的三种基本结构

2104

顺序流程

2105

还有呢

2106

条件分支条件判断刘条件分支流程

2107

还有一个是循环三种基本三种基本结构

2108

对吧

2109

哈哈

2110

这就就顺序来

2111

就顺就顺下来

2112

最简单的一种

2113

那咱们弄的JS里边儿提供的API

2114

Fell open啊

2115

还有那个之后read

2116

Fairy fair open呢

2117

直接把那个read兜兜兜兜风庄去了

2118

都封装进去了

2119

包括打开文件

2120

读文件

2121

然后然后在那个关闭文件

2122

这三个步骤它全都封装到哪一个函数里边了

2123

那个函数就是

2124

同步阻塞式的

2125

这是最简单

2126

那么这种模式

2127

这种模式它的好处

2128

是什么呢

2129

好处就是省CPU

2130

当我们的程序在这儿等着的时候

2131

CPU根本不执行他的代码

2132

对吧

2133

CPU它它只需要去维护这个内核的代码

2134

只需要跑内核代码就行了

2135

当我们的CP当当这个程序代码在执行的时候

2136

CPU除了要跑这个程序代码

2137

还要跑内核代码的

2138

要在这两个代码儿

2139

这这这这两种代码之间来回切换的做任务吗

2140

那你要是同步阻塞式了

2141

只需要跑内核代码就行

2142

不用管不用管那个程序

2143

程序呢

2144

程序代码暂时挂起了

2145

在CPU角度上来说

2146

它是高效的

2147

它的效率比较高

2148

那但是呢

2149

对于程序来说那就惨了

2150

对吧

2151

他你读大文件读大文件

2152

读大文件你就等着

2153

一直读完了

2154

或或者说那个内存耗尽

2155

然后你才有一个反应

2156

对于这个用户体验是不好的

2157

然后

2158

然后呢

2159

咱们是第二种

2160

第二种是同步非阻塞

2161

同步非阻塞

2162

那么同步非阻塞怎么回事儿呢

2163

先看这个非阻塞

2164

非阻塞咱们前面给大家解释的

2165

给大家怎么解释的

2166

你a让B去去打印资料

2167

然后B在打印的时候

2168

A就问这个B

2169

你打印多少啦

2170

然后B就告诉我a

2171

然后一直到最后打印完了

2172

把结果给

2173

这就是非阻塞

2174

那这个模式

2175

同步非阻塞

2176

同意和刚才的和刚才的这个流程是一样的

2177

那么这个a让B去打印的时候

2178

A他干不干别的事情不干

2179

他仍然是在这儿等着

2180

但是等的时候他也没闲着

2181

他没闲着

2182

他在干什么

2183

他在问问这个状态

2184

这是同步非阻塞

2185

那同步阻塞呢

2186

A让B去打印

2187

然后B打印的时候

2188

A什么也不干

2189

就在那儿死等

2190

他也不干别的活儿

2191

一直到B把这个打印好的文稿拿回来

2192

A才继续处理

2193

处理这个文字

2194

处理这个文档

2195

这这是这是同步阻塞

2196

可可见那个这种效率

2197

对于程序的效率来说

2198

对于程序来说效率是低的

2199

那么这个同步非阻塞呢

2200

我们接着看她也试一下顺下来的

2201

他也是一下顺序来的

2202

他也是只干这件事儿

2203

那他他只干这件事儿

2204

那他干这个事儿怎么

2205

他怎么干呢

2206

先看

2207

先把这个工作交给了内核

2208

内核去去读了

2209

内核去读读数据了

2210

内核读数据

2211

然后呢

2212

他这儿马上返回

2213

这个函数马上返回

2214

那这是异步函数

2215

一这个这个非阻塞函数

2216

非主非阻塞实现的这个函数

2217

你让他干活

2218

他说好累

2219

对吧

2220

他马上马上就干了

2221

干的时候好累

2222

这告诉你我在干了

2223

然后收到这个

2224

知道你在干了

2225

对吧

2226

知道你在干接下来

2227

接下来呢

2228

接下来这个程序

2229

想知道这个做完没有

2230

想知道做完没有

2231

然后他去问状态

2232

问状态没有做完

2233

返回没做完的状态

2234

如果说他做完了呢

2235

做完了把结果给你返回来

2236

把结果返回来

2237

那么这样

2238

这样

2239

这种模式有一个好处

2240

好处是什么

2241

好处就是你让他干活

2242

他这个函数马上返回来了

2243

返回来以后

2244

你这个时间可以干别的

2245

你可以在这儿见缝插针

2246

那可以在这儿见缝插针

2247

你问一下

2248

你问一下发现没做完

2249

你可以干干会儿别的

2250

干会儿别的你突然想起来了

2251

那那个文件你给我打完了吗

2252

还没呢

2253

你在干会别的

2254

你那个喝口水

2255

抽根烟

2256

聊会儿天儿

2257

对吧

2258

摸会儿鱼对吧

2259

你什么时候这个回来了你问的时候做完了

2260

做完了

2261

那你就不要摸鱼了

2262

你就在处理这个返回来的数据

2263

你反你你去处理

2264

那不做别的

2265

你可以做别的也这个同步非阻塞同步同步非阻塞你是可以做别的

2266

同步阻塞你是做不了别的

2267

同步阻塞你得在那儿等着刚才咱们写的这个代码

2268

对吧

2269

刚才写的这个代码

2270

这个函数

2271

这个读函数

2272

读取这个函数

2273

它再返回来之前

2274

你是执行不了后边的代码的

2275

对吧

2276

这是同步阻塞是那同步非阻塞式呢

2277

同步非阻塞式

2278

仍然是这个前面这个模式

2279

咱们在这儿那个再写一个同步同步非阻塞式

2280

同步非阻塞是这样读的时候

2281

实际上它它表示的他他是一个什么

2282

它是一个状态

2283

他是一个状态

2284

他是个状态

2285

然后干啥呀

2286

然后判断

2287

然后判断判断啥呀

2288

判断这个studiOS

2289

判断这个死第六次

2290

判断死第六次

2291

然后

2292

做完了他就去调那个做完的事儿

2293

如果说没做完

2294

那好

2295

我这儿干点儿别的

2296

我这儿写点儿恶

2297

写点儿别的吧

2298

可以可以写个进度条对吧

2299

这可以写个进度条

2300

然后在干什么

2301

然后

2302

然后再接着问死第六次

2303

然后再接着问

2304

问啥呀

2305

问状态问问问问这个状态

2306

然后再去判断

2307

然后再去再去这样

2308

A

2309

记录调

2310

然后不断的重复这个过程

2311

对吧

2312

不断的重复这个过程

2313

那什么时候什么时候

2314

读完了

2315

接着再再去考品

2316

那你不断的重复

2317

你这儿不能写一串

2318

你不能写一串这个这东西是吧

2319

你不能写一串这个同同样的代码

2320

那怎么办

2321

循环背循环背

2322

循环呗

2323

如果这个是这个状态

2324

它是没有读完的状态

2325

对吧

2326

没有读完的状态干什么

2327

在这儿

2328

在这儿写进度条

2329

玩儿

2330

没有读完

2331

那就在这儿写进度条

2332

读完了

2333

写后边儿

2334

进度条就就就就就不做了吧

2335

然后然后把它输出出来这个模式这个模式来

2336

同步非阻塞

2337

你在等他的时候

2338

你可以干点儿别的这这这这这

2339

这么个这么个流程

2340

哈哈

2341

对吧

2342

这么个流程

2343

那么这个流程对于

2344

咳

2345

这个流程

2346

对于CPU来说

2347

对于CPU来说他是低效的

2348

对吧

2349

他要反复的在内核空间

2350

和用户空间之间

2351

来切换

2352

那这种低效

2353

但是对于程序来说呢

2354

程序它可以干点别的

2355

他可以干别的了

2356

然后接下来接下来就是异步阻塞

2357

那接下来是异步阻塞

2358

异步阻塞就是调用这个阻塞式的IOIO接口

2359

那一部阻塞调用阻塞式IO接口

2360

那么怎么去调呢

2361

一不这个时候操作模式是一不了

2362

接口是阻塞的

2363

那怎么弄呢

2364

这个时候你必须干啥呀来

2365

一不就代表着

2366

代表折

2367

你把这个工作交给他

2368

交给他以后你可以放心的去干别的

2369

放心的干别的

2370

什么时候人这边儿事儿干完了

2371

过来告诉你

2372

过来告诉你干完了

2373

然后你把这个事儿放下之后

2374

你再去处理

2375

这这有点儿像

2376

这有点儿像什么

2377

给你配了个秘书

2378

给你配个秘书

2379

秘书干什么

2380

秘书负责帮着你去等结果

2381

秘书负责帮你去等结果

2382

你干什么

2383

你去干别的

2384

比如说你这个aa

2385

要去打文件

2386

然后呢

2387

把这个文件

2388

告诉告诉CC是他的秘书

2389

告诉C干什么

2390

把这个文件告让B去打印一下

2391

他打完了你告诉我

2392

然后这个B在打印的时候

2393

他就闷头打

2394

这个秘书也不问什么时候打完了

2395

把这个结果告诉CC再告诉AA

2396

那么a把这个活儿就相当于

2397

交给交给交给他们俩辣交给他们俩了

2398

让这个C去监督B

2399

B干完了

2400

C把结果给a na

2401

那么C怎么把结果给压回调回调

2402

那C去回掉a

2403

这个时候这这个模式是什么

2404

A就告诉C是吧

2405

A告诉他的秘书说

2406

你把这个文档交给B去打印

2407

他打印完了以后你告诉我

2408

你通知我通知a的时候

2409

这就是回调

2410

通过回调来通过回调来来通知

2411

那么他在没有回调的时候呢

2412

没有回调的时候

2413

A可以干别的

2414

可以喝点茶

2415

见见客户啥的

2416

那文件拿过来了

2417

他立刻就停止手头的活

2418

马上去马上去处理这个文件

2419

这叫异步阻塞

2420

那么这个异步阻塞这套这套IO模型在Linux思娜在Linux里边什么样呢

2421

在Linux里边儿

2422

异步模型在Linux里边儿要依赖一个

2423

系统调用

2424

哈哈

2425

依赖一个系统调用

2426

这个系统调用叫什么

2427

他的函

2428

这个函数名就叫select

2429

他叫select

2430

然后呢

2431

Select它去再颓掉你的那个程序

2432

这个select就相当于这个秘书

2433

那么这个模式

2434

异步阻塞模式

2435

它也相对简单

2436

也相对简单

2437

但是呢

2438

它有一个问题

2439

问题是什么

2440

它的它的那个并发量不大

2441

并发数的

2442

那你交给这个秘书

2443

一个活在交给他一个蜜

2444

一个活在交给一个活儿这个秘书

2445

他就一个人

2446

他能管的事儿

2447

她能管的事儿

2448

就那么几就那么点儿

2449

他的精力有限

2450

A select的这个秘书也一样

2451

他最他的默认

2452

它的默认并发数是多少个呢

2453

1024个

2454

Select默认能够帮你去管理的这个并发数是1.24个

2455

也就是说它能够帮你最多帮你去管1024个这个爱屋任务

2456

这他一不阻塞式模型适合做什么

2457

适合做这种小病发的

2458

这种小病发的这种IO任务

2459

做一个简单小服务器

2460

它它的那个上限

2461

他地上限不超过不超过1000

2462

这个时候呢

2463

这个时候用select

2464

那么高性能的

2465

高性能的怎么去用

2466

用一碰

2467

用这个e po模式

2468

这个一碰模式它是分层的

2469

这一套模式分层的

2470

他的所管理的并发数非常非常高

2471

可以可以达到上万实际上别看select的默认的那个病发

2472

默认的那个能够并发这个文件操作是1.24

2473

实际上他还到不了1.24

2474

他最多她最多维护1024个这个IOIO文件的这个文件句柄

2475

也就是说最多维护11024个任务

2476

但是他称

2477

但是他未必能够撑得住

2478

他的性他的性能未必能够保证

2479

而这个e po呢

2480

它可以它可以保证上万个并发

2481

而且性能能够保证

2482

因为一碰里边它是有缓存的

2483

而这个select里边它它它没有缓存

2484

它直接就是一个一个回调

2485

一个简单回调只要数据来了

2486

他就给你回掉

2487

这我的秘书

2488

他可不管你忙不忙

2489

只要回来

2490

他就他就给你回掉

2491

你要你这儿要特别忙的秘书

2492

他可能会把这个文件在暂时给存一会儿对吧

2493

这这这这这这就是那个缓存

2494

这就是缓存的那个概念

2495

这是异步阻塞

2496

异步阻塞那是和小病发的这个任务

2497

那么最后一种呢

2498

这是四种基本模型里边

2499

最后一种是异步非阻塞异步非阻塞

2500

那么异步非阻塞它

2501

是怎么回事儿呢

2502

他是多任务处理

2503

多任务处理怎么叫多任务处理

2504

专人办专事儿

2505

专人办专事

2506

怎么专人怎么专人办专事呢

2507

比如说那比如说我要读文件

2508

读文件的时候说把这个

2509

把这个文件

2510

交给专门读文件的那个那个进程或者是线程

2511

然后呢

2512

就等于把这个活交出去了之后

2513

他这个进程

2514

舅舅在这儿跑

2515

然后再有读文件的时候

2516

再交给另外一个人

2517

再交给另外一个人

2518

他再去打他他再去打文件你有比如说你有三份文件去打对吧

2519

你就交给三个人去打

2520

交给三个人

2521

这就相当于

2522

帅出

2523

三个进程

2524

这就相当于甩出三个进程

2525

而这个交代任务的这个人呢

2526

就相当于主进程

2527

他他就这么个玩法

2528

那这种玩法

2529

这种玩法那咱们

2530

他叫什么呢

2531

它有它还有一个名字

2532

还有一个名字

2533

这个名字叫AIO

2534

这个叫AIOAIO这个模式

2535

AIO这个模式

2536

如果说你学过Java

2537

学过Java

2538

在Java里边儿那个tomcat

2539

就是这个那个web服务器

2540

Java的那个服务器tomcat

2541

那个里边儿

2542

后来就加上哎呀好

2543

它它默认的

2544

它默认的就是模式就是AIO啊

2545

它里边有好多处理线程

2546

一个线程负责你一个请求

2547

他是这么个

2548

他是这么个模式

2549

后来汤姆开的这个这个模式

2550

就就这个觉觉得性能很低

2551

再做做个扎瓦Java后端的同学应该知道

2552

他们看的并发量是很低的

2553

对吧

2554

过去那个tomcat并发量是很低的

2555

尤其是TOMCAT5的时候

2556

为什么呢

2557

他又吃内存

2558

并发量又低

2559

就是因为它默认的就是这个ae I ou

2560

后来呢

2561

加了一个新机制

2562

叫NIO

2563

加了个NIO

2564

那个NIO就相当于那个世界循环

2565

它的这个性能一下就上来了

2566

那么咱们这个node JS啊

2567

Node JS那个世界循环就相当于这个NIO啊

2568

还有那个安奈克斯

2569

安吉next里边

2570

他用的也是这个事件循环机制

2571

同时呢

2572

还用了这个这个多任务

2573

它也是一种集群模式一个这个集群模式这么一个进程实例

2574

他的每一个进程实例里边儿

2575

它都有一个这个世界循环

2576

这这这样最大限度地去利用这个CPU

2577

这是异步非阻塞

2578

然后呢

2579

咱们接着

2580

这是四种

2581

这四种模式

2582

这四种模式是四种基本模式

2583

然后后边这个是select

2584

就是那个异步阻塞是

2585

异步阻塞式的这个这个更加这个更加详细的这个

2586

更加详细的这个描述

2587

这是select

2588

这个刚刚才刚才也给大家那个顺便一块讲了

2589

他的那个select最大的那个这个文件句柄数呢

2590

就是1.24个

2591

而且呢

2592

他的姓他他的那个开销挺大的

2593

他的那个性能开销挺大

2594

所以做做那个小小规模并发用select

2595

然后呢

2596

最终终极解决方案

2597

Linux里边的这个

2598

大并发IO

2599

终极解决方案就是一碰

2600

一炮方案这个一炮

2601

过去在Linux里边儿是要自己实现的

2602

后来呢

2603

把这个一碰

2604

把他给把这个模式放到了内核当中

2605

那么这个1PO它是分层的

2606

一碰是分层的

2607

那么这一块儿是这一块是内核

2608

这个一泡

2609

它在内核里面实现他这他这儿呢

2610

有有这个套接字

2611

还有什么定时器

2612

有这个处理进程有处理进程

2613

然后呢

2614

它这里边分了好多模块

2615

而这些模块各司其职各干各的

2616

然后呢

2617

有共同的缓存之后

2618

内核这一块儿

2619

通过这个一套API

2620

像你的程序来向你的程序来提供

2621

来提供那个来提供这个服务

2622

那么当大大规模并发的时候

2623

大规模并发的时候有数据来了

2624

在你的程序里边儿

2625

你可以给他发多个任务出去

2626

可以发多个任务出去

2627

那么这一块儿是一泡在你程序那儿要调的那个库

2628

要掉到那个库的那个实现

2629

更上边儿才是啥呀

2630

更上面才是你的程序

2631

那就相当于这一块儿是一剖的客户端儿

2632

这一块儿是1PO的服务端

2633

服务端这边他要要他和客户端这边

2634

它有自己的这么一套传输机制一套那个通这个通知的这个通知机制

2635

然后他

2636

告诉你的应用1PO告诉你的应用呢

2637

他怎么告诉你的应用呢

2638

它去触发你

2639

他去触发你两种触发模式

2640

一种是水平触发模式

2641

一种是边缘触发模式

2642

那么这这个先说水平触发模式

2643

水平触发模式它所支持的这个IO

2644

这个IO操作模式既支持阻塞式的

2645

也支持非阻塞式的

2646

他比较他比较灵活

2647

那么这种水平触发

2648

水平触发性能稍低

2649

性能稍差

2650

但是呢

2651

它能够解决大并发

2652

能够解决大并发的问题

2653

那么第二种模式就是边缘触发模式

2654

边缘触发模式只支持非阻塞的

2655

只支持非阻塞的

2656

那么这种模式

2657

他能够

2658

只要有所动作

2659

只要有所动作

2660

他就能够通知给你

2661

然后呢

2662

当你有了数据

2663

通知给你

2664

当你这个数据完了

2665

收完了

2666

再通知给你

2667

通知给你你没读对吧

2668

你没你没有把这个数数据读

2669

你没有去拿这个数据

2670

那那那好

2671

这个数据我就扔了

2672

我告诉你来拿

2673

你不拿

2674

那我这个数据我就给你扔掉了这是一种这个高高性能模式

2675

而那个水平触发模式呢

2676

就是告诉你

2677

告诉你来拿这个数据

2678

数据你不拿

2679

我就帮你存

2680

我我我就帮你

2681

那个我就帮你保存着

2682

然后不断的通知你来拿

2683

这是水平触发模式

2684

那么这两种触发模式

2685

一个比较

2686

一个一个可靠性高另外一个呢

2687

性能更高

2688

一个追求可靠性追求可靠性那你性能就会就会降低一些

2689

而你要这这个追求更高的这个性能呢

2690

你的可靠性就要降低

2691

因为你不来拿这个数据

2692

我会扔掉

2693

这是一碰的两种模式

2694

那么这个1PO和你的程序

2695

和你的程序进行数据交换的时候用什么呢

2696

用MAPP

2697

那用MAPP它是一种共享内存

2698

那共享内存的一种

2699

操作系统内核和你的那个和你的那个程序

2700

他都他都去操作这一块内存

2701

一块特殊的内存区域就不就不用那个函数的返回不用函数的这个返回值来来给你传数据了

2702

那种函数返回值传数据性能太低

2703

还不如告诉你这个时候就就就就用到什么辣

2704

用到信号了

2705

通知信号通知你数据来了

2706

你去拿对吧

2707

你不拿的话

2708

一小段时间

2709

我我给你消除掉

2710

我我心数据就给你覆盖掉了

2711

这个数据就没了

2712

这叫边缘触发模式

2713

那如果说

2714

这块共享内存它满了对吧

2715

它满了

2716

它满了以后你不来拿

2717

那怎么办

2718

他就塞不进东西去了塞不进东西去

2719

那后边的全都给后边的那个数据全都给堵在这儿了所以说它的性能就会稍差

2720

但是他可靠性高

2721

你数据一直在那儿

2722

我就我就不断通知你来拿a

2723

可靠性就高然后下一种呢

2724

就是IOCP模型

2725

IOCP模型他是谁的

2726

它是Windows的

2727

它是Windows的这个这个异步IO模型

2728

那Windows的异步IO模型

2729

我们看他这形成了一个环

2730

它形成了还这个玩意儿他

2731

咳

2732

这个玩意儿它不如这个模式

2733

他不如这个e po这个模式

2734

简单一po模式

2735

它是分层的

2736

咦

2737

破模式分层

2738

而这个IOCP模型呢

2739

它形成了个环儿

2740

这个LCP模型同时呢

2741

用到了Windows的一个设计思想

2742

就是组建这个组件思想

2743

实际上那个异步IO Windows里面异步IO他用的是一个IO组件

2744

给你提供一个IO的这个端口儿IO组件的端口

2745

你的程序

2746

像

2747

这个异步组件儿去发任务

2748

还有呢

2749

去向向他去向他去发任务

2750

像他发任务还有这个这个组件

2751

这个组件把这个任务交还给你

2752

走的是两条线路

2753

他走的是两条线路

2754

我们就可以看到他他他这是这是一个还你发任务走这个走这个线路

2755

他交还给你呢

2756

走这个线路

2757

走这个线路那就复杂了

2758

这个机制就复杂了

2759

但是呢

2760

他仍然是高校的嘻嘻

2761

仍然是高效的

2762

但是他也有问题

2763

对吧

2764

他也有好多问题那么这个问题呢

2765

这个问题他过于过于去看中这个稳定

2766

过于看重稳定性

2767

过过于看重稳定性

2768

它的这个性能就会稍差

2769

所以说那个很多那个大并发的这个大并发的这个服务

2770

大并发的服务

2771

比如说像这个游戏服务器对吧

2772

一般都用一破模型来解决

2773

一炮模型收到这个数据以后

2774

把这个数据放到队列里边

2775

然后一个一个处理

2776

哈哈哈

2777

还对

2778

还有聊天儿

2779

还有聊天服务器

2780

游戏服务器等等

2781

这些都是用都是用一剖的

2782

好

2783

最后呢

2784

就是这个lab

2785

这节课呢

2786

这节课呢

2787

咱们那个先

2788

咱们先那个

2789

简单的

2790

简单的看一下这个lab view

2791

然后下节课下节课下节课主要看代码

2792

一个是re viv代码

2793

一个是note JS代码

2794

还有一个VBA代码

2795

下下下节课主要看这三个代码

2796

这节课咱们先简单看简单的那个了解一下

2797

Lab是用C语言写的

2798

那么这个lab Le这个官网

2799

写的是极其的简洁简洁

2800

但是他不捡漏

2801

过去lab的官网是极其简陋

2802

她就是一个页面儿

2803

没有用任何CS修饰

2804

大家一看这是啥玩意儿

2805

这太丑了

2806

就有点儿像啥的

2807

有点儿像安吉尼克斯

2808

有点儿像安吉nice的这个官网

2809

X官网就这么简陋

2810

对吧

2811

X较简陋

2812

他他没有修饰线

2813

这个这个lab we呢

2814

这是简洁

2815

过去lab的官网和APP next官网这这个这个风格是一模一样的

2816

现在还现在还加了一个底图

2817

看上去还好看一点

2818

但是呢

2819

你继续往里去点

2820

你去看他的文档就就就那个就露馅儿了

2821

对吧

2822

他这个文档还稍微的稍微的有点儿修饰

2823

过去这个文档也是那个纯页面

2824

也是纯文本页面

2825

像这个人家经历就就在那个lab UV上

2826

人人家不去

2827

人家不整得那么花里胡哨的

2828

人家核心竞争力又不在这儿

2829

你像那个X

2830

我这就是web服务器对吧

2831

我这个页面儿就是n Gin X上搭出来的

2832

我不去做这个页面儿

2833

你要你要来

2834

你不是看我这花里胡哨的东西的

2835

你是用你是用我这个

2836

那你是用我这个我这个裤或者我这个软件的

2837

所以这些底层的东西

2838

一般都是很朴素的

2839

那么这个lab Le这个代码

2840

刚才刚才刚刚才给大家给大家比划了一下

2841

下节课咱们

2842

下节课咱们详细的看

2843

我那个在这儿呢

2844

那个代码在这呢

2845

Lab Le a在这里

2846

然后呢

2847

Lab是纯粹C语言写的呢

2848

而且它跨平台

2849

这里还有那个还给Android

2850

还有安卓的这个编译脚本

2851

还给安卓写的编译脚本

2852

就是林克斯的

2853

而且给这个Android的编译脚本还还分那个32位arm64位arm32位X8664位X86这这这这玩意儿

2854

他的那个代码就就就就这么点儿

2855

代码就这么点儿

2856

核心代码

2857

这这就是核心代码

2858

就这么几个文件

2859

然后这两个里边是什么

2860

封装的API

2861

一个是优尼格斯把API的封装

2862

一个是Windows的API封装

2863

她把这个操作系统层面上的这个特性封装成统一的接口

2864

然后给给这儿去用

2865

给这个地方去用

2866

那么他的那些函数

2867

它的那些功能在哪呢

2868

就就就在这儿呢

2869

这是这是导入库的时候

2870

导入点H怎么去

2871

为什么要导入点H

2872

下节课给大家讲

2873

下节课就要回到这个这个这个C语言这个代码层面上来然后咱们咱们要看

2874

教给大家怎么去看明白这个代码

2875

比如说咱们打开的代码里边儿一堆一堆的这个玩意儿

2876

乱乱乱糟糟的这么多警号

2877

这么多井号是吧

2878

还include什么什么

2879

然后后边这么多这个东西个这么多XX这这这是啥呀

2880

都是

2881

这都是查

2882

这叫红

2883

那个C语言的红

2884

然后里边什么开不的饭

2885

这这是啥呀

2886

对吧

2887

这是自定义类型

2888

这是结构体自定义类型

2889

然后后边儿这玩意儿boy的小括号星儿

2890

然后用小括号这啥呀函数指针

2891

这是函数指针

2892

下节课把这些东西

2893

包括结构体函数指针红等等

2894

都都都在给大家讲一讲

2895

然后然后呢

2896

就是那个哪去了

2897

在这儿

2898

然后就是加加的no de JS c加加的

2899

看一下C加加的代码C加加的代码

2900

比如说实现呢

2901

找个C

2902

比如说这个东西

2903

Quick哈

2904

这个玩意儿C加加的

2905

C加加的这个C加加的函数

2906

这这里边儿好多指针呢

2907

对吧

2908

还有那个类的实现

2909

类的类的定义

2910

类的定义得看头得看那个头文件了

2911

随便随便随便来一个吧

2912

比如说这个它的流

2913

它的流是怎么处理的

2914

这是那个基本输入对吧

2915

流的基本输入流

2916

这这监控号

2917

对吧

2918

监控号是什么

2919

梵行

2920

梵行

2921

那TS里面有饭行吗

2922

有

2923

对吧

2924

TS里面有饭行

2925

里面泛型是这么写的吗

2926

也差不多

2927

泛型又叫什么

2928

又叫模板类

2929

泛型又叫模板类

2930

就是那个ttemplate

2931

就是C加加的C加加特性

2932

好下节课呢

2933

就详细的去详细的去给大家

2934

去去给这个讲讲一下这个代码当中涉及到的这个这个语这个语法概念

2935

让大家能够看懂

2936

实际上让大家看懂这个代码

2937

不是看这个代码本身

2938

而是干什么

2939

去看这个代码的这个实现的思路

2940

你能你能看懂这个思路

2941

并不是说把代码看懂

2942

这一行干什么呢

2943

这一行又是干什么的

2944

不是这个

2945

而是让你把这个流程看懂

2946

他是怎么做的

2947

先干什么再干什么

2948

放到什么数据结构里这个数据结构它怎么操作

2949

看的是这个

2950

而不是说那个数据结构它是怎么实现的

2951

不是这个像比如说像那个微吧

2952

对吧

2953

像那个V8V8

2954

V8

2955

这个V8V8里边他的那个堆

2956

是吧

2957

他的那个heap

2958

咱咱咱简单看一眼

2959

他的那个堆

2960

在这儿微吧里边儿这个堆它是怎么实现的

2961

他是一个

2962

在这儿呢

2963

这是那个堆的那个那个涉及到堆的那些定义

2964

这个堆他她它定义了这么多东西

2965

然后这个堆里边儿

2966

堆实际上是个什么

2967

他是一个他的这个堆的实现

2968

是一个复合结构

2969

一个复合的数据结构

2970

一个大数组加上

2971

加上

2972

二叉树

2973

一个数组加二叉树

2974

这是他是这么实现的

2975

那下个阶段就要给大家讲数据结构了

2976

哈哈

2977

下个阶段讲数据结构

2978

讲完数据结构就能就就能看明白

2979

你看你看这这这玩意是个啥呀

2980

对吧

2981

实际上实际上是个是个大顶堆

2982

是个大顶堆

2983

行

2984

咱们这节课先讲到这儿

2985

下节课

2986

下节课先给大家讲一下那个V8引擎

2987

V8引擎的那个东西

2988

它的那个结构

2989

然后剩下的时间都是代码都都都是基于这个代码的

2990

好今天就先到这儿

2991

然后明天咱们继续

2992

咱们连着三天

2993

连着三天都是这个

2994

好了下课了

2995

先明天明天同一时间

