1

嗯

2

这一路上

3

走走停停

4

顺着少年漂流的痕迹

5

迈出车站的前一刻

6

竟有些犹豫

7

不禁笑着

8

近乡情怯仍无法避免

9

而长野的天依旧那么暖

10

风吹起了从前

11

从前初识这世间万般流连

12

看着天边似在眼前

13

也甘愿赴汤蹈火去走它一遍

14

如今走过这世间

15

万般流连

16

翻过岁月不同侧脸措不及防

17

闯入你的笑颜

18

我曾难自拔于世界之大

19

也成了一个汽车

20

梦话不得真假

21

不做挣扎

22

不惧笑话

23

我曾将青春翻涌成她

24

曾指尖弹出盛夏

25

心之所动

26

且就随缘去发

27

着

28

风吹雨打咯

29

短路

30

走走停停

31

有na几分的距离

32

不知抚摸的是故事还是段心情

33

也许期待的不过是时间问题

34

再次见到你

35

为了晨光里笑得很甜蜜

36

从前初识

37

这世间万般流连

38

看着天边死在眼前

39

也甘愿赴汤蹈火去走它一遍

40

如今走过这世间万般流连

41

翻过岁月不同侧脸

42

措不及防闯入你的笑颜

43

我曾难自拔于世界之大也沉溺的心中梦话

44

不做

45

真假

46

不做挣扎

47

不惧笑话

48

我曾将青春翻涌成她也从指尖弹出盛夏

49

心之所动

50

且就随缘去吧

51

晚风吹起遮白发

52

我凭回忆留下的

53

把你的眼中明暗交杂

54

一笑生花

55

暮色遮住你蹒跚的步伐

56

走进床头藏起的画

57

画中的你低着头说话

58

我让感叹于世界之大

59

也沉醉别的世界

60

话不想挣扎

61

不做挣扎

62

无悔笑话

63

我终将青春还给了他

64

从指尖弹出的盛夏

65

心之所动就随风

66

去爱你

67

爱着你

68

你还愿意吗

69

我们还是

70

我们还是08:05开始同学们

71

不对

72

02:05说错了

73

为啥子川菜中的钵钵鸡本来是串串

74

里面没有肌肉还叫钵钵鸡

75

对呀

76

所以不叫串串吗

77

不

78

他不一样

79

串串

80

你看你吃吃的是什么串串

81

有有那种冷锅串串

82

用冷锅串串

83

一般就叫做钵钵鸡

84

或者是有的串串

85

它是那个煮火锅煮的

86

拿那种就比较热

87

然后冷锅串串的话

88

饿死

89

里面没有肌肉

90

还叫钵钵鸡

91

你说这话

92

你觉得这个有点儿

93

好像是

94

可能是他们早期里面主要是肌肉

95

主要早期里面主要吃鸡肉吧

96

而且这个

97

而且这个一开始的话

98

他是走乐山乐山乐山那边的钵钵鸡特别有名

99

乐山的那个豆腐脑儿和乐山的钵钵鸡又便宜又便宜又好吃

100

应该从那边传过来的

101

就是船到成都的

102

因为成都的那个钵钵鸡本身没有乐山的那边好吃

103

一般打钵钵鸡的招牌都打的是乐山的钵钵鸡

104

要吃的话

105

那边就特别便宜

106

而且特别好吃

107

那边就有机子了

108

那边肌肉就比较多了

109

你可以可以

110

如果要去那个峨眉山

111

或者说是

112

乐山大佛那块儿

113

然后就可以

114

吃里面的饽饽鸡就比较好吃一些

115

对

116

但是其实如果要去峨眉山

117

请注意

118

一定要小心当地的猴子

119

峨眉山的猴子特别的凶残

120

就是你

121

你有什么东西都可能被猴子给抢了

122

那边的猴子太厉害了

123

一东西一塞

124

歌

125

歌词这歌

126

这

127

这个叫大山和日本的

128

猴子会打人

129

不

130

猴子一般情况下只会抢东西

131

一般情况下

132

他

133

比如你买点儿什么

134

他可能会抢你的包

135

如果你买点儿什么排骨钱

136

你问他们为他们的话

137

他可能直接就从你的手中抢走

138

如果要

139

如果你带孩子去乐山

140

就一定要小心

141

因为之前有一个新闻

142

一个新闻是啥

143

楼上有一个猴子打一个小孩

144

一个小男孩

145

那个小男孩

146

那个小男孩是躺在那个婴儿车上的

147

然后我被他的猴子把那个小儿的蛋给偷了

148

特别凶残

149

一定要小心

150

对

151

我去过一次

152

真真的

153

特别是看小女小女生一个人

154

小女生猴子根本就不怕

155

就算

156

and

157

nano

158

不知道有没有把他自己了

159

反正

160

反正你们要去了

161

要去那个峨眉山的话

162

小心地

163

他们在那儿的猴子是最凶残

164

的

165

对

166

是的

167

就是因为有峨眉山的保护吗

168

保护区特别肆无忌惮

169

也在所拔的都拔孤单女生

170

身上有啥好地方玩儿的

171

挺多的

172

去九寨沟

173

你可以去一下

174

九寨沟

175

的风景非常美

176

还有像

177

康定

178

康定那边也挺漂亮的

179

还有一些像单就是四川

180

还有一些少数民族聚集的地方

181

就是贪婪

182

贪婪部分的话可以去

183

就是我刚说的康定有个叫做康定那边有海螺沟

184

然后还有毕棚沟

185

然后这些都特别漂亮

186

还有500

187

就是五千米以上的雪山

188

四川也有几座

189

牙齿

190

咋被坑了

191

收了多少钱

192

四川川南的赞助还是挺多的

193

因为苍南有一条街赞助的通道嘛

194

对吧

195

那你们大渡河也在那边

196

我还没遇到过呢

197

我还没遇到

198

一条鱼

199

800

200

这有点坑

201

不过四川重点推荐的话

202

可以去

203

可以去一下那个什么九寨沟

204

九寨沟还是真的特别漂亮

205

这一生至少要去约去了

206

九寨沟

207

而且很有名

208

时间到了

209

为什么不能使用

210

呆着强吧

211

明天明天讲那个

212

他不能够直接使用

213

明天讲顾客好

214

时间差不多到了

215

我们今天接着昨天的

216

今天接着昨天的讲

217

昨天啊

218

不是前天讲

219

前天我们对是我

220

同学们大家好

221

今天我们就时间到了

222

我们就先不等了

223

先不等了

224

同学们来的也有27个了

225

我们就先讲着走

226

其他同学的话没来的可能后面就直接看回放

227

前面的可以看回放

228

之前那一节课我们讲了

229

就是react时期的三个大部分中的一个

230

就是调度器

231

它可以控制是什么

232

它控制的是

233

哪一个

234

更新的就是哪一次更新

235

哪一次开始的更新可以优先进入到接下来的流程

236

接下来的流程指的就是会在进行一项创建fiber

237

创建fiber

238

然后dif

239

最后把它渲染到页面上

240

然后今天的话

241

我们就主要就讲这三大部分的另外两块儿

242

一个就是它的名字叫做re consider

243

也可以称为中文可以称为协调器

244

另外部分可以称为他叫做render阶段或者

245

com的阶段都可以

246

这都都都可以这么叫

247

但是它并不是我们函数

248

我们那个class函数的那个render函数

249

并不是

250

并不是你可以理解为它的作用就是把他电话组建渲染到页面上

251

就是真正的渲染到DOM上了

252

这个只是它的一个称呼

253

有人称他render阶段

254

也能称为commit阶段

255

都可以

256

都可以

257

因为它既包含

258

它主要包含两个部分

259

一个叫做render root

260

一个叫做commit root

261

所以所以有的就这么称呼她

262

反正大概就是这样

263

今天我们就介绍协调器re consider

264

它的主要作用

265

我们还是用一句话就可以先说明它的主要作用是什么

266

他负责构建February

267

就是前面我们讲了一节课

268

其实啊

269

他还根本还没有走到构建Patrick的这么一个阶段儿

270

我之前已经讲过

271

就是在RA clip它是有一个

272

相当于是有一个虚拟

273

虚拟数的

274

就是我们所通俗说的

275

像那种微催账

276

对吧

277

VV当就是虚拟数

278

就是虚拟down

279

那么在record里

280

F16之后的微创就指的就是February February了

281

那么他在这个阶段

282

Re consider

283

他就负责构建fever tree

284

然后呢

285

把变化的组件给找出来

286

然后把组件是什么变化给标记上

287

这句话什么意思呢

288

比如说比如我下面这个图

289

我只有刺探变了

290

对吧

291

我们会有

292

我在X这个阶段不仅要把这个数给构建好

293

而且还要找到

294

具体是哪个元素

295

具体哪个组件哪个节点发生了变化

296

然后呢

297

他可能是被删掉它

298

也可能是改了属性它也可能是增加了子节点

299

那么这三种就分别是不同的处理逻辑

300

那么在这里

301

但是这三种处理逻辑都适合当操作有关的

302

而不所以而在re consider这个阶段的话

303

他还

304

不会操作大

305

因此他只能先给他打上一个标记

306

标记他比如说标记假如他是个删除

307

把这个数量给删了

308

那么我就把他的一个叫做flex的字段

309

把它设为删除设为删除

310

然后到最后render阶段的时候

311

在这个阶段

312

我们只需要遍历

313

所有的遍历所有更改的

314

所以更改的翻版note了

315

更改的word找到它的那个flex

316

然后啊

317

比如说flex删除

318

那我们就直接执行删除的逻辑

319

而不用再判断一次

320

因此相当于不需现在在re consider这里面做的事情就很多

321

就很多

322

他之所以多的话

323

实际实际上是本来把把正常流程后面render就是render阶段要干的事情先提前干干好了

324

但干好了之后

325

他只是先把他存在那儿

326

后面在用

327

所以他re consider这个阶段

328

他要干的事情比较多

329

要更新比较多

330

我们可以

331

因此它主要来说他就

332

他就可以用一句话来解释复购件发票去找变化的组件

333

标记组件的变化

334

在这个阶段的话

335

在这个阶段的话

336

我们的

337

我们的

338

我们的那个生命周期

339

是会执行一部分的

340

会执行一部分的生命周期

341

具体来说是执行render

342

即render之前就render生命周期

343

以及render之前的生命周期都会执行

344

都会执行到

345

而这个consider这个阶段

346

由于

347

由于他

348

因为由于我们之前讲过react

349

优先级高的会打洞

350

优先级低的

351

所以这个re cons or也会可能会反复执行

352

可能会反复执行

353

所以react它里边有一些生命周期

354

被他给标上了一个UN safe

355

就是因为可能他这个生命周期执行的次数会比以前更多

356

会比以前更多

357

所以加了个UN safe

358

而像render之后的生命周期就没有S了

359

因为后面就不会再就不会再那个反复的被打断了

360

原因很简单

361

因为render render过程其实最主要的是干什么

362

最主要的是

363

把那个变化的组件给渲染到页面上了

364

这个时候要操作down了

365

ER down是很昂贵的

366

如果我在我本来已经要开始操作DOM的时候

367

然后你还能把我给打断了

368

就是优先机构还能把我打断了

369

这其实是得不偿失的

370

因为本来我只需要一次操作档

371

然后就把它全部给渲染到页面上

372

但是由于由于我这个优化

373

如果我的优化就是这个高优先级达成的

374

优先级的这个优化反而让

375

让那个操作当也变成多次的话

376

那么我们的一次操作就变成了多次

377

操作上而操作但又非常的昂贵

378

所以昂贵的意思就是他耗时比较耗时比较久嘛

379

我们一个DOM节点

380

大家可以看

381

比如一个div节点

382

它有N多的属性

383

属性超级多

384

属性超级多

385

这么多的属性

386

如果您

387

还多次的进行调动

388

调动的话

389

很多次进行调研的话

390

那么它的性能肯定会比以前更差

391

就变成了一个负向的优化

392

所以他的逻辑

393

那么他就只能允许你的re consider就是自然

394

坐着这一件事情的过程当中

395

允许被搭讪

396

后面的就不允许了

397

就不允许

398

我们来看一下它的就是大概他是这么

399

做这样一件事情

400

但是具体做了他其实做了蛮多事情的

401

我们可以一起来看一下

402

首先我们来看一下

403

我们直接来看一下一个已经构建好的一个faculty长的样子还是之前那副图

404

还是之前那个做咱们这样

405

每一次rag发生一次更新的时候

406

比如像write down

407

典

408

Render或者sit EST

409

它都会从

410

February开始从上往下便利

411

就是一开始他只只有一个节点

412

从上往下遍历

413

逐一找到变化的节点

414

然后构成一个完整的entry

415

如果

416

如果之前没有

417

如果没有变

418

就是如果之前从来没有生成过

419

那他就逐一生成节点

420

然后呢

421

构成一个完整的发票退

422

而在rock的内部

423

他有可能会同时存在两个发票

424

同时存在两颗发布会

425

这就是要用到我们上节课所讲到的那个范儿

426

Note的一个属性

427

我们可以回顾一下

428

回顾一下这个就是反而我们的每一个filed

429

每一个filed我们讲了

430

他也retired child spring这些节点来构成February

431

但他实际上和发包

432

连接有关的还有另外一个属性

433

叫做outlet

434

这个outlet它是指向上一次构建的镜像

435

三四个渐渐

436

什么意思呢

437

我们来

438

我们来看一下上一次构建镜像

439

比如说

440

第一次就是我从来没有的

441

从来没有过见过FAB的时候

442

那么它有一个feb ru na的这个就是FAB root吗

443

FAB的一个节点

444

然后他一个current

445

指向的是我们的root

446

然后APP0

447

这就是一开始

448

但我们只是write down

449

Crack down的时候

450

我画一个图

451

画一个草图

452

就是一开始热点render的时候

453

那么在整个内存当中

454

它所存在的数就是这样的一个

455

就是这样的一个数

456

嗯

457

就这样一个假如

458

假如啊

459

整个内存当中这个是root

460

这个root not那么

461

他一个carry的数

462

一个CAD的字段

463

它就直线了

464

这样一个

465

当这个税构成构建完成了之后

466

那么我们的页面也就终于渲染出东西了

467

对吧

468

因为它我们的这个内部的REC的内部的

469

因为它是数据驱动视图吗

470

我们的内部的是什么样子

471

他最后映射到页面上就会是一个什么样子

472

当这个QQ的完全建立好之后

473

然后再把它下载到页面上

474

那么我们的页面就有东西了

475

那么第二次进行C的

476

C的之后

477

同学们第二次进CF之后

478

他这现在这个情况

479

他们的每一个的outlet

480

因为没有上一次的镜像吗

481

没有他的每一个节点的outlet

482

它都是什么呢

483

都是那肯定都是那

484

因为这里头它的学名就是她的意思就是指向上一次的相同的那个节点

485

先就是我第一次

486

那么他肯定是就是

487

那假如第二次构建的时候

488

什么是构建

489

比如选C的CTE

490

则C的他又会从头开始

491

就从头开始

492

比如这里有一个root

493

但是他的outlet属性它就有

494

它就会直线上一次的

495

就这样一次的

496

然后呢

497

他的每一个

498

每一个结点它都会有一个out的属性

499

而每一个out的属性它都会对应上一次

500

上一次相同位置的那样的一个节点

501

它都是属于对应的关系

502

因此就就如同这幅图所示

503

在第二次的时候

504

这是第一次

505

第一次构建好了就构建好

506

这个比较简单然后呢

507

第二次有的时候那么

508

那么他的重新重新生成了一个新的发票退

509

那么在内部就把它称之为叫做working progress working progress tree

510

而这个working progress tree字面意思怎么样呢

511

字面意思就是我要先新建一个新的APP

512

对不对

513

新建一个新的Patrick

514

而现在页面上

515

由于我们的这个

516

在这幅图中

517

由于我们的filed

518

他的carry还指向先前那一个

519

所以我们页面上现在还没有做任何的改变

520

还没有做任何的改变

521

那什么时候会改变呢

522

就是当他这个

523

当你的心的发票去完全构建成功之后呢

524

它的它就会把这个care这个字段指向新的Patrick

525

就是指向新的working progress tree

526

就相当于一个什么备胎转正的一个感觉

527

我构建了一个新的

528

新了之后

529

他

530

他叫working progress tree

531

然后我就把我的feb ru Donald

532

The current字段指向了新的working progress tree

533

然后我的新的work in progress是不是就变成了他就变成了carry了耳

534

旧的这个相当于就不要了

535

自动就不要了

536

而如果也有新的

537

假如

538

假如在这里

539

假如这假如有了的

540

我又发现了另一次新的更新

541

对吧

542

假如发起一次更新的更新

543

那么对他来说

544

他的上一次的character就是他

545

而他又是一个新的

546

又是一个新的working progress tree组件的又构建

547

等他构建好了之后

548

构建好了之后

549

然后呢

550

他的carry a又在直线打

551

在之前打

552

让他老了

553

然后又给丢弃了

554

又给丢弃了

555

是这么一个过程

556

而他的奥特利的属性是之前上一个

557

可以直接上一个

558

上一个吧

559

相互只只只只

560

这样有个什么好处呢

561

这样一个最大的一个好处是

562

对

563

是的

564

始终保持的是上一次的forever nod

565

他虽然他是一个working book ST

566

但是它实际上节点与节点之间是相互指的

567

相互的并不是

568

并不是说只有在跟

569

就是范儿

570

Roots roots favor

571

这一个节点指向他的outlet

572

指向上一上一个

573

这样的好处

574

好处是显而易见的

575

就是非常的方便对比

576

比如说我我我一个非常就是深的一个节点

577

对吧

578

非常深的一个节点

579

我这个节点

580

就是他吧

581

非常深的一个节点

582

他很深

583

那么啊

584

他只需要他的一个out的属性

585

就可以

586

只要通过他奥特的属性

587

就可以立刻拿到他上一他上一次的那个老的节点

588

上次那个老师几点

589

就可以立刻拿到它

590

对于新的来说

591

大家看这里是相互指的

592

新的那就是旧的

593

他的out是指向新的

594

新的out是之前旧的

595

它有一个复制的过程

596

为什么这样做呢

597

因为有的时候

598

因为在那个当dif的时候

599

他有的时候

600

他要用旧的来做主题来比较

601

有的会用旧的来做主题进行比较

602

有的时候会用新的主题来进行比较

603

所以他两个

604

所以他在进行纸箱的时候

605

他干脆给他进行一个相互的指

606

他们都可以

607

拿到对方如果没有的话

608

那就没有

609

是这样

610

那为什么是双缓存结构呢

611

这就是内部REC的内部的一个双缓存结构

612

所以双缓存结构就是有有两个数

613

大家记住有两个队

614

两个队一个叫做current

615

这个current她永远永远和咱们屏幕上显示的内容是对应的

616

它是咱屏幕上显示的内容的一次真正的映射

617

比如我

618

比如我就算发起了一次CS的

619

那么在屏幕变化之前

620

那么他的carry就还是老

621

还是老的那一个

622

而working progress that re work in progress the

623

它就是

624

要创建一个就是我们我们要更新的新的一个February

625

新的一个开发区

626

他们都是通过Outlook的属性连接

627

而他的优点就是可以

628

可以快速的拿到之前的节点进行对比进行复用

629

甚至直接可以进行服用

630

如果那个节点他对比了一下

631

发现

632

我没有任何的变化

633

那么我就直接复用了这个

634

所以这个是为了一个是为了找起来快

635

第二个是为了服用

636

第二个是为了服用对于性能的提升还是非常有帮助的

637

而类似这种在函数里边儿

638

在介词里面

639

类似这种刷卡的结构还有很多

640

还有很多

641

如果大家

642

有看过那个careless careless

643

careless就是canvas里面一个非常重要的一个优化

644

叫做礼品凯尔斯

645

这是礼品

646

凯尔斯

647

我一看到这个working progress的时候

648

就立刻想到了这个礼品卡

649

它就是差不多

650

他其实差不多就是在

651

礼品开发商渲染相似的图形和重复的图像

652

如果

653

自己在动画帧的重复一些相同的会操作

654

可以把它放在礼品卡时尚

655

大家下来

656

如果以后有那个喝canvas相关的

657

这个我就不多讲了

658

如果和callous有关的觉得很慢

659

你可以考虑用一下礼品careless

660

它有一个叫做off screen

661

以前是直接相当于用一个

662

最早的时候叫做礼品careless

663

是你是创建一个看不见的careless

664

然后呢把它来做

665

那现在其实就直接就有一个叫做off off screen canvas这么一个方法可以拿来用

666

这也是对于carry来说一个非常重要的一个优化点

667

ER RA tic实际上它内部相当于就实现了一个礼品的

668

你另外一个数

669

所以叫做

670

这就是它的上层结构

671

是非常就是是整个

672

嗯

673

整个就是开发使上

674

反正是一个比较重要的一个优化

675

一个优化的东西

676

它这个还是挺有作用的

677

挺重要的

678

这块能听明白吗

679

能听明白的可以各一

680

不能拼爹听明白的扣个呢

681

好滴行

682

为什么双方的结构

683

这个也给大家讲到了

684

就是可以很快的找到

685

对吧

686

可以直接服用

687

然后更新完成之后

688

我们的current会指向working progress root完成federal trade

689

这个平行OB就变成新的February

690

这个我们到时候看那个代码分析的时候

691

我会给大家讲到它这个更新完毕

692

它实际上是在那个component的mount那个差不多那个阶段的时候

693

他才会重新制

694

每次C都会从底部重新开始遍历吗

695

是的

696

这就是react

697

我个人觉得他其实没有那么智能

698

他没那么智能

699

他每他每一次他都要从根组件开始重新建立

700

重新便利

701

而不像那个VIVO

702

它是它的那个依赖收集

703

其实可以做到效率更高

704

VIVO的那个依赖设计

705

其实效率会比这个更高

706

但是他们的发展方向不太一样

707

发展方向不太一样

708

所以react他后面他的

709

更新迭代你就会发现它全部都点到哪里去了

710

他的逻辑全部都把它的优化方向主要是进行运行时的进行

711

主要是进行运行时的优化

712

就是运行的过程当中进行优化

713

React因为react他也他也有运气这句话

714

然后它有一部分呢

715

是放在编译前

716

就是因为它它的那个MP的

717

V1的MP的

718

他有的是静态的

719

那么

720

她在编译阶段就会做一些编译方面的优化

721

所以react和Vue他们现在其实从内部的代码角度上来讲

722

他们的发展方向的话已经不太一样

723

不太一样

724

React现在就是运行

725

是运行时的巅峰

726

比如说像什么双缓冲结构

727

之前还有

728

之前还有那个

729

之前还有那个request idle call back等等

730

他们主要是在运行的过程当中

731

他想办法让你更快

732

可以更快

733

但是由于它设计上的

734

你可以说设计上的

735

他每次都从底部重新开始

736

那么这个其实就保证不了

737

他可能就真的没有没有那么快

738

但是她也有自己的优势

739

就是在运行时

740

他就是他就是非常快的

741

他就非常快

742

对

743

那么

744

Correct

745

那就这样

746

所以所以他的这这这点我其实之前也不太能理解

747

也不太能理解

748

但是呢

749

但是他确实很有用

750

后面我会讲到它这个re consider啊

751

他这个re consider其实不光不光react可以使用它

752

可以把它单拎出来

753

然后你在其他地方也可以用

754

也可以用

755

比如说像什么呢

756

比如像什么Tara

757

大家听过吧

758

Tara

759

就是用rap来写小程序

760

用right来写小程序

761

Tara用rap的一些小程序

762

它里边其实

763

它里边其实就是把这个re consider单独剥离出来

764

单独剥离出来直接就拿来用了

765

不然呢

766

然后这里边所做的所有的优化

767

它都可以移植到他的框架里

768

他都可以移植到他的框架里

769

那么相当于

770

Rap的部分

771

这一部分运行时优化的能力

772

他就直接他就直接使用上了

773

呆会儿接下来我给大家给大家提一嘴

774

给大家提一嘴这块儿就是他的优势

775

它的优势来看

776

那接下来我们来看一下那个

777

构建fair trade这么一个整个过程了

778

比如说

779

比如说我这里render的时候

780

我弄了一个简单的

781

就这个的

782

我们一般都这么写吗

783

对不对

784

但是你也可以写的很复杂的字

785

弄的比较简单

786

那么在构建发票催的时候

787

他会从

788

Render road sync

789

大致是从render think还是开始

790

从优先级最高的root开始的贵

791

优先级最高的三个肉的开始地位就是从头开始往下走

792

从头开始往下走

793

那么这我们可以就这种代码我是重点分析的

794

大家先看我打了黄色标记的这几行代码

795

先给我打了黄色标记的讲

796

这讲代码

797

第一个首先是一个函数

798

这个函数里是一个递归

799

对不对

800

是一个递归

801

这个while while里有一个字段叫做working progress

802

这个先给大家

803

这个working progress节点

804

我们刚才给大家已经说过了

805

什么事working progress节点

806

这个working progress or working progress working progress fiber刚给大家介绍这个呢

807

它指的是working progress节点

808

他指的是

809

Working progress

810

几点

811

姐姐

812

她什么意思呢

813

他表示

814

当前正在

815

构建的哪一个

816

Favor他只是当前正在构建的ever

817

它是会变的

818

它是会变的

819

因此这儿有一个这个Y

820

这它它不是只属于这个函数类的

821

所以它相对于这个函数来讲

822

它是全区的

823

它是全局的

824

几个他几个那个函数可以共用

825

他实际上是在那个文件里的一个B包

826

因此

827

当这段话的意思就很简单了

828

当working process不等于浪的时候

829

那么就一直掉problem上teamwork

830

而在performance until work里

831

我们的working progress

832

它的指向会发生变化

833

这个我们下来马上会讲到

834

这个performance until work就在这里

835

然后这里对吧

836

我们用到了outlet

837

因为这个until work它实际上就指的是working progress吗

838

Check out let是不是指向我们的current current current就是当前页面上

839

就是当前页面上页面所对应的那个LV的其中的一个节点

840

就是那个节点

841

凯特找到了

842

他可能会用到它

843

可能会用到它

844

然后在这里它会做什么呢

845

首先掉了两方法

846

其实它主要就是调了两个方法

847

一个叫做begin work

848

另外一个叫做completed on tear of work这两个方法

849

而在我先他这里面做了很多事情

850

我先

851

大致的告诉大家

852

他这实际上返回的这个next指向的是她的俏的

853

待会我们会详细的详细的讲

854

不用着急

855

不用着急

856

我们你可以先按照老师的思路来走

857

他调这个begin work里

858

它会返回的是什么呢

859

返回的是until work下面的child

860

然后呢

861

发我一个next

862

而这个next如果为那个next

863

如果为none

864

那么就执行complete after work

865

如果这个next不为浪

866

那么就把这个next复制给working progress啊

867

那么这样我大概就懂他的意思了

868

他的意思是这样的

869

大家看它的意思是这样的

870

我这样一个pap a tree

871

我这样一个happy我

872

我这样一个ipad

873

因为我有个循环吗

874

我首先我有个working working progress的字段

875

我第一次肯定是指向他的发了root

876

对不对

877

然后呢

878

我当我进入到这个performance until work里执行了begin work

879

那么由于

880

由于begin work会返回我们这个节

881

Working process这个节点的纸

882

子节点对吧

883

有人返回它的子节点

884

就是他翘的嘛

885

他有三个属性是child submit return

886

构成federal trade这三个重要的节点

887

这构成发布这个节点重要的三个属性

888

就是这三个ER child就指它的子节点

889

那么working progress

890

当第一轮轮询就是第一轮

891

就是第一轮那个循环

892

那么之后

893

就到了这里

894

那如果那个存在就是存在

895

直接点就是跳的存在

896

那么

897

Work in progress就等于他的直接点

898

那么第三轮循环之后

899

它就会指向他的新的节点

900

一直执行

901

一直执行

902

一第四轮就指向心里直点

903

直到什么呢

904

直到他没有任何的直接点了

905

直到没有任何的直接点了

906

它才会执行

907

这个叫做complete down to our work的

908

也就是说假如我们是这样的一个结构

909

那么再把内轮循环执行完毕之后

910

大概走到这个地方为止

911

当她走到这个逻辑分支的时候

912

我们

913

这个节点

914

这个节点

915

这个节点的这个节点

916

这四个发展节点都已经创建好了

917

都已经商量好了

918

这个时候有同学可能就发生疑问了

919

老师

920

发不出一两个就建好了吗

921

我们现在我们现在只

922

只看到他的第一个子节点市场就好了

923

但是他不是还有设备吗

924

他不是还有我们一个

925

我们一个含税

926

可能会经常出现并列的

927

对吧

928

他还有他还有他的兄弟节点

929

而这些兄弟节点却通通没有处理

930

接下来不要着急

931

他的兄弟节点呢

932

其实就在这个complete until work里

933

我们接下来先直接看complete until work谈

934

他和February构建主要的部分的逻辑是什么

935

Complained on their work

936

我们看在这个地方

937

大家看他又来了一个新的循环

938

大家看到了一个豆一个

939

一个well

940

不过这一次他外的是叫做complete walk to complete work是什么呢

941

这个complete work

942

A complete work

943

就是当

944

当我们找到我们找到最下面的时候

945

是不是这个child就是working progress就等于烂了

946

等于烂了之后

947

他就把这个

948

这个节点付了一个新的新的变量

949

叫做complete work

950

就这个最底下的这个点

951

附了一个新的变量

952

叫做computer work

953

然后大家看这是比较重要的

954

然后他找到了complete works点

955

说不定现在开始处理他的兄弟节点了

956

兄弟节点有

957

如果有

958

大家看

959

如果有兄弟节点他干了一件什么事情

960

他又把兄弟节点付给了working progress

961

She work in progress

962

现在只想他了

963

只见他

964

假如他还有直接点

965

那么还是按照上面的那一层行o king progress又会继续

966

网址节点下面去指他这个return呢

967

实际上是把这个这一轮这一轮循环给return掉了

968

如果他的说不定还有直接点

969

那么就继续还是按上面的那个流程

970

一级一级的撬的撬掉

971

撬点撬点

972

撬的一直往下找

973

直到又找到没有了

974

那么他又看他有没有

975

他又会进入到这个complete a work

976

又看他有没有split

977

如果没有了

978

我们刚刚讲的是有的情况对不对

979

如果没有了

980

好他的逻辑是返回父节点

981

返回节点我们还是回到刚刚这个

982

假如他没有直接点

983

那么它就返回父节点

984

返回了父节点

985

那么他就直会执行这一层循环

986

那么它又会长

987

这个complete work就等于他了

988

那么他就找这个complete work有没有

989

有没有兄弟节点

990

如果没有兄弟几点

991

她就找她

992

她有没有兄弟节点

993

那么我我重新给大家发一复数

994

所以这个节点甚至顺序是怎样的呢

995

这个节点生成的顺序就是他是第一个

996

对不对

997

他第一个他是第二个

998

他是第三个

999

他是第四个

1000

注意看我这两个兄弟节点

1001

我这上面这两个节点它都是有设定的

1002

然后这是第五个

1003

然后呢

1004

第六个

1005

是

1006

他的spring

1007

然后他说不定大家看他是怎么循环

1008

是他是怎么构建web的

1009

他首先是从上往下

1010

立刻从上往下找了一轮

1011

对不对

1012

从上往下找了一轮

1013

然后等找到最底层的时候

1014

等找到最底层的时候

1015

他然后他再由下往上

1016

然后

1017

再来一次

1018

这两次合并构成了一个完整的family tree

1019

这样大家能理解吗

1020

能理解的话

1021

扣个一

1022

不能里解扣一个零

1023

这其实其实是一个深度优先遍历

1024

是一个深度优先遍历

1025

关键代码其实就在那里

1026

就在我

1027

我打上标记的

1028

这我打上

1029

标记了这几行

1030

我打上标记的就是构建发票

1031

这一次打那个最强

1032

那有同学可能非常有疑问

1033

就是那为什么要从上网就要来一次从上往下

1034

再来一次从下往上的这样的两个查找

1035

后面我给大家解释

1036

解释他这样的做的好处

1037

这个好处是什么

1038

总之

1039

我们的faculty实际上就通过

1040

我们的发票就通过这样的以上一下一上

1041

这样的两次构建

1042

我们的family tree就构建完毕了

1043

但是我们可不仅仅只是构建web翠这么简单的

1044

就在在这个re cons ter这个阶段

1045

可不仅仅是构建web这个这么简单

1046

接下来我们要来看他这两大函数

1047

他这他这两大函数我刚刚讲了

1048

这个在performance until work里有两大函数

1049

第二个叫做begin work

1050

第二个是complete on till work

1051

这两个所做的事情可不是那么简单的

1052

我们接下来就要来详细的讲一讲这个begin work里其实在REC的

1053

这个re consider里面它是一个非常关键的一个点

1054

非常关键的一个点

1055

因为他在里面会

1056

因为创建favor TE

1057

就相当于是通过begin work创建

1058

不管是哪一个节点

1059

它都是通过beginner创建

1060

所以他做的事情有这么几件

1061

大概有这么几件

1062

第一

1063

那肯定就是创建和付付或者复用fiber节点写错了

1064

第一

1065

肯定就是创建或者复用fer ti Li

1066

第二点它就是对比节点是否需要更新

1067

看一下节点是不是需要更新

1068

如果节点需要更新的话

1069

那么就会给他打上一个标记

1070

这个刚刚也讲到了

1071

为什么需要给他打成标记

1072

而不是直接就执行的原因

1073

因为我们节点这个内部

1074

它内部的这个微大事

1075

维持节点就是虚拟节点

1076

因为是在是在begin work里创建的吗

1077

这个也跟大家讲了

1078

为什么只打上一个标记

1079

而不是立即立即更新档的原因

1080

然后呢

1081

返回直接点

1082

返回返回直接点就是就是这一行

1083

就是这行代码

1084

就这是为了构建fever tree所必不可少的

1085

根据IP这个大逻辑必不可少的

1086

最后

1087

在begin work里

1088

它会执行扔到生命周期之前的所有生命周期

1089

加上人的身份证七

1090

这其实有一个

1091

有一个比较关键的面试题

1092

这是一个面试题

1093

如果说

1094

我们

1095

就是比较right的节点

1096

它的它的那个生命周期的执行

1097

生命周期的执行

1098

经常有这样的情况

1099

比如说人走之前生命周期的执行

1100

如果给你一个具体的具体的例子

1101

那么你可能需要结合这张图

1102

如果你想

1103

比较完美的回答

1104

有可能你需要结合这张图才能够完成的完整的把它回答出来

1105

因为为啥呢

1106

因为

1107

因为有个比较关键的点是它的这个父节点

1108

就是子节点和子节点下一个spring节点

1109

他们的这个执行顺序是不一样的

1110

对不对

1111

是不一样的

1112

复线执行

1113

直接点接着执行

1114

然后又会执行直接点

1115

直接点

1116

最后才会执行兄弟节点

1117

兄弟节点他执行的时候

1118

那么当然他才会构建法治

1119

所以如果说比如这四个节点中对这四个节点中

1120

他并不如果说让你让你回答render之前的生命周期

1121

比如就是render

1122

哪个render现执行

1123

两分钟后执行

1124

那就是12341234

1125

但是我们平常可能就是感觉上

1126

可能会感觉成1243对不对

1127

可能会这么这么感觉

1128

就是先把这一层全执行完了

1129

再执行下一个

1130

实际上不是

1131

现在不是要小心

1132

你得你得想

1133

你得你得在想象中

1134

或者在那个纸上

1135

你可以把

1136

那个例子就是面试官给你的那道题

1137

具体是哪几个发表

1138

你可以把它大概的发表所画一画

1139

然后呢

1140

按照老师刚刚讲的顺序这样子

1141

这样子

1142

假如他还有的话

1143

那就是这样子

1144

嗯

1145

这样子

1146

这样子

1147

这个顺序的话有一点就是还是有一点那个迷惑性的

1148

附逐渐带动

1149

紫竹院刷新的顺序

1150

也是1234值带动植组建沙县的顺序

1151

其实就是render的顺序吗

1152

对吧

1153

接着点顺序

1154

She不定有直接点

1155

说不定有直接点

1156

刚刚讲到了

1157

说不定有子节点的话

1158

那么他

1159

那么在

1160

在这里

1161

萨林有自己店

1162

但是一般也不会出的这么难

1163

如果是不令

1164

有sub令

1165

那么就把sub另付给了working progress对不对

1166

那么他就继续走walk in progress的逻辑了

1167

Seven有子节点

1168

那么现在working progress就只抢了他

1169

那么

1170

如果Sabrina直接点

1171

那个working process就指向继续指向Sabrina直接点

1172

如果没有了

1173

他才会反馈回来

1174

然后再往上走

1175

能理解吗

1176

也就是说

1177

如果说这儿说不定一个直接点

1178

那就是一

1179

这是123

1180

四

1181

五

1182

六

1183

这就变成六了

1184

他四接下来就是五

1185

如果他还有一个直接点

1186

那还是我们刚刚一样

1187

我们刚说的一样

1188

就是12123

1189

4567能明白这个意思吗

1190

对

1191

如果submarine有子节点的话

1192

那么他肯定就又进入了working progress的就是先找纸的

1193

再找先找纸

1194

当纸的没有的情况下再找纱布的

1195

然后在网上地位

1196

这就是为啥说一个往下一个往上呢

1197

要活跃活跃活跃活跃

1198

如果再往下

1199

然后他就是这样的嘛

1200

对吧

1201

嗯

1202

OK

1203

好

1204

那我们接下来

1205

来看看

1206

这个begin work大致先讲一下begin work的

1207

刚刚我们讲了大致begin work做的事情

1208

然后接下来讲这个begin work了

1209

第一他做什么事情

1210

第一判断节点

1211

是否可以服用

1212

根据不同的tag生成不同的FAB节点

1213

然后呢

1214

给存在更新的版本节点打上一个标记

1215

然后呢

1216

返回OK book翘的

1217

我们来看一下

1218

她常建了两三个两个节点

1219

一个scare and一个working progress thick ness

1220

如果current不等于

1221

那那就说明什么

1222

那就说明之前已经构建过了

1223

之前已经构建过一次了

1224

至少说明构建过一次

1225

就是它肯定不是ROM的那次对不对

1226

那么这个时候你就比较它是不是可以服用

1227

是不是可以复用

1228

是不是需要更新

1229

这是这比较大是是不是需要更新

1230

如果是有

1231

就是你的props如果变了

1232

大家想如果plus变了

1233

是不是肯定要更新

1234

你的你的你的组件的props变化了

1235

是不是肯定要更新

1236

那一定会更新的

1237

所以如果说props变了

1238

或者说你的context改变了

1239

这些

1240

这实际上就是指的是context

1241

我们regularly有context概念对不对

1242

Context概念这个应该都懂

1243

都懂吗

1244

CONTEXT12点

1245

Create a

1246

context

1247

他可以跨级context可以跨层级渠道属性渠道属性

1248

这样子避免的是我如果你的组件比较多

1249

那么我不需要一级一级打props

1250

一级一级的往下传

1251

我直接通过context

1252

那么可以取到很高层级的属性

1253

很高层级的主主线节点的那个属性

1254

所以

1255

Contacts这个变化啦

1256

那么他也要

1257

也也要更新

1258

就是它也是需要及时更新的

1259

也是需要及时更新的

1260

然后这里大家看这边有一个注意一个东西叫做班out

1261

Buy out by out

1262

在REC的内部就有很多这种八二的开头的方法

1263

这其实意味着啥

1264

意思是说你的这个东西直接就可以服用

1265

直接可以服用他这么一这么个意思

1266

这个意思

1267

那么这

1268

所以他把直接把它标记为了是吗

1269

Reserve它就不用更新了

1270

更新了就用这个就行了

1271

就这个就行了

1272

这个第一件事情

1273

他判断

1274

他判断这个节点需不需要更新

1275

当然他不光是这里判断

1276

大家想

1277

因为可能有同学还在还在想老师

1278

判断更新是不是还有一个东西叫做should component update对不对

1279

还有a component update的判断更新

1280

这只是第一次判断

1281

这是第一次判断

1282

后面他还会根据是component update那些

1283

然后来改这个值

1284

来改这个值

1285

所以不需要着急

1286

这是通过props context

1287

我们可以首先判断他是第一次更新

1288

就是需要更新

1289

因为如果你这个改变了

1290

那你肯定要更新吗

1291

第二个working progress烂

1292

我们来看workingprogress.tag根据这就是第二件事情

1293

根据它的不同

1294

大家看它的不同

1295

它里面其实处理了非常非常多的类型

1296

非常非常类型

1297

我这儿没写完

1298

我这没有写完

1299

因为我要是把它全部粘过来的话

1300

我这一我这一瓶都摆不下

1301

我这一瓶都摆不下

1302

它里面的这个类型非常多的

1303

比如说比如说我们之前我们可能认为他不算是一个

1304

特殊的类型的

1305

在这都是有不同的逻辑的

1306

比如lazy

1307

Function这个这个function肯定和class不一样

1308

对吧

1309

这个我们肯定都都知道

1310

我们都知道

1311

比如这个后手机是在render的时候第一次喝

1312

第一次的时候他会执行host

1313

Black down的对

1314

他自己host

1315

Host root

1316

还有其他的

1317

比如像portal

1318

比如我们有个party的概念

1319

在record里有portal

1320

有fragment

1321

对不对

1322

Fragment都是不同的功能

1323

不同的内内部不同的功能

1324

那么它根据这个tag的不同

1325

他就执行不同的case

1326

而这个case里其实大部分

1327

创建favor的这个逻辑是创建一个web的逻辑

1328

其实是一样的

1329

其实是一样的

1330

但是呢

1331

他们有自己的差异的

1332

差异化的部分

1333

比如function和class的差异部分上

1334

比如说class

1335

它可以执行生命周期

1336

方形呢

1337

他可能会有hooks

1338

那么在class component里

1339

Class complain的这么个分支里

1340

他对他执行

1341

这里边儿就是执行生命之妻

1342

而function component这个分支里

1343

它这里呢

1344

他就会去初始化

1345

Cook猪肉hooks

1346

上下文就是有一些不一样

1347

但是呢

1348

但是呢

1349

有一些又是相同的

1350

相同的就在这个

1351

Re consider children there是来做构建FAB节点的

1352

因为他们始终要创建一个节点

1353

除非像fragment它不需要创建节点

1354

那么就不需要

1355

如果说只要你要创建节点

1356

不管你是走哪个逻辑分支下来

1357

那么你肯定都要走到这个re consider dian children里面去

1358

对

1359

所以我就直接把它单拎出来了

1360

像这个host roots也是一样

1361

也是一样

1362

它会走到这个cos的确诊了

1363

好走到这个走到这个re cons脸children之后

1364

我们可以看到它区分

1365

区分了两种情况

1366

第一种是can a等于浪

1367

等于

1368

那意味着什么

1369

页面上什么也没有

1370

我们可以理解为

1371

页面上并没有结

1372

并没有这个节点

1373

那么要创建对不对

1374

叫创建

1375

如果页面上有了

1376

那么我们来看一下是否可以服用

1377

如果

1378

不能服用的话

1379

看一下该怎么更新

1380

所以分为两步

1381

如果页面上没有节点的话

1382

如果是mount阶段

1383

就创建fiber节点

1384

如果是update阶段

1385

那么我们就更新fiber节点

1386

更新快点儿

1387

这儿大家看创建的这个节点

1388

是直接赋值给了他的翘的

1389

对不对

1390

是直接复制了给了他的翘的

1391

能能看清楚

1392

复制给他翘的后面这里又会把翘的返回去

1393

一会儿把翘的返回去

1394

你看上面吧

1395

对

1396

对

1397

Retire working prison terms

1398

是不是因为比如像这个这个分支

1399

他最后也会调到re consider返回一个

1400

得到一个working progress and child

1401

而这

1402

他就说

1403

这里return的时候

1404

里边儿他就直接把working progress and child给ritter回去了

1405

睿册回去了

1406

这就是它的逻辑

1407

因此这这一步我们也讲到了

1408

他创建了PI节点

1409

复制给了子节点

1410

创建好了

1411

同时也给它指向working progress

1412

指向working progress点抢

1413

然后再根据我们刚刚所讲到的那个创建翡翠的那个流程

1414

那么他把working progress紧俏的是不是也复制给了work in progress就一层一层的往下推动了

1415

推动了

1416

走了

1417

这

1418

这不止这一个

1419

同学们

1420

这不止这一个

1421

这个方法是什么意思

1422

这个方法是指的是

1423

Police mun替换

1424

Please就是placement single child

1425

这是只是替换节点

1426

替换节点

1427

但是这是直接打上flex

1428

大家看到了

1429

直接打上了flex替换节点

1430

不止这一个

1431

如果是的

1432

他有个方法叫做delete

1433

吓得我这就没有写出来了

1434

我这就没有写出来了

1435

它里面不只有那肯定

1436

因为他不止有新增替换

1437

还有删除

1438

那么等等这种这些类型可能还有更新吗

1439

更新更新的话

1440

那就是比如说你的数属性值更新了什么的

1441

那么他会给你标记一个属性叫做

1442

更新属性值

1443

而他后面处理处理这个副作用的时候

1444

这种会在right里面称为一个副作用

1445

就是一次每一个节点你发生了一次变化

1446

那么他把这个节点叫做一个副作用

1447

本来这个flex

1448

他原本叫做CD effects

1449

他现在改成flex

1450

他认为是一个副作用

1451

如果这个副作用有这个副作用

1452

他最后会遍历这个副作用

1453

然后再批量的做处理

1454

而那么他就不需要在在那个render就是render阶段

1455

他不需要再

1456

循环一遍

1457

然后来判断一遍了

1458

他就可以直接处理了

1459

相当于他这一次的循环

1460

他利用了非常的充分

1461

在recovery的这一次循环

1462

它实际上是利用的比较充分的

1463

接下来我们看到它不仅不仅会打上fax

1464

它打的东西可多了

1465

做的东西可多了

1466

的算法

1467

的算法我们暂时先不讲

1468

等待会把整个这两个begin work和complete work都讲完了之后

1469

我们再讲dif

1470

它可能会把我们的流程拉远了

1471

newfiber.outlet指向的是working progress

1472

A new fiber

1473

不是的

1474

不是的

1475

这个new fiber他是不是新的fiber

1476

新的fiber的话

1477

它其实指向它

1478

其实它本身就是working progress however

1479

它的outlet就是指的是老节点

1480

他的a的值是现现在页面他只是current理解

1481

因为live fiber他的名字吗

1482

什么是new working progress才是new face啊

1483

Working progress number

1484

所以他的所以他的outlet

1485

它指向的是current

1486

就是也就是页面上现在正有页面上现在

1487

这有到那个节点

1488

而如果他carrot不存在的情况下

1489

Please

1490

他就给他打上一个这个节点

1491

其实他的这个语义化做得还是不错的

1492

同学们与计划做的还是不错的

1493

Current你就理解为就很好理解嘛

1494

就是叶荷叶面反正是对应的那个current当前那个

1495

对吧

1496

这个new favor那肯定是一个

1497

这一次要创建一个新的

1498

他就其实是working progress

1499

好

1500

Begin work

1501

我们来总结一下

1502

他这是你第一判断节点是否可以服用

1503

第二根据不同的是否需要更新

1504

因为如果不需要更新

1505

不需要跟你是不是就是

1506

是不是就是直接可以复用

1507

不需要给你是不是直接就可以服用

1508

而根据不同的第二个第二个件事情

1509

根据不同的tag生成不同的favor节点

1510

一个是MT

1511

一个是update MT就创建

1512

Update就更新

1513

然后在这个阶段他会做diff

1514

回头differ

1515

这两个地方的话

1516

我暂时还没给大家讲到

1517

待会会讲到第三

1518

我们知道它变

1519

它具体的变更了

1520

那么就给他打上标记

1521

打上标记

1522

Replacement update a delicious

1523

还有其他的

1524

第四

1525

创建web节点

1526

复制给working prison child返回

1527

还有第五

1528

他会执行

1529

执行对应的

1530

执行不同的

1531

不同的类型

1532

不同类型的节点

1533

不同类型的favor几点

1534

会执行

1535

除了构建petri

1536

会执行就是相应的特殊逻辑

1537

比如说如果是class

1538

那就会执行

1539

生殖器

1540

会掉生命值减函数

1541

如果是方形

1542

它没有生命

1543

之间还是可以调

1544

那么会注入

1545

对

1546

是的是的

1547

Cooks

1548

上下文

1549

是的

1550

其实它就指的是

1551

这指的就是方向

1552

Comment就指的是我们一个我们写的那个function component函数组件

1553

这些只是我们写的那个class函数组件

1554

如果是function还是组建

1555

那么它在这个它会掉这个update的function component

1556

它里面会调用一个方法叫做render with hooks

1557

这个方法会注入hook上下文之心

1558

芳心

1559

直接发个信

1560

函数题

1561

大家注意

1562

在hooks里大家可能都写过

1563

就是如果你在class里调hooks

1564

实际上调不通

1565

对不对是用不了的

1566

他会给你报错

1567

原因就是因为它只有因为在class里hooks上下文并不存在

1568

它是实时给你副词的

1569

他是时势赋的值

1570

明白吗

1571

实时赋的值

1572

所以说class里永远掉不了

1573

护色

1574

就是后续的东西

1575

护士的东西只有在放弃里面才能调实时复制

1576

第二

1577

判断节点是否服用

1578

能服用者巴拉的获取方法

1579

服用节点

1580

就主要是这个不太一样

1581

在class里面的话就直接扔的就是生命

1582

Render之前的生命周期

1583

我们可以从代码里面看一看

1584

现在rock实际源码在这里的目的是

1585

什么意思

1586

是啊

1587

肯定啊

1588

内组建类组件并不会被废弃的

1589

同学们

1590

方形组建

1591

虽然现在说有很大的方形组件

1592

现在虽然说有很大的那个

1593

就是它的份额比以前更大

1594

但是内组建并不会被放弃的

1595

他也同样是react里面还是一个非常重要的一个功能

1596

不会不会

1597

只是说内组件它不能调用hooks

1598

这肯定是

1599

这肯定是一定的

1600

但是它原本的那些生命周期

1601

那些都是还在

1602

并不会放弃掉

1603

而方见

1604

因为他以前还没有这个逻辑

1605

现在有了

1606

有护士了

1607

所以他也会掉

1608

我们可以来看一下

1609

可以看一下从代码里面瞅一瞅

1610

第二

1611

我们因为我们了解了大部分大概他

1612

做了什么事情

1613

我们就可以来跳一跳代码了

1614

跳到代码

1615

如果直接跳的话

1616

可能大家都会

1617

被他绕晕了

1618

在react时期的时候

1619

大家看它的函数里有两个

1620

比如有一个叫做点六

1621

也就是点二的

1622

刚开始他是直接复制了一份出来

1623

直接复制一份出来

1624

因为她不想影响

1625

她在开发新功能的时候

1626

他不想影响老的东西

1627

所以他就这么区分一下就是

1628

用了一个点o的点六

1629

然后如果说他觉得时机成熟了

1630

那么就把所有的纸箱都变成六

1631

否则之前的话就还是用o的

1632

这样的话他

1633

让内部不是说要做那个渐进式的升级吗

1634

渐进式升级不会说我这次开发了新的功能

1635

你老子就直接就像像那个什么安哥拉

1636

安哥拉之前一样

1637

然后做断崖式升级

1638

没有做这种断崖式升级

1639

想做间接升级

1640

所以他想了这么个办法

1641

这个办法我们现在看六就行了

1642

看就行了

1643

我们看一下它这个APP的function convenient

1644

的我们不看Di v它其实DV里面可能有很多调试的逻辑

1645

DV都给他切掉

1646

让我们

1647

Up de function component里面

1648

我们看到了没

1649

Render with hooks对不对

1650

Render with hooks

1651

这里面render with hooks就是注入我们的hook上下文了

1652

我们的hook上下文

1653

就是这个

1654

比如说我们当前的要处理的fiber

1655

他就把它复制给叫做currently rendering fiber

1656

然后这个难nice

1657

有了这个之后

1658

Hooks才能掉得了

1659

如果没有这个hooks是根本调不动的

1660

还有就是这款

1661

大家大家注意

1662

如果你是在react源码里搜这个react current dispatch action current

1663

她会是什么

1664

它会是浪

1665

源码你直接掉

1666

你直接去找这个东西

1667

它会是个浪

1668

他是个那但是你只有在注入

1669

Render with hooks so

1670

他会实时给你复制就给你复制

1671

而当你的这个节点运行完了之后

1672

他又把这个值又重新给设备让了

1673

又重新给设备上了

1674

这就保证什么

1675

这就保证了你只能够在函数组件里调

1676

你在其他组件里

1677

比如在内组件里掉

1678

你是掉不了的

1679

因为他在用户时

1680

他就会去找这个

1681

复试的时候

1682

我们后面会看原版

1683

你就可以看到他直接就找这个

1684

如果这个为让他就什么也不管

1685

就直接报错就行了

1686

直接报就行了

1687

而这个柱子的逻辑就是在我们这次讲到了这个地方

1688

这

1689

Ren der with hooks and or with hooks

1690

这个地方

1691

然后这也是设了一个working books

1692

然后再调了我们刚刚所调的那个所说的那个re considered children

1693

他其实就是

1694

我开始调整对不对

1695

跟我们说看到那个代码一样

1696

如果等于零的时候

1697

就MT一个新的

1698

如果不等于

1699

Current存在的情况下

1700

那么他是要进行一个对比的

1701

再进行一个对比

1702

再就是

1703

Function component function

1704

做事情

1705

我们再来看一下class

1706

我们刚刚说的生命周期

1707

我们来看一下生命周期

1708

有没有如老师所讲的那样被调用呢

1709

还是第一位不看

1710

第一步看他里面写了

1711

很多的

1712

ADV

1713

这这这就有点烦人那天

1714

这行不行

1715

高的吧

1716

那个新的可能我可能我

1717

烧的那个可好

1718

有的时候听到

1719

Class对吧

1720

他就给了一个社

1721

是否有context是否context

1722

然后

1723

是否youth did not

1724

如果是stayed not等于

1725

那那就说明是第一次执行

1726

因为还是和canon一样

1727

那个斯诺的

1728

我先提一嘴

1729

它储存的是真的大美元素

1730

就是你那个范儿节点

1731

他当元素

1732

它会在它会在我们后面会讲到的complete until work里给他生成好

1733

而如果是下一次更新

1734

那么你的这个节点有没有

1735

有没有这个氮元素

1736

那么它可以来做一些判断

1737

这个还好

1738

这个其实就是一个属性

1739

放放它的一个属性

1740

第一次执行走这个

1741

第二次执行就是如果不是第一次执行

1742

那么这里会执行

1743

这个方法你会执行well I MT should component update等等

1744

生命周期就会执行这个

1745

而下面这个会自信

1746

Computer will receive props

1747

Complete did catch up date the flag

1748

这大家注意

1749

这里只是会打上一个flag

1750

因为他认为的update也好的MT也好

1751

他也是低的update

1752

不是慢的dock的

1753

就说明你的属性更新了吗

1754

他认为这也是一个副作用

1755

所以要达成一个标记

1756

然后执行这个执行他执行他

1757

我们他比较全

1758

我们看一下他

1759

After class

1760

我们看一下

1761

这里啊

1762

很多的这种props对比

1763

对吧

1764

我们不用细看

1765

我们只看他掉没掉

1766

我们所想要看

1767

所关心的几个方法

1768

第一个

1769

Get drivers seat from props

1770

好

1771

我们看到了这个生命周期

1772

如果它等于function

1773

他是直接执行呢

1774

是否会直接执行

1775

Good drive state from props

1776

我看一下他在哪咨询

1777

看

1778

如果它等于放行

1779

他会执行他这个

1780

这个的意思是会执行一个生命

1781

会执行生命周期

1782

它会执行这个方法

1783

但是会给他附上附上首要的职责

1784

附上谁的字

1785

然后这下面的这还是上面的一个

1786

会执行component will receive props就在这里执行的

1787

他的对比很简单

1788

就是props不一致

1789

就执行这个component will receive props

1790

但现在已经给他标上了UN safe的一个标记了

1791

On set的一个标记了

1792

然后下面是滴的update

1793

大家看的到update之前有同学就很疑惑

1794

说的的update呢

1795

不是在认的

1796

就是和那个component did mount的时机一致的

1797

差不多一致的吗

1798

为什么会在这里用

1799

这实际上只是给他打了一个flex

1800

就说明有东西更新了

1801

她也是认为它也它是一个副作用

1802

给snapshot before update

1803

这个同样也是这个含这个生命周期同样也是在什么呢

1804

也是在

1805

那也是在康复的阶段

1806

就是那个阶段执行的

1807

所以也是打上一个标记

1808

就这两个打上了标记

1809

这个是

1810

给drive that said from props自信了

1811

这一次行了

1812

Get the should component update执行了

1813

如果这个为醋

1814

那么就认为值逐渐会更新

1815

如果说come

1816

如果说the update啊

1817

这这不对

1818

同学

1819

我说错了

1820

这只是判断她是否需要update

1821

如果需要update它才会执行

1822

Compared with up的生命周期

1823

这里complete will update

1824

会自信

1825

你好

1826

这也是打上标记

1827

好差不多了

1828

差不多就到这里

1829

差不多就到这里

1830

而他的函数体的执行

1831

我们刚这讲的是

1832

他的点润

1833

它的函数体的执行

1834

就是构建发那个执行肯定是执行典render

1835

对不对

1836

执行点render

1837

我们可以看一下它的典render

1838

执行了这么多生命周期

1839

对

1840

前面这个这个地方执行的是render

1841

之前的所有的生命周期基本上都执行了

1842

接下来

1843

他会执行

1844

生命值的

1845

也就是如果是方向的肯定就执行函数体

1846

这就执行end

1847

我们看

1848

我看一下关键的

1849

大家看

1850

Instance典render执行了

1851

得到了新的东西

1852

得到了子节点

1853

他可能不止一个嘛

1854

对吧

1855

得了得到了节点

1856

然后后面再做处理

1857

这就是生命周期的执行

1858

这块能明白吗同学们

1859

给大家看了一下

1860

我们的begin work做的事情大概就是这么几件了

1861

能能明白嘛

1862

有不懂有不明白的地方吗

1863

如果明白的话扣个一

1864

不明白扣个零

1865

我在大概捋一遍大概捋一遍

1866

行行

1867

然后dif的话就下半节课继续讲

1868

下半节课就是呆会儿会继续讲

1869

因为complete until work还没讲完呢

1870

现在时间已经过了一个小时了

1871

大家可以休息五分钟

1872

去喝点水

1873

然后上个厕所

1874

我们03:10的时候继续

1875

刚刚我们跳代码跳的快不快

1876

大家能跟得上吗

1877

因为以前的时候直接就没有这个文档

1878

就直接挑代码

1879

然后大家反应就是经常被绕晕

1880

因为因为函数太多了

1881

还是太猛了

1882

所以那那你看我这里看我这里就行

1883

看到这边这个地方吗

1884

就是在class com那里

1885

北京这个大家下下来把那个代码发给大家

1886

大家自己去跳来大家自己去跳吧

1887

反正可以看到就是它其实也就是要紧的那几个函数

1888

要剪就开始

1889

这可能生命周期因为比较多嘛

1890

对吧

1891

生命周期比较多

1892

可能跳得比较

1893

跳得比较厉害

1894

大家申请吧

1895

申请

1896

我给大家

1897

没有钱

1898

现在申请给他加这个后面会发的

1899

因为现在可能会有一些补充

1900

所以不适合一开始就发

1901

手机上就别打开了

1902

用电脑吧

1903

手机上他不一定支持

1904

我也不知道它支不支持手机

1905

后面会把这个给大家弄成一个PDF

1906

然后

1907

然后呢

1908

链接分享给大家

1909

大家可以申请

1910

然后在PC上看

1911

如果有PDF

1912

后面有PDF了

1913

后面有PDF了

1914

大家

1915

就就可以在手机上查看

1916

现在他可能不支持吧

1917

好久没弄这个

1918

好久好久

1919

好久没有打开过了

1920

已经不太清楚

1921

时间嘛

1922

时间后面有

1923

好

1924

时间到了

1925

我们就接着讲吧

1926

同学们回来了没

1927

就是也感觉有bug

1928

是感觉bug吧

1929

这里好几个百米与乐趣

1930

好吧

1931

这也不重要

1932

不重要继续吧

1933

接下来是complete complete until work

1934

这个东西

1935

上面我们讲了begin work的事情

1936

现在completely UN work

1937

他首先他要做的第一件事情就是向上递归

1938

对吧

1939

向上的compete complete work

1940

这个大家讲到了

1941

他是构建faculty的一个非常重要的一个过程

1942

他做的做的第二件事情就是创建DOM节点

1943

更新或者更新DOM节点

1944

然后呢

1945

把DOM节点赋值给state not

1946

第三

1947

他是把子节点叫做city fact

1948

什么city fact呢

1949

City fact

1950

这里的sit in fact

1951

这里的CD pack

1952

它是指的是

1953

一个链条也也是一个链表

1954

但这个链表是只是有更新的

1955

比如有根就是需要有更新的节点的

1956

FAB有更新的FAB节点

1957

他会通通的放到这个c de fec链条上去

1958

然后子节点的CDC的链条又会附加到父节点的CF链条之上

1959

这个也是在康蜜的阶段备用的

1960

我们的这个单节点复制给斯诺的属性

1961

它也是在

1962

com的阶段备用的

1963

第四

1964

存在兄弟节点

1965

将working progress指向新的节点

1966

执行兄弟节点呢

1967

Begin work的过程

1968

这个也是之前讲到的整个federal trade构建过程的一个很重要的部分

1969

同样也是

1970

这个也讲过了

1971

就不多说了

1972

然后这在complete work里我们看到这个循环

1973

对吧

1974

也就是说如果是整个构件设备处于一个双重循环

1975

除以三种循环

1976

第一个循环就是上面那个大外耳

1977

大外那个那个第一层刑事处理working progress就是指节点

1978

一直处理节点

1979

Complete a walk的这个小循环

1980

它处理的是什么

1981

他处理的是生理节点

1982

以及返回的父节点

1983

返回节点

1984

那么这可以回答之前呢

1985

把这几个代码讲完了之后

1986

就可以回答一个非常重要的问题就是

1987

为什么他一定是从下从上到下

1988

他为什么选择从上到下

1989

就然后再从下

1990

然后一级一级的返回的这种形式

1991

原因是什么呢

1992

我们来看一下他做的事情

1993

比如他执行的一个complete work的方法

1994

这个complete work

1995

它主要的逻辑是在MT的阶段创建DOM节点

1996

并且将子孙DOM节点插入到刚生成的DOM节点中

1997

赋值给c note保存备用

1998

一句话

1999

创建节点

2000

更新的时候

2001

由于当前创建过

2002

于是更新一些属性就可以

2003

这是第一件事情

2004

第二件事情把子弟CD fac的附加在附近的CD fac电视上

2005

大家看这实际上是一个链表的一个链表的一个拼接

2006

Richer发表

2007

我们讲了瑞特fiber是他的父节点

2008

绿茶婊

2009

父节点看也看得明白对不对

2010

父节点呢

2011

那个副作用链条不等于那等于浪的话

2012

那么就把直接点了

2013

这个是我们直接点

2014

这是我们当前的这个直接点

2015

直接点的链条复制给他

2016

如果

2017

父节点的那个链条不等于不等于浪就是有

2018

那么就把他的这个first effect它复制给

2019

他的lasteffect.next effect意思是什么

2020

意思就是夹在父节点的那个副作用链条的最后一位

2021

对不对

2022

那是不是就给他相当于给他拼接到付几点呢

2023

City fact链条之上了

2024

而这个city effect我讲到了这个CD fec

2025

他指的就是有更新的发展节点

2026

有任何更新的发展节点

2027

而她找的这个发布节点

2028

通过我们这种方式

2029

通过我们的

2030

我们再把画一幅刚刚画的那个图

2031

大家看从上到下

2032

假如现在走到这儿了

2033

我们走到最下面了

2034

对不对

2035

到最下边了现在

2036

假如他我已经产生了一个effect

2037

我已经产生了一个副作用

2038

比如我们有一个有一个单元素发生属性的变化

2039

有个大圆杀生的属性的变化

2040

那么我拥有了一个effect

2041

然后呢

2042

当他回去的时候

2043

他就把这个发给富也富集了

2044

而负极呢

2045

他同样有自己的effect

2046

然后呢

2047

复制的effect

2048

再加上直接点effect

2049

他又复制一个负极

2050

这副又反馈给负极

2051

然后负极又有了

2052

好几个effect

2053

那么又把所有的加上

2054

然后一直是法人

2055

一直返回

2056

直到返回根节点

2057

但返回根节点大家发现一件事情就是

2058

我更节点的这个IP的链条就包含了下面所有的effect

2059

也就是说他汇总

2060

他把所有的要更新的节点的这个一份量

2061

已经全部汇总到我们的根节点了

2062

那么下一次如果在咖啡的节点

2063

com的阶段

2064

我想要获取哪些

2065

我想要对已经更新的节点做处理

2066

那么就是不是很方便

2067

不是很方便

2068

因为我只需要找到这个working process fiber的那个root

2069

就是根结点

2070

Working process的根节点

2071

然后拿到它的链条

2072

拿到它的这个F链

2073

就瞬间就知道了所有的

2074

更新的要需要更新的版本

2075

需要处理更新的版本节点全部拿到了

2076

同时什么呢

2077

由于我们的

2078

由于我们的这个

2079

同时也已经创建了

2080

当当元素

2081

我们的氮元素同样也是这样

2082

一级一级的会把它插入插入DOS de note里

2083

因为它有两个属性

2084

一个struts

2085

External的另外一个working progress啊

2086

就是那个F链条这两个属性

2087

都是都是下面子节点全部汇总上来的

2088

那么他处理起来的话

2089

那么在在computer阶段处理起来的话

2090

就不需要再遍历一次了

2091

就只需要取来用就行了

2092

这就决定了

2093

这就是为什么从下到上

2094

他做的事情做得非常的就是就是使用这一次循环使用的非常的充分

2095

对不对

2096

就不需要后面我们用不用再

2097

在这样子整整体的再来一遍了嘛

2098

对吧

2099

Complete work我们刚刚讲了

2100

他是创建的节点

2101

在这里创建的节点

2102

这48

2103

子孙的大节点插入到刚生成的大门

2104

几点钟

2105

其实也就是给父级嘛

2106

对吧

2107

把尺寸的叉给我

2108

我再给父级

2109

然后一直一直给他更几点

2110

最后把这个创建好的到极点复制给了斯塔诺的属性

2111

复制给山东数据

2112

这就是complete a walk complete until work做这个事情

2113

我们接下来来一个总的汇总

2114

一个总的汇总做了什么事情

2115

一个总整整体的汇总就出现了

2116

整体的汇总出现了

2117

从句构建February开始构建February

2118

从他

2119

跟分别是一个非常重要的一个字段

2120

叫做working progress对吧

2121

他就是从根结点一直往下创建

2122

一直往下创建

2123

这图还是亮起来

2124

我

2125

做二个吧

2126

别乱

2127

这是根节点

2128

好

2129

我以class举例

2130

假设全是class组件

2131

那么我听我在创建粉碎首先从上往下

2132

从上到下的流程

2133

从上到下的流程

2134

那么他肯定是走这样的一个县的

2135

就是走这样的一个县

2136

然后呢

2137

我们的working proxy一点就一级级往下至儿在

2138

每次都会创建一个子节点

2139

每次都会创建一个子节点

2140

创建子节点

2141

然后呢

2142

又把它复制给working progress

2143

复制给working progress

2144

负责给working progress

2145

而创建这个节点过程

2146

创建子节点的过程

2147

毫无疑问他肯定是要执行生命周期的

2148

因为

2149

因为你的直接点在哪里

2150

在你的render函数中的函数中

2151

所以每执行一个begin work

2152

那么你的render以及render之前生命周期就已经被执行了

2153

已经被执行了

2154

然后呢

2155

再从下到上

2156

从下到上的时候

2157

那么他

2158

同样

2159

他会

2160

得到你的这个

2161

它首先会有city fact

2162

键桥

2163

菲菲链条

2164

然后往上

2165

把这个city fac复制给他

2166

然后呢

2167

Send log

2168

也复制给他的那个

2169

插入到他的CF里

2170

然后呢

2171

在这里

2172

同样也是

2173

把c de fines垫片往上浮

2174

嗯

2175

赛得诺的同样也差了

2176

他决定就一直往上差

2177

最后最后回到最上层的这个root的时候

2178

那么

2179

同首先

2180

February构建完成了

2181

在February构建完成的这一瞬间

2182

他同样他得到了所有的有副作用的CD fact链条

2183

得到了

2184

得到了一个整体的一个said nod

2185

得到一个整总体的总体的一个signal

2186

都在这个跟根节点上

2187

那么后面要处理的时候就很方便了

2188

关于这点

2189

大家能明白的扣一个一

2190

不能明白的扣一个零

2191

可以明白吗

2192

其他同学呢

2193

可以呀

2194

兄弟节点同样也是一样的

2195

兄弟节点他写的CD fac

2196

他同样会返回给父节点

2197

再返回复检的那一刻就复制给父节点

2198

对吧

2199

插上去就行了

2200

没明白链条从底下往上走的时候的连接顺序

2201

那就是那就是一开始这个February

2202

发射出的逻辑还没明白

2203

挑战嘛

2204

对吧

2205

这里是不是一

2206

二

2207

三

2208

是啊

2209

然后呢

2210

走到这儿

2211

他的next就等于空了

2212

就是begin work里的next就已经是烂了

2213

因为他没有直接点了

2214

然后他就进到complete until work里

2215

在这里边儿

2216

他会复制它会

2217

去判断他有没有病

2218

如果有病的话

2219

就把sub Lin复制给了working progress

2220

所以这里是第五个节点

2221

这点能能明白吗

2222

能明白吗

2223

所以这里是第五个节点

2224

能明白吗

2225

然后因为他又复制给了working progress working progress又有了

2226

他又执行working progress

2227

只要不等于那

2228

那么他就会找他的翘的

2229

又会找她的翘的

2230

它翘的又存在

2231

对不对

2232

这是存在的

2233

所以它是第六个节点

2234

然后现在翘的没有了

2235

那么next又被控了

2236

她又进入到了work in progress until work里

2237

现在

2238

但是进入到了complete until work early

2239

它的

2240

他的兄弟姐妹也没有

2241

兄弟没有会干什么

2242

兄弟几点会干

2243

兄弟节点没有的时候

2244

看没有兄弟节点的时候

2245

他的return the favor等于work in progress

2246

等于complete work

2247

等于complete work

2248

于是她是不是她就指向了他

2249

是不是就指向他的父节点了

2250

对不对

2251

直接他的父节点了

2252

然后现在这副节点

2253

我们这个节点有没有设备

2254

没有设备呢

2255

他是不是又回到这个副节点了

2256

他他上一个父节点

2257

回到这个父节点

2258

这个父节点有没有什么练弹跳的设备吗

2259

尤瑟不定

2260

那么是不是

2261

一个spring的情况下

2262

那么它的split就成了第六个点

2263

因为它又复制给working progress

2264

然后他又有了

2265

直接点

2266

到了七

2267

然后呢

2268

如果没有的话

2269

它又会返回三

2270

然后就

2271

二

2272

他

2273

返回到这个这一层的时候

2274

他也有兄弟节点

2275

对不对

2276

这就是吧

2277

然后呢

2278

如果什么

2279

这又什么也没有了

2280

烧回来了

2281

对

2282

你理解是对的

2283

兄弟

2284

今天没围绕的时候

2285

并且没有主见

2286

思想递归没错

2287

没错

2288

它是其实是先判断地

2289

没有直接点

2290

千盼

2291

没有直接点

2292

因为没有直接点在上层

2293

上层讲的那层循环里

2294

没有节点

2295

同时兄弟节点也没有

2296

也没有了

2297

那么他就返回父节点了

2298

列表结构的是下边的六个

2299

嗯

2300

Sorry

2301

五六这里应该是七

2302

七码吧

2303

九

2304

另外几个字下面滴溜的下一个元素

2305

我为啥不去死

2306

五为啥不去死

2307

耳机删了

2308

找的是父节点同学

2309

父节点六的父节点是五的父节点是三

2310

我的父节点是三

2311

这期的父节点是二大家看445的445的兄弟节点

2312

你根据这行代码

2313

它并不会回到他的兄弟节点

2314

喂

2315

好

2316

我看一下每个节点咋带上

2317

Effects seen flex吗

2318

有flex

2319

有flex的时候他是不是

2320

就是有副作用吗

2321

对吧

2322

有flex就说明是需要做处理的

2323

然后呢

2324

他通过这种代码其实

2325

这一整段都是

2326

但是我标黄的这这几行

2327

就是把它连起来的

2328

这个逻辑是把它连起来

2329

它实际上要紧的是什么

2330

要紧的事

2331

这个副作用链条

2332

如果没有的情况下

2333

那么就直接如果父节点并没有负作用点

2334

那么就直接等于他如果有就把它放在它的最后

2335

这其实就把它放在最后的下一个对不对

2336

最后的下一个

2337

给了父节点呢

2338

因为它是递归的那副节点的父节点

2339

那肯定也是同样的逻辑

2340

一直到根节点

2341

那是不是他就有了所有的副作用裂掉了

2342

明白了吗

2343

这点儿同学们

2344

明天扣一个一

2345

OK

2346

好的

2347

好的

2348

所以我们所以他这个从下到上

2349

再从下在从上到下

2350

再从下从下到上

2351

当sub tree构建完成之后

2352

你看它就多了好多东西了

2353

对不对

2354

他做了好多事情

2355

把后面的相当于一部分优化都给做了

2356

但你说不做能不能行

2357

行

2358

但是他做的这个实际上是为了优化

2359

是为了优化

2360

原因是他不想在扔的过程

2361

他想要尽可能减少人的过程的时间

2362

因为这段时间是不可以被打断的

2363

这段时间是不可以被答案的

2364

对不对

2365

好

2366

现在我们来看一下

2367

的算法

2368

我刚刚没有讲的算法对不对

2369

没有讲的算法

2370

因为它我刚刚如果讲的话

2371

把这个讲完了

2372

我们再来讲complete on their work的逻辑

2373

实际上就有点费劲了

2374

因为就绕远了

2375

就绕远了

2376

我们现在先把这整个相当于大框架

2377

给大家捋明白了

2378

明白了

2379

接下来我们再看具体的详情

2380

详细的大家很关注的这一块儿

2381

的算法是怎么回事儿

2382

因为有可能面试的时候

2383

因为有可能面试的时候他还是会问到这块儿的

2384

这真的做这个bug

2385

Dip的瓶颈以及wrecked down的应对就是的算法实际上是有一定的瓶颈的

2386

首先当地扶他会预测几个规则的

2387

只对同级进行比较

2388

对同级节点进行比较

2389

比如我们刚刚那个图

2390

你的父节点你就不要和

2391

子节点不要和

2392

就是你的current feb的父节点就不要和

2393

翻倍的子节点进行比较了

2394

没有意义

2395

对不对

2396

没有意义

2397

第二他认为这个没有意义

2398

是rock认为这个没有意义

2399

因为你如果是可以跨成绩比较的话

2400

那么对于rocker来说

2401

对rock来说一个是它的开销

2402

他的那个计算开销性能会特别大

2403

第二

2404

这种场景却非常的少

2405

其实这个就是一个

2406

其实这就是一个rar的对比嘛

2407

一个IR不够高

2408

阿拉伯告我的

2409

我要消耗的资源又非常的大

2410

但是呢

2411

这种场景又并不多并不多

2412

所以他干脆就不满足你这个需求

2413

我只对同级节点进行比较

2414

第二节点变化的话就直接删除

2415

然后重建

2416

第三

2417

存在K值对比节点的K值

2418

所以K值是非常重要的

2419

K值是非常重要的

2420

不能够乱写的

2421

向record里

2422

一般在循环对case一般的话

2423

嗯

2424

一般的话

2425

你如果不是在

2426

不在循环里

2427

对

2428

你如果不在循环里

2429

他就是那个比如佛一起

2430

不不是

2431

不是说是map

2432

如果不是那种用map的形式是一般是可以补血的

2433

一般是可以不写

2434

他会默认

2435

但是有的情况下是需要写的

2436

在什么情况下

2437

有没有的情况下是

2438

比如你发现你的原你的那个REC的组件

2439

它的更新起来就是有一些不更新

2440

我就我之前遇到过这种场景

2441

就是当你知道kiss

2442

真正的罗

2443

知道kiss的逻辑之后

2444

你可以用他做事情

2445

比如我之前有一个场景是

2446

比如我是在那个

2447

这是我们的

2448

这是我们的一个electronic APP对吧

2449

我点击了一个元素a

2450

点击这个a

2451

然后我出现了一个新的窗口

2452

我调了一个新的窗口

2453

这个窗口就是新的

2454

就是新的页面嘛

2455

对吧

2456

新的页面儿

2457

我这个点击a的时候

2458

它实际上会传入一些社会传入一些

2459

阐述进来了

2460

只要传阐述进来了

2461

我看之前他们写的逻辑就有个bug

2462

就是我点了这个

2463

点了这个之后

2464

第一次没问题

2465

然后当我在这个窗口不消失的情况下

2466

我再点一次就会发现就会发

2467

再点一次另外的一个属性不一样的进来

2468

就会发现我们这个窗口并不会及时的更新

2469

这个方法就不会及时的更新

2470

可能是有有其他的逻辑上的一些问题

2471

最简单粗暴的解决方法方式呢

2472

大家知道是什么吗

2473

我当时要优化这个问题

2474

然后一共响了不到一共享了不到三分钟

2475

最简单的语法问题就是把K给他改了

2476

他绝对会墙根墙根一次

2477

对

2478

如果说你要是因为是老逻辑嘛

2479

我懒得去看

2480

我懒得去看后面的话再优化

2481

而当时项目又紧

2482

那么就把K改这个问题bug解了

2483

我们会我们会详细看的会详细看的

2484

对这几个规则会一直会一直存在

2485

我们会看

2486

他的有单节点的对比

2487

就得单节点的地方和多节点的地方

2488

循环也能加K码

2489

不对

2490

可以的

2491

不是循环可以加K

2492

可以嫁给

2493

你只要保证你的那个用法是在你的掌握之内

2494

就比如我刚刚说的那个场景

2495

我刚刚说的那个场景

2496

那就是我只要我只要进了plus不一样

2497

我那么我的K值每次都会重新变

2498

我会我会想办法让他变化

2499

没有啊

2500

就直接一个开字

2501

就放就行了

2502

你就这三个开

2503

对吧

2504

组建嘛

2505

就是个K就完事儿了

2506

即使它不是循环

2507

你还可以加

2508

同样可以加

2509

很简单这个

2510

但是呢

2511

逻辑并不简单

2512

就是改起来就觉得就是你如果懂这块儿

2513

改起来就快

2514

而且改起来也很简单

2515

你不懂这块儿

2516

你就想不到它

2517

其实主要是你想不到的

2518

这个case还是很重要的

2519

不能够瞎写在wrecked在

2520

特别在放一起的时候

2521

大家千万不要根据这个

2522

不要根据他的index来写

2523

比如说什么一二三点佛一起办法

2524

对吧

2525

这就

2526

Index

2527

一般不是这么高吗

2528

艾特了

2529

假如怎么写

2530

嗯

2531

这样子写的话是负向优化

2532

就如果在克瑞微的话

2533

这种想法是会被嘲笑的

2534

同学们

2535

这种写法是负向优化

2536

就是你反而你本来加K只是为了优化它的那个当地的

2537

结果你搞成什么了

2538

结果呢

2539

搞成了优越

2540

优化效果越差

2541

那么他这就是典型的一个例子

2542

越优化效果越差

2543

就不能直接这么用

2544

不能直接这么用

2545

你可以用这个APP里面的属性

2546

可以用这个APP里面唯一的属性

2547

比如说像什么FBI的对吧

2548

I TE dian ID啊

2549

或者什么其他东西

2550

如果这个艾特实在是没有啥可用的

2551

而且他是有这些中文你不想用

2552

那么你至少可以这样写

2553

那么你那么你至少可以这样写

2554

比如说

2555

什么testa对吧

2556

每一个都不一样

2557

你知道可以这样写

2558

就不会和其他地方的壮起来

2559

记住这一点很代码对应的性能提升

2560

可能你说我还是要想办法做个优化

2561

结果越做优化越差

2562

可能就是这个原因导致的

2563

下来检查一下这种

2564

这种是明令禁止的

2565

不可以这么写

2566

那个yes里面也有类似的

2567

这也有类似的规则

2568

就是不让你这么写

2569

你这么写他就给你报错

2570

Good about yesterday的错误

2571

好点儿了

2572

发的有点多了

2573

好

2574

接下来看一下它的的

2575

首先这其实区分了一下

2576

这代码在react翘的fiber

2577

点六下的re consider the child fiber

2578

首先看一下它是不是react组件

2579

是不是react组件X组件

2580

那么他一定是一个object X单独的软件是一个object

2581

Rock之间里有个叨叨的type of的这个

2582

是标志你比如你到底是react点

2583

就是点create element创建的呢

2584

还是什么其他的东西

2585

还有什么其他东西

2586

根据这里对不对

2587

如果是

2588

有不同的节点

2589

那么还是喝

2590

刚刚上面的逻辑一样

2591

不同的代码就是不同的type处理不同的逻辑

2592

这其实是给她家她的事

2593

给他加flex的

2594

那如果是

2595

Error

2596

如果是个error

2597

就是我们所常用的这种多节点的速度

2598

这其实就是判断了一下单节点速度

2599

就是单节点的符合多节点的父

2600

分别的逻辑是什么

2601

我们先看一下单节点

2602

单节点就非常简单

2603

判断存在对应的节点case是否相同

2604

如果case也相同

2605

节点类型也相同

2606

就服用

2607

如果存在对应节点cases

2608

是否判断K是否相同

2609

节点类型是否一致

2610

如果不一致的话就标记一个delete

2611

如果存在对应节点

2612

Case不同标记删除

2613

重新创建

2614

不存在这些节点

2615

创建新节点

2616

这就是罗

2617

这就是单节点

2618

我们可以看一下

2619

首先是

2620

翘

2621

如果撬不等于

2622

就存在吗

2623

然后就对比K值是否相同

2624

K相同同时什么呢

2625

大家看它的APP一样

2626

比如说你从丢你的K算一样

2627

但是你把它从div改成了一个屁

2628

那么他同样是要

2629

那么他同样是要把它给

2630

处理掉了

2631

同样是给它处理掉了

2632

这里就是指case相同元素类型也一致

2633

那么这里就可以服用了

2634

这是服用

2635

但是服用并不是什么属性都不改

2636

同学们并不是什么属性都不改

2637

这个之前有同学真的被面试问到

2638

就是说费用是怎么个服用法

2639

他就说不上来了

2640

其实这个就是要举一反三

2641

要举一反三

2642

不可能什么都讲到同学们下来要想一想

2643

这其实就是只复印的逻辑

2644

这个exist existing就是存在

2645

但是你有的有的结

2646

有的点要改的

2647

比如像那个riff的return

2648

因为因为你之前的可能return he

2649

现在return万一不一样了怎么办呢

2650

所以它这里是要改这两个节点的

2651

这两个点先把它改掉了

2652

然后就服用

2653

如果这个LC就是

2654

Else就是element type不一样

2655

这是标志

2656

节点类型不一致

2657

标记为删除

2658

标记为删除下面下面这个是K值都不一样

2659

同样是把它标记为删除

2660

这两个区别是

2661

这两个区别是它的仔鲢子节点会一起上

2662

他是不删自己点的

2663

这个是不是点直接点一起删

2664

因为她的

2665

这就意味着

2666

它的节点不一样了

2667

嗯

2668

然后呢

2669

如果不存在对应的节点

2670

创建同样也是要复制这个属性

2671

这就是丹姐的地府

2672

就这么多东西

2673

是很简单很简单

2674

其实但是你要理解他的话

2675

你就要

2676

你就要把这个咱们的玉氏的这两个规则放一起看

2677

现在看明白

2678

就是你才能理解他

2679

才能理解他

2680

因为他只能对同济来同济的来做单集的例子就是这么简单

2681

嗯

2682

对单击点确实是

2683

比较简单

2684

好这个能理解是吗

2685

能理解扣一个一

2686

分离接客呢

2687

是否全复印那个科目的问题就是复印我们是不是服用了赛尔节点

2688

对不对

2689

是不是复印了FAB节点的节点

2690

每个节点是不是有N多个属性同学

2691

看不见你的属性是很多

2692

所以全部的意思是说

2693

他是不是直接把整个的那个对象给复印过来

2694

啥也不改呢

2695

对不对

2696

他这实际上不是

2697

他实际上是先把它找到

2698

找到这个存在了

2699

然后他的瑞福瑞特要重新赋值

2700

其实就这么个

2701

其实就这么个变化

2702

因为原因是啥

2703

你的riff可能变

2704

你的riff每次都会变的

2705

Return他有可能会变

2706

好那就是多节点了

2707

多点对比

2708

单节点的要稍微难一点点

2709

要稍微难一点点

2710

他做了这么远

2711

谁看我写的东西都比较比较多嘛

2712

对吧

2713

多简单

2714

要难一点点

2715

他他要判断新的场景就是

2716

我我单几点

2717

就看他自己多几点的情况下

2718

他要考虑的是

2719

比如它的顺序打乱了

2720

对不对

2721

顺序打乱了

2722

我能否把它给服用出来

2723

顺序打乱的情况下

2724

这个时候其实就依赖于我们的K值了

2725

K值他就会去找

2726

他就会去找在reactor里面多挤点地方

2727

我们来看

2728

实际上有两次循环

2729

不是双重循环

2730

同学两次循环双重的话

2731

我们一般认为它是一层套一层

2732

两次

2733

就是先来一次

2734

再来一次

2735

这个很成为两次第一次

2736

我们先看一下

2737

他做了哪几件事情

2738

第一

2739

对比性

2740

就因为因为既然是数组

2741

那肯定就是两个数组的对比

2742

对不对

2743

两个数组的对比

2744

对比新旧数组中的相同index对象的K是否相等

2745

如果是返回该对象

2746

如果不是返回

2747

那

2748

就是对比相同index的对象就是

2749

二码

2750

对

2751

嗯

2752

这是

2753

老大

2754

老子也是个数组行好点拳迷

2755

在家家去

2756

嗯

2757

放大不了吗

2758

稍等

2759

我这文档太大了

2760

这文档写的太大了

2761

操作起来

2762

操作起来都有点卡顿

2763

现在可以吗

2764

还要吗

2765

还在大点儿吗

2766

行

2767

这是对比相同index的

2768

相同index的

2769

接着我这一个

2770

下面一个我们相同

2771

Index的K是否一样

2772

对吧

2773

我们先看一下有没有第一轮时间就找的是香

2774

第一轮循环其实

2775

就是找的是

2776

第一次循环找的就是比如相同的

2777

至少说我们这个节点一个一个对应过来

2778

我们是不是一样的

2779

这个是一个一个的

2780

然后第二次判断节点是否存在移动

2781

存在着反卫星的位置

2782

如果其实他他这是有逻辑的

2783

如果说存在新的速度

2784

其实小于老速度的情况下

2785

大家看如果是有新的数组

2786

如果是一个新的数组

2787

比如我这我小娱乐的数字

2788

即意味着它肯定有东西是需要被删除的

2789

对不对

2790

需要被删除的

2791

如果我有新的数组比老数组大

2792

那就说明我是有新增的

2793

那么我是有新增的

2794

这两种情况也判断了创建就是创建新节点

2795

如果是一个把把上面这些

2796

都处理完了之后

2797

然后呢

2798

他在会统一的再来找一次

2799

就是里边儿有没有可复用的

2800

里面有没有可以统一找一次

2801

这样避免遗漏

2802

避免遗漏

2803

我们从代码的逻辑上来看一下好不好

2804

从代码的逻辑上再看看

2805

第一

2806

这第一次是第一次

2807

大家这是第一个for

2808

这是第一个负循环

2809

第一个循环之后

2810

它有一个二的forever

2811

然后有一个new的index

2812

他刚开始是零

2813

然后是根据六桥墩的认识

2814

为他的

2815

为他的那个判断条件

2816

然后一直加一直加

2817

这第一轮其实就是判断的是我们的这个相同index的fiber是否可以服用

2818

如果可以服用

2819

其实就是这儿

2820

这个updates lot这个函数

2821

我直接给大家讲他的意思

2822

它的功能

2823

它它里边儿就是对比

2824

相同index对象的K是否一致

2825

如果是一致的话就返回该对象

2826

如果不一致就返回那所以这儿的罗

2827

所以这他直接是判断是否等于那

2828

如果等于

2829

那就说明K值不等

2830

那就说明它的顺序变了

2831

就不用对比拉结点不能服用

2832

第一轮逻辑就不用就不用管了

2833

就是第一轮复习完就结束了

2834

如果K值相等

2835

就意味着你没有几没有任何位置的变化

2836

位置没有变化

2837

那么他就

2838

只对比相同指的K就行了

2839

对比相同的K就行了

2840

如果出现了

2841

那就是写的有问题

2842

所以就说为什么刚刚我讲的前面那个例子说他他是负向优化

2843

如果你这样子写K

2844

那么他就一定会出现一样的

2845

那么这就是一个负向的优化

2846

你就反而会给他增加麻烦

2847

就如果出现的话

2848

那你那你要调整代码

2849

那个不能那么写

2850

好

2851

好他就先对比的相同index的

2852

如果是

2853

这是第一种情况

2854

假如他已经跳出了吗

2855

大家看刘index是不是上面内存循环

2856

上面内层循环的

2857

所执行到的认识

2858

假如他的中途

2859

如果他的中途被跳出了

2860

大家大家看

2861

假如他的中途

2862

比如某有某一个K变了

2863

K就不等了

2864

跳出了就是break

2865

这就只跳出了这种循环了

2866

对不对

2867

这种情况就直接跳出了

2868

那么我的new index肯定是小于new children s的

2869

这个大家能理解吗

2870

就如果中途跳出了

2871

我的new index肯定比他小

2872

所以啊

2873

能理解的扣个一

2874

我中途跳出去了

2875

我肯定比他小

2876

好

2877

下面就根据这个index的

2878

来判断了

2879

大家看如果new index等娱乐children刘超刘超吨的认识

2880

这意味着什么

2881

就说明我整个循环是不是都是整个循环都都走完了

2882

中途没有跳出的情况

2883

对不对

2884

如果它等于了他

2885

那就说明中途没有特殊情况

2886

那就是顺序一直是一样的

2887

顺序从来就没有变过

2888

那么他这做了一个东西

2889

之前讲的时候大家都蒙了

2890

Delete

2891

为什么还会delete

2892

原因是啥

2893

也就是说

2894

也就是说在

2895

在我整个都走完的情况下

2896

我的new index全部都走完的情况下

2897

存着极有可能存在一种

2898

极有可能存在一种情况就说明

2899

就是老的速度

2900

假如老

2901

因为他是根据

2902

因为它是根据这个新数组的这个认识进行判断的

2903

进行循环的那集

2904

可能存在我老数组的认识的角度比较多

2905

对我老数组有这么多

2906

我心素只有这么多

2907

我就算是Lin X等于六千点认识

2908

又敲重点

2909

认识到了这里

2910

我这儿全都就是这全都是没变的

2911

这全都没

2912

顺序是没变的

2913

顺序是没变的

2914

但是我脑子是不是还可能还有有可能是还还有这种情况绝对存在

2915

而在这种情况下

2916

他做了一个优化

2917

就直接把后面的给删掉

2918

所以这出现了一个delete

2919

因为因为前面的顺序没变的情况下

2920

而极有可能存在新速度小于老树的认识的情况

2921

那么就把后面的给它删掉

2922

这个就不需要再判断了

2923

这个大家能理解吗

2924

因为已经不需要判断了

2925

这肯定是减少了

2926

因为你顺序没变吗

2927

OK

2928

好这里这都理解了

2929

现在能理解了

2930

然后

2931

Old favor等于na

2932

说明

2933

数字中的就是老数字的东西

2934

X等于

2935

那老数组的东西都可以服用

2936

这个是o

2937

因为o的fiber

2938

大家看o的fiber

2939

他也是在曾随着新数组的就是new index增加

2940

Old farmer也在变

2941

看偶的发表一直等于sin o的发表也在变

2942

就是old后面看old一直等于Selina

2943

就等于next也在变

2944

如果o的FAB等于line了

2945

那说明什么

2946

说明我old法儿都已经走完了

2947

那这个其实是另外一种情况

2948

其实写的虽然就是rock写的有点儿不太好懂

2949

但是呢

2950

逻辑是好懂的

2951

逻辑是好着呢

2952

New old fiber为难的情况

2953

那就是这种

2954

我所有的old都对比完了

2955

还没有跳出

2956

也就是

2957

旧的节点

2958

旧旧的数组

2959

它是小于等于新的数组的

2960

这样子我的

2961

但是它有很有可能等于骂

2962

这个情况肯定是存在的

2963

但也有可能小于

2964

就是我们新速度有可能有新的节点

2965

有

2966

也很可能有新的节点

2967

我当我的FAB等于零的时候

2968

OK

2969

那么我们就看

2970

还剩下几个对吧

2971

这个是new index

2972

如果X等于

2973

那肯定只要找到这里

2974

那new index等于他

2975

对不对

2976

那后面这些

2977

如果存在那都是新的

2978

那都要创建

2979

因为这几个新的的话

2980

也不需要再对比了

2981

创建就完事儿了

2982

再找人理解嘛

2983

理解扣个一

2984

对他逻辑其实你看这个代码写的复杂

2985

但它逻辑是简单的

2986

对不对

2987

逻辑是简单的逻辑

2988

我们我们如果自己要

2989

做这样的

2990

做这样的那个优化

2991

我们可以不写他们这么复杂

2992

他可能考虑的场景比较多

2993

我们可以不写那么复杂

2994

但是我们可以

2995

使用他的这个逻辑

2996

你看他什么呢

2997

FAB等于linein X等于认识

2998

Ad等于

2999

那就是不好好给你写不

3000

你重新用个上面变量给它标一下

3001

是不是逻辑看起来会更加清晰好懂一些

3002

但他但他没有

3003

所以我们的逻辑好懂

3004

但是代码不太好懂

3005

就这个意思

3006

下边儿

3007

下边这个

3008

就是最后最后一章

3009

如果它顺序被打乱了呢

3010

对吧

3011

顺序要是被打乱了

3012

那上面的情况

3013

那肯定就是属于中途被跳出了

3014

那么就是这

3015

这其实也是一种很经典的一个

3016

方法吧方法吧

3017

就是他先

3018

他先把老的做成一个map

3019

大家看他把老的做成一个map

3020

这个map to returning children

3021

他把剩下的老的做成一个map

3022

然后新的来找

3023

来找他是

3024

是否可以服用

3025

这样子是干什么

3026

这样的话可以减少复杂度

3027

减少复杂度

3028

这就相当于如果我们不用这种方案

3029

其实他

3030

现在他要做的事情

3031

这个他要做的事情就是对比两个数组

3032

他要对比两个数组

3033

里面的东西

3034

有没有一样的

3035

按正常的想法对比

3036

两个速度有没有一样的

3037

最简单的逻辑

3038

那肯定是双层循环

3039

它的复杂度是o的平方

3040

对不对

3041

OPPO的a的平方

3042

因为对比两个数组

3043

你没有办法

3044

你只能够

3045

你只能够你要对比的准确的话

3046

那么你只能够一个循环套一个循环OM的平方

3047

而这实际上是一种非常非常普遍的一种优化

3048

就是我把其中的一个

3049

比如把它做成一个

3050

做成一个map

3051

这是一个map

3052

那么它就相当于是循环了一次

3053

在下面这个数字

3054

然后便利下面这个数字

3055

然后那从这个map中找

3056

可能是ID

3057

有可能是ID

3058

这他是K值

3059

这他是通过K值来找的

3060

通过K值作为它的map

3061

作为他那个漫步的K

3062

那么K其实就是对象嘛

3063

对吧

3064

对象的键值对的K

3065

也就是说它循环了一次

3066

做成一个map

3067

循环了第二次

3068

来找他的K

3069

这样的话

3070

它的复杂度就是二的

3071

二的N2的on

3072

他把复杂度成功地从on的方降低了二的

3073

这样能理解吗

3074

理解的扣个一

3075

不是你理解的扣个零

3076

应该遇到过这

3077

应该遇到过这种场景吧

3078

上周有同有同学还还问过另外一个问题

3079

其实就是就是比如说当时问的那个问题是我一个数字

3080

一个老树组一个新数组

3081

他想他要对比这个

3082

他要对比

3083

新的速度是就他这比那个

3084

新数组里的那个

3085

IDID如果等于老师的ID

3086

他要把它替换掉

3087

然后他想知道就是能不能不用三种情况的这种方式

3088

有什么优化的方法

3089

然后我就告诉他这种方法

3090

就成功的把复杂度给降低了

3091

就这样

3092

就是这样

3093

所以从源码里其实能学到不少东西

3094

但这个你如果仔细的去想

3095

其实也能想到

3096

也不是他也不是他独有的也能想到

3097

OK

3098

单击点的不多点DF就讲完了

3099

多点DF

3100

会比单机的地方麻烦一些

3101

咋不了K中判断会拿K中判断同学

3102

但是我没把它代码列出来

3103

它在这个方法里面

3104

在这个update from APP里累不

3105

这这我讲的吗

3106

他这个

3107

这个方法它会把它做成一个map

3108

这个map的K值

3109

这个map的那个键值对

3110

其实就是键值对吗

3111

键值对就是一个K

3112

然后一个forever

3113

所以他在update from map的时候

3114

怎么from map

3115

那他肯定通过K去找吗

3116

但是他还要这个

3117

不光是index的时候

3118

他还要替换回去

3119

他还要千万回去

3120

对

3121

你这个也是2N

3122

你这个也是2N

3123

但是你做成map

3124

它的场景要更全面一些

3125

你用include来对比的话

3126

那你还要找到他

3127

让他再给他付值

3128

对不对

3129

拍

3130

再重新给它赋值

3131

都是一样的

3132

嗯

3133

没K直接pass了吧

3134

是的

3135

没K的话

3136

那既然没有K呢

3137

就找不到吗

3138

找不到的话

3139

那么他就得充电了

3140

就得充电了

3141

这个逻辑我没有写

3142

没有写出来

3143

但是我跟了

3144

我这是跟着带码的了

3145

代码的

3146

它这就是一个map

3147

就是我们的绿数组的这个绿

3148

就是JS里面的new map它的K

3149

他那个建筑的K

3150

就是里面这个克制

3151

所以这对比也是很方便的

3152

其实就是这个逻辑

3153

对吧

3154

还是说哪句话

3155

他写的复杂了

3156

他我觉得他写的复杂

3157

可能不够

3158

不够语义化

3159

但是他的逻辑还是很好懂的逻辑还是挺挺容易懂的

3160

对不对

3161

OK

3162

然后啊

3163

剩下的在begin work里打上flag标记

3164

这个就不说了

3165

已经讲过了

3166

毕竟这是re cons or

3167

这个阶段就讲完了

3168

这个阶段讲完了

3169

接下来我们还剩一个大的模块

3170

但是这个模块很好讲

3171

很好讲

3172

其实前面的主要主要的活儿就是re cons ter干的

3173

Consider干了很多

3174

接下来我就直接给大家讲这个人的阶段

3175

或者说commit阶段

3176

他做的一件

3177

它其实主要就做一件事情

3178

把变化的组建渲染到页面上这么一件最要紧的事情

3179

而由于操作当时最昂贵的一件事情

3180

JS的性能瓶颈在哪里

3181

大家都知道吧

3182

JS的性能瓶颈就是操作DOM上面

3183

所以为什么刚开始从这块儿要过渡到

3184

过渡到那个像react Vue这种数据

3185

其实是框架

3186

第一个原因是因为是响应式的

3187

那么第二个原因是

3188

用j query

3189

他每次都要每他每掉一次就操作一次down

3190

对吧

3191

它的它的那个性能

3192

它的性能的这个上限很高

3193

下限同样很高

3194

同样很低

3195

因为你如果如果写的差的话

3196

那你每次操作但不太多了

3197

你的页面会极其的卡

3198

但他上线又很高

3199

上限就是你真的知道什么时候该操作

3200

什么时候不该操作

3201

那么

3202

那么你

3203

你的性能不一定比用react

3204

用VB写性能差

3205

这块

3206

ER ret和view这种数据驱动视图的

3207

他由于有JS的这么一个过程

3208

就是结石做当地府对吧

3209

向wreck的运行时的

3210

逻辑尤为繁重

3211

运势的这个开销尤为繁重

3212

所以所以他他会额外比直接操作当会有一部分的开销

3213

但是呢

3214

他实际上是给你的一个君子

3215

就是保证了你性能的最低限度是什么

3216

他给你保证了

3217

你就算写得非常一般

3218

对吧

3219

就算写得非常一般也也慢不到哪去

3220

你要是再懂点儿优化的话就更好

3221

你如果想要非常牛逼的性能

3222

那么你肯定不会用没有react

3223

因为他们会有一部分的JS是超杰

3224

是运行的时候的一些性能开销

3225

就比如说像这个re consider扔的

3226

扔在阶段

3227

那么这种心理开销他是存在的

3228

所以他是我觉得他是保定的一个性能最低的一个下线儿

3229

操作当非常的昂贵

3230

所以在这个

3231

操作昂贵的过程

3232

它的优先级会是最高的

3233

就是它会run with property

3234

这儿有一个最高优先级的就是

3235

就是那个immediate immediate priority

3236

立刻执行的那个优先级

3237

然后就执行compute

3238

所以他就干这么一件事情

3239

其他的啥也不干儿

3240

干这么一件事情呢

3241

分为三个阶段

3242

第一个阶段是

3243

更新当他的钱

3244

但操作中

3245

操作后

3246

分别在当操作前和当操作后分别对应两个生命周期

3247

而当操作的话就直接操作

3248

当操作钱就是给你最后一次更改的机会

3249

一个勾子叫做get snapshot before update

3250

我们在begin work里也看到过他

3251

只不过只是给他打上一个标记

3252

对不对

3253

只是已经看到过他了

3254

只是把标记给他打好了

3255

标记给他打好了

3256

然后我们看一下他做了什么事情

3257

第一

3258

处理单结点渲染删除后的澳洲

3259

FOX blue

3260

Bloom逻辑这个的话其实还好

3261

第二个就是当超

3262

当宣传

3263

就是当操作前骂

3264

那咱们几点见点钱

3265

就是要要更新前

3266

然后做一些准备工作

3267

再调一个你掉一个

3268

你还有最后一次更改的这么一个机会

3269

的一个生命周期的勾子

3270

他是不是就类似于浏览器提供的那个叫request request animation frame

3271

他也是在浏览器每一帧调用之前也给你一个机会执行方法吗

3272

这其实也就是一个勾子

3273

可以在当学生当真正操作前来掉第三个

3274

它会调度you the fact

3275

有同学可能这就有点迷糊了

3276

之前有同学就迷糊了说

3277

我记得就是有同学就说

3278

老老师use the fact

3279

我记得他适合

3280

他是在当操作之后才掉的

3281

他he demanded应该是同一个时期的

3282

同一个时期的方法

3283

说的没错

3284

说的很对

3285

但是这里他是我并没有说调用儿

3286

说的是调度调度usage effective

3287

因为

3288

You the fact

3289

他实际上并不完全等价于

3290

Component demand

3291

的那个调用时机

3292

它是异步调用的

3293

ER component did mount是同步调用什么

3294

而他调度usage就是她

3295

比如衣服

3296

我们知道

3297

就会给他设一个类似于山猫的

3298

对不对

3299

那他解假如

3300

假如这么简单吗

3301

他的C

3302

他猫的时机

3303

那就是在这个地方设了

3304

于是他并不会在这个时候就立刻执行use effect

3305

那个call back

3306

这个能理解吗

3307

这样能理解吗

3308

他是在这个地方调度的

3309

不然大家如果下来真的看代码的话

3310

看到这儿可能就就觉得有点懵

3311

他也不是注册

3312

他是先

3313

他就先发起了嘛

3314

他就先发起了

3315

但是因为他这个一步的

3316

他在红任务当中运行

3317

对吧

3318

他也在红任务当中运行

3319

所以他会等你整体这个主线程执行完了之后

3320

再执行那个红任务当中的扣back

3321

他在这儿已经发起了

3322

但是这个课的最终执行并不是在这个位置

3323

能理解吗

3324

OK

3325

然后我们就可以看一下代码

3326

代码其实非常简单

3327

这个是react已经优化过一部分的带一版的代码了

3328

之前写的很乱

3329

那现在写的比较简单

3330

第1FAVOR得到一个第一个fiber

3331

然后呢

3332

如果发不等于

3333

那那么看一下

3334

如果看下是不是要删除的

3335

如果是要删除的

3336

就去注意它的一些out of focus blue的这些逻辑

3337

这个就不展开讲了

3338

拿这儿如果他有子节点大家看

3339

如果有子节点

3340

那么先处理这是递归

3341

这个和它是一样的

3342

打个标记

3343

这个他是一样的

3344

他这是在递归就是

3345

然后这儿完了之后

3346

它才会执行他自己的这个come come it before mute Asian effect in July

3347

其实这个就是为什么说在REC的生命周期中

3348

它的的MT也好

3349

Complaint啊

3350

给snapshot before update

3351

他都是

3352

子节点先执行这个生命周期

3353

直接点先执行这个生命周期的逻辑

3354

在这里

3355

因为他是先帝规处理的子节点

3356

然后才出去的

3357

自己先先让自己的子节点的这个

3358

先自己减

3359

这个生命周期调

3360

然后他们调完了之后

3361

才会调用自己的就是地位处理子节点

3362

他是不是又来到这儿

3363

如果有直接点

3364

那又又处理直接点

3365

你知道没有子节点

3366

然后呢

3367

他才处理父节点

3368

就是他在那个render节

3369

就是render阶段和这个re consider阶段

3370

他们的这个生命周期的这个调用的顺序是不一致的

3371

他们完全是两套顺序

3372

同学们

3373

他们完全是两套顺序

3374

然后呢

3375

才返回兄弟

3376

也是先先紧着自己的直接点

3377

然后呢

3378

再来自己

3379

那自己处理完了再处理兄弟几天

3380

就这么回事儿

3381

这这就是第一个循环

3382

其实对于render面试的时候

3383

是非常好讲的

3384

他就三个大外

3385

就三个大循环

3386

三个大胸

3387

但肯定不是嵌套的三个

3388

第一个就是这个

3389

但操作前的这个大循环

3390

第二个档操作中的单操作

3391

这么来看同样也是一样

3392

这个delete他每次都会这样

3393

都会这样一下颜色family child不等于那的规

3394

如果

3395

如果等于浪了

3396

自己

3397

大家看这里的话

3398

和上面的结构是完全一样的

3399

死

3400

完全一样

3401

但是对删除组件呢

3402

它就执行VRMT这个方法

3403

这个是在

3404

这个是在

3405

这个是在

3406

怎么啦

3407

这个是在当操作中

3408

当操作中这个阶段调用调用

3409

所以严格来说

3410

Component will mount的这个生命周期

3411

它的执行时期肯定在determined之前

3412

对不对的嘛

3413

之前因为demand是在最后才执行的

3414

这这这

3415

大结构同样是一样

3416

第三个

3417

第三个这里稍微多一点点东西

3418

怎么啦

3419

一个是一个是

3420

他要处理

3421

一个是他要处理

3422

按照上面的一个循环翘的不等于

3423

然后就递归

3424

递归还是先处理自己

3425

自己点

3426

如果自己点

3427

没有那么就

3428

在在走自己的带走自己的生命周期

3429

这个地方是执行use layout INF ECT只会掉

3430

如果这个地方是指的是方形comment方形comment

3431

如果有hooks

3432

那么他肯定就自行used your defect

3433

这这处理的稍微多一点class的话

3434

这就自信

3435

真正执行的MT的地方就执行这个

3436

所以严格来讲

3437

Use layer odd effect才等于卡斯组件中的demand

3438

ER you slay out you the fact的区别

3439

这是面试常考问题

3440

Usually you out

3441

He you the layout affect和effect

3442

区别

3443

就是use effect是个异步的user yard是同步的usually I de fec

3444

同步的ER usually or defect其次比较严格

3445

等于

3446

Component did mount的这么一个执行17

3447

他们都是同步执行

3448

就是在ER effect刚刚我们看到它其实会把它放到宏任务当中

3449

执行一个异步的逻辑

3450

衣服的逻辑

3451

所以根据这个又衍生出了一个新的面试题

3452

大家有没见过就是

3453

就是这里

3454

嗯

3455

还是生命周期

3456

就是生命周期的顺序

3457

比如a

3458

对吧

3459

这是个比如方向组建和class组件

3460

他们连在一起来考虑考察这个问题

3461

比如ABC3个组件

3462

ABC3个直线a

3463

的生命有生命周期

3464

然后呢

3465

B有生命周期

3466

C它没有生命周期

3467

但是他这个hooks

3468

那么他的执行顺序是什么

3469

这个你

3470

你非得了解you the effect he usually also affect

3471

区别这我给大家说一嘴

3472

Usually are you the effect

3473

他这个CC肯定是最后的

3474

不管怎样

3475

他肯定是在最后

3476

因为它是异步的吗

3477

大家大家叫着他一步

3478

他就会把它放在最后面

3479

对不对

3480

我们可以来看看

3481

比如说a extension

3482

那么

3483

A

3484

包含了两个组件

3485

XBXC

3486

这里一个demanded

3487

一个get snapshot before update这两个

3488

属性

3489

这两个生命周期都是在任何阶段的

3490

所以他们都是先优先直接点的

3491

对不对

3492

其实他们是优先子节点的

3493

而他们的子节点是B和C

3494

对

3495

衣服的都放在最后

3496

是的

3497

但是你要

3498

但是如果你不知道usually ah the fact he uses的区别的话

3499

你就不懂

3500

你就你就

3501

你就做不对

3502

就这个问题肯定就做不对

3503

是不是

3504

所以

3505

我们就就看的MT就行了

3506

这个snapshot的up data适合他的逻辑是一致的

3507

你这

3508

他有个的帽子

3509

他一肯定不会先打呢

3510

我们来看一下B和CB

3511

B为底的话

3512

那么他会先执行B对不对

3513

先执行B

3514

然后呢

3515

执行C的弟弟

3516

因为我说了

3517

Usually are out effect

3518

他基本上他比较类似于component的执行时机

3519

所以他会先打二对不对

3520

然后再打B的兄弟节点

3521

C的这个u CL effect就是滴滴滴

3522

二

3523

滴滴的

3524

而这个CC由于它是一部的

3525

所以先不会执行

3526

然然执行a的

3527

一

3528

最后自信谁谁谁

3529

明白吗

3530

对

3531

有同学已经给出了正确答案了

3532

很棒

3533

同学们比较强

3534

非常强大的

3535

那么这个我觉得已经由这个问题延伸出来的

3536

比如这个问题你们也会了

3537

衍生出来的这个生命周期的问题

3538

我觉得大家也会了

3539

对不对

3540

也会了

3541

我们再来看

3542

他除了这个还做了些什么

3543

我们刚刚讲到他还做了一件非常重要的事情

3544

这个复制瑞福

3545

瑞福他也是在

3546

因为他是可以拿到

3547

如果对于当节点

3548

它是可以拿到当元素

3549

如果对于react组件

3550

它是可以拿到整个reg组建的实力的

3551

所以他的副职也是在

3552

最后commit这个地方

3553

就是最后commit阶段的第三个大V

3554

就是demand这个阶段唱当操作之后

3555

以及还有一个重要的不重要的一件事情

3556

那就是

3557

把

3558

一

3559

这个我

3560

我打了黄色标记的care and a tree

3561

在这个时候会发现纸箱会变

3562

和我们之前所讲的就联系起来了

3563

我们刚刚不是讲了双缓存结构嘛

3564

一个ref I ber

3565

对吧

3566

一个是ER ECT routes

3567

他有care and属性

3568

指向了一个current组件

3569

然后呢

3570

构建一个新的working process street

3571

然后当

3572

页面变更完了之后

3573

他就会把它给纸箱最后一股拿了纸箱

3574

我们最新的work in progress the work in progress re

3575

就转正了

3576

就成了Karen的T了

3577

这是chemistry

3578

这个我好像没有粘出来

3579

我可以找一找

3580

我可以找一找

3581

这样

3582

我们就来

3583

稍微看一下吧

3584

再看一下他肯定在这个阶段做的

3585

嗯

3586

Black里面逻辑其实很多的同学们

3587

很多的远远远远不止我讲的这些

3588

但是

3589

但是我讲的这些其实是它的最主要的价格的这个逻辑

3590

有很多东西是可以往上靠的

3591

负责riff

3592

帮我找一找点Kevin

3593

那就是

3594

嗯

3595

哪些人

3596

应该是在调他之前

3597

123串

3598

我还在还在

3599

他累不

3600

四

3601

干啥去

3602

让我找找

3603

否则re

3604

否则这个地方

3605

帮我看看饿的呢

3606

看的有没有

3607

这里漏点current等于

3608

Finished work

3609

Parent

3610

Carrot变了

3611

大家看current

3612

这就是root

3613

那个root的指向吗

3614

绿色之下

3615

嗯

3616

咱这个地方

3617

的那个双缓冲结构

3618

烧化成结构

3619

对不对

3620

Wrote the current指向一遍

3621

做这么一件事情

3622

那这件事情在

3623

哪里呢

3624

也在

3625

看

3626

Commit commit mute Asian INF ECT

3627

新的他的地方肯定发生

3628

他的名字肯定变了

3629

但是他的罗

3630

他的地方肯定是不会变的

3631

在此之后

3632

如此奸嘅指向working progress

3633

Working policy as commit a relation in fact

3634

之后就是把党员县的页面之后

3635

然后又在

3636

又在这个函数之前

3637

这个就是执行我们的

3638

Component的demand生命这些之前他把它给变了

3639

就是这样

3640

这就是我们今天所讲的re consider和render

3641

两块

3642

Red

3643

其实开干扰很简单

3644

我们的RI cans are

3645

我们大概讲了一个半小时

3646

Render

3647

可能就20分钟就讲完了

3648

非常

3649

因为它其实就三个well

3650

没有什么过多可以讲的

3651

接下来讲讲这个

3652

Rock的刚re consider

3653

这个就是我所说的re consider的单独的封装

3654

Wrecked把re consider给封装成了一个独立的模块

3655

什么好

3656

这样做的一个好处就是你不管是浏览器的环境还是原生的环境

3657

你如果用react的形式来构建

3658

你都需要构建February

3659

而这个逻辑是公用的

3660

所以REC to re consider就可以完全拿来服用

3661

就像我们的那个

3662

京东的terra对吧

3663

京东terra塌陷reg写法

3664

那么它直接就用re cons ER就可以

3665

然后开始就可以就这样浏览器

3666

Write down

3667

浏览器里面我们就结合right down right

3668

只要re consider

3669

当然red down的时候

3670

他是不会让我们掉的

3671

他是那个刀内部会直接掉

3672

Re consider

3673

它是内部就掉了

3674

而像你如果想要写新的

3675

比如

3676

而且relative也是内部调的

3677

如果你想写新的

3678

比如像Tara

3679

比如像Tara

3680

那么他就引入这个red re cons are cool

3681

然后呢

3682

再写一个render e

3683

我们来看一下这个方

3684

我们看一下这个库

3685

这其实是

3686

如果说大家以后想写一个类似享用react的

3687

写法

3688

写一个类似的跨平台或者那么一个

3689

框架的话

3690

那么可以用到它

3691

那么可以直接用到它

3692

会非常方便

3693

会非常方便

3694

它用法很简单

3695

第一

3696

引入他

3697

然后写一个config

3698

把他关键的一些API给替换了就完事儿了

3699

比如说在write down里面

3700

在浏览器环境下

3701

它创建一个元素

3702

就是我们是不是叫做document.create element

3703

这是创建函数的方法

3704

创建创建元素的方法那么假如你是小程序

3705

那么你就你就把这个方法给改了

3706

就是create instance

3707

你就把它给改了就行了

3708

改成小程序创建名字上了

3709

就完事儿了

3710

然后呢

3711

他有很多的

3712

他有很多的就是一些

3713

就是这个class里面会有很多的这个属性

3714

这个它有很多这个属性

3715

属性你你可以把它替换了就完事儿

3716

所以这个写起来的话

3717

你就相当于你重新创建了一个跨平台的一个方案

3718

但实际上

3719

但实际上他的逻辑却很简单

3720

而且还服用了rap的这个

3721

这个很强悍的运行时的优化

3722

都说Tara的API不太全

3723

网上解决方案也少

3724

当时用的是是

3725

Tara的

3726

API你你是用的是

3727

几啊

3728

应该是几

3729

后面应该还行

3730

TARA3是他是38CHIRON ex

3731

但是用telnet它就已经用了这种方案

3732

因为你如果单用小程序写

3733

已经就是来一个一个APP一个APP的转

3734

已经不太方便了

3735

所以TARA3就是最新的那一版

3736

他用的这个方案

3737

最新的那一版采用这个方案

3738

以前的时候不是以前的

3739

并不是直接调到X

3740

最新的是

3741

可以这么说

3742

所以如果说大家有需求

3743

自己想写一个

3744

比如说想在shell上写个什么玩意儿

3745

你可以用它

3746

对吧

3747

这是一种方案

3748

如果说要需要你以后作为一个高级工程师

3749

资深工程师

3750

然后来做一个全面的方案选型的时候

3751

那么这就是体现你价值的时候到了

3752

你完全写一个不同平台的渲染器

3753

那么是完全可以的

3754

大家可以下来也可以看一下这个库

3755

好

3756

今天我们讲的话就讲到这儿吧

3757

然后晚上的话

3758

我们会再讲接下来的护士的源码的解读

3759

以及以及Jess CA

3760

然后REX18带来一些新的变化

3761

现在就下课吧

3762

同学们

3763

可以休息会儿

3764

休息会儿

3765

晚上八点钟的时候我们再见

3766

好吧

3767

这儿绝对有bug

3768

行

3769

这块儿

3770

这个咖啡的流程的流程这块儿能明白吗

3771

明白了给大家

3772

扣个一不能再扣一个呢

3773

有意的话我们就下课了

3774

行的话我再讲讲

3775

同学

3776

你刚刚有没有认真听

3777

Get snapshot before update

3778

Render看render有三个流程

3779

有三个循环

3780

第一个循环

3781

适当操作前

3782

他会调这个get a snapshot before update第二个循环

3783

适当操作中

3784

这个地方并不掉生命的记忆的方法

3785

第三个循环是当操作后

3786

这个地方会掉的MT

3787

所以肯定是before update掀掉

3788

然后did mount后调

3789

好

3790

这块还有不明白的吗

3791

行

3792

那就下课吧

3793

你下课吧

3794

下来晚上的时候我们再把

3795

他妈收尾

3796

反正在收尾

3797

行

3798

朋友们辛苦啦

3799

拜拜

