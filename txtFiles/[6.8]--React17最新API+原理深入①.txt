1

思念

2

滴答

3

滴答许

4

告诉

5

哒哒

6

哒哒哒哒

7

东西嘎洒

8

Hello

9

孤独

10

你该死哪

11

没多久

12

梦里的叹息

13

多么大

14

希望

15

吧

16

一米

17

伊玛目

18

Kiss

19

提莫洛希诺丝的

20

哒哒哒哒

21

哒哒哒哒啦

22

微凉的车

23

车是扶持八路由

24

的残酷

25

一切都为了通往圣堂的路

26

吹不散

27

水轻柔

28

着

29

我们每天都追着不同的罪

30

我能决定谁对谁又该要沉睡

31

争论不能解决

32

在用我自己的关掉的最唯一的站在前面的人都有最后面无路可退

33

吃亏就像

34

深藏

35

希望我的左手

36

没关系的

37

结果他就让我去战场

38

弱智

39

等下我们08:05的时候开始

40

根据以往的经验

41

八点钟应该来的不是很多

42

承受

43

着

44

这个这个

45

小说

46

的

47

天空

48

下

49

着我的双手

50

一卡一卡

51

的沙

52

一朵

53

最喜欢我的左手美国吃的承诺战场

54

作为艺人蓝色联盟推动烟花的撒珊序幕

55

开始

56

逐渐减少

57

长春

58

承载着

59

整个世界的我们一起来祷告

60

请

61

丞相

62

坠

63

坠

64

守

65

着守

66

着

67

说说

68

感觉

69

冲上家庭的莎莎这样守着

70

撒

71

着

72

陌生

73

跟我聊啥呢

74

迷谷浪刻薄那旮瘩大米

75

妻子

76

快乐

77

度过

78

何必有我

79

大哥

80

一路好地方诺

81

的日记卡

82

好自由

83

But me I know he I want

84

you

85

抖的修路

86

高

87

比

88

随花落

89

咔咔

90

咔

91

喋喋不休

92

同学们

93

对

94

第一次见

95

第一次见同学们

96

今天我们就开始上

97

我们正式开始我们的课程了

98

我们

99

对

100

我姓何

101

大家好

102

我姓何

103

大家可以叫我何老师

104

那我主要是给大家讲那个react的源码系列

105

一共有三节课

106

然后今天报了三节

107

然后还有周天有两节

108

然后一共三节课

109

我们会讲到哪部分呢

110

我们会讲大概会讲

111

大概会讲到

112

一个是其实会讲到整个Rex的那个

113

你会讲怎么学习源码

114

然后呢

115

React它里面的价格的眼镜

116

以及他现在REACT17

117

我主要是

118

基于之前REACT17来分析的他的三大块

119

三大块结构怎么样

120

然后最后会给大家讲一下

121

就是REX18

122

然后带来一些新的变化

123

以及还有一些常用的一些面试题

124

就是常用的he right相关的一些面试题

125

会给大家做一定程度的那个就是这是之前班主任老师

126

然后收集了一波

127

就是正经的

128

就是在大厂面试问到的

129

经常问到的一些题目

130

也可以给大家做一些那个归纳

131

我我是四川的

132

我四川的现在在北京

133

老家在四川那边

134

老家是那个好

135

我们先来看一下那个rap的源码源码吧

136

这个是我下载的网上的RIGHT17.0.0

137

然后这个版本就是这个版本的源码

138

其实我们可以看一下它的源码

139

如果你看

140

你看一个rock的源码

141

一个那个开元的一个框架

142

如果它里面有很多东西的话

143

基本上都是这种结构

144

基本都是几个

145

如果你在你们公司里

146

如果说

147

你们也想发布一些包

148

然后到NPM上发布包

149

NPM上

150

那么那么你可能有一个一类的包

151

对吧

152

你发不不可能只发布一个包

153

其实也都是用这种结构

154

比如外边儿

155

外边儿有一些那个文件

156

比如说这里向他这里很多

157

不过他这里像yes

158

Yes ignore get e nor这些都是必须的吗

159

他这里还有像

160

我看看

161

这个是背包

162

这个danger danger danger fell

163

这个danger fear就是来

164

他是在那个C上来去执行你要检查的某些东西

165

如果如果你的检查不通过的话

166

那么他就不会通过

167

那么就会给你打过去

168

提交上就不能提交成功

169

等这些塞的检查检查下

170

然后一般script这里边儿是拿来放什么

171

拿来放

172

我们用来打包构建相关的东西

173

一般用一个文件夹叫做script发

174

大体的话大概然后我们

175

然后我们的罗

176

我们的安全包

177

然后会放在packages下面

178

大家看这个package package下面我们可以看到一些熟悉的

179

除了我们经常熟悉的lac之外

180

然后你看还有REC的开始第一位臭写在里边

181

所以他每一次每一个都可以把它

182

应该都是可以把它打造成一个恩平包的

183

大家看每一个都其实都是可以打造成一个面包的

184

所以这个pacs下

185

它相当于是N多个恩平分包的一种结合

186

一种就是放在同一个仓库里

187

放在同一个仓库

188

然后还有他应该是用

189

真的没有用那个

190

好

191

所以我们的源码部分的话

192

大概都在package下面儿

193

我们今天也肯定也看不了这么多

194

肯定看不了这么多

195

所有的我们会看react

196

然后write down

197

以及he right

198

但他会依赖什么

199

它会依赖这个schedule里面的东西

200

Schedule就是我们的调度器

201

调度器REC的REC前期的就是它有一部分的逻辑

202

它是放在skater里面呢

203

我们也是

204

随时会用了

205

还有这边大家还可以看到其他像这个relative render relative没有在这里面

206

但是有个relative and or还是wreck to re consider

207

这个后面都会给大家提到一嘴

208

提到一嘴

209

其实它在我们进行代码的分析当中就会涉及到re consider和这个schedule or

210

这两块其实还是蛮重要的

211

到时候给大家提

212

以及这个react native render也会给大家提一提

213

这就是我我们及我们所要讲的内容

214

然后之前有很多同学

215

然后就有疑问

216

就是比如他们就问就是就到底要怎样才能

217

到底要怎样学习源码

218

因为源码的话

219

一般学习比较枯燥

220

而且也比较困难

221

所以

222

所以有必要给大家先做一个这个如何看源码的这样一个讲解

223

你要看源码

224

首先第一个要点的做源码分析

225

其实确实是有点儿

226

相较之于使用来说

227

确实是会比较难一点

228

但是为什么要做圆满分析呢

229

因为有的时候比如

230

有的时候你在生产环境下或者开发环境下

231

如果你遇到某一个问题

232

遇到了某个问题

233

然后网上又没有现成的答案可以去帮你解答的时候

234

你就只剩下一条路

235

那就是看它的源码到底是怎么样写的

236

因为我们前端有有那个NBNNPM仓库

237

大家平时不用恩平包肯定是不可能的

238

那么

239

或多或少都会用到恩平包

240

那么你要是遇到

241

你要是遇到有一两个NB吧

242

正好正好出现了某些问题

243

而这些问题就是别人所没有遇到过的

244

那么这个时候怎么办呢

245

他们就只有通过阅读源码来解决

246

阅读源码然后找到出错的位置

247

或者找到运行就是不正常的位置

248

然后来调试

249

然后来找到

250

然后才找到就是具体定位到哪个地方

251

或者是你到底是你的写法不对

252

如果是你的写法不对的话

253

那么你可以改变自己的写法

254

那么更有可能的是

255

可能就是这个包里面有一个bug被你给碰上了

256

那么那么你还要提个eater

257

提个issue

258

然后给那个报的作者呢

259

这个这个

260

所以阅读源码其实对于前端来说

261

其实是以下

262

对于高级

263

高级前端工程师来说

264

是一项必备的一项技能

265

必备的一项技能

266

你不能够排斥这个

267

不能够排斥

268

也不能够

269

就是抵触

270

抵触这个有之前又遇到有同学说

271

那我为什么要学习源码

272

我用rap的感觉用的已经挺溜的了

273

那是因为你没有遇到问题

274

你如果真的遇到别人也从来没有遇到过的问题

275

那么你就会如果如果真的遇到了

276

那么你其实就很难很难解决这个问题了

277

要能解决这个问题

278

所以这个是我们阅读源码的一个非常重要的一个一个原因

279

就比如我前几次遇到的

280

就是我们在定位rocked

281

如果写的不好

282

不好的话

283

可能有的时候会出现新的问题

284

那么那么你要定位到底是哪个组件

285

或者说是哪一部

286

出现了怎样大的性能开销

287

那么你要去分析

288

你就得干什么分析

289

一般一般这个分析都要

290

这是通过我们的performance分析性能

291

分析性能的时候你会发现什么

292

你会发现这里面有

293

你会发现这里有

294

这里有很多就是react源码相关的东西

295

正好也看

296

我没有运气

297

我没力气

298

如果说你这样分析的话

299

他的这个为他在这些位置上

300

它会出现一个什么呢

301

每一个函数

302

比如你

303

比如这这一段

304

然后是某个函数调用的战的时长

305

这段是某个函数站的时长

306

而你在wrecked如果用red开发

307

你就你就发现它有很多食材都是right内部的鸽子

308

内部的函数给占据的

309

那么你要分析他到底是具体某一个地方

310

有新的开销

311

有新的问题

312

你怎样才能顺藤摸瓜的找到那个组件

313

或者找到那个位置

314

那么你

315

如果懂表演相关的源码

316

那么其实找起来的话也会比较快

317

也会比较快

318

这就是我们要学习源码的理由

319

那么我们怎样学习呢

320

你首先要看源码的话

321

我觉得第一件事情就是你首先你首先得是他的用户

322

比如你是re

323

你要看red的源码

324

那么大家首先需要掌握的就是它的API

325

就是他那边我们没有办法

326

就是一行代码一行代码

327

一行代码

328

就是说

329

就是没有这么看源码的

330

就是从这儿歌有的同学这么看

331

原版的从这儿第一行是什么

332

然后一直从里面找找找

333

然后

334

一行一行的看

335

这种是绝对不行的

336

这是绝对不行的

337

特别是像like这种大库

338

他源代码实在是太多了

339

而且有很多的功能是经常缠绕在一起的

340

经常缠绕在一起

341

你很难就是通过一行一行代码去把它给读出来

342

而有些裤子可以有些不可以

343

比如说之前未向web1.0的时候

344

向web1.0的时候

345

它那个功能我当时就把他原版扒下来看了一下

346

然后

347

基本上你可以一行一行的往下看也没问题

348

但是这种即使是一些小的库里

349

一行一行看下来可能

350

有一些细微的地方你还是不明白

351

这种时候就得调试运行的来看

352

所以第一件事

353

如果建议大家看原版的时候

354

第一首先你肯定要知道他是哪个API

355

你要掌握哪个X哪个API

356

然后你掌握了那个API

357

就是你学会用了这个APP

358

你至少知道他是干什么的

359

然后你就来针对性的看这一个地方

360

看这一个位置

361

站在一个位置

362

而如果你还不明白的话

363

我们其实通过

364

Chrome的这种的bug的形式

365

我们实际上是可以通过断点然后打进去的

366

比如我们city state

367

对吧

368

假如一个city state

369

我们我们

370

我们的开发者所写到的调用的代码就是city state

371

它里边到底怎么运行的

372

那么你可以跟进去

373

一个一个的来的bug的bug

374

那么这是第二步

375

如果你是第八个

376

不明白的时候要学会抓大放小

377

因为像react和其他的酷

378

一喝鸡巴喝加速相比其实算是一个比较庞大的一个类一个内裤了

379

它里面的逻辑

380

比如说sight的逻辑就很多就很多

381

你要学会取舍

382

就是她和你

383

和你想关注的那份

384

比如你想关注说他为什么

385

我给他写的CC的

386

他没有粒

387

他没有立马更新

388

你想

389

找的是这个问题

390

那么其他的你可以暂时先把他给忽略掉

391

那么至关主要的部分

392

我们把主要的作用先看明白

393

然后

394

先明白一个函数是做什么的

395

就是如果说你的一个函数

396

我可以举个例子

397

比如举个例子

398

比如像

399

Render

400

就是这个函数

401

这里面其实就掉了很多

402

里边儿又掉了很多逻辑

403

它里面皮特update a container我们看到有有两有两个分支

404

对啊

405

我们分析的时候

406

比如我们要知道这个方法到底干了什么

407

我们就可以通过先检查主要分支来看

408

比如这两个分支

409

第一个分支就是

410

当他这个其实很好看懂

411

当他那个room存在的时候

412

就是如routes

413

不存在的时候

414

刚开始入的不存在的

415

不存在呢

416

也就是说他之前从来没有被注册过

417

对吧

418

没有被注册过就走这个分子

419

如果他已经被注册过了

420

就是下面这个分子

421

所以它区分了两种场景而已

422

如果没有被注册过的话

423

他给这个地方包了一个an based update

424

有点儿有点儿不同了

425

而如果已经注册过的话

426

他并不会给他包上一个叫做update update这个东西

427

这个东西我们只好通过找他的不同可以找到

428

那么我们接下来就要分析

429

为什么

430

为什么这个这么一个区别

431

昂被消费者是干什么的呢

432

我们你再通过其他地方找就看到

433

原来是on based的

434

原来是指的是不批处理

435

然后用最高优先级把它

436

嗯

437

渲染出来可能现在好一些吗

438

现在能看到吗

439

现在呢

440

我再放大点

441

好

442

然后我们再通过其他分析

443

但是这个分析是我分析的

444

不是大家分析的

445

不是大家分析的

446

通过比如查找他的那个代码逻辑可以直接得到

447

但是这个方法在react里用的还是挺挺多的

448

内部用的还是挺多的

449

我们也其实也可以外边儿掉

450

他的意思是不期望不作批处理

451

然后立刻就有最高优先级渲染出来

452

然后所以就给他包了一个on based update

453

这儿有个概念叫做批处理

454

什么是批处理

455

比如说

456

比如这里

457

我掉了一个this date

458

同时又掉了一个this date

459

我这儿同时掉了两个

460

就是就是从上到下掉了两个

461

那么在react里

462

在react如果它是发生在生命周期内的

463

如果假如他是component did mount

464

我写全一点

465

如果他是在component did mount类

466

那么虽然我掉了两次c EST

467

但实际上它只会执行一次

468

它内部只会执行一次更新

469

它的更新只会执行一次

470

所以我们就认为他的J两次发起

471

两次发起的更新

472

然后被做成了一个批次的一个处理

473

所以叫做批处理耳

474

这时毫无疑问

475

做这个PPT的作用是干啥

476

肯定是为了优化性能

477

对吧

478

如果你一次

479

你比如说掉了三次、四次、五次

480

那么你每次比如每设一个赛特

481

赛特

482

然后你内部都发几次更新

483

那我们的JS的损耗其实是挺大的

484

特别是什么呢

485

特别是你的rock的组建的组建速特别庞大的时候

486

那么他这个开销其实是非常恐怖的

487

所以这就叫一个p react

488

有一个批处理的优化

489

而这他on based on data

490

这指的是不是批处理的一个

491

不是批处理的一个优化

492

那么有同学就搞不懂了

493

就说老师既然说批处理是对性能的一个优化

494

那么这为什么还要专门写作

495

不是批处理

496

其实认真一想

497

老师当时也是认真想了三秒钟

498

然后想明白了

499

为什么呢

500

因为如果进了这个分支说明什么

501

说明他之前从来没有被渲染过精致分支是从哪儿来的呢

502

是从

503

这个市场

504

Fracture

505

当地render

506

对吧

507

这个我肯定必必须会用到这个函数的REC的render

508

第一次的时候他就走到这儿来了

509

然后给他做一个on based on a date

510

也就是说

511

因为我们页面上现在大家要理解一下

512

现在我们页面上什么都没有

513

因为我我才刚开始调嘛

514

对吧

515

我刚刚开始掉

516

我的页面上现在是什么都没有

517

我现在期望的什么

518

期望的是我的页面上赶紧把东西给渲染出来

519

我不管

520

所以我需要我的这个

521

Render

522

我的这一次更新一定要是不等的不等

523

其他剩下的更新我一定要

524

这次更新一定要最快

525

一定要最快

526

所以他给他加了一个ion based update

527

也就是

528

也就是我这个

529

确实REC的内部

530

它很多地方它默认给你做了自动的批处理

531

但是但是对于我让点render这一次来说

532

这第一次来说

533

我希望他步骤这个批处理的逻辑

534

我希望它最快的渲染出来

535

能听懂吗

536

听懂了的话

537

同学如果懂了的话

538

就回答一个一

539

不懂就靠一个您

540

OK

541

这就是write down

542

那我们就立刻这个函数的功能我们立刻就明白了

543

原来他做了分了两步

544

第一步就是区分了一下

545

然后呢

546

区分了一下我到底有没有被渲染

547

到底有没有注册过

548

如果注册过了

549

那么号不用

550

那么我就给他设一个on based update

551

然后这里是要让他最快的渲染出来

552

然后再给他这个after container

553

因为两个都是相同的

554

我们可以接下来再去看after container到底是指的什么

555

那如果他已经被渲染过了之后

556

那么他就可以做批处理了

557

这个就没关系了

558

对吧

559

我们一个函数

560

一个函数至少就知道它是什么功能

561

大概知道什么功能

562

但是我刚刚其实有很多地方也没有讲完

563

对吧

564

比如说这个

565

像这个回调我就没有说因为原因是啥

566

其实这个平时看的话

567

这些都都是不难看懂的逻辑

568

我们可以

569

但是他和我们想想要就是了解的逻辑

570

可能就是不是特别相关的

571

我们都可以先把它忽略掉

572

但这可以给大家顺便讲一讲

573

比如这个container direct

574

如果这个实际上是一个属性

575

这个属性值

576

它实际上就是react router recruit这个属性词

577

它是挂在down上面的

578

他是挂着them上面的刀

579

上面挂着这个属性值

580

就是比如说我们我们REC的render一般都会

581

一般除了都是这么写的对不对

582

然后

583

APP

584

比如这个当然APP

585

这个APP这个氮元素

586

如果是注册个REC的话

587

那么他就给他挂载一个

588

这个挂载了它

589

然后他再去指向我们整个的REC的数

590

这就指向整个rock数

591

就是说也就是说

592

如果说你不想通过

593

如果你在外边儿

594

在外边儿

595

你

596

你没有

597

你不是代码的开发者

598

你如果想要得到整个react的塑型结构

599

就是那个树形结构

600

其实你是可以得到的

601

你只需要找到它的

602

通过我们的当

603

就是我们的档操作

604

先拿到它的这个元素

605

然后再拿他的

606

然后这

607

Root

608

对

609

叫做REC to root container

610

然后里面再找initial root

611

然后再找

612

就可以找到整个reg的罪

613

最祖先的那个组件

614

你就可以找到他

615

然后如果你想更改的话

616

也可以更改

617

我记得之前看过一篇文章

618

就是如果说

619

如果说你想更改

620

某一个就是站外的

621

就是你并不是开发者

622

你想更改它某一个元拿到他的某个

623

Correct的某个特性就是某个值

624

那么你可以怎么做

625

其实就是就是这样就这样操作

626

我们可以试一下

627

就是在

628

所以这个我看一下他是不是

629

REC的

630

我也不知道他是不是REC的

631

我可以看看

632

他可能是REC的

633

但是也不是没有那么肯定

634

比如这个对吧

635

我们可以操作一下看看

636

不一定是

637

我不知道飞出这个

638

大哥们的点select

639

我们有个属性叫什么来着

640

Raptor root container

641

找到了

642

大家看找到了

643

对不对

644

我们找到run continue

645

然后我们再来找她的

646

大家看

647

然后再找到当前他的

648

这个kernel kernel就指的是整个根节点

649

那这个current

650

其实这current就是跟我们的react组件的根节点

651

然后里面就是它整个的组件

652

我们可以找到这个

653

但有同学说这个可能也没有

654

就是看起来这个是没有什么用的

655

但是当你需要用到它的时候

656

那么你就会非常感谢

657

然后你知道有这么一件事情

658

有这么一件事情

659

OK

660

闲话就不多说了

661

感觉有点扯远了

662

有点扯远了

663

即使我们来看源码的这么一个这么一个流程吧

664

这么一个流程

665

我回到我们的这这个地方来

666

好

667

如果我们看明白一个函数是做什么的

668

然后再弄具体实现

669

他就这么搞的

670

但如果你还看不明白的

671

其实rock我之前看的时候有的也看不明白

672

那就可以看right相关的一些英雄或者别的开发者之类的文章

673

也可以来参照一下

674

参照一下毕竟就是大家都站在巨人的肩膀之上的

675

对吧

676

那么最后

677

看完了这前五个之后

678

记住一定要做一些简单的DEMO来刺激的运行

679

具体来看一看和你所设想的到底是不是一样的

680

这就是学员的几个步骤

681

当然

682

它不仅仅适用于ASP的源码

683

你可以看任何的源码

684

比如我其其实如果大家刚入门的话

685

肯定当当然

686

但是大家肯定不止刚入门了

687

有几个源码可以一定要去看一下

688

比如像lo Li的源码的底细了的原版

689

你看完了之后

690

你至少对写一些工具类的方法

691

函数式编程

692

然后会有一个比较初步的了解

693

比较初步的了解

694

然后你可以看一下wait的

695

Which的

696

然后view的对吧

697

那么REC的

698

那么今天也给大家也再给大家讲

699

但是下来的话也得需要大家就是讲肯定三节课

700

我们只有三节课六个小时

701

那么要把rap这个东西讲完肯定是不现实的

702

我们会

703

但是我会讲什么呢

704

我也讲到它最重要的几个部分

705

就是怎么样把它流程给串起来

706

就是我们一个人

707

比如像一个人wrecked

708

它和人一样

709

它有一个骨架

710

对吧

711

他有精

712

他有他的经脉

713

有骨头

714

把它连起来

715

那么这是最要紧的部分

716

然后呢

717

剩下的就是填充他的肌肉那些什么的

718

所以我们

719

会讲到会讲到就是他最主要的里面的价格

720

里面的价格剩下的他很多东西都是可以直接填充在这个价格上的

721

所以不会讲嘛

722

它所有的API这个是讲不完的

723

这个是讲不完的

724

所以而且这个价格也非常的复杂

725

需要大家下来的话

726

继续去看一看

727

继续看一下

728

行

729

学习怎样学习源码就给大家讲到这儿了

730

那我们来看一下从整体的reactor看是怎么引进过来的

731

怎么演进的

732

rap我分了几个篇章

733

第一个wrecked

734

以前RACK16

735

之前X16X17

736

以及最后还有X8

737

其实ROCK17和18所讲的东西并不多

738

绝大部分的话是RACK16做了很多调整

739

大家应该也有这种感觉

740

RACK17到18很快

741

几个月就几个月就从17到18了

742

但是REACT16到17

743

最近过了很久

744

推荐过了很久

745

所以X16中很多的东西

746

它的价格也比较难改

747

价格也比较难改

748

16到17

749

很多东西都是比较割裂的

750

比较割裂

751

我们现在讲那个ROCK15吧

752

Rock的

753

从a开始就是一直到他16之前

754

他的整体的价格其实可以大概的分为两个部分

755

第一个部分叫做re consider

756

第一个部分叫做render render render e

757

分别是什么

758

什么作用呢

759

Re consider

760

它的作用就是找出具体的变化的组件

761

比如我掉了一个4S店

762

City state

763

对吧

764

我调了一个distance estate

765

那么他肯定有某个组件变化了

766

他肯定有主见变化了

767

那么我就要找到那个组变化是哪个组件

768

然后把那个组件做通过做的衣服什么的

769

最终把这个组件的更新给更新到页面上去

770

那么以前的react架构整体来讲可以分为两部分

771

就这两个地方

772

但是它内部其实rock事物就已经有了批处理的优化

773

就是就是我们这个

774

我们执行了两次或者多次system system实际上它只会发起

775

最终只会发起一次更新

776

就是在这种场景下

777

并不是所有的场景

778

假如你把它放在车身

779

官方18以上了

780

我们18

781

18已经有那个版本了是吧

782

已经有先行版本了

783

队友先行版本

784

你可以看它的先行版本

785

他还没有正式发布

786

但是也快了

787

既然已经发了消息了

788

那也快了

789

Right之前就是这样

790

然后

791

但是像这种价格

792

其实大家可以看到一句话讲完的事情

793

但大体上是一件老话讲的事情

794

那么他肯定就会有很多问题

795

童年事实也是如此

796

这个图我相信大家肯定都已经见过了

797

这就是REG15的典型的一个更新的一个图

798

因为RECORD15他就只有两部

799

一个找出变化的出现

800

一个把它现在页面上

801

那么

802

当你的一个react页面

803

它的组件特别多的时候

804

我们肯定有这样的需求

805

那就是那就是一个react

806

他有N多个组件

807

或者你引了很多个包

808

总之你这个组件是非常的庞大

809

逐渐出非常的庞大

810

那么如果你写的不好

811

就出现这种情况

812

你一个变化

813

你一个更新

814

然后呢

815

他就一直掉一直掉一直掉一直掉

816

就掉了这么久

817

然后都不会想用户

818

那么对于用户来说是什么样子

819

就是卡死就是卡顿

820

卡顿住了

821

很不流畅

822

效果很不好

823

那么这就是一个常常任务

824

导致主持会阻塞用户会的交互

825

那么这个是Rex面临一个问题

826

因此从RANK151直到REC16 rock的团队

827

然后就对他的价格进行了一个升级

828

也是X6

829

现在我们市面上文章

830

分析也比较多的就是X的fiber价格

831

她调整了之后

832

上面的这个图可以做到像下面这个图一样

833

像下面这个图一样

834

下面这个图就是和他们的区别在哪里呢

835

我们看这个比这个水面上水面上

836

是响应用户的操作

837

大家看

838

上面这个图从第一次点击了之后

839

假如这个点击事件点击之后

840

一直这么长时间内

841

用户无论做任何的操作

842

他都响应不了

843

而下面这个组

844

我隔一会儿他会回来

845

他隔一会儿会回来看一下用户有没有什么操作

846

隔一会儿回来看用户有什么操作

847

这样的话

848

即使是用户后面有新的

849

有心里有其他的交货

850

那么我不至于因为是卡死的

851

因为我不至于是卡死了

852

那么这是一个优化点

853

那么第二点就是什么呢

854

那有同学可能会问呢

855

就算是他响应用户有什么用呢

856

因为你的那个长任务还是存在

857

你那个长任务还是会接着执行

858

就算响应的用户

859

那么用户对用户的体验来讲的话

860

好像也没有特别的提高

861

对如果单纯从这一点来说

862

你只是想用户

863

那么但是你的进程还是被站着的话

864

那么肯定没有用

865

对吧

866

所以react fiber价格大概有两个非常重要的东西

867

一个就是它的执行义务的

868

调度任务会在洪洞中进行

869

这样可以保证不会让用户失去响应

870

我们那个图

871

有一个图

872

这个大家应该都见过

873

就是那个鼠标呢

874

这样一个这样一个图

875

然后

876

这里是主进程对吧

877

这里主进程

878

那后面是

879

微任务在后面是红任务

880

对吧

881

侧面是红任务

882

那么如果你的主你的主线程一直被占据的话

883

那么你的你的整个屏幕都是被卡死的状态

884

但是当你在红任务当中进行

885

如果你在红任务当中进行这个红任务

886

红任务当中进行一个任务

887

那么任务完了之后也会进入下一个

888

就是下一个周期

889

的主线程不会被占据

890

对吧

891

你的用户还是可以接着操作

892

然后接着又在下一个活动当中进行

893

因此

894

这就可以保证什么呢

895

可以保证就是我们我们始终不会丢失

896

要对用户用户的响应

897

这就是能够回到水面上的原因

898

因为它是在红豆当中进行的

899

这是第一个比较重要的一个变化

900

第二个变化

901

第二个变化

902

REC的同时

903

对所有的更新做了一个优先级的绑定

904

这就是我们刚刚所提出的那个问题

905

就算你就算你用户又更新了之后

906

那就算你用户做了一个新的交互

907

那我还不是要等上一个任务完成之后

908

就上次更新完成之后再来做你新的更新吗

909

那么对用户的体验其实并没有很大的提高

910

因此

911

React做了一个优先级的绑定

912

也就是什么呢

913

假如说你之前正在更新的实际实际上是一个优先级较低的任务

914

我们就用优先级这个概念回去和优先级概念

915

假如说你现在这里尝试的是一个优先级低的任务

916

优先级的

917

然后下次用户在这里操作了之后

918

他操作了一个优先

919

优先级比较高的一个任务

920

关于优先级

921

待会儿会给大家比较详细的讲他现在我们只需要知道优先级

922

那么他肯定就执行顺序是不一样的

923

那么我这个新的任务是一个星期

924

比较高的

925

那么我这个月就高的任务就可以打断优先级较低的任务

926

也就是说

927

如果你后面用户操作了

928

我们认为

929

你的优先级高

930

假如一旦被认定为你的优先级高

931

那么你这才会优先执行前面这个

932

如果没有被执行完的话

933

那么会被会被中断掉

934

会被中断掉

935

这样的话用户的体验就会比之前要好很多了

936

都会更新

937

能理解为

938

多个CC的操作吗

939

可以理解为

940

它不只是多个实验操作

941

你有可能是一次

942

一次system

943

比如你的一次甚至可以

944

比如像这种

945

对于本来是发起了两次CS

946

对吧

947

两次CS的他但他实际上只发起一次更新

948

但它实际上只发起一次更新

949

它实际上是被批处理的儿

950

对

951

而你如果有这

952

你如果是放在

953

但是这是一个组件类

954

如我看一下这个结构

955

假如这是

956

A组件对吧

957

这是B组件这是C组件

958

第一组建的组建

959

假如说你这儿有一个更新

960

这儿有个更新

961

这儿有更新

962

我们刚刚这种情况

963

她是不是在同一个生命周期

964

同一个组件的生命周期里

965

那么他肯定就他就直接给你批处理

966

但是你在不同的组件内发起了不同的任务

967

发起了不同的更新

968

那么就有同学说

969

假如说四个C的

970

假如这个CS的

971

那么那么它就是三个不同的任务了

972

三个不同的任务

973

至于这些任务还能不能合并

974

那么其实L还有其他的优化策略

975

还有其他的优化策略

976

可以理解为是在不

977

但是并不是所有的4S店都可以穿

978

并不是简单的理解为就是多个CS的操作

979

因为有你

980

如果在同一个组件的同一个生命周期里

981

你发起了好几个操作

982

那么它实际上最终只有一次

983

只有一个更新

984

你在不同的组件内

985

那么他会是多个不同的更新

986

我们可以看一下我们刚刚讲到的优先级的

987

讲了两个步骤

988

讲到两两点

989

一个是红任务中进行这块儿

990

这个代码待会我们会在代码中给大家看

991

会给大家直接分析到那里去

992

我们现在需要记住两点

993

一个是它自己会变成这个样子

994

从上面的图变成下面这个图

995

就是因为它是在红肉当中调度的

996

所以不会把主线程给占据

997

不主线程给占据了

998

不会一直占据主线程

999

这样他就有时间去响应用户的操作

1000

第二由于他对每一个更新

1001

都有这个优先级的绑定

1002

那么他就可以在多个更新同时出现的时候中断的优先级的执行高优先级的

1003

这个就是我们接下来要讲到的schedule模块所要做的事情

1004

他就是来调度任务的优先级的erf16相比REG15

1005

他实际上在整体上就多了一块儿

1006

他在这儿多了一块就是我们的schedule模块

1007

这个是GK的模块儿

1008

他是来控制到底哪个任务能够进入下一个流程

1009

就是来找出逐渐变化的组件

1010

然后再渲染到页面上

1011

就说这相当于来了一个把门儿的

1012

来个把门儿的

1013

他来控制它来控制

1014

来控制调度我们进入我们后续后续那个JS流程

1015

的任务的任务

1016

任务的多少

1017

那这些都是可以由它来控制的

1018

这种schedule要做的事情

1019

然后我们现在先讲一个

1020

优先级的概念

1021

当我们的优先级

1022

其实这个优先级并不是随意定的

1023

Rock他把

1024

他可以大致分为这几类

1025

大致分为这几类

1026

生命周期方法

1027

比如

1028

这是同步执行的生命周期方法就是同步执行

1029

然后如果用户的输入这个优先级

1030

从高到低

1031

当然内部还不止这几种

1032

我们可以大致的来说一下

1033

比如说他是按照用户的这种交互

1034

就是说用户的最佳体验的

1035

这种观察

1036

然后来给你列了几几了

1037

裂了好几种不同的优先级

1038

而这个优先级是不需要用户

1039

是不需要开发者进行操作的

1040

是rock的内部就给你绑定好了

1041

比如

1042

说明这些方法

1043

那么他认为他的这个优先级是高的收入的用户输入

1044

比如说你的输入框内输入东西

1045

这个你的输入框内输入东西

1046

你是不是期望期望什么

1047

期望的是立刻就在输入框中显示

1048

就是这样对不对

1049

肯定是期望立刻在输入框中显示

1050

那么他这其实受控的用户输入

1051

那么它就是一个较高的陷阱儿

1052

比如像交互事件动画高优先高动画

1053

比如像动画

1054

那么它的优先级也也高

1055

但是他没有用户输入那么高

1056

其实就区分出来了

1057

还有其他的

1058

比如像数据请求

1059

那么这个项数据请求

1060

他并不是需要立刻展示出来的

1061

对于用户来说

1062

他也有一个简单的预期就是

1063

一个简单的假如

1064

这是一个一个搜索框

1065

他的简单与他的预期肯定是

1066

那么我输入的东西能攒

1067

我输入的这些能展示出来

1068

然后他过一会儿可以展示出来我要搜的内容

1069

对吧

1070

这是一个简单的预期

1071

那么对于用户这个预期来说

1072

我输入能能立刻反应在表单上的

1073

这个他肯定是一个高优先级儿

1074

数据请求他

1075

他可以接受

1076

过一会儿

1077

然后再展示

1078

那么他的预算就比较低

1079

所以他是根据这种人机交互的这么一个模型来制定的一个优先级的概念

1080

当然但是这这个是不需要我们的开发者进行操作的

1081

我们只需要知道他有这么个东西

1082

他有这个东西

1083

而且用这个东西做了一件事情

1084

就是可以打断的优先级的更新

1085

我们可以简单的看一个例子

1086

这是我之前写的例子

1087

这是一个REC的组件

1088

REC的组件数

1089

这个件数大家看

1090

大家注意这是一个列表

1091

这是一个双向链表

1092

每一个REC的节点都称为一个fiber节点

1093

这个大家会想到它具体的属性

1094

我们现在可以大致看到它有三个

1095

第一个是

1096

他只向一他的一个链表

1097

一个结点指向翘的

1098

他一个翘的属性指向下一个节点

1099

而这个翻倍呢

1100

它有一个return可以实现他的附件

1101

他还有一个sub令

1102

可以直接他的兄弟

1103

今天这是一个双向的一个链表结构

1104

这REC的组件数大概就这样

1105

后面我们还会好几次看到这幅图

1106

先长个记性当

1107

这样的一个组件数出现的时候

1108

我们在失败了第一次假如在spanner发起了一个烟机

1109

米色的更新

1110

就在sight嘛

1111

但是假如优先级不是很高

1112

VC

1113

那么紧接着我在这儿发起了一个为a的

1114

一个外搭

1115

那么在REACT16我就不卖关子了

1116

在REACT16里

1117

他有可能发生两种情况

1118

第一种就是a和C一起执行

1119

第二种就是a先执行

1120

第二个就是a先执行

1121

然后C

1122

总之a他一定不会比谁慢

1123

因为我因为我因为我是紧接着发起的吗

1124

那就说明说明我们的span

1125

比如这个CM还没有执行完

1126

对吧

1127

我们还没有执行完

1128

那么

1129

那么

1130

我发起了一个优先级更高的一个优先级更高的一次更新

1131

那么他就会打断他

1132

他实际上他有可能打断他有可能和他一起执行这个看情况的看情况

1133

接着假如我又在div里又发现了一个有线GV

1134

A的更新

1135

它的更新如果说C备a打断了

1136

他没有执行

1137

那么就会发生两种情况

1138

第一种是

1139

第一种是随着时间的流逝

1140

就是讲这个时间轴

1141

这个时间轴

1142

我这儿我先先发起的这个更新一下是C对吧

1143

这个C

1144

然后我在这发起的一个是一个a

1145

这个时间轴我在这儿发起的

1146

一个是

1147

也是一个圆锥的更新

1148

那么我发起C的时候

1149

他没有执行完就遇到了

1150

就遇到了这个MV的更新

1151

所以把它打断掉

1152

那么C

1153

他就被打断了

1154

那么a执行完了

1155

下期下一次我又发起了

1156

我又在下一个时间段里发起了一个

1157

为a的游戏优先级

1158

为a的一次更新

1159

那么这种情况就发就有两种情况

1160

第一种是我们的C就是优先级

1161

优先级它实际上它是和时间有关的

1162

在rock的优先级是和时间有关的

1163

比如说我这个优先级它是C

1164

但是过了一会儿之后

1165

他的优先级实际上会慢慢升高

1166

比如过了一会儿他可能就变成a了

1167

这个我会给大家具体讲的

1168

只是大家理解就是我们的这个优先级

1169

它并不是一个简单的一个级别

1170

一个级别来看呢

1171

它是通过时间

1172

它是通过时间来对它进行度量的

1173

所以我们的优先级

1174

我这说的C和a都只是一个简单的一个表示

1175

都只是一个简单的表示

1176

但这他有可能随着时间的变化

1177

比如我这个

1178

过了一会儿

1179

比如过了一会儿才变

1180

我才执行

1181

我才又发起了a的更新

1182

那么我们我们的这个C它是有可能

1183

优先级变得很高的

1184

如果他的优先级变得很高了之后

1185

他可以和a一起执行也可以

1186

如果优先级还没有变得比更高

1187

那么

1188

还是a线执行

1189

我这可能有点懵

1190

我们可以接下来看一下这

1191

比如通过上面的几个我们的优先级的描述

1192

在right的函数类

1193

他就把它分为这几类

1194

这是rock的逻辑

1195

X逻辑

1196

比如这个叫做immediate priority就是立即执行的优先级user blocking priority就是用户交互的normal

1197

就是一般你正常发起一个更新

1198

它就是normal

1199

然后向爱豆

1200

爱豆和烙

1201

这都是比较低的优先级的

1202

一般都是一些动画

1203

那么他可能会涉及到这两个鱼仙籍

1204

而预先解释什么呢

1205

有的同学可能对我刚刚说的说法有点儿懵

1206

预期实际上在reactor live

1207

它表述成一个叫做expression time字段

1208

他比如我这个

1209

Invited priority

1210

他的一个他他会对应一个亿

1211

Expression态

1212

它对应expression on

1213

他们对expression he当前时间有关

1214

比如说

1215

比如说啊

1216

我这每一个优先

1217

每一个优先级

1218

他们他们会有会给一个固定的时间间隔

1219

比如我这

1220

给个100对吧

1221

然后50

1222

时

1223

1111

1224

这个是固定的时间间隔

1225

然后我们有一个时间

1226

然后他的expression time最终会等于它的expression

1227

在计算的时候

1228

根据它的优先级

1229

它会

1230

计算一个X

1231

兴叹

1232

大家注意

1233

根据优先级这儿有点儿

1234

这个有点绕的

1235

根据优先级计算

1236

一个expression time

1237

而后续所有优先级的对比

1238

后续所有优先级的对比

1239

都是通过expression来对比的

1240

其实它实际上就是一个时间的一个

1241

数字

1242

时间的一个数字

1243

而对于比如在高于县级

1244

那么它的速度就比较大

1245

比如它叫做

1246

它就会等于Karen踏着Karen叹

1247

给他加100

1248

如果是最高优先级

1249

如果是的优先级

1250

那么他的ex pressing探他那个任务的experience

1251

可能就是这样

1252

这个高约县级的一个分析碳这是高约县级的

1253

这是第一优先级的

1254

X16

1255

就这样的逻辑

1256

那么高于县级的一个flash he的县级

1257

他们再进行一个对比的时候

1258

后续就直接通过express来对比了

1259

那么那么我刚刚说的那种

1260

就是它会根据时间的变化

1261

优先级会变化

1262

又是什么意思呢

1263

是什么意思呢

1264

Rex还有一个逻辑

1265

这个逻辑就是假如说我的这个expression差

1266

我的这个character to

1267

大鱼了

1268

X变态

1269

那么就会把这个1000级

1270

调到最高

1271

调到最高

1272

所以说根据时间的变化

1273

它我们的这个C的优先级

1274

它是有可能

1275

他有可能就变成最高的优先级

1276

最优先执行的这个逻辑是什么原因呢

1277

这个逻辑的原因就是

1278

假如我一个的优先级就是刚刚那个C

1279

我后面一直不停的来a任务

1280

一直不停地爱着我

1281

在正式的生产环境

1282

这种情况肯定有

1283

对不对

1284

因为你肯定预料

1285

预料不到会出现什么场景

1286

如果

1287

如果没有这个逻辑的话

1288

那会出现什么

1289

我们的C优先级的那个任务永远不会被执行

1290

对不对

1291

如果没有这个逻辑

1292

我们C1星级任务就永远被打断了

1293

我的假设是什么

1294

我的假设是假如C发起来之后

1295

后面一直a一直打他

1296

那他是不是就永远执行不了了

1297

那么这个实际上是

1298

那么这个实际上这不是性能的问题

1299

而且是一个bug了

1300

因为我一个任务直接丢了

1301

所以有一个这么个逻辑是高于星球如果判断

1302

等级就是判断优先级的高低

1303

我们直接通过数字的对比就是expression

1304

而如果我们的

1305

Can a time大于了你的这个expression

1306

这意味着这意味着你已经被打断太多次了

1307

那么我必须要立刻把那个安排把立立刻把这个C相机给执行

1308

避免掉

1309

避免掉那个更新

1310

就至少是算你这个确实也比较低

1311

但我们也得给你安排上

1312

不能把你给调了

1313

所以有各种逻辑

1314

因此它会随着时间的变化

1315

我们的这个1700他是会发生变化的这块儿

1316

逻辑这个大家能理解吗

1317

如果能理解的话

1318

可以各一

1319

不能理解可以零

1320

刘杨同学杨同学

1321

有什么地方还不太明白吗

1322

是哪一块儿不明白

1323

优先级就是上面这个

1324

它实际上是指的是优先级

1325

就是从一开始说函数调的时候

1326

CAD的时间变成了家了吗

1327

Carry on time

1328

但你可以理解为Canton

1329

就是我们当前的时间

1330

就是我们当前时间

1331

根据我们当前时间计算的一个值

1332

所以他肯定是越变越大的

1333

我们的时间是不是一分一秒都在走

1334

让这个canon差

1335

那么开始呢

1336

比如我们每次每次

1337

当每次进入到我们的这个schedule里来的时候

1338

那么它都会重新计算一次

1339

Canon上就是每进入一个任务进来的时候

1340

我们的客人就会重新计算一次

1341

那么他肯定是会逐渐变化的

1342

能理解吗

1343

就是我们这个skater他会不会掉很多次

1344

比如我有一个于仙姐

1345

对

1346

我有一个任务

1347

他就进来一次

1348

创建时间到直径的时间差是

1349

越来越大

1350

对

1351

是

1352

你从创建的时候

1353

比如你创建的那个

1354

创建的时候你就会得到一个固定的experience

1355

对不对

1356

因为你创建的时候优先级就已经固定了

1357

就是比如你是哪个优先级就已经知道了

1358

你在创建的时候

1359

你的这个expression上就已经固定了

1360

而你后面再进来的时候

1361

就你在DOS这儿来

1362

你这个explained a care

1363

他却会不停的再往上加

1364

任务开启时记录expression

1365

他进行比较的时候用当前时间

1366

不是

1367

假如有两个不同的任务

1368

比如这两个不同的任务

1369

高于县级和地级县级的吗那么

1370

那么他会

1371

那么他会在初始的时候就会给你

1372

计算好一个expression time

1373

然后付给你的这个fiber

1374

那你放一个属性叫做expression碳

1375

然后呢

1376

你要比较这两个

1377

阿德

1378

优先级的时候

1379

你就他和她之间进行一个对比就行了

1380

如果你比较两个任务之间的优先级

1381

这简单理解就是比较两个任务的优先解决

1382

就通过他们的explosion它的大小来对比

1383

但是有一种特殊情况

1384

即使是假如你的当前时间比

1385

你的

1386

如果我们的当前时间都比你的expression太大了

1387

那么它会自动把你的眼睛给调高

1388

就是你的expression

1389

他会给你调的特别大

1390

让你立刻走

1391

立刻把你升职

1392

所以在相互对比的时候

1393

还是对比的experience

1394

OK

1395

好

1396

接下来走了

1397

接走了

1398

其实在调的时候

1399

比如这里react

1400

我们在on click是比如在图片上把那个a click那么

1401

On click撕掉REC的方法

1402

实际上它就会在一开始就给你设好陷阱

1403

比如我们APP的时候

1404

或者说用input的时候

1405

它就可以通过rang with priority的方式

1406

然后给你设一个优先级

1407

这其实就是给你设优先级

1408

落先给你设好于谦急

1409

所以说你在哪里钓了

1410

实际上就是你发起了什么样的更新

1411

你的优先级一开始就被确定了

1412

被确定了之后

1413

那么他就会计算你的X形态

1414

我们可以看下面的逻辑

1415

比如这他得到了

1416

他得到了当前的优先级

1417

这就是

1418

得到当前的优先级

1419

放大点

1420

嗯

1421

这个方法这是REC的方法

1422

我之前

1423

之前讲的时候

1424

把这个当下来了

1425

这就是来

1426

字面意思就是计算expression为fiber

1427

计算expression time首先得到

1428

最大的这个我们的priority

1429

然后

1430

如果这里是这里是直接是think这是同步的

1431

Concurrent model是我们就是right后面更新一个非常重要的一个东西

1432

看看的model

1433

它直接同步

1434

而这里is working is

1435

Commit ting

1436

这说明他已经在生命周期内了

1437

已经在生命周期内了

1438

所以直接把它复制给她

1439

因为她已经有了

1440

然后接下来其实主要指的是这块逻辑

1441

就是看你的优先级是哪个

1442

如果你是你的immediate priority

1443

这个我们刚刚已经看到了

1444

对吧

1445

他的优先级是最高的

1446

那么就

1447

就把这个SYNC复制给explosion案

1448

这个think是一个非常大的数字

1449

他是一个数字

1450

是一个非常非常大的常量

1451

他应该是直接等于二的31次方减一

1452

这么大还不行

1453

现在行了吗

1454

好

1455

这个think他是一个常量

1456

它就直接等于二的32次方减一

1457

Write写的它标志什么意思呢

1458

就是没有什么比他更大了

1459

对吧

1460

没有什么比他更大了

1461

所以要把如果是这个有县级那就立刻送走

1462

那这个是因为用户交互阻塞的优先级

1463

那么计算一个变态

1464

就是normal就是正常的

1465

一般默认的计算

1466

他们计算的时候其实都会得到一个这个值

1467

它会有一个间隔这个

1468

Beckett赛斯

1469

这个什么因为我

1470

没有

1471

我们之前那个ray下载的X6的不太好找了

1472

所以没给大家

1473

实际上实际上如果是诺莫

1474

He use black king priority

1475

他们都会掉这个方法

1476

都会掉这个方法

1477

但是因为他们的这个back its eyes不一样

1478

也就是它们的间隔是不一样

1479

所以兼职不一样

1480

所以他们的expression差也就也就会不一样

1481

就算是同时发起的两个不同的任务的一些细节

1482

那么你们的expression他他就是不一样

1483

通过它来做的

1484

所以他这个时候这个实际上就是数字

1485

就是我刚刚讲的那个逻辑

1486

就是X16 x16应该是16点儿13以前吧

1487

那么它都是这个逻辑

1488

通过expression粲然后来判断这个于青姐通过这两个

1489

逻辑一个是一个是优先级的绑定

1490

一个是红任务中执行

1491

那么我们的forever价格比X15的性能

1492

那么就好像非常多了

1493

因为我们的用户至少不会因为一个长任务

1494

然后就是卡的不行

1495

卡的不行至少是能够交互的

1496

就是FAB架构所做的事情

1497

所这两个主要的事情

1498

但是呢

1499

它还是有缺点的

1500

他还是有缺点

1501

他的缺点是什么呢

1502

在ROCK16里

1503

Expression的大小恒定优先级

1504

Expression越大

1505

Expression越大

1506

优先级越高

1507

所以高优先级的任务

1508

那么他肯定会将的无限极的任务给注册掉吗

1509

这是我们的expression

1510

它的逻辑

1511

REC的逻辑

1512

他有个

1513

但他有一个

1514

这上面的调度算法吗

1515

是但是但是我们会继续会讲到这个schedule具体的逻辑

1516

肯定不止这么点儿

1517

肯定不止这么点

1518

我是说他大概做的

1519

从宏观层面上来说

1520

他大概做了这么两件事情

1521

他大概有这么两个事情

1522

但是具体的调度逻辑的话

1523

我们会在schedule继续讲

1524

好不好

1525

嗯

1526

即使是即使是做到了

1527

我们的X60做到了这样

1528

其实还是有个缺点

1529

缺点是

1530

但这个缺点并不是从RANK16一开始就带来的

1531

而是随着代码的迭代

1532

Rock的内部出现了新的东西

1533

叫做suspense suspense

1534

不知道大家有没有用过suspense he lay the

1535

我们可以用suspense he lazy来做我们的动态懒加载

1536

东南加载而三次

1537

它实际上就是等待

1538

等待你的执着

1539

等待你的

1540

你的子组件等那个子健那个完全访问回来之后

1541

他才会展示

1542

所以它有一个等待的过程

1543

对于SaaS来说

1544

它就可以

1545

它就实际上就出现了一个IO的一个任务

1546

他是一个IO的任务

1547

会阻塞的优先级的CPU的任务

1548

因为suspense之前没有Spence

1549

那么我们用VX6是没有问题的

1550

觉得是挺完美的

1551

但是因为S出现之后

1552

出现问题了

1553

出现问题

1554

问题是什么呢

1555

我们来看一下这个

1556

自己看一下这个

1557

这是官方的DEMO

1558

好像是官方店吧

1559

也有点儿有点儿早了

1560

大致看一下这个逻辑

1561

大致看一下这个函数

1562

这是通过Spence包裹起来的一个子组件

1563

对吧

1564

然后呢

1565

这是一个loading

1566

这个loading这什么意思呢

1567

就是当我们的子组件还没有回来的时候

1568

先渲染楼顶

1569

我们经常有这种情况吗

1570

经常有这种处理

1571

比如我们一个查询的查询

1572

在查询到数据返回之前

1573

先展示了Lowe的

1574

对吧

1575

那么我们的space也可以做得到这样的一件事情

1576

当我们的APP的宣传之前

1577

展示一个娄底儿这边做了什么事

1578

传进了一个S

1579

这个S是一个值

1580

这个值会每秒变化

1581

大家看这会每秒变化对吧

1582

可是当我们点击click的时候

1583

当我点击click的时候

1584

然后我们看看会发生什么事情

1585

大家看

1586

棚顶住了

1587

我们的这个词刚刚没有变

1588

对不对

1589

我再再给大家演示一遍

1590

再看它是不是

1591

变成50角

1592

我们的这个值并没有

1593

我们这个值并没有更新成功

1594

再来一次

1595

看他现在每一秒都在变

1596

不要了

1597

但实际上它内部的数据是变了

1598

只是宣传不出来

1599

这就是原因

1600

就是因为萨斯把这个阻塞了

1601

差十分主次了

1602

又随着rock的迭代

1603

它的内部

1604

产生了IO任务

1605

ER react中的L任务和我们和我们平常所说的那个L并不太一样

1606

他就是只和Spence机制相关的任务

1607

他就是L任务

1608

我之前也不太理解

1609

但是你记住这句话就理解了

1610

他就是只和他分是相关的

1611

你听明白了

1612

所以如果一个任务会引起30分下子组件抛出任的对象

1613

那么他就一定是L任务

1614

他就一定会阻塞

1615

所以通过sus pen SI

1616

那么因为它它的这个N任务

1617

但是他运气还挺高

1618

所以你有的修建的第一天的任务的时候

1619

比如我们刚刚那个塞帽子

1620

明显就是一个低优先级的CPU任务

1621

因为毕竟我用户并没有操作嘛

1622

对不对

1623

我没有操作

1624

他肯定不是用户

1625

他肯定不是用户操作那么高的任务

1626

所以他最多是个normal

1627

有可能是个吊吊的的

1628

因此我的高优先级的任务就把他给阻塞了

1629

就这么个逻辑

1630

这怎么逻辑

1631

因此

1632

原本的expression time

1633

仅仅通过对比优先级的高低

1634

那么实际上是解决不了这个问题

1635

大家能理解这个问题

1636

能理解这个含义吗

1637

因为我这个任务的优先级高

1638

那么按照之前的逻辑来说

1639

那我就是该阻塞

1640

但实际上并不是因为因为你是个等待的过程

1641

也是一个等待的过程

1642

即使是你优先级高

1643

那么

1644

但是你其实啥也没干

1645

也只是展示一个loading

1646

对吧

1647

就只是展示一个loading

1648

啥也没干

1649

那我们可不可以先展示地域性学生

1650

这就是expression time

1651

Expansion

1652

他们之前的一个缺点吧

1653

就是它的优先级

1654

他把优先级和批处理

1655

它相当于一起给坐一起给做了之

1656

比如我有两个a的任务

1657

对吧

1658

我有两个任务

1659

一个C任务

1660

那么这两个a任务就打包一起一起处理了

1661

但是也就是说他就只根据大于

1662

比如说a大于B

1663

那么a是所有的

1664

A就可以先处理

1665

他把优先级和批处理一起做了这两个事情

1666

他一个事情一起做了

1667

这种实际上不太好

1668

对吧

1669

我们再带我们在平常的开发过程当中

1670

其实也也会遇到一个字段处理两个功能的情况

1671

没有扩展的情况下

1672

他还能他还能够解决问题

1673

只要需求一个变化

1674

那么它

1675

一下子就不能够满足虚

1676

不能满足需要了

1677

这个express上也是如此

1678

他之前是能够很好的完成任务的

1679

但是出现了任务之后

1680

他就不能够很好的完成了

1681

因为他已经处理不了了

1682

所以rock的

1683

关于这个处理实际上非常简单

1684

就是呢

1685

这就是RAKE17

1686

然后增加了

1687

把那个expression太给淘汰了

1688

变成less less就如果大家觉得expansion但不好理解的话

1689

这个last可能就更加有一点点的不好理解

1690

但是我们现在只是有概念

1691

只是有概念

1692

具体的话

1693

面试问的也不多吧

1694

面试问的也不多

1695

只能这么说

1696

只能这么说我们

1697

但我们还是要先来看看呢

1698

Less是什么意思

1699

Less它实际上做的最主要的一个功能就是它把experts探柔和的优先级和批处理

1700

又见嚼批处理她

1701

把她给娶她把它给分开了

1702

他的一个分开了这些

1703

其次是那是主要的一个功能

1704

我们来看一下优先烂

1705

但是里面有两个有两种类型的一种较量

1706

一种叫lance

1707

一看就是一看就是一个多一个表单数据表多数嘛

1708

对吧

1709

一个表双数烂就表示单个的优先级

1710

Lance表示

1711

多个批处理多个优先级

1712

也就是说我如果只处理一个优先级

1713

那么

1714

那么我只占一个

1715

如果我要处理多个县级

1716

如果要只占一个县级就烂

1717

如果要占多个县级

1718

用尔这个烂

1719

它的中文含义叫做车道

1720

就是

1721

其实就是

1722

一般这样

1723

其实我不知道咋翻译了这个

1724

感觉怎么翻译的不对

1725

就叫烂扒嚼烂

1726

但是类比

1727

国内一般类比把它全

1728

把它类比成像车库

1729

车库的这个样子

1730

就是比如说

1731

比如说你有一个停车位

1732

一个停车场

1733

停车场

1734

那么

1735

你的每一个

1736

这里有好几个位置

1737

真没

1738

这有好几个位置

1739

对吧

1740

一辆车停一个

1741

一辆车停一辆车停个

1742

可以同时停多个

1743

可以同时停多个

1744

以前一个分析

1745

但他就只能停一个

1746

他就只有一个ERS的话

1747

就相当于这个车道

1748

比如一个优先级

1749

那么他占一个a县级

1750

他站在这个位置

1751

第一个县级站在这个位置

1752

C县级可以站在这个位置

1753

它就可以把多个相近的优先级

1754

大家注意

1755

多个相近的玉娴姐

1756

那么他的这个任务

1757

他们他那么他是可以一并把它进行处理掉

1758

一并进行处理掉了

1759

就这个样子

1760

所以

1761

所以他比相比于相比于expression

1762

他多了一点什么

1763

他就可以处理多个

1764

其他就可以处理多个

1765

这就是它的

1766

优势

1767

但是还挺复杂的

1768

非常复杂

1769

我们多少算相近

1770

下面有代码

1771

我们直接来看吧

1772

把这概念讲完了

1773

S模型使用31位的二进制代表31种可能性

1774

其实它是用31位二进制代表31种可能性

1775

就是31个车道

1776

对他有31个车道

1777

31个最多可以最多你可以同时

1778

最终你可以同时更新30个

1779

30个

1780

优先级优先级的任务

1781

这个可以重新更新那么多个

1782

再多了他就不支持了

1783

太多了他就不支持了

1784

所以所以如果有Les的话

1785

用less来处理我们刚刚所看

1786

高优先级和低优先级的任务的话

1787

那么他可以分别给IO任务和CB任务不同的呢

1788

然后并发地执行就行了

1789

所以他就是从以前只能执行一个月县级政务

1790

到同时执行多个月星级任务

1791

我们来看一下具体的逻辑具体的

1792

大吗

1793

比如这里就是一个的士

1794

发起一个

1795

比如说我用户操作的一个更新

1796

发起了一个用户操作更新

1797

那么它这里会设置一个

1798

优先级

1799

这个叫做input

1800

Continuous lens priority

1801

这个是车道的一些

1802

它相比于上面的这几种

1803

下面我们可以看到有五种优先级对不对

1804

有五种优先级

1805

那么它区分的更加详细

1806

他确实更加详细

1807

但是我其实你只要看到input

1808

反正是跟输入相关的

1809

是跟输入相关的

1810

他是输入相关的优先级

1811

然后下边儿

1812

通过设置的这个优先级

1813

然后他就给它探测到去给他站车到这里就是占车道的逻辑

1814

这就是输入的1700

1815

如果是同步的

1816

大家看这是烂不是烂

1817

烂的话

1818

那就是运气非常高

1819

如果是同步的

1820

或者是批次批量同步的

1821

那么他就直接把他送走

1822

这就是优先级很高的

1823

那么就不需要做后面的递归操作了

1824

就是只占一个就够了

1825

只占一个就够了

1826

就不用粘太多

1827

因为它优先级很高嘛

1828

他就类似于我们刚刚的这个1IMMEDIATE priority一样

1829

这个这个优先级

1830

这个RANK17的这个think烂和X6的

1831

我刚刚讲到的立即处理的一些

1832

就是image的priority是一样的

1833

这个星级是一样的

1834

特别高

1835

那么只要出现了这个优先级

1836

那么

1837

那么它就是会被最优先执行的

1838

这个逻辑还还好说

1839

对吧

1840

还好说下面假如说你遇到了这个input description re

1841

Input continuous re

1842

那么我们看代码

1843

就需要看一下源码

1844

这大家看

1845

他们都是时间都是二进制的

1846

通过二进制来表示的

1847

通过二进制来表示的

1848

像这个

1849

Input continues烂那么

1850

这每一个大家可以把它想象成停车场的停车位

1851

零的话就不是他的一的话就是他的为相相当于这个

1852

Input Dis input Dis credit line

1853

那么它是从这儿开始的

1854

它是可以有两个

1855

有两个

1856

如果这个

1857

他这两个位置都被这就是它这可以停放两个优先级的任务

1858

如果这样不够的话

1859

他可以去借

1860

就是他会去继续找剩下的就是这个一再去找后面的一

1861

但最终他是要连续的

1862

他会他必须要连续的放

1863

连续的放在一起

1864

然后把这几个连续的一星期

1865

拿去做一次

1866

拿去做一次更新

1867

有点儿

1868

这可能

1869

有点难

1870

有点难

1871

我再给大家

1872

我再给大家捋一捋

1873

再给大家捋一捋

1874

首先

1875

烂lines相比于

1876

Expression碳相比于expression碳的模型

1877

那么它可以

1878

它可以放多个优先级的任务都可以

1879

不同优先级的任务他都可以放

1880

他都可以放

1881

那比如说我们

1882

从这里开始

1883

发起了两次更新

1884

我觉得发起两次更新

1885

我们一起来看吧

1886

这是第一次更新

1887

这是我之前写的逻辑

1888

假如他走到了这个就是和用户操作有关的

1889

那么

1890

第一次我们看到它是这个input description LAN priority

1891

那么他指的是input的

1892

那么第一次更新

1893

他就会找到

1894

他就把这个先放在这个位置

1895

他就放在这个位置

1896

下一次更新

1897

第二次更新就会继续往前走

1898

放这个位置

1899

优先级的高低是从后往前看的

1900

比如这个就是最高的

1901

我们的signal吗

1902

Signal这个就是这个

1903

它就把它放放在这个位置的优先级是最高的

1904

ER

1905

中途的这个

1906

就是从从右到左

1907

从右到左是由高到低的这个顺序

1908

我们因为它是用用户的操作

1909

所以他不会占据我们前面的这两个signal的东西

1910

他不会占据这两个

1911

它就会占据他自己的

1912

这里其实也也就隐隐的有一个有一个优先级对比的关系

1913

其实已经出来了

1914

同学们

1915

云姐的对比关系已经出来了

1916

比如这两个是最高的

1917

对吧

1918

然后

1919

中间的input相关的

1920

那么从就从这儿开始看

1921

是不是从这开始可能会占好几个

1922

大家看有哪几个是硬铺的

1923

一直到这里吧

1924

对吧

1925

一直到这里

1926

这个冷战

1927

那么这些就是相近的

1928

这就是相近的

1929

然后这我们看

1930

如果这没有了

1931

占据逻辑就是

1932

大体的逻辑

1933

我们大体逻辑就是我刚刚讲的那样

1934

如果没有了

1935

对吧

1936

他又去找下面

1937

就是这本来是described烂

1938

现在还去找continuous line

1939

就是又到下面来了

1940

下面来了他就又去找continues烂

1941

然后他就找地方呢

1942

就是一直往后找

1943

一直往后找

1944

假如你有那么多要更新的

1945

他就一直往后找

1946

第一次最高限制

1947

啥意思

1948

不是啊

1949

不是

1950

啥呀

1951

你说这个吗

1952

你不管你别管这个好吧

1953

看瓢了

1954

对看漂了吧

1955

所以这个算的更新逻辑

1956

大概就是这样的

1957

对

1958

右边儿看最高级

1959

一边儿看最高级

1960

而且我们也要看名字

1961

你不看名字不行

1962

比如像这种think

1963

一看到它就知道它是最高级的

1964

但是我们会看具体逻辑的

1965

会看具体逻辑的

1966

还有这个计算

1967

我不确定大家想不想看

1968

因为之前这个计算把大家搞得非常的难受

1969

我们可以试一试

1970

可以试一试

1971

计算逻辑是这样的

1972

它是通过

1973

因为这条都是通过二进制来表示的

1974

ER red内部像这种二进制的计算非常多

1975

就是按位运算非常的多

1976

那么之前我们就可以挨个挨个来掰扯

1977

就是第一个有同学说

1978

同学就想问

1979

老师你说他是从右到左占的

1980

那我想知道他到底是怎么样从一个大作战的

1981

对吧

1982

他这是怎么他的写法

1983

这个二进制的写法

1984

因为不知道吗

1985

因为你不知道吗

1986

所以所以他是怎么从一到这站着呢

1987

其实这块儿是非常精妙的

1988

其实是很精妙的

1989

我们来看一下外plans

1990

Web是指的是当前的遇仙记

1991

同学们当前要更新哪些印记

1992

如果你之前一个任务也没有

1993

那么他肯定全是零

1994

这个能理解吗

1995

因为我一个任务都没有吗

1996

我肯定全是零

1997

对不对

1998

因为我

1999

然后之前的全是零吗

2000

然后当走到这里的时候

2001

我现在要占一个位置

2002

对不对

2003

那么就是通过这个来通过这个来计算

2004

这2万他本来全是零

2005

然后呢

2006

他给他取了一个飞

2007

对吧

2008

飞的话就变成一了

2009

对不对

2010

直接就变成了他

2011

这是二进制的运算这个二进制的运算大家

2012

看一看吧

2013

还是有好处的

2014

他就要做到非非wap烂就变成了这个样子了

2015

然后input description

2016

那我们刚刚看过

2017

我们刚看过他了

2018

我们看过她长这样

2019

它是一个常量嘛

2020

对不对

2021

他和他他他是进行了一个羽羽的操作

2022

就是安慰语

2023

安慰于大家怎么安慰

2024

安慰语的话

2025

当两个都是一的时候

2026

才是一安慰语

2027

这个应该会吧

2028

都是一

2029

31

2030

只要有一个是零的话就

2031

就不是一了

2032

所以所以他这儿

2033

通过

2034

这个

2035

嗯

2036

非web烂和这个input input re

2037

那么它们两个进行一个安慰语之后

2038

他只会得到这两个词

2039

对不对

2040

只有这两个还是一

2041

也就是说他得到了最后这个结果还是两个一

2042

就是这两个一

2043

然后再通过这个PK

2044

我直接把它拷过来

2045

我先把它拷过来批克every难在这里

2046

在下面

2047

最后他会他会通过他

2048

通过这个方法

2049

也就是说我们本来是这个值

2050

那么它能通过烂安富烂

2051

最后得到的

2052

就最后能够拿到这个这个位置

2053

这就是稍微比较复杂一点

2054

所以我说非常精妙

2055

他拿到这个结果

2056

烂我们肯定知道

2057

那么富烂是什么呢

2058

赋滥这要涉及到一个原码和原码

2059

反码和补码的一个关系

2060

源码就是这个Lam

2061

这就是她的

2062

他的那个烂赴烂

2063

它的源码是

2064

驸马赋值就是在第一个位置

2065

标致的是他的那个到底是正数还是负数

2066

所以因为他是负的

2067

所以他就变成了一

2068

这个是它的源码

2069

这是腐烂的源码儿

2070

它的源码在计算的时候还要变成他的补码

2071

然后原码的反码呢

2072

自然就是

2073

把零变一变零补满的话要加衣

2074

本来就是这个是砝码

2075

砝码再加一一加一变成000

2076

这个一加一变零

2077

然后又进位加1000

2078

所以这几个就全变零了

2079

而这里我们想要的这个值变成了一

2080

所以他娶到了

2081

他娶到了我们想要的这个结果

2082

这大家能理解吗

2083

大家能理解吗

2084

好的

2085

同学们理解能力很强

2086

我上次讲这把他都讲蒙了

2087

大家理解能力非常棒

2088

棒棒的

2089

所以他就拿到了通过他的

2090

烂和他和他的那个反码

2091

和他的那个反码的一个与他直接就从从倒着倒着往前就得到了那个一的这个位置

2092

得到这个一的位置

2093

所以他首先所以他第一次那么他就拿到了

2094

他想要拿到从后往前的这个位置

2095

他拿到了

2096

然后第二个

2097

假如第二个更新来了

2098

我们现在已经有一个一了

2099

对不对

2100

现在已经有一了

2101

第二次更新

2102

现在已经有一了

2103

那么他的富烂就变成这是不是变成

2104

写错了这个一

2105

然后他到

2106

波浪线这个直接取砝码

2107

这是什么

2108

这就变成零了是不是

2109

然后雨的时候

2110

大家看鱼的时候

2111

他就只他就把之前已经占据的那一位

2112

他就已经过滤掉了

2113

然后再通过刚刚那个流程

2114

他就又会去到这个位置

2115

因为他现在在和他对比的时候

2116

它是不是就变

2117

它是不是就变成了这个啦

2118

是不是就变成这个这个再拿下来做处理

2119

拿下来做处理

2120

那么他最终还是能找到这个位置

2121

所以这个就是他出

2122

你看他其实写法其实写的非常简单

2123

一个

2124

对

2125

确实是写得很精妙

2126

你如果不仔细的去思考的话

2127

你可能看不懂这段代码

2128

主要是

2129

对吧

2130

你如果不仔细的去思考

2131

然后仔仔细细的把他的把他的原码反码补码给计算一遍的话

2132

你可能看不懂这段代码

2133

就是不知道还是不知道为什么

2134

就之前有同学就很看不懂这个代码

2135

就是原因就是他知道我讲的是从后面往前找

2136

但是为什么这种代码就能够实现从后面往前找

2137

不明白

2138

这就是这张代码的精妙之处

2139

实际上非常

2140

实际上他写的非常简单

2141

几几下就写完了

2142

这这一行这一行写完了对吧

2143

如果说后面大家

2144

有类似这种

2145

想也想这么处理吧

2146

其实black一发你就发现你只需要两行代码就实现了这个功能非常强非常强

2147

而且安慰安慰运算的话

2148

它的性能的话也是非常好的

2149

非常好的

2150

这就是

2151

赖斯

2152

这样差不多了

2153

那次大概就差不多了

2154

好

2155

那我们再来回顾一下

2156

当然还没有讲完

2157

再来回顾一下我们的react时期

2158

他通过lance扩展了expression time

2159

相当于是扩展了吗

2160

因为expression time他满足不了

2161

我们的内部生存在的L任务

2162

什么任务

2163

就是有suspense机制相关的任务

2164

因此

2165

它不能够有效的区分高于县级IO任务和低线级的CPU任务之间的组织关系

2166

所以他必须

2167

他通过

2168

来解决

2169

就是可以同时发起多个任务的

2170

可以同时更新

2171

不是同时发起

2172

我说错了

2173

同时更新多个任务的一种机制就是nice

2174

所以把之前的expression给淘汰了

2175

因此如果大家看市面上一些文章

2176

有的是expression time

2177

有的是lance

2178

不要怀疑

2179

他们只是版本不同而已

2180

他们只是版本不同而已

2181

ER rand毫无疑问是更加先进的

2182

对

2183

毫无疑问是更加先进的

2184

这就是rock时期

2185

就是整体的架构的演进

2186

我们可以就差不多演进到这里了

2187

对

2188

眼睛在这里就是fiber价格

2189

我们还是说fiber价格

2190

它多了一

2191

她比Rose的食物多了一个东西

2192

就是schedule

2193

这个过程叫调度器

2194

调度器调度哪些任务

2195

再换掉的哪些任务

2196

然后可以进行接下接下来的更新

2197

这么判断优先级

2198

那么都是在调度器中间完整的

2199

今天我们会把调度器讲话

2200

OK

2201

大家一口气讲了一个半小时

2202

大家先休息五分钟吧

2203

这次休息五分钟

2204

喝点水

2205

然后快速把它讲完了

2206

老师

2207

我明白了那优先级对比

2208

但是还是没明白怎么解决express的那个DEMO的问题

2209

嗯

2210

怎么说呢

2211

嗯

2212

首先首先那个DEMO

2213

所以那个DEMO如果你升级了之后

2214

它实际上不需要你改

2215

其实他不需要你改

2216

这个问题的话是需要rack自己来

2217

他是通过REACT17

2218

他会他内部他肯定自己自己来做

2219

自己来自己来做

2220

然后

2221

解决这个问题的话

2222

也会逻辑其实就是

2223

逻辑是什么呢

2224

他在处理那个问题之所以出现的原因吧

2225

这个问题只出现的原因

2226

刚刚也讲了

2227

是

2228

是4S的那个任务

2229

对吧

2230

S的那个任务因为一直处在那个进程当中

2231

然后你的那个system out不是他妈set interval所发行的任务优先级较低

2232

就把他给阻塞了

2233

这个是他出现的原因

2234

对不对

2235

这是它出现的原因

2236

但其实并不是

2237

但其实并不是他完全没有资源去做这样一件事情

2238

只是rap的内部

2239

因为她有高纤高优先级的任务和和低优先级任务

2240

他们的这个express的对比就会导致就是那个并不是卡死了

2241

同学们必须要这么理解就是

2242

浏览器其实没有卡死

2243

但是感觉像是卡死了

2244

懂这个意思吗

2245

因为因为你的那个的信息任务一直通过expression time一直轮不到他执行

2246

轮不到它

2247

因为我们的高级任务还在执行中呢

2248

轮不到他执行

2249

所以看起来像卡死

2250

但是并不是我们正常的

2251

就是我们结实主主主线程一直在执行

2252

导致导致没有

2253

就导致就是后续完全完全执行不了那种情况

2254

他其实并没有卡死

2255

而只是看起来主持

2256

看起来用户主色

2257

因为什么呢

2258

因为我们刚刚讲到他通过express来对比吗

2259

而我们的的县级的express就有在高度县级任务执行完之前

2260

他就永远执行不了

2261

他就执行不了

2262

但是我们浏览器实际上还是有资源的

2263

所以如果通过lance的话呢

2264

那么他解决方案就非常简单了

2265

就是你

2266

高县加IO任务你是一个烂

2267

那么我的CPU任务再战一个烂

2268

大家都有美好的未来

2269

对吧

2270

我其实那个时候CPU是有任务

2271

就是我那个时候实际上是有资源的

2272

那些是有资源的

2273

他是可以执行的

2274

它是可以执行其他任务的

2275

并不是真正的死掉

2276

他只要把它

2277

只要没把他给这个对比

2278

只要能够通过

2279

那么我们的那个任务就是可以执行的

2280

所以同学可能有的时候

2281

可能可能那有点迷惑的就是你以为他浏览器这个真的死掉了

2282

那肯定没办法

2283

如果浏览器真的被你给

2284

比如一个结石

2285

你的结石一个函数

2286

你真的要执行一分钟

2287

那就真的没办法

2288

那确实解决不了

2289

但实际上浏览器那个时候还是有还还是有资源的

2290

他只是轮不到他

2291

所以看起来像是死了

2292

实际上没有死

2293

我发现群里有两个刘洋同学是吧

2294

你们见过面吗

2295

有线下课吗这次

2296

我那期的时候也有两个

2297

也有两个

2298

男刘洋给刘洋

2299

有两个聪明的同学

2300

都是现实

2301

好的

2302

这些学员还挺多的

2303

所以排几点都是专业点吗

2304

是的

2305

南流北行

2306

我们开始了

2307

继续开始不不过度耽搁大家时间

2308

然后我们就要三个模块

2309

我们我们会搭个字看一下

2310

Schedule or是调度器

2311

它的主要任务是什么

2312

就是调度任务的优先级

2313

控制哪些任务优先进入recovery

2314

那么接下来有一个叫做re considered

2315

他是干什么的

2316

负责构建February

2317

找出变化的组件

2318

标注组建的变化

2319

也就是我们必须要先调度哪个任务

2320

然后再具体去执行一个任务

2321

就是构建February

2322

抓住主线到最后

2323

这不完了

2324

之后还有一个render阶段

2325

也可以称之为康威的阶段

2326

负责将变化的组建渲染到页面上

2327

其实整体来说

2328

整体的架构分为就分为这三个大的

2329

三个大的模块

2330

你可以把它分成三个大的模块

2331

我们先来看第一个

2332

调动这么多县级了

2333

我们就看这个优先级就好了

2334

这个已经前面已经搬到前面给大家讲过了

2335

就不讲了

2336

我们先看一下大致的调度逻辑

2337

要看大致的调度逻辑

2338

我们先来看一下我们的一个final的一个节点

2339

散落的节点

2340

嗯

2341

有同学刚刚已经问了

2342

我们现在正式来看一下每一个

2343

首先在rock里面

2344

在rock里面它每一个节点都是一个final的

2345

都会把它作为一个L的

2346

它既可以是一个真实的DOM节点

2347

它既可以标注一个真实的节点

2348

也可以标注我们的主见

2349

都没有问题

2350

都是犯了的呢

2351

我们看一下它有很多的属性

2352

大家可以看到它的属性非常的多

2353

但是有几个是比较重要的

2354

我们可以比如tag tag标志是对应的属性的类型

2355

你到底是比如我们组建可能是function的

2356

可能是class是host the fragment portal等等

2357

这些都是就是rock的好几种类型

2358

以及你可能就是真真正的一个当元素

2359

一个档一个档真真实的DOM节点

2360

那么同时通过这个tag来标志

2361

为什么要标注这个榻呢

2362

最大的原因是不同的节点他处理的逻辑是不一样的

2363

所以他要标记一下

2364

K这个K应该大家都听到过

2365

都听过K

2366

那肯定是标准这个节点的微信

2367

那么通过这个case

2368

他实际上是非常有作用的

2369

后面我们看在dif那一节

2370

我们可以看到通过K值他们来做的事

2371

会通过case来做diff

2372

因此我们一般上来通过

2373

一般上一般来说

2374

如果我们要

2375

对于我们我们的那个数组吗

2376

一个县的一个数组

2377

那么都会给他打上一个标志性的K

2378

对不对

2379

打一个标志性的K的原因就是他有可能会导致有可能会复用那个组建这个case必须要全剧唯一

2380

必须要全剧全剧唯一

2381

然后这个

2382

Enter type edit APP

2383

它指的就是你的这个元素的类型

2384

这还有个tap

2385

这个tap可能更加的形象一些

2386

他就是对于function component来说

2387

子函数对class component和子class

2388

对host cover的指弹节点

2389

它指的东西都不一样

2390

然后这个stayed not后面其实我们会详细介绍这个属性

2391

后面这几个属性都会详细介绍斯诺的他实际上

2392

它会储存我们对应真实的这种节点

2393

实际上假如我们这个是个低微

2394

那么他会得到

2395

他最后会渲染会只会计算好它是一个div的东西

2396

然后把它存到这儿

2397

暂时先不动

2398

就是存储在这里

2399

存储真实阶段

2400

它叫做斯诺的这么个属性

2401

当然这是为了优化考虑

2402

后面会讲到

2403

然后这就这三个属性

2404

我们刚刚已经看到过了

2405

非常重要

2406

它就是用来连接其他cyber

2407

形成cyber数February

2408

通过这三个节点

2409

我们就我们的整个发飙的

2410

看起来就像一个真正的数一样

2411

但实际上又不一样

2412

因为它完全是属于列表结构

2413

完全属于列表结构

2414

我有每一个tab键都有这三条

2415

这三个分别指向三个不同的

2416

一个是父节点

2417

一个是子节点

2418

一个是兄弟结点

2419

然后这样构成一个构成一个完整的一个竖

2420

一个完整一个数

2421

那同学有同之前有同学就问这种老师为啥要用

2422

为啥要用链表

2423

对啊

2424

为啥用链表

2425

链表对比数组来说最大的一个好处是什么呢

2426

最大的一个好处是可以很轻松的被打断

2427

比如说我一个执行到了翘的某个地

2428

翘的节点现在我被打断了

2429

那我只需要把翘的这个节点复制给一个属性

2430

就可以了

2431

下一次我在恢复的时候

2432

那么我可以直接通拿到那个属性

2433

然后就恢复到之前的那个节点

2434

对

2435

同学说

2436

没错

2437

可以这样提

2438

因此它是因此

2439

因此wrecked实际上REACT16之前

2440

他并不是链表

2441

就是因为要做这个范儿价格

2442

然后他连整个的结构都给调了

2443

结构都给调成列表了

2444

而且我们它它不光是整个发展趋势列表

2445

它里面像副作用

2446

像什么

2447

它都全部都是用列表的形式非常统一

2448

所以所以链表结构大家也可以了解一下

2449

反正就是一条一条的链条嘛

2450

对吧

2451

还是比较弄得好

2452

弄得然后pending props member of props props相关的一个是新的

2453

一个是老的

2454

对吧

2455

然后是memories date这个

2456

这个属性是来锤hooks

2457

纯hooks

2458

后面hooks那张我们会讲到

2459

这个属性比较重要

2460

叫flex

2461

之前他叫city if X

2462

它是什么呢

2463

他来标记你的跟你的你的这个更新的类型

2464

就假如

2465

你的这个节点被删了

2466

它并不会

2467

它并不会在re consider哩

2468

就直接把你给删掉

2469

他而是先给你标记一个类型

2470

把这个标记上

2471

然后呢

2472

最后从衣橱里到render这个函数

2473

也是就是这个不是函数

2474

在render这个阶段

2475

然后来把你的

2476

当变化更新到页面上去

2477

因此他就先打上一个标记

2478

他为什么不直接更新呢

2479

原因是因为我们所有的更新其实都是跟当有关的

2480

对不对

2481

跟当节点跟档操作是有关的

2482

你如果一个更新你就立刻把他给

2483

就是一个更新你就立刻把它给更新的大幕上

2484

但操作是非常昂贵的

2485

那么热的性能肯定会急剧的下降

2486

一直

2487

他林跃是什么呢

2488

您阅示

2489

宁愿是把你给聚合在一起

2490

最后找一个统一的时机

2491

对不对

2492

找一个统一的时机把你一一股脑给处理掉

2493

因此他在这里的时候

2494

他在前面部分

2495

即使是他已经计算好了

2496

就是当地否这些东西他已经计算好了

2497

但是他并不动

2498

它只是给你存着

2499

包括像咱们这个赛诺

2500

他的真实的DOM节点都给你算好了

2501

都给你都给你准备好了

2502

但是还是不会立刻给他填上去

2503

而是先存起来

2504

存起来之后等到

2505

最后的这个扔扔的阶段的时候

2506

在一股脑给你弄上去

2507

对呀

2508

人家当中对他肯定是

2509

但是它不是接客的

2510

肯定不是接口的API

2511

他就直接利用浏览器原生的API

2512

比如create element啊

2513

对吧

2514

像这种

2515

最终真实操作当肯定都是通过浏览器的API吗

2516

这个less对我们找到了less这个蓝色

2517

我刚刚如果大家觉得还想对它有详细的了解的话

2518

可以看一下这个PR

2519

下来下我把这个链接分享给文档

2520

分享给大家

2521

可以看下这个PR

2522

这个就是当时lies刚出来的时候

2523

很多人不知道这个是干什么的

2524

很多人不知道这是干什么的

2525

于是哀作者加了一个

2526

通过一个PR

2527

一个request

2528

然后解释向开发者解释了一下这个问题

2529

以及就是为什么会把它升级成蓝色

2530

你说现在怎么解决不了的问题

2531

大家其实这个比我刚刚讲的可能会详细一点点

2532

英文好的大家可以看一下

2533

这个呢

2534

就是我刚刚讲的那个了

2535

然后这个outlet也比较重要

2536

他是指向一个叫做work in progress travel的

2537

纸箱的其实是他上一次构建的一个发布的镜像

2538

这个也挺重要的

2539

后面我们会详细的利用的

2540

我打黄色标记的这个就是我们这次需要大家就是

2541

稍微眼熟一点的比较

2542

Said nod returned childs play flex

2543

Outlet

2544

Outlet需要大家眼熟一点

2545

后面因为我们讲整个价格的时候会用到它

2546

用到它

2547

好

2548

这是一个fiber节点

2549

大概就长这样

2550

那么fiber节点我们也大概这个属性

2551

然后我们再来看我们刚刚那幅图

2552

这个一个分节点

2553

分节点加起来

2554

连接起来这就像是一棵树了

2555

对不对

2556

像是一颗简单的树了

2557

这种节点

2558

因为我们的链表非常容易中断

2559

所以它是用列表的形式

2560

它通过跳的对吧

2561

就这事说不定

2562

然后瑞特这三个属性值

2563

然后连成一个完整的一个family tree

2564

整个发票退大概就长这样

2565

那我们来看一下大致的调度逻辑

2566

因为因为这个

2567

因为它的每一个模块儿

2568

逻辑都非常的复杂

2569

之前刚开始讲的时候

2570

前面的同学就不太能听明白

2571

所以我整理了一下

2572

把他们大致的逻辑

2573

先写在前面

2574

我们先给他过一遍

2575

然后下来

2576

剩下的话我们再来继续来过他这个具体的代码

2577

具体的代码就是非常的就是方便

2578

就是逻辑非常清晰

2579

之前我们直接在代码里跳

2580

就从这从代码里看

2581

大家可能会代码里看会比较带感

2582

对吧

2583

但是

2584

之前有同学反映就是什么呢

2585

跳过来跳过去

2586

就是经常在各个函数之间进行切换

2587

那么很多同学就因此而绕晕

2588

因此然后就被绕晕了

2589

然后就不行

2590

所以我们就先把

2591

大致逻辑给大家整理了出来

2592

整理了出来

2593

然后我摘出来了非常关键的代码

2594

关键代码我都摘出来了

2595

然后一些一些和这个主流程无关的代码

2596

我就暂时省略掉

2597

暂时省略掉

2598

如果大家以后看就直接看这个源码里边儿

2599

可能会发现和他并不完全一样

2600

就是因为有部分的代码是舍弃掉的

2601

他当然也是有用的

2602

但是和这个流程无关

2603

不然的话我们肯定看不完

2604

对会分享给大家

2605

所以我们先看一下这个大致的逻辑是这样的

2606

首先他根据优先级区分是同步和异步

2607

同步和异步的任务

2608

我们把一个更新一成为一个任务

2609

一次更新成为一个任务

2610

根据县级区分同步和异步的

2611

同步的

2612

就立刻同步执行的主线程执行

2613

大家现在先先跟我过一遍

2614

有印象

2615

有印象

2616

我们待会会讲

2617

讲完了大家就明白了

2618

先去区分同步异步同步

2619

任务立刻同步执行

2620

他的主线程执行最快渲染出来

2621

如果是义务的任务

2622

他就会在红任务里执行

2623

这还是挺重要的

2624

儿童什么是同步任务呢

2625

也就是一开始我给大家讲的render的时候

2626

当热点render

2627

因为这个是要最快渲染出来

2628

因为因为还是白的嘛

2629

所以它就会走同步任务

2630

它是会放在on based update

2631

我们也看过了

2632

放在on based update这么一个函数列

2633

然后他会去给他标记一个同步的东西

2634

那么他最终是在主线程执行的这个就是

2635

不会等

2636

不会等

2637

而且而且有可能是会阻塞

2638

主线程就是right的render

2639

他是有可能是会诅咒的

2640

如果你的你的那个档次非常大的话

2641

都是非常大的

2642

他就注册

2643

这是第一个

2644

这是第一个步骤

2645

区分同步、异步

2646

第二个步骤得到expression expression X等于current和timeout

2647

计算得到XX

2648

然后对比

2649

Start he can to

2650

将任务又分为及时的和岩石的

2651

英语的任务他可能是岩石的

2652

就是啊

2653

要过一会儿才执行

2654

有的任务是当前就近调度的

2655

就是即时和延时

2656

分为即时任务、岩石任务

2657

及时任务的话就当即执行调度

2658

及时任务的话需要等到care的碳大于等于四大灿

2659

才会自行调座

2660

只因为有

2661

既然有GCS的区别

2662

那么区分它的就是这个沙滩

2663

沙滩如果是即时任务

2664

它的start就是等于勘探

2665

如果是以S任务

2666

他的是大踏会比特大

2667

所以他判断通过盼

2668

Can a current time判断大于等于了沙滩的时候才会执行

2669

否则就等

2670

我们每执行一次即时执行即时任务

2671

就会去判断是否有延时任务

2672

到了该执行的时候

2673

如果是

2674

就把岩石任务相当于

2675

拿过来执行

2676

对

2677

这个是调度逻辑

2678

然后每一批任务的执行都会在不同的红任务中

2679

他是不会阻塞用页面用户的交互的

2680

这个大概

2681

Stay就是大概这么欺负我们具体来看

2682

我们继续来看

2683

这是为了给大家

2684

给大家一个更清晰的一个东西

2685

所以我提前在这里写好了一些基本的概念

2686

基本概念比如这个signal

2687

他指的是同步的优先级

2688

这个优先级最高同步处理

2689

同步处理就think这个think

2690

那肯定就是think的道理

2691

这个字段叫做execution context

2692

因为record这种变得非常的多

2693

这个我认为是比较重要的

2694

我认为比较重要的

2695

所以大拿出来说一下

2696

大家印象更深刻

2697

他其实他其实就是什么呢

2698

他就是来标志

2699

他就是为了区分你这个任务到底进行到哪儿了

2700

你的任务到你的任务进行到哪个阶段了

2701

因为rock的整个处理周期会比会比较长

2702

而他经常需要同他经常需要来判断这个判断你到底执行到哪一步了

2703

因为他会涉及到打断的逻辑

2704

比如我一个C任务现在要执行

2705

那么我一个a任务进来了

2706

那么它要判断你前面那个任务执行到哪个阶段了

2707

如果他已经执行到

2708

假如他已经执行了后面这个render了

2709

就这个render这个阶段就已经马上要渲染了

2710

那么

2711

那么我就不打算了

2712

因为他已经已经要渲染了

2713

这个时候就不好打了

2714

如果他还在之前

2715

比如还在

2716

就是还在进行当地府

2717

那么实际上是可以达到的

2718

因此这个execution context

2719

这个东西可以拿来判断

2720

非常多的东西就在判断到哪个阶段

2721

到哪个阶段

2722

而且它还可以有多个

2723

因此他可能存在多种

2724

可能存在多种有同学

2725

就很迷糊

2726

这个怎么可以存在多种

2727

比如说一个函数里还能同时存在两个函数猪吗

2728

是这样

2729

假如它存在一个函数a对吧

2730

在存在一个

2731

芳心

2732

然后放心里

2733

然后掉了

2734

放心B

2735

放心哔哩又掉了放心C

2736

XKC

2737

假如这种情况

2738

那么有的时候我需要判断她在a中

2739

有的时候需要判断它在C中

2740

所以那么我这两个都不能丢

2741

因为否则的话

2742

那么我还需要增加其他的变量

2743

还要增加其他的变量来判断损失变量对不对

2744

稍微变凉吗

2745

要判断在a中在C中在B中

2746

那么我如果

2747

没有多种的话

2748

如果这个字都没有多种的话

2749

那么我需要增加好几个字段来区分

2750

来做处理

2751

因此这个execution context大家看

2752

非常荣幸

2753

他也是一个二进制的

2754

他也是一个二进制

2755

分别来标志几种不同的上下文

2756

几种不同的上下文

2757

他有可能是

2758

他有可能是多种

2759

有可能是三种

2760

多种和单总

2761

反正他也是一个

2762

但他通过这个二进制的

2763

就像刚刚的车道一样

2764

那么如果它是多种的话

2765

对不对

2766

他就肯定是这种形式

2767

然后区分的话也很好

2768

区分的话二进制也会很好区分

2769

而注册它添加exchange contacts

2770

这个是我拿出来的

2771

就是比较

2772

典型啊

2773

比如在这个render red里

2774

他就或一下对不对对吧

2775

这个execution context

2776

这个是一个

2777

B包的一个变量

2778

那么大概或一下

2779

是不是就把它的值

2780

给加上了

2781

然后呢

2782

就是在执行这个真正的函数体之前

2783

他把他给货一下

2784

换一下就是标志

2785

他把他把这个render con tax加到了excuse me contacts里

2786

让它执行完了之后再恢复原样

2787

这个大家能理解吗

2788

就这行代码大家能理解吗

2789

能理解扣个一

2790

祝你姐开个年

2791

在执行这个货吗

2792

好行不太理解或

2793

像刚刚说的

2794

比如这个excuse me contacts

2795

假如他刚开始是零

2796

对吧

2797

你刚开始肯定没有上下文吗

2798

现在我要或上一个render context

2799

嚯上了之后

2800

货肯定是只要有一个一

2801

对吧

2802

只要有一个一

2803

那么它就会变成一

2804

那么它的结果是什么

2805

结果就变成了

2806

这样啊

2807

假如他还要假如这个

2808

现在他这边execution context现在就成了他

2809

对不对

2810

然后第二次

2811

假如我要或一下又要进入

2812

com的contact了

2813

那么他

2814

哎呀

2815

再错

2816

这样他在或一下就变成两个亿了

2817

对变成两个亿了

2818

嗯

2819

这样子

2820

对于他的来讲

2821

他就已经能够

2822

他就已经能够区分

2823

已经能够区分到底是在哪个函数之内

2824

就在哪种上下文里边儿

2825

在它在执行这个函数之前调到他

2826

而在执行函数执行完了之后就把它给去掉

2827

然后他就他又回到了prime

2828

就是pre v X q Shun context

2829

很多逻辑是这么写的

2830

很多也是这么写的

2831

给他去掉就行了

2832

那判断的话就非常简单

2833

判断的话

2834

下面其实就是一个判断逻辑

2835

它就与上

2836

比如说我要判断我是不是render context

2837

比如我这里

2838

比如我刚刚这个

2839

比如这个in context

2840

我要判断是不是render context

2841

它就很简单了

2842

我自己教他

2843

鱼对吧

2844

与上他

2845

因为与上他的话

2846

这两个都是一

2847

然后呢

2848

不等于no context

2849

不等于那个context

2850

那么其实他的逻辑呢

2851

就相当于在这种常见的逻辑相当于他等于他对不对

2852

但是他他这个这个代码相比下面的代码一个好处是什么呢

2853

它的场景会更多

2854

就是他的处理情况会更多

2855

下面它就只能处理一种情况儿

2856

上面这个它可它首先它可以等于不同的值

2857

第二它可以处理多个值

2858

它可以处理多个字

2859

实际上在rock之前

2860

16:13之前

2861

她用的就是烧饼变量

2862

比如

2863

他没有contact

2864

它就叫做上面叫做is rendering

2865

之前就用这个等于true和false就是处

2866

之前是这么写的

2867

然后commit就是一只

2868

competing

2869

抵触

2870

他就有很多种这种变量

2871

后面的时候我在看着

2872

他就改了

2873

它就变成了context上下文了

2874

其实非常他用他那个上下文的话就更加清晰了

2875

他只需要这一个字段

2876

然后他可以处理很多很多种的场景

2877

其实还是很有优势的

2878

非常有优势的

2879

大家能理解了吗

2880

好的

2881

好

2882

这就是两个基本概念呢

2883

我们来看第一步

2884

其实把这基本概念理解了之后

2885

我们来看下面的逻辑就非常简单了

2886

我们来看第一步它会掉到这个

2887

我们之前看到那个阿飞的container

2888

它会掉到这个函数

2889

首先获取当前更新的1000几当N等于当N等于

2890

Think的时候

2891

这个烂就是我们当前的优先级吗

2892

如果这个优先级还等于sig man也是

2893

也就是优先级最高的同步的那个优先级

2894

与此同时

2895

在看立刻就要便立刻就做了一个对比了

2896

对不对

2897

Excuse me contacts

2898

与上一个on base context不等于no text这个的含义就相当于是说execution context等于magic on based context

2899

这个APP是什么呢

2900

其实之前也给其实之前已经给大家介绍过了就是

2901

就是这里的

2902

就是这个a bitch在这个APP下载

2903

这个我们不是搜了吗

2904

当她当她被包裹在这个函数里面

2905

意思是不不批处理

2906

以最高1000级宣传出来

2907

这实际上给他加了一个什么呢

2908

给他加了一个

2909

Context the contest就叫做legends on based context

2910

因此

2911

如果是第一次走render过来的情况

2912

第一次rightdown.render过来的情况

2913

那么他首先赖肯定是sing ly

2914

那么他

2915

和他与上肯定等于不等于那个context就是它们两个相等的

2916

然后呢

2917

同时它不等于这两个都是任何一个

2918

现在确实也不等于他之前这么处理

2919

是因为有很多种情况

2920

他需要就是不停的来调这个函数

2921

不停的在这个函数

2922

大家需要知道的是

2923

就是render的这个

2924

这个分支是成立的

2925

就是on base context有这样

2926

他也不在这两个里边

2927

因此他就直

2928

他就直接走了performance in work on route

2929

这个函数很重要

2930

其实走这个函数就进入我们接下来的re consider就成了

2931

他就直接不不走我们的调度逻辑了

2932

他就直接去下一个流程去了

2933

因为他是最优先的码儿

2934

他也是同步执行的

2935

它并不会

2936

它并没有在CML的或者说红任务当中执行

2937

也就是说

2938

第一个优先级最高的同步任务

2939

以及

2940

当然同时必须是on based on data

2941

那么他就会

2942

优先级最高的同步执行

2943

这就是第一第一个分支

2944

第一个逻辑分支

2945

大家能理解吗

2946

这个能理解扣个一

2947

应该还行吧

2948

我们把毕竟把这两个都已经讲了

2949

OK

2950

接下来就是一部的

2951

衣服的

2952

这个叫做ensure loo ses

2953

这句包含一不掉的逻辑

2954

我们来看下面这个函数

2955

先先看我标黄的这几个

2956

先看我标黄的这个ensure his schedule

2957

他首先检查他有没有可诺的这个课呢

2958

如果我们是第一次进来的时候

2959

就是第一个任务进来

2960

那么他肯定是空的

2961

原因是什么呢

2962

原因是他在第一个执行完了之后

2963

第一个执行完了之后才给它赋值

2964

对吧

2965

你看root.call back note在这儿复制的

2966

所以第一个肯定是空的

2967

这个我们应该也经常写

2968

对吧

2969

其实这是一个判断复可以复用的一个逻辑

2970

如果第一个有了可怕承诺的

2971

后面我们就复用他

2972

复用这个可怕的诺的

2973

这其实也就是

2974

一个意思

2975

如果有我们就复用他

2976

如果没有

2977

我们就新建

2978

就新建一个

2979

而服用它会产生什么效果呢

2980

我们刚刚不是有这种逻辑吗

2981

比如同时发起了两次C他妈CNC的

2982

但是在同一个组件的同一个生命周期里同时发起了两次c EST

2983

实际上只会产生一次调度

2984

原因就在这里

2985

原因就在

2986

原因就在第一次进来

2987

比如这个distance EST

2988

然后

2989

他exist Co BAC不等于等于

2990

那等于落

2991

他走下面的逻辑

2992

然后呢

2993

创建了一个可靠的

2994

当第二个C的进来的时候

2995

这个存在了

2996

所以这就直接瑞特了

2997

大家看这就直接瑞特了

2998

就不重新发几个吊坠儿

2999

就复用之前那个

3000

就复用之前那个

3001

因此他们就批处理就形成了

3002

这大家能理解吗

3003

开个一

3004

好的

3005

这个应该没问题

3006

应该没问题

3007

嗯

3008

好

3009

发起一个新的调度

3010

然后我们继续来看

3011

大家看这他把performance work on route

3012

对是其实就是一个

3013

其实就是一个缓存吗

3014

服用之前的复用之前发起的一次更新

3015

因为你不需要发起很多个

3016

然后现在这个大家看他把performance work on route

3017

他把这个方法实际上是传过去了

3018

传到这个方法

3019

传到这个schedule back里

3020

接下来我们进行第二步

3021

得计算得到expression叹

3022

Expression X等于X加上看首先看它这个can

3023

我我之前已经给大家讲过吧

3024

看着它它实际上是根据当前的这个时间计算得来的

3025

计算得来的

3026

当然他肯定不是直接取得这个时间

3027

但是他和时间是成正相关的

3028

大家知道这个就行

3029

然后呢

3030

这儿根据它是否传进来了有滴泪

3031

把它分为

3032

然后把这个坑他家上的累就是什么

3033

得到了star

3034

根据started呢

3035

我们在下边儿

3036

会计算

3037

会计算我们的starter he carried进行一个对比

3038

如果沙滩

3039

就这个任务这个沙滩一指

3040

就是我们任务开始的时间

3041

是我们任务什么时候要进行调度的时间

3042

当它大于了开始探

3043

那说明什么

3044

说明说明你的star比当前时间还远呢

3045

就是你的当前时间

3046

当前时间小于就是小于你的任务开始之间

3047

对不对

3048

当前时间小于任务开始之间

3049

那毫无疑问就意味着你的任务还不开始

3050

所以他把这个放在这里

3051

叫做time Queenie

3052

教他们Queenie

3053

有两个任务列表

3054

一个教堂queen

3055

一个叫tasks task queen就是要

3056

就是要

3057

就是即使任务

3058

他们可以就是岩石任务

3059

因此如果我们当前时间小于了

3060

啥等一下

3061

如果当前时间小于了我们的开始时间

3062

那就还不开始

3063

所以他就是把它放

3064

把这个任务就放到岩石中

3065

不然的话就把它放在即时任务当中

3066

然后呢

3067

即使任务大家看原始任务的时候

3068

他实际上

3069

这里这里这儿的时候就就不会发起

3070

就不会发起一次掉落

3071

就在即使我这里的时候

3072

他会发起这个会第二个request host go back

3073

那即使污染当即执行

3074

但是

3075

他调这个looks back最后就走到了这里

3076

Looks back即使任务他是要当地执行的

3077

但是它和我们前面所说的那个同步的又不太一样

3078

同步的就真的只是在rap的主线程中执行

3079

而这里的即时任务

3080

虽然说是即时任务

3081

但是

3082

他也是

3083

不是在主线程中执行的

3084

而是在红任务中执行

3085

这里要给大家讲一个message channel

3086

这个是浏览器的API

3087

这个浏览器的API它类似于CS的

3088

注意啊

3089

它是类似于三八的

3090

它是一个宏任务

3091

同学们它是一个宏任务

3092

它的它的用法是什么呢

3093

它的用法是

3094

比如他有两个point

3095

一个叫POINT11个POINT2

3096

它的用法是POINT1发起一个点post

3097

比如

3098

嗯

3099

比如PART1

3100

在普洱呢

3101

这咋看还是看吧

3102

这个PART11个PART2

3103

比如我这个PART2

3104

他只要发起一个post message

3105

那么他就是在红任务中执行另外一个抛投一的安美

3106

谢谢

3107

自己比其实画个图吧

3108

画个图就更容易理解了

3109

这是POS

3110

这是PART1

3111

这是PART2

3112

这是POS机

3113

他这是PART2

3114

当在PART1

3115

他可以有一个

3116

On message找他呢

3117

有一个on message写

3118

PART2也有一个on message

3119

如果这儿有个post message

3120

这个post是一个方法

3121

他们都有

3122

这个post message方法

3123

我在这里发起一个post message

3124

就是执行一下post message向这样

3125

那么他会在红任务中执行它的执行另外一个地方的on message

3126

红色执行这个逻辑

3127

如果他这儿发几个post message

3128

那么这也一样

3129

这是它的作用

3130

这是它的用法

3131

这样的用法

3132

那之前有同学就有疑问就是

3133

如果说为什么要用

3134

就是我能理解他是在活动执行

3135

但是为什么要用post message

3136

但是为什么要用那个message channel

3137

对吧

3138

其实我也仔细想了一下

3139

官方给的答案是什么

3140

官方给答案是一个是c Mo的

3141

有的时候不准

3142

有的时候不准

3143

大家这个应该能理解

3144

这他妈的不太准确

3145

对不对

3146

他有的时候你的一个一个任务没执行完

3147

它并不会

3148

它并不会就是非常准确的

3149

然后就执行第2ST channel他的

3150

他还会在赛他妈的之前执行

3151

他不在三方了之后

3152

其实它的准确性是更有保障的

3153

因此用AC channel比用cmos好

3154

但是呢

3155

但是你用摘帽的应该问题不大

3156

你如果你自己想用的话

3157

你你会MISS1000龙

3158

你可以用它

3159

你不会面签了

3160

你用其他模特也能实现这样的一个功能

3161

流程没有懂

3162

流程刚刚刚刚

3163

好吧

3164

再说再说一下

3165

刚刚去给大家讲流程

3166

嗯

3167

点不上

3168

我怎么画不出来了

3169

画出来了

3170

比这次post有两个point吗

3171

有两个point一个叫POINT1

3172

有一个二这是破的一

3173

这是破的二

3174

它有两个将我们的左手和右手一样

3175

每一个point上他都有两个方法

3176

一个叫做on message

3177

一个叫做post message

3178

On message post message

3179

这个是on message

3180

这是on message post post message

3181

他们两个并不是割裂的

3182

它们是一个整体

3183

你要把它当成一个整体来看

3184

同学们让这个整体来看

3185

这是post message

3186

这也是post message

3187

然后呢

3188

Capacity其实就是绑定我们响应的方法

3189

绑定我们响应的方法

3190

这就是绑这个方法就是让他自己写的

3191

然后自己写的一个方法

3192

而他是他的执行时间在什么时候

3193

他的执行实际在这里

3194

比如我这个point

3195

这个part就是PART2码

3196

Point发起了一次post message

3197

假如他发起了一次post message

3198

一开始如果大家看到这里就不要迷惑

3199

可能就迷糊了

3200

就觉得说他发觉不合适没之后就断了

3201

对吧

3202

就断了

3203

因为后面就什么也没有了

3204

实际上接下来他就会走到哪里

3205

他会在红任务当中

3206

注意是在红任务当中

3207

他就会来到这个函数内

3208

就调到这个方法里边

3209

也就是我的POINT2的post message移调

3210

那么point一个on message就会就会在下一个宏任务当中执行

3211

这个逻辑能明白吗

3212

同学

3213

至于为什么要用它

3214

我刚刚也讲到了

3215

那就是他冒的不太准

3216

而我们的message会在三号之前执行

3217

所以我们的即使任务就算当即执行

3218

但是为了不组织因为交互

3219

因此它会在红任务执行

3220

它是一个宏任务

3221

这因为在红任务执行中执行我们的主线程并不会被一直站着

3222

对不对

3223

所以才有了我们最上面的那幅图

3224

他是过一会儿它就会回到用户的交互

3225

他又会去检查有没有互一会儿

3226

因为用户因为主线程空着的话

3227

他才会有响应嘛

3228

对吧

3229

他是有响应

3230

那么即使任务

3231

说完了岩石任务呢

3232

盐食物

3233

它有一个判断

3234

就是他每执行一个即时任务

3235

他都会判断

3236

她就有一个advanced m UR的这么一个方法

3237

他就会判断

3238

你的时间

3239

比如你的时间是否carry

3240

是否大于等于expression差

3241

谴责腾讯

3242

也求一篇

3243

谁不是呢

3244

怎么不是

3245

Post message前段也有的

3246

前面也有POS机

3247

比如说

3248

特别是像I frame I frame和你的父窗口之间的通信就通POSMIS也可以

3249

就一个属性叫做温度点post message同学

3250

豌豆店铺什么

3251

对吧

3252

还有温度

3253

点on message其实都是一样的

3254

这个没有设码

3255

你可以给他设

3256

OK

3257

就先不说这个了

3258

岩石任务大家看这里就会把他们困境中的第一个拿出来

3259

拿出来之后

3260

然后来判断

3261

如果你的这个start a小于等于KX

3262

说明什么呢

3263

说明你的执行时机已经到了

3264

他就把它从它弹出来

3265

然后把他加到我们的他这个片段中去

3266

他每执行一个任务

3267

他每执行一个task的任务

3268

他都会掉一个这个方法来检测

3269

检测你的岩石任务当中有没有要执行的

3270

有的话就把它拿出来

3271

拿出来之后就继续去调动

3272

我们的task品级又回到了

3273

继续回到这个地方

3274

因为调入的task

3275

然后我画了一个草图

3276

大家看一下

3277

还有一个书我们的

3278

Schedule

3279

他怎么走的

3280

第一

3281

他分了两步

3282

一个寺

3283

同步任务优先级

3284

一个其他优先级

3285

同步优先级同时还是安倍夏被的时候

3286

一般这种情况都是绕道理论的

3287

它是直接走入performance in work and

3288

就是同步掉了

3289

其他的话他要走一步调度

3290

也就是说除了上面这种情况

3291

其他的肯定在

3292

红色当中运行

3293

红色当中运行

3294

ERRA里边儿它实际上是既包括了同步任务和异步任务

3295

所以如果说有面试关注到这一点

3296

就是react是同步的还是异步的

3297

同学

3298

现在你知道这个问题怎么答的吗

3299

就是如果有面试官问REC

3300

它是同步的还是异步的

3301

CF是同步的还是异步的

3302

那么这里咱们是怎么答这个区分情况对不对

3303

区分场景了

3304

你如果是把它放在update的呢

3305

他就是同步掉

3306

你如果不是

3307

那他就是一不掉

3308

最近的区分场景

3309

并不是并没有一个确定

3310

并没有一个100%的一个固定的答案

3311

你你得给他分析分析

3312

什么情况下是同步的

3313

什么情况下是一部的

3314

的指认的是同队

3315

还有就是你这个update是可以拿出来掉的

3316

就是它是可以导出来的

3317

你如果把一个state

3318

假如你就把一个state

3319

你把一个C的放在了

3320

比如假如你是这么写的

3321

对吧

3322

那它也它也在同步

3323

但也可以在同步里面

3324

恰好

3325

如果你还是在生命周期里面的话

3326

所以要区分这个

3327

实际上是没有一个完全固定的答案的

3328

他既有我们的rock的内部

3329

怎么答呢

3330

到时怎么答呢

3331

原来的内部它是既有同步的任务

3332

也有义务的任务的同步的任务

3333

那么当它是同步的优先级

3334

以及是安倍下部队的时候

3335

大

3336

然后他会走

3337

他会走同步

3338

大约的话就是write down点润的第一次调的时候

3339

那么他肯定是同步的

3340

其他的比如CS data c EST

3341

一般情况下是这个衣服的

3342

当然有特殊情况

3343

所以大家就这么回答就行了

3344

这么回答就行了

3345

然后其他的一度的话

3346

他就把他分为了即时和延时

3347

及时和任务和原始任务当然不管事

3348

即时延时任务的话就等及时任务的话

3349

就把它一个一个的放在mes牵扯的回调里

3350

大家看

3351

每一个都是放在他并不是放在同一个S1000里地

3352

同学

3353

这点儿这点儿在

3354

比如一个任务他走到了这里

3355

第一个任务走到了这里

3356

他是不是放到了

3357

一个红楼梦

3358

如果第二个任务在这里

3359

他会放到下一个宏任务

3360

是下一个红任务

3361

能理解吗

3362

比如说这是一条线

3363

这是当前的时间

3364

当前时间线

3365

这是当前的时间线

3366

这个是主线长

3367

这是微任务

3368

这是红任务对吧

3369

下一个

3370

主线程任务红任务

3371

第一个任务放这儿

3372

第二个任务放这儿

3373

第三个任务就一直往下放对吧

3374

那么他是不是就不会被堵塞了

3375

这种情况下他就很难被堵塞了

3376

所以他并不是放在同一个通道

3377

然后在执行的时候呢

3378

每次都会掉兑现执行的话是timer

3379

然后呢

3380

再添加到他这个空中

3381

一直一直后面去调查咨询

3382

这些

3383

这个是

3384

咱们的schedule

3385

Skate

3386

我们再来回看一下

3387

回看一下我之前给大家写的

3388

大家看一下对不对

3389

比如第一个逻辑是根据优先级区分同步和任务同步

3390

任务立即同步执行在实践中

3391

也不怎么

3392

就是感觉这这红忍不住

3393

然后呢

3394

标志性的就是update的

3395

Update right down典论的之所以特殊

3396

也是因为他把那个

3397

也是因为他把他的这个函数放在a sharp的当中的

3398

就是他之所以比较特殊一点

3399

就是因为把它放在里面了吗

3400

所以同步和异步的区分

3401

第二个就是计算X减X

3402

然后第三个就是对比star k X把它分为即时和延时任务

3403

即使任务当即延时任务

3404

等到慨叹大于四大叹才会调度执行

3405

然后呢

3406

在红任务重自己

3407

不只是要用界面的交互

3408

对不对

3409

然后我们再来一遍

3410

第一个

3411

这个代码其实非常简单了

3412

烂等于sig man对吧

3413

Execution context与3a context不等于context

3414

然后就

3415

直接到下一个re consider接上去

3416

剩下的那么都走一步

3417

掉入逻辑

3418

这儿会有一个

3419

会有一个复用的一个逻辑

3420

同时就是一个缓存重用他的一个逻辑

3421

那么我们的连续存在的CS data

3422

您现在现在就被优化掉了这个这个逻辑

3423

接下来就是把它放到我们的

3424

把它放在我们的schedule back就是计算expression to了

3425

计算XX

3426

然后呢

3427

把它区分成不同的任务

3428

一个是即时任务

3429

一个岩石任务

3430

即使任务的话

3431

那么就发起调度

3432

原始任务的话就等着

3433

发起调度之后

3434

把它通过message channel这儿

3435

这儿其实信息量还是蛮大的

3436

因为有很多有很多东西可能带来试试新鲜的玩意儿

3437

比如说C1000了

3438

大家下来可以再看看S7000了

3439

反正是个红任务

3440

当POINT2的post message发起的时候

3441

Pet pet1的on message这个回调会执行

3442

而且在红任务当中执行

3443

因此

3444

因此我们就可以做到最上面的这个

3445

这个像做到这上面的这个效果就是什么呢

3446

这个上面的这个

3447

这样子的效果对吧

3448

这样子效果就是可以实现的

3449

这个就是

3450

就是因为他放在了

3451

放在了每次签到当中执行

3452

其实这段其实已经删了不少代码了

3453

原来的时候他还他之前他是通过request idle call back

3454

如果大家看过一些文章的话

3455

应该

3456

会对这个有一些会有一些文章有印象

3457

他会他会介绍

3458

就是它是通过request idle call back

3459

然后在每一天的空闲时间

3460

他会利用他的空闲时间来执行

3461

对

3462

他们说的没错

3463

但是现在这个代码里没有了

3464

原因是已经被删掉了

3465

应该是之前

3466

我看了一下那个

3467

别人问他就是外国外有网友问为什么

3468

就是把那个request that a call back

3469

给删掉

3470

他就他觉得首先那个东西

3471

首先这个东西效果不是特别明显

3472

其次增大了复杂度

3473

复杂度显著的增高了

3474

确实之前那个逻辑看到我也头疼

3475

我也头疼

3476

特别麻烦特别麻烦

3477

所以后面更新的版本

3478

他已经把那块代码给删掉了

3479

删掉了就变成现在这样了

3480

就已经没有通过u CAS I call back来做了

3481

实际上我们现在所讲的ROC时期

3482

有一些东西在RIGHT18里也优化

3483

这个优化的东西我会给大家讲到

3484

给大家讲到

3485

但现在还没有涉及到

3486

只是说这么一嘴

3487

只是市面上有通过request that call back这样的文章

3488

我也看过

3489

他说的确实也对

3490

但是版本不一样

3491

但版本不一样

3492

所以要有信心

3493

不要不要

3494

你可以自己去看一下

3495

可以自己到时候在大门里去看一下

3496

现在它就已经没有了开赛的卡bug了

3497

执行了

3498

执行宏任务

3499

在红任务里执行任务

3500

在红任务里执行

3501

好好那个哇噻

3502

在红肉里

3503

执行那个同步的任务

3504

每一个的每一个执行的时候

3505

他都会去判断一个俄罗斯timer

3506

然后他会把他们村里面的原始任务判断她的私探是不是小于当前时间

3507

如果是的话

3508

就把它拿出来

3509

拿出来之后继续去循环

3510

循环下一个

3511

循环到下一个活动当中去执行

3512

这就是整个调度逻辑

3513

大概就这样

3514

我们看一下

3515

再看一下这个图

3516

为了为了这块逻辑写了很多东西

3517

同步优先级对吧

3518

直接掉一部优先级分两个类

3519

分两个类

3520

但是他们都会放到她里面去

3521

每次之前都会先资金要到20

3522

她又会把它添加到

3523

这个advance

3524

就会把他们困中添加到他这个空当中去

3525

也就是说这个摊位他就等嘛

3526

对吧

3527

他就等

3528

按理说他应该是直接

3529

不过这个不太会用

3530

再删了吧

3531

他实际上是直接把它又放到了他这个片中去

3532

怎么搞的

3533

这是actors OK

3534

今天我们大概讲的内容就这么多

3535

回顾一下吧

3536

回顾一下

3537

首先讲到了极点

3538

就是价格的这个眼镜15

3539

他有什么缺点

3540

有一个长地归他就立刻不行了

3541

就卡顿住了

3542

16

3543

它可以做到这样的效果

3544

那么它是依赖于它是依赖于两两个方面

3545

一个是他的调度任务变得在红任务执行

3546

因此它的主线程并没有被占被完全占据

3547

第二个是他对更新做了优先级

3548

因此如果有多个更新同时处理

3549

那么高优先级会中断的优先级的

3550

但是rocket时期里又做了扩展原因做了扩展的原因已经说了

3551

是因为出现了SaaS的这种高优先级IO任务会组成的优先级CPU任务

3552

同样会出现页面的假死状态

3553

所以lions它可以同时发起多个优先级

3554

同时处理多个优先级的任务来解决这个问题

3555

来解决这个问题

3556

然后我们这儿看到了一些Les

3557

就是Les具体的

3558

Less具体的计算

3559

还有less具体的计算

3560

在advance具体的

3561

Less

3562

不在这儿吗

3563

我是刚刚看到的那个我删了吗

3564

嗯

3565

就是这个就是这个

3566

但是具体的计算逻辑这块是安慰的

3567

这块我们也给大家讲到了

3568

大家理解的也挺好的

3569

反正理解的也挺好的

3570

下来可以再看看

3571

这非常的精妙

3572

对安慰

3573

安慰运算

3574

这挺精妙的

3575

我觉得

3576

然后呢

3577

他写的

3578

他写的这个

3579

这个是发布note节点以及fiber tree

3580

特别是长什么样子

3581

然后大致的调度逻辑

3582

然后给大家讲到了

3583

以及render

3584

他和她为什么和其他的不一样

3585

他为什么同步任务

3586

其他任务不一样

3587

这是因为他有那个

3588

我在想

3589

其实这是第一块儿

3590

当我们把最后

3591

把最后把钱三块全部连起来的时候

3592

然后到时候在讲话的时候就会发现

3593

所有的东西

3594

他们就是他们就是骨骼

3595

所有东西都是挂着在他们之上的

3596

如果

3597

如果说我们不讲这个会发生什么

3598

假如假如同学们

3599

假如我直接给大家讲

3600

护士绝对讲不懂

3601

为啥

3602

因为这局

3603

因为他们的

3604

因为hooks这块逻辑

3605

他就是挂在这三块之上的

3606

如果你不懂这样

3607

比如consider或者这个

3608

Render阶段

3609

这两块儿不明白

3610

你就hooks

3611

比如它的代码虽然说比较少

3612

但是你看不懂他做哪行代码会有什么用

3613

就是你完全不知道他作用是什么

3614

这就是react的源码

3615

看起来比较困难的一点

3616

就是它的这个联系性特别大

3617

联系性特别大

3618

你如果把前面两块儿看不明白

3619

那么你其他的也就不用看了

3620

因为看不懂

3621

他就是虽然说他可能就只有几行代码

3622

可能讲代码它最后后面会发生的变化确实特别多特别多

3623

就像我们Thursday to对不对

3624

C EST他后面也会发生很多的变化

3625

也会发生很大的变化

3626

你就不行

3627

对

3628

护士太多whose

3629

但是我们把

3630

这几块搞明白了

3631

我们再看hooks

3632

绝对能明白

3633

非常能

3634

绝对能搞明白会比直接讲Linux会简单很多

3635

种类种类也不是很多

3636

但我们也讲不完

3637

会下节课下节课会讲

3638

下面一个就是re consider

3639

当地府就在它中间

3640

它里边儿

3641

然后和render这两个

3642

我看一下还有什么问题

3643

批处理人等待的时间都是什么规定呢

3644

什么

3645

你是说

3646

Petri等待的时间周期

3647

是这里吗

3648

可以说这里马晓巴同学

3649

时钟周期是怎么规定的

3650

他实际上

3651

再看

3652

这儿

3653

他有一个科诺是周期的

3654

那个可怕的内就是bug的类

3655

在rock的时期

3656

这在rocket时期里

3657

他这么干他

3658

他必须在同一个

3659

她不能再红任务当中

3660

也不能在cmos里边儿

3661

它只能在

3662

喝它放在同一级

3663

也就是说

3664

也就是如果说你把假如说这样

3665

我把它拿出来就是

3666

set set

3667

对吧

3668

那

3669

这样写的

3670

他是红

3671

他那个是批处理的

3672

但是如果你把它放在system out

3673

当我们看到它实际上因为三帽子它就会等嘛

3674

对吧

3675

就会等到下一个宏任务中

3676

他就把它放到了下一个宏任务重了

3677

所以那即使是这样子

3678

那他就已经不在一起了

3679

最近不太想

3680

那么它的批处理就失效了

3681

放在cmos中

3682

放在他帽子里

3683

那么他的

3684

在ROCK17中的PC是失效的

3685

但是在REC18中他就不失效了

3686

这就是17和18的区别

3687

在18中他对这个情况做了处理

3688

这人家做了处理

3689

他就

3690

又是在一个那个

3691

时间周期内一个同一个时间周期内

3692

在rock时期里

3693

他是他是不同的X8又正常了

3694

如果说不是在cmos之类的话

3695

那么

3696

你就看他的这个fiber节点

3697

它的fiber节点这个科诺的

3698

如果他这个科诺的

3699

同样也是在一个相当于是这样的

3700

对相当于是

3701

还是刚刚那个图

3702

还是刚刚那个图

3703

他从那儿进来开始

3704

它首先是一种

3705

主线程进来的对不对

3706

他把这个任务放倒

3707

进来之后

3708

他把这个任务放到了哪里

3709

放倒了

3710

红

3711

任务当中

3712

下个任务再进来

3713

因此如果下一个任务再进来的时候

3714

因为它还没有被执行嘛

3715

所以这个课根本还存在

3716

就这进来一个

3717

下一个又进来了

3718

因为红

3719

因为他吧放在红色当中了

3720

它是客观工作还存在

3721

所以他就可以服用

3722

如果你把它放在C盘猫在里边

3723

那么

3724

那么

3725

当你执行赛模特的时候

3726

这个红任务就已经执行了

3727

我刚刚讲过

3728

他会在三没得之前执行

3729

山猫之前执行

3730

所以所以也放在C大猫的里执行

3731

它就等不到了

3732

那么下一次他就失效了

3733

如果说你是在他执行之前

3734

就在这个红任务执行之前

3735

一直有新的任务进来

3736

那么她是会一直在同一个时钟周期内的四个周期内的

3737

对

3738

是的是的

3739

所以但是这个是在class里边儿

3740

如果是

3741

如果你是在那个hooks中

3742

比如hooks中的话

3743

他就不一样

3744

X中他没有批处理

3745

可以hooks中他没有做自动的批处理

3746

这个我们讲hooks会给大家区分一下

3747

现在只是给大家说一嘴

3748

这针对的是啥

3749

我这写的一直是distance is state

3750

如果是护士

3751

比如他通过

3752

比如说这个name

3753

比如就算是同一个

3754

就算是同一个连续的东西

3755

塞name c的edge

3756

那么他同样要发

3757

他同样要发起两次更新

3758

因为在hooks在17中它是不支持

3759

在17中它是不支持自动做批处理的

3760

你得自己做

3761

你自己做还是不一样

3762

还是有点不一样的地方

3763

能明白吗

3764

行

3765

今天的内容大概就讲到这儿

3766

讲了两个小时

3767

希望大家

3768

然后后面的话也是周天周天的话我们再见

3769

再见

3770

再见吧

3771

好的

3772

谢谢同学们

3773

拜拜

