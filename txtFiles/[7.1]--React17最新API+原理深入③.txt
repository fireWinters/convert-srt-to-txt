1

对符合实际

2

要求孤独的风景

3

自从开始时间还有什么事好关心

4

他可真不再象征和平

5

我从此被提醒着社会时的声音

6

我用漂亮的押韵形容

7

被偷的爱情

8

开始

9

整天在漫天飞行

10

送你的白色玫瑰在纯白的花

11

7101夜在树枝上

12

诡异的很安静

13

静静听我黑色的大衣的你日渐冰冷的回忆

14

走过的走过

15

生命还是迷茫

16

无极在空旷的墓地老去

17

我还爱你

18

这首

19

歌曲

20

记得我死去的爱情

21

点点风雨的声音

22

青春

23

再见

24

美丽的森林

25

很熟悉

26

记得我死去的爱情

27

在月光下

28

新的

29

还是如此

30

那么热情

31

的心

32

这些歌词整天伸着森林

33

而我的眼睛没有思考

34

失去你

35

泪水混浊不清

36

失去你

37

我连笑容都有放在咱们的顶

38

我的伤心像一口没有水的估计经历的自信就会后悔莫及的爱情

39

悲剧

40

记得我死去的爱情

41

偏偏风的声音

42

再见

43

我的思念很小心

44

地盯着

45

我死去的爱情

46

甜蜜

47

在月光下

48

还是如此的热闹

49

情景

50

的新

51

表情的风景

52

自己也在开始

53

时间还有什么时候

54

都在想着隔壁的重复的提醒着什么是

55

爱情

56

同学们

57

还是08:05开始啦

58

老板转了咖啡

59

我手一杯

60

品尝你的美

61

留下唇印的嘴

62

花店玫瑰名字写错

63

谁告白

64

气球风吹到对街

65

微笑在脸上飞

66

你说你有点难追

67

想让我知难而退

68

礼物不需挑最贵

69

只要香榭的落叶

70

一场浪漫的

71

约会不害怕搞砸一切

72

拥有你就拥有全世界

73

亲爱的

74

爱上你

75

从那天起甜蜜的很轻

76

亲爱的

77

别任性

78

你的眼睛在说

79

我

80

知道了

81

爸说

82

安了个非

83

我说

84

一杯品尝你的美

85

留下唇印的

86

水

87

蝴蝶

88

玫瑰自己做鞋

89

告白

90

气球风吹到对街

91

微笑在你的伤悲

92

别说你有点难追

93

想让我知难而退

94

吕布不需挑最贵

95

只要香榭的落叶隐藏浪漫的约会

96

不害怕搞砸一切

97

拥有你

98

就拥有全世界

99

亲爱的

100

爱上你

101

从那天起甜蜜的很轻

102

亲爱的

103

别任性

104

你的眼睛在说

105

亲爱的

106

爱上你

107

日记

108

飘香水的回忆

109

你曾经的梦境

110

全都有你

111

搅拌在一起

112

亲爱的

113

别任性

114

你的眼睛

115

再说

116

我愿意

117

拼命开始

118

悲伤要怎么变成

119

我的天天上

120

中炸弹

121

一抹浅浅的

122

医用春雨说

123

你要离开

124

难过无声般留下来

125

潮水

126

一定平凡

127

不是难

128

而是

129

总是

130

话说不出来

131

海鸟跟鱼相爱只是一场意外

132

我们的爱假一直存在

133

梦中

134

之类情深深

135

转身离开

136

分手

137

说不出来

138

蔚蓝的珊瑚海

139

错过瞬间苍白

140

当初彼此

141

不够成熟

142

坦白

143

寂寞

144

的笑容

145

勉强不来爱上南山竹海

146

毁坏的沙雕重来

147

有裂痕的爱怎么重开

148

只是一切

149

结束太快

150

你说你无法

151

被看

152

隐藏什么

153

我们也已经无心猜猜猜

154

面向海风

155

咸咸的

156

深深的

157

撑不住

158

还有未来

159

诠释

160

着

161

说不出来

162

还要等于相爱

163

只是一场

164

爱

165

一直存在

166

天泪器蒸下

167

好了

168

同学们

169

时间到了

170

我们就

171

你们就正式开始今天晚上的课程啦

172

OK

173

今天的话主要讲的是X的对hooks的源码分析

174

Hooks这块因为是X16.8

175

然后新更新出来的一个功能

176

而且在现在

177

一般大厂的话用的也比较频繁

178

而且他也又有一定的上手难度

179

所以呢

180

在面试的过程当中被问到的频率

181

都是比其他的温暖的频率要高很多的

182

所以把它

183

单独拿了出来

184

然后我们做一个比较完整的一个讲解

185

这个比较完整的讲解

186

首先就是面试官一般在

187

护士

188

这块地是问的

189

会问很多相关问题

190

其中呢

191

这就是一开

192

一开始可能会首先问问他

193

就是为什么

194

就是hooks

195

她到底为什么hooks会流行起来

196

然后hook解决了一个什么样的问题

197

解决什么样的问题

198

在

199

再大点那个字也看不到

200

就在有hooks之前

201

我要讲一下

202

大概讲一下

203

再有hook之前

204

其实在的reg代码里

205

一般是以class component为主

206

也就是以class为主

207

因为它可以定义生命周期

208

可以定义stated

209

所以他的能力比较齐全

210

在没有户口之前呢

211

我们的function component只能打辅助

212

主要的原因就是因为他不能够定义state

213

而且也没有任何的生命周期

214

所以在hooks出现之前

215

他的

216

最佳实践什么

217

在乎出现之前的最佳实践

218

护士

219

出现前的

220

最佳时间就是class comma

221

做容器组件对

222

这个

223

做容器

224

组件

225

然后发现component

226

做

227

Class component做容器组件

228

Function component做

229

UI组件

230

原因就是因为我们的方向和那个时候的能力实际上是不足的

231

他他只能够通过props

232

把C的传递进来是一种方式

233

这一种方式而自己不能定死的

234

而且也没有生命周期这种概念

235

因此这就是以前的生命这个最佳时间

236

但是

237

如果遇到比如想一下这个问题

238

你刚开始把一个组件写成了容器组件写成写成了UI组件

239

如果说随着需求的迭代

240

对吧

241

随着需求迭代

242

比如那个组件的功能越来越大

243

越来越大

244

这种事情是非常有可能发生的

245

对不对

246

那么怎么办呢

247

唯一唯一唯一的办法就是你可能你可以继续的

248

通过props把父组件传递进来

249

那可能传递的属性越来越多

250

越来越多

251

那么如果

252

当需求更改到就是你觉得已经没办法维护的时候

253

然后你可能会想办法把它重新又改造成class组件

254

改成开始建

255

这样的后期才会更好的维护

256

总之你的业务的复杂度越高

257

你就会觉得放心卡盟他就越不适用

258

这些之前的一个问题

259

这样一个问题

260

那可能有代码里很大量的都是卡组件

261

卡组件当然也挺不错的

262

但是但是他的但他他的那个代码量其实会比较庞大

263

比较大

264

我们要定义非常多的生命周期

265

然后呢

266

然后一般要写这次写代码的时候

267

可能已经十多行了

268

已经十多行了

269

对啊

270

像这种props比较多的时候用过

271

对象包揽一下不可以吗

272

那你的那你的主见

273

那你的主见就会永远更新

274

就是任何一个属性更新的时候

275

你的那个UI组件是不是会永远更新

276

任何一个属性的变化

277

你的都会变好

278

这就是

279

一开始

280

一开始就是这么搞的

281

那么hooks出现之后

282

出现之后那么

283

有一个什么变化

284

就是在hooks里

285

就是在函数组件里

286

因为他就是为函数组件添加功能似的

287

那么会出现之后我们在函数间里

288

已经可以

289

以及函数线就可以自定义state

290

也可以模拟生命周期

291

然后呢

292

从而减少

293

减少就是减少了那个

294

既补齐了函数组件的功能

295

同时你用class组件就大家就发现一件事情

296

你用class组件所做的事情

297

你用函数组件大概花一半的代码量就能够把这个事情给做好

298

而且逻辑的话会更加的清晰

299

因为他是

300

基于函数的逻辑会更加清晰

301

然后大家再上手了之后

302

然后就觉得这玩意儿挺好使的

303

都

304

但是他有一些定的问题

305

但是也不妨碍大家对它的热情

306

因为大家都是想少写几行代码

307

都是想少写几行代码

308

而且这个诱惑是非常非常大的

309

刚开始的时候

310

诱惑是非常大的

311

所以它解决了什么样的问题

312

解决了函数组件

313

它为函数组件增加了定义state

314

定义state膜

315

还有模拟生命周期

316

然后使用context能力补齐的能力

317

然后呢

318

显著地减少了代码量

319

而且提升了

320

提升了那个代码的可读性

321

这都是hooks hooks带来的变化

322

这就是为什么

323

就是它解决什么这样的问题

324

这也就是大场面

325

或者说很多的程序员

326

都喜欢选择它的一个比较重要的原因

327

比较重要的原因

328

然后

329

那么我们就接下来要讲那个hooks的会有什么问题

330

Looks有什么问题

331

待会给大家讲

332

待会给大家

333

孩子出现什么问题呢

334

没什么问题

335

我说是

336

或者是它可能会有一些坑

337

他可能会有一定的坑

338

你都踩过你才知道

339

不然的话

340

你用起来的话

341

它的上手上手成本会比class组件要大一些

342

要大一些

343

所以这也是这也是为什么

344

这也是为什么就是面试的时候老爱问这个

345

因为它真的是比克拉组建

346

他的上手难度是存在的

347

蔡澜

348

都是存在的

349

有一定的坑

350

你

351

你不踩的话你就不知道

352

我们

353

接下来讲一下那个hooks基本用法

354

基本用法

355

这个可能大多数的同学都是知道的

356

比如比如他有很多hooks

357

有很多hooks

358

我们就选选几个我们经常用的

359

常用的比如这个

360

Use context

361

我看一下use context

362

我们大概讲一下它的原

363

它的

364

它是什么作用

365

Use context

366

在之前在

367

函数组件

368

你不能够使用context

369

不能够使用context

370

所以use context的顾名思义也就是能够在函数组件里使用context

371

Use rid use effect

372

这个是比较重要的一个属性

373

向use effect usually ah the fact

374

这两个他们都是

375

使用方法都是差不多的

376

只是一个同步一个异步的

377

它们的功能就是模拟生殖器

378

比如像的MT的DA up date he will amount

379

这三个生命周期

380

You the fact

381

它一个一个hooks

382

就可以把他们三个都给模拟到位

383

而且用的代码量还很少

384

这就是他的一个比较大的优势u c Mo它主要的作用是缓存

385

缓存一个值

386

You school back

387

它的作用是缓冲一个函数

388

Uf它就是能够在函数组件也正常的riff

389

Use date就是最常用

390

最常用的一个功能呢

391

就是定义state和改变state的能力

392

定义色彩和改变色的能力

393

大概平常非常常用的有这些

394

但还有一些其他的

395

还有其他的

396

我们现在一个一个来看

397

这几个平常都会用到的

398

然后依据这些

399

然后就会有非常非常多的面试的问题

400

比如说

401

比如这个

402

比如在乎

403

试问一下在hooks里

404

怎么让他做

405

在就是在函数组件里怎么让他做类似于pure component的事情

406

对props做钱比较

407

做前比较

408

这是should component update吗

409

Should component update的

410

学Java的

411

好吧

412

就是类似pen的的事情

413

因为component是他

414

它的功能就是对props做前比较

415

然后如果钱比较没有任何的变化的话就不渲染

416

钱比较

417

就是

418

Props没有变化

419

就不重新选就不重新算的

420

对不对

421

在乎可以怎么做这样的一件事情

422

刚有同学

423

我看已经有同学在抢答了

424

用user memo

425

You Yong use memo

426

一般一般他都在pure component

427

其实

428

Peer component在relatively

429

他首先他肯定是一个class component

430

其实right提供了另外一个

431

另外一个API是专门对

432

是专门对那个

433

函数组件来做封装的就是remo

434

对

435

Write down ready memo

436

spread.member它里面就会做一层铅比较

437

会做起来比较

438

而且这个是只针对hooks

439

是只针对函数组件的

440

那有同学就有疑问了

441

老师

442

我们不是讲hooks吗

443

Memo

444

他好像并不是一个hooks

445

对吧

446

我们上面讲的是use memory read member

447

并不是一个hooks

448

如果说ready memo

449

而且真正的是函数组件

450

针对的是函数组件的嘛

451

那么跟hooks好像就是没有hooks的话

452

他也能做到

453

他似乎也是能够做到的

454

对吧

455

好像是这么个道理

456

但实际上如果你只用regular member的话

457

你会发现不行

458

我们可以尝试一下

459

假如说假如说举个例子

460

假设举一个简单例子

461

比如说这个翻新

462

APP

463

拿着return一个

464

这就是填一个a吧

465

然后我这一个方形a

466

那我再return一个DV

467

第二位

468

然后我给他传一个截图

469

给他传一个

470

我不记这是一个对象

471

或者再传一个千金

472

的一个方法

473

然后现在我想现在我想

474

我再来一个吧

475

我再来

476

然后再来一个cost

477

然后呢

478

这是我

479

来做

480

好

481

前进name的时候

482

我就给他set name

483

或者再做点其他什么事情

484

好在这里其他东西

485

然后呢

486

假如我把这个name传给他

487

就是change令传给他

488

然后B的话就穿一个

489

接着我去参一个

490

Object

491

OK

492

那我再传一个

493

注意这样的一个

494

就这样的一个非常简单的一个调用

495

一个非常简单的调用

496

那假如说我我APP里的更新

497

那么我肯定是我肯定是期望什么呢

498

我肯定是希望我的

499

比如我的name变化

500

那么我不影响

501

我不影响我的B组线对不对

502

我的B组线不要跟着变

503

我的假如我的奥秘借遍了

504

这个变了

505

我希望他不要影响我a组件

506

不要让我a组间发生

507

那个RN的不想让他重新渲染

508

Na

509

可能会想

510

那么我们就要操作了

511

怎么操作呢

512

通常情况下对它做一个

513

做一个封装

514

把它变成

515

这里就把它变成

516

这个是咖色

517

对吧

518

这是原本是一个函数线

519

那就把它包裹在

520

regular member中

521

包括remember中

522

但这样行不行

523

如果大家去尝试的话就会发现

524

还是不行

525

我的OBG

526

假如一遍我的我的这个a

527

我的a组建的组建

528

它还是会发生重新生的

529

她仍然会重新扔的

530

我的这个a还是会重新扔的

531

原因是什么呢

532

原因是我在我在

533

比如我的那个name一遍

534

就是如果我的name一遍

535

一般是通过city name改变的吗

536

我通过city name e改

537

改了之后

538

CM

539

OK吧

540

假如OBG

541

我通过CDOBJ1改我的这个函数题

542

根据我们今天白天所讲到的

543

我们又发起了一次更新

544

发起一次更新

545

我们要重新构建February

546

那么就会走到begin work那个地方

547

在begin work那个地方

548

由由于它是一个函数组件

549

那么他肯定会执行它的函数体

550

也就说这个会重新执行

551

这块重新执行之后

552

那么我们的name还是之前那个没问题

553

但是我们的change name

554

我们的change name他就变成了一个新的函数了

555

大家看因为因为什么

556

因为这个函数题

557

整个函数体已经被重新执行了

558

之前那个千金链

559

我们每每我们美这样子操作

560

美这样子调一番

561

我们得到的这个方方法

562

他总会是一个新的函数儿

563

这个新的函数和上一次更新的那个老的函数

564

虽然长得是一模一样的

565

但是大家知道在在那个JS里

566

就像两个长得一模一样的对象

567

只要它的指向不一样

568

就只要他在

569

它的内存的地址不一样

570

那么它

571

被判断她

572

他就一定会判断为假

573

对不对

574

这也是一样

575

虽然说这个切面它并没有任何的变化

576

但是由于他是被重新创建了

577

它在内存中的地址和上一次的存存的地址是不一样的

578

所以即使是reading memo

579

在进行钱比较的时候

580

他是永远会比成first

581

就当时传的时候

582

一个方法的时候

583

他永远会比成force那么

584

因此

585

你只用read the memo

586

把自制件包裹了

587

你会发现没有用

588

就发现没用

589

只要你传了方法

590

你就发现没有用

591

原因就是

592

原因就是虽然说他们的方法的名字就是方法

593

内容也是一样的

594

感觉什么都是一样的

595

也确实什么都是一样的

596

但是地址不一样

597

他们就是两个不同的东西

598

因此为了解决这个问题

599

就有了use Co BAC

600

通过u SCO back

601

它的用法很简单

602

第一个是一个含

603

第一个参数是一个函数体

604

第二个参数是它的依赖函数

605

叫做依赖

606

我们看一下

607

我们现在会看到这种写法

608

然后我们把我们把这个方法包裹在use back的

609

第一个参数里

610

第一个第一个参数中

611

那么这种情况一般是这样

612

就是你依赖着什么

613

你在函数

614

你在这个函数体内调用使用了什么变量

615

你就把这个变量加到她的依赖数组里

616

他这是什么意思呢

617

意思是只有N变化的时候

618

它会重新创建一个函数

619

否则他就使用使用之前的那个函数的一个引用

620

就假如说我的N不变

621

比如OBG变了吗

622

对吧

623

我的N没有变化

624

那么即使是我的这个APP又重新render了我的这个千金链

625

得到的还是之前那一个引用

626

那么

627

我的这个a组件就不会变

628

我的组件就不会重新登的

629

这样才能达到效果

630

那假如N遍了呢

631

N遍了那么

632

为了让他内部的函数体拿到最新的值

633

最新的N这个值

634

那么钱GM就会创建一个新的函数

635

这个时候才会创建一个新的函数

636

然后才会传给

637

这个时候是正常的

638

没有问题

639

因为你的属性其实是正常的变化

640

这块大家有听明白吗

641

如果说要进行一个在hooks里进行一个前比较

642

光是用REC ton memo

643

这个是得不了分的

644

如果面试官问了你光用writing memo

645

这个是没办法得分的

646

你必须要辅以

647

Use the back

648

你必须辅以use Co BAC来对函数做缓存

649

如果你要传递的是一个对象

650

大家瞧

651

如果你要传递的是一个对象

652

那么其实也是有问题的

653

因为你的对象就算没变

654

这个这个还好

655

假如你是假如你就是

656

Or BG

657

假币是这样的

658

你传递给了B这个组件

659

就算没有任何的

660

同样也是一样

661

因为它是一个什么

662

它虽然是一个值

663

它不是

664

它不是边

665

他不是函数

666

但是它是一个引用类型的值

667

对不对

668

他和函数面临的是同一个问题

669

他函数面临的是同一个问题

670

所以对于直怎么办

671

对于执有一个方法叫做use memo对不对

672

Use memo

673

它会返回一个值

674

它它的使用方式也是一样的

675

也是一个大数字music back说白了是对函数的

676

是对函数的缓存

677

Use memo是对对象的缓存

678

你可以理解为是对象的缓存

679

通过这两个东西再加上

680

Use或者use memo再加上memo的

681

再加上memo的这个钱比较

682

然后才能够完整的做一次

683

漂component的事情

684

Perhaps

685

没有变化就不重新更改

686

这样才能够完整的做出来

687

use regular member可以替换成u SCO back吗

688

Remember是必须的

689

但是光有它还不够

690

要用regular member包裹在子组件上

691

大家看

692

Memo是包括在子组件上

693

包括在a上的

694

ER you strike

695

他是在父组件

696

因为我要用父组件传递给他

697

传递给他属性是包括在父组件传递给他属性上的

698

他们两个要一起用

699

单独用的话

700

有可能是没有效果的

701

但也有可能有效果

702

如果说如果你只这样传

703

对吧

704

你只传一个

705

只传一个是菌

706

那么它是有效果的

707

但你的只要你的变量一家

708

变量易家这没有用Excel包起来

709

那么他的钱比较就是做不了的

710

这点能理解吗同学们

711

能理解的扣一个一

712

OK

713

好的

714

这个面试常问的常问的

715

一般来说一一般来说

716

因为因为它的官方网站里就说的是

717

什么呢

718

就是music可以用来做

719

用来做那个缓存吗

720

用来做缓存

721

但是呢

722

之前的时候有一些

723

有一些来面试的一些同学

724

可能并不知道

725

他需要和memo结合享用

726

Memo结合享用

727

而且很多可能并没有真实的来做优化

728

只是听别人说过一嘴

729

现在

730

现在就是如果说大家在面试中

731

中问到了

732

那么他一定是要结合起来使用才会有效果的

733

否则的话是没有办法得分的

734

这个地方就得不了分

735

OK

736

这个就是

737

那么我们至少我们知道啦

738

Use Co BAC use memo

739

的作用是什么

740

他们两个其实差不多

741

但是只是一个缓存function

742

一个缓存值

743

一个缓动值

744

You j EST我们刚刚也定义了对不对

745

You state的方使用方式就是通过

746

通过这他有接受一个参数

747

这个参数是

748

是它的初始值

749

是它初始值

750

然后返回一个数组

751

第一项是

752

直第二项是更改值的方法

753

第二项是更改的方法

754

这就是它的用法

755

而他这个值就是初始值

756

既可以是一个

757

既可以是一个变量

758

既可以是一个

759

比如比如说这种

760

数字就是

761

这个是一个那个基本类型的

762

也可以是引用类型

763

而且也可以是一个方形

764

如果是一个方形的话

765

那么你需要给他

766

你需要你需要一个return的

767

你要反馈的东西也可以是一个方形都可以

768

都给它还是比较

769

就是对函数是比较友好的

770

你什么地方都可以查函数

771

而且有的时候是有用的

772

有的时候是有用的

773

You state就是这样做的

774

就这样用的

775

我们再来看一下

776

You the effect so you the effect

777

You the fac的

778

它可以模拟三个生命周期

779

我刚刚讲过可以模拟三个生命周期对吧

780

那么它分别怎么办的呢

781

我就直接给大家

782

我就直接给大家写一写比如如果在cars里面

783

那么他一般来说会定义complaint demanded对不对

784

那么它的写法也是

785

也是和刚刚use call back一样

786

一个他一个

787

函数第一个参数是一个函数

788

第二个是一个数组

789

第一个他的依赖宿主

790

而这儿的意思是

791

如果把它藏为空

792

如果把它传为了空

793

意思是他只有在第一次就是choose mount阶段MT阶段会执行一次

794

其他的时候就再也不会自信了

795

所以当我们这样写的时候

796

由于她的依赖

797

速度是空的

798

由于她的依赖速度是空的

799

所以他只会执行一次

800

而这个执行一次的时机

801

执行涉时机和那个

802

执行的实际和那个component did mount是差不多的

803

只是他是个一补呢

804

他是个一补

805

他

806

他肯定也是会再当渲染之后才执行

807

如果你想要完美地模拟

808

完美地模拟就是complaint demanded

809

那就用user you out

810

Effect这两个都可以

811

但是建议大官方是建议大家使用use effect

812

因为它是一部你这里面如果做了什么

813

大的操作

814

那么他实际上他是不会影响的

815

那么什么时候用官方建议

816

什么时候用use your out effect呢

817

你有什么和党有关的东西

818

那么你可以

819

那么你在这里用同步的去改就行了

820

就不用等

821

就不用等

822

就同步的去改

823

所以

824

所以这两者的区别就是一个是同步

825

一个是异步

826

一个同步

827

这两个的区别就是我们现在就按最常用的you the fact来讲

828

它们两个的用法都是一模一样的

829

而我写的这这一段的号代码就是类似于在component did mount里

830

Component did mount里做一做一件事情

831

这就相当于模拟了component did mount的生命周期

832

因为他也执行只执行一次

833

第二种

834

我要模拟component did update

835

其实对于

836

You d find的时候就非常轻松

837

比如说我的泪没变化

838

对吧

839

我立马变了

840

那么

841

他会执行两次这个函数

842

它会执行两次

843

第一次也是在也是在mount阶段

844

初始化页面初始化的时候

845

它会执行一次

846

然后呢

847

在name

848

只要发生name发生了更改

849

大家看name只要一改

850

他就会立刻掉一次

851

内容一改他就立刻掉

852

是不是就相当于相当于掉了component

853

Di DA Di LA

854

因为component的它类似于一次聚合

855

就是你任何的

856

你任何的那个stayed一遍

857

他都会掉一次

858

然后还需要你手动的去判断

859

你可能要写很多个if去判断

860

If啊

861

比如props.name等

862

不等于上一个prove

863

Proof那个stayed in name还有这样子判断

864

然后他这其实是

865

自动的就给你拆开的

866

它是符合我们那个程序开发的一个

867

程序开发的一个单一职责的原则的

868

所以他看他写起来也会非常的

869

你就觉得写起来的时候会比会比component did update会更加的清晰

870

是不是我这很明显一个

871

就是的

872

戴帽子的时候

873

要做的事情一个是

874

Name变化的时候要做的事情

875

一个是a级变化的时候要做事情非常清晰

876

每一块的功能都是拆出来的

877

都是拆开的

878

但你如果想要多个也可以

879

但是你一定要

880

你一定要

881

注意区分就是你在添加依赖的时候一定要特别小心

882

一定要特别小心

883

不要加多了

884

加多了的话

885

你的寒你的这个函数的执行次数可能会比较多

886

如果那么改啦

887

立马调用一次也还是异步的吗

888

什么意思

889

内蒙改啦

890

对啊

891

有这个函数是不是也是吏部的

892

也是一部

893

更新了是吗

894

如果能改了

895

内蒙一更改

896

那没更改

897

因为他是state吗

898

那么肯定是一个state

899

如果这个state一遍

900

那么它会导致你的整个它是不是就发起了一次更新

901

待会我们会待会给大家更详细的演示

902

演示一番

903

但是我就大致说一说内幕一遍

904

他是不是就发起一次更新

905

发起一次更新的时候

906

它就会走我们白天的流程

907

先走schedule

908

然后再走

909

再走那个re consider

910

然后再走

911

再走commit阶段

912

然后当他又到达commit阶段的时候

913

那么他还是在第三

914

他还是在卡密特完之后

915

然后那个异步的就是异步的异步的红任务当中执行这段代码

916

执行资料代码对他的流程其实很长

917

但是它是靠在咱们咱们白天所讲的那个流程上的

918

待会给大家详细的分析

919

它并不是说你那么一遍内容变了

920

不会马上执行这个口感

921

肯定是不会的

922

OK

923

然后第二个生命周期我已经模拟完了

924

那么第三个不是说还有一个

925

We are amount嘛

926

对就是组件卸载的时候

927

逐渐卸载的时候

928

那么他其实是很巧妙

929

如果你有存在return

930

这是它的用法

931

就是我为什么会先讲它的用法

932

因为有同学可能没有用过X

933

那么我如果直接上来讲源码的话

934

那么连用法都不知道

935

那你肯定是听不懂的

936

我再讲第一节课的时候就说过

937

我们要学习源码

938

首先要去学习一下他的API到底是怎么死的

939

如果你不会用法

940

那你肯定是

941

看源码也看不明白

942

所以要先大致的讲一下它的用法

943

OK

944

现在

945

用component will UN mount

946

模拟的情况是这样的

947

嗯

948

阿曼达模拟情况是这样的

949

比如说smart

950

如果说有一个

951

如果说你的you the fact里你return的一个函数

952

同学们注意

953

你一定要是return是一个函数

954

那么它就会在你的组件卸载的时候

955

调用这个妈的就是

956

如果说你对他的一个函数

957

那么我在组件卸载的时候就掉他

958

如果你没有对他的感触

959

那就啥也没有

960

那就不用管

961

因此就这么

962

其实你整体来看

963

就这么1234566行代码

964

它就已经

965

可以模拟

966

Demanded update

967

Where are mt3个生命周期就模拟完了

968

我们一般经常做的一些需要在逐渐逐渐卸载的时候立刻销毁掉的东西

969

比如说绑定事件

970

对不对

971

大家能不能点

972

比如ADD event

973

Listener

974

比如我给他一个

975

Screw

976

Bill gates group

977

这叫做

978

昂酥肉

979

咋

980

Well his crew呢

981

可能你没调这个

982

你可能只掉一个click

983

那就click吧

984

这是我的名字都写好了

985

因为CPU的开销比较大

986

所以我就写了他

987

如果你用click或者没有没有把它及时给销毁掉的话

988

可能你觉得对你影响不是很大

989

但你用screw

990

那么你的开销可能就比较大了

991

那么你毫无疑问

992

你再卸载这个组件的时候

993

你就一定要把这个代码给加上

994

你看

995

大家大家瞧一瞧

996

相比于之前如果我要在那个喀什监理用的话就卡死

997

我们看一下它有什么优势

998

Component did mount

999

那么我们是这么写的

1000

我们必须这样写

1001

然后这是this点

1002

Hello component will mount

1003

然后是这样写

1004

有的同学可能觉得

1005

这样写也还是虽然多了抢代码

1006

但是也还是很清晰这是我这样

1007

我现在这么展示

1008

大家这么感觉是因为我没有其他逻辑

1009

我如果有其他的逻辑

1010

假如我在这里又加了很多

1011

中间又加了很多函数

1012

中间又加了N多个函数

1013

这里又加了很多其他的逻辑

1014

那么你的这个逻辑

1015

你的这个ad和remove

1016

他们实际上是同一个功能的两个部分

1017

对不对

1018

同一个功能的两个部分

1019

你你写这个功能的时候

1020

你ad VO CA lists and的时候

1021

毫无疑问你肯定会想办法

1022

下一个你就要写remove

1023

它实际上逻辑是很分散的

1024

他也就分散在两个方法功能

1025

两个两个生命周期内了

1026

你中间可能会加N多个东西

1027

就会导致他的东西很分散

1028

你如果写的不好的话

1029

找也难找

1030

看也难看

1031

但是这儿的话

1032

大家看它是一个玩具合成呢

1033

实际上是一个完整的一个整体

1034

大家有没有发现它是一个完整的整体

1035

你你在u这个UCS中写了

1036

你就给他返回一个return

1037

然后就把它给扔掉

1038

就直接把他给删掉

1039

功能的话

1040

它是一个整体的一个整体的一个模块儿

1041

也非常符合我们代码开发的那个单一职责的一个原则的一个

1042

这种原则是非常符合的

1043

为什么我建议大家在做这种有副作用的操作的时候

1044

一定要写

1045

一定要写这个

1046

一定要写这个函数

1047

Destroy这个函数是一定要写的

1048

原因是啥

1049

你比如说这个SQL的开销比较大

1050

对吧

1051

看起来比较大

1052

但是他也不会出错

1053

你如果要进行set interval的话就是

1054

你要进行interview的话

1055

如果不给他清掉了

1056

因为它是根据计时器来的吗

1057

你的你的那个可能程序直接就乱了

1058

比如说你那个计时他可能就是乱的

1059

因为因为他可能创建N多个计时器

1060

然后它这个几个技师之间就完全就乱了

1061

你如果比比对

1062

这个是

1063

这个是有血泪教训的

1064

刚开始如果不写这个

1065

真的就是两行泪

1066

你们真的就只有两行泪

1067

比如set interval的时候

1068

在在护士当中

1069

你如果把他不把这个给清掉

1070

如果把这个给清掉的话

1071

会非常的

1072

你的程序可能就是直接是错的程序会直接出错

1073

下面两个可能只是性性能不好

1074

而他就感觉像是一个bug一样

1075

就感觉像是一个bug

1076

他到时候会感

1077

如果你不清他就是一个

1078

他感觉是一个bug

1079

一定会

1080

你大家可以下去试一试

1081

如果有同学不相信

1082

可以下去试一试

1083

但是如果就算你在后面王了之后

1084

如果你能够及时地回想起来

1085

及时地回想起来

1086

Sight in TE我们王乐你如果时间以后

1087

大家在处理的时候发现时间乱了

1088

就是一种本来是应该是59秒

1089

本来应该是59秒

1090

突然一下子变成了40

1091

变成了其他什么几个树

1092

老师也想不明白了

1093

你就要想你的这个CD

1094

英特尔到底有没有把它给清掉

1095

那个坑到底有没有他坑掉

1096

到底有没有把它扔掉

1097

你把他坑掉

1098

你就会发现

1099

它又正常了

1100

就是这为什么要多提这么一嘴呢

1101

多提这么一嘴

1102

因为你第一次遇到这个问题的时候

1103

你可能是蒙的

1104

你不知道我就是正常的设了一个CD

1105

英特尔而已

1106

他怎么一下子

1107

他怎么一下子就

1108

奇奇怪怪的

1109

非常奇怪

1110

就这个原因

1111

因为你没有气

1112

OK

1113

然后这个关于这段you the fact的功能

1114

大家能理解能理解吗

1115

能理解的扣个一

1116

能理解扣个零

1117

这也是代码中脑出的问题

1118

老出的问题都是一些经验之谈

1119

OK

1120

那我们来看它其实还有一些其他的问题

1121

还有其他的问题

1122

或者是其他常见问题

1123

第一

1124

使用use date或者使用hooks

1125

这个太宽泛了

1126

就使用cooks

1127

只能在顶层使用

1128

不能出现在条件语句当中

1129

任何的条件语句当中都不可以

1130

什么意思

1131

这个可能大家也有所耳闻

1132

就算没有

1133

就算没有用过的

1134

应该也是有所耳闻的

1135

比如

1136

我如果

1137

比如我想在

1138

嗯

1139

If

1140

对吧

1141

If tu ni

1142

我想在这里用一个you the fact

1143

能不能用

1144

不能

1145

不能用同学不能用我之前

1146

遇到过有同学说

1147

就是我问use use that能不能放在

1148

能不能放在这个

1149

分支里

1150

他说不可以

1151

早上好

1152

我说you the fact能放吗

1153

他说可以

1154

我说为什么you state可以

1155

You the fact不行

1156

那就不知道了

1157

You the fact也不行

1158

所以我刚刚在这儿调整了一下

1159

就是只要是hooks use use effect

1160

毫无疑问也是hooks

1161

对不对

1162

Use effect也不可以

1163

我会给大家讲原因

1164

也也会给大家会给大家讲原因

1165

原因是什么呢

1166

我们不不论是used也好

1167

You are back也好

1168

You the fac也不能

1169

都不能

1170

Use the state也好

1171

Use call back you the fact也好

1172

所有的hooks

1173

她实际上在你的

1174

它都会在你的这个

1175

我们这个APP

1176

它是一个函数组件吗

1177

这个函数组件

1178

他在rap的内部里

1179

在red内不理

1180

他会给你描述

1181

描述为一个什么呢

1182

描述为一个fiber node节点

1183

这个大家这个大家应该知道

1184

对不对

1185

Fiber node节点

1186

他会描述一个发怒的节点

1187

而这个发怒的节点

1188

他把所有的hooks他是用一条链表存起来的

1189

比如

1190

我这是一个final的一个节点

1191

我有专门有一个属性来存hooks的

1192

这个发热建有一个呼属性成分

1193

是专门来护城hooks的

1194

不管你是use data

1195

对他来讲他是一个hooks

1196

对不对

1197

然后user back他的列表

1198

又练到下一个books

1199

Use effect

1200

又练到下一个hooks

1201

然后又练到下一个X

1202

然后又练到下一个X

1203

他是一个列表来的

1204

然后呢

1205

然后呢

1206

当这是初始化的时候嘛

1207

就是第一次慢的阶段的时候

1208

他就注册了一个这样的列表

1209

但是呢

1210

你一更新的时候

1211

比如你一更新

1212

你任何一个数

1213

你任何一个变量与更新

1214

那么他下下一次他就重新扔的这个函数题

1215

重新扔的这个函数题

1216

而重新中的这个函数体之后

1217

他就执行的是更新逻辑了

1218

更新逻辑他要找到

1219

就比如这个set name

1220

他要找到什么

1221

他要找到对应的这个name

1222

它是根据它就是根据顺序直接来找的

1223

比如说我的这个said name

1224

他一定就指向他

1225

他就一定指向这个位置

1226

我下面一个赛特他就指向这个位置

1227

下面就是这个

1228

它就是按位置来对应的

1229

如果你有任何一个if

1230

比如你这个F了

1231

比如你这个衣服了

1232

那么它的对应关系就会一下子错乱掉

1233

就有可能错乱了

1234

你的程序代码就直接就是错的了

1235

你就会发现

1236

本来我要改变的是我的内蒙

1237

怎么一下子改了age了

1238

你就有

1239

你如果用了if

1240

那么它就出现这种场景

1241

这毫无疑问

1242

代码直接就是错误的

1243

所以压根儿不能这么写

1244

有同学问

1245

自定义hooks可不可以

1246

自定义hooks也不可以

1247

原因是为啥你的自定义hooks你实际上会用到hooks

1248

对不对

1249

你的自定义hooks会用到hooks

1250

所以它包括了hooks

1251

那hooks能不能放在放放在条件分支点不行

1252

所以你要制定hooks也不可以

1253

那有同学说了

1254

那我就制定hooks

1255

假如没有福克斯呢

1256

那你就只是一个普通的方法而已

1257

那就不是自定义

1258

福克斯能理解吗

1259

能理解的扣个一

1260

不理解扣个零

1261

对

1262

他就是你永远记住他是一个练

1263

它就是一个链条

1264

它后面更新的时候

1265

我要准确的找到她

1266

你只要有个if

1267

我就我就没办法准确的找到它了

1268

他就可能找错

1269

那这绝对是不能不能被允许的

1270

但就是record也不允许你这么做

1271

他可以直接给你报错的

1272

就是如果面试官问到了这个问题的话

1273

那么我们的回答就可以是这样

1274

就是这样卫生

1275

这为什么

1276

但我们会再看代码的时候

1277

其实能够给大家讲到这一块儿

1278

能给大家讲到这一块儿

1279

这是第一个

1280

经常就是几个容易出问题的地方吧

1281

容易出问题的

1282

地方

1283

第二使用

1284

嗯

1285

史俊华

1286

什么事

1287

这什么意思呢

1288

喜欢什么意思

1289

比如说我又

1290

这个是刚用户的时候老出这种问题

1291

老师这个问题

1292

而面试官呢

1293

也很喜欢问这些问题

1294

比如啊

1295

分析一个

1296

什么

1297

孕妇吧

1298

应该是关于也爱问

1299

然后呢

1300

一般来说对不对

1301

加的废气什么叉叉叉

1302

然后点认

1303

然后

1304

Stan Jason

1305

一般这么写的吗

1306

点赞

1307

然后比如我这

1308

Set name

1309

S假如假如

1310

然后这里name变化

1311

好

1312

这样一写

1313

一个死循环诞生了

1314

我来给大家解读一下

1315

我在家用use that bag包起来也是一样的

1316

Use the fact

1317

刚刚给大家讲了当name一遍

1318

当内没变化的时候

1319

那么他肯定要肺气

1320

因为肺经发对不对

1321

飞机或飞机完了之后

1322

它又会重新设定

1323

重新测量之后

1324

Name又变了

1325

他又要飞进凤飞尽复

1326

又变了

1327

那么他要重新设定

1328

那么这就是一个循环

1329

这就是一个

1330

永远不会间断的一个循环

1331

你会发现你的你的那个谷歌浏览器

1332

它就会瞬间发几十条几百条的请求出去

1333

把那个项目

1334

就这样

1335

那有同学说老师这种这个代码其实明显有问题

1336

太傻了

1337

我跟你说

1338

有的时候有的时候并不傻

1339

比如说比如我

1340

这配音吗

1341

就那个

1342

假如我要用它来判断一下

1343

我假如我判断她比如等不等于一扔

1344

你就算不传

1345

对啊

1346

就是说我根本不会用

1347

不会涉及到

1348

这样我怎么会传一个名字

1349

然后又改一个名字呢

1350

那假如你就只这样进行判断

1351

这种情况很常见吧

1352

是不是很常见

1353

你只是在进行一个判断而已

1354

但是你也要把它作为你的依赖

1355

他照样是一个师兄

1356

对不对

1357

这种情况是刚开始非常非常容易遇到的

1358

没有没有

1359

Use effect是一个hooks

1360

我是在use effect函数里面用的衣服

1361

明白不

1362

它定义的地方

1363

它定义的地方不能够

1364

就是你不能够把它这样放

1365

你不能够把它这样放

1366

这样放是不行的

1367

这样是不行的

1368

对

1369

这个use if you stayed还是hooks used a sad state

1370

他并不是

1371

他并不是hooks

1372

这样不行

1373

好

1374

那么这个死循环怎么办

1375

量一般来说

1376

我知道的有

1377

两种通常有两种吧

1378

有两种方法

1379

有两种方法有两种方法来做

1380

但是

1381

就

1382

最有偶尔的时候可以通过这种方式

1383

比如

1384

你这有依赖对吧

1385

你这儿有这个依赖

1386

我们的这个city name

1387

我先讲一下这个CDM

1388

这个M

1389

它它可以给它传一个值

1390

他也可以给他传

1391

他也可以给他传一个函数

1392

如果你给他传一个函数的时候

1393

那么

1394

你的这个比如你的这个

1395

这个函数里面会默认给你填充一个参数

1396

这个参数就是最新的最新的我们的那个name的值

1397

有的情况下

1398

你用它其实可以解决

1399

因为比如说你我如果布局这种布局这种例子举个例子

1400

我我在哪呢

1401

我在这儿吧

1402

我改一改稍等

1403

改一改

1404

比如说在这衣服

1405

比如name等于等于

1406

一登

1407

然后我就

1408

我觉得他

1409

对不对那么

1410

这种情况同样是死循环的

1411

我给大家讲一下为什么

1412

因为内蒙一遍

1413

就是我第一次use effect的时候肯定会掉

1414

他又飞机佛飞机in for1掉那么

1415

他这个set name name一遍

1416

那么一个变化

1417

那么导致你的这个飞机因或有变化了

1418

飞机或就会变

1419

就会产生一个新的函数

1420

这个新的函数与变化

1421

你的you the fact同样是会变化的

1422

那么同样是一个死循环

1423

然后在这种情况下

1424

现在

1425

他这个时间段产生的原因就是我记忆中的

1426

我既用到了这个state

1427

同时我还更改了这个state

1428

这个就是产生它的原因

1429

那么我要做的事情是什么呢

1430

要做的事情就是

1431

把这个链条给断掉对不对

1432

我是不是想要把这个链条给断掉

1433

只要我不恶一

1434

我只要不依赖他不就完事儿了吗

1435

是不是我只要不依赖他就完事儿

1436

不一样就完事儿这种一般第一种方法就是

1437

这种应该就只能通过用use rid了

1438

比如

1439

比如写一个riff

1440

对一个riff我刚入

1441

我给大家讲if

1442

他可以在他在那个hooks里可以使用react的riff

1443

就是可以使用if

1444

同时也可以把它当做一个当做一个变量来时

1445

可以把它当做一个变量来

1446

是因为rift的变化并不会引发大家注意

1447

可以

1448

之所以可以把它用这种方式来做的原因是

1449

Rough的变化并不会引发你的整个

1450

并不会引发一次更新

1451

他变了就变了

1452

不会造成你的这个组件又重新render

1453

那么你可以把它

1454

比如你可以把它放在屋里

1455

你可以把它放到roughly或者说

1456

你这个如果说你内容变化你要实时更新的话

1457

那么你可以

1458

rift.charon to点亮

1459

等于等你你判断的时候

1460

你就不用这个这个来判断

1461

你用ref来判断

1462

用F来判断

1463

那么你这个

1464

链条就一下子就解开了

1465

就一下子就解开了

1466

通过rift因为rift的变更

1467

并不会引起

1468

那假如你这

1469

对吧

1470

这样子就是一个完整的

1471

你的ref变化了也没关系

1472

他并不会引起你的整个逐渐的重新变化

1473

而且瑞否则也是不需要放在

1474

一般的情况下是不需要放在你的

1475

这个依赖是图中的

1476

不用他能够拿到最新的值

1477

通过内服

1478

是解决这种这种

1479

死循环的一个最通常的一种通常的一种解法就是

1480

对对

1481

在hooks当中

1482

Riff可以不放在down上

1483

你就可以把它

1484

当做一个

1485

你可以把它当作一个类似于全局变量这样的玩意儿

1486

但是hooks里面是这么这么用是可以的

1487

是可以的

1488

当然

1489

它也可以放在档上

1490

他也可以看得到了

1491

嗯

1492

对

1493

Rift and is可以

1494

对是这个意思

1495

是这个意思

1496

死循环大概就是这样的写法

1497

我刚刚说还有另外一个方式呢

1498

可能用到的

1499

没有这个没有这个

1500

没有瑞福这个方式用的这么广泛

1501

没有她用的这么广泛

1502

我们可以再举另外一个例子

1503

比如use effect

1504

类似啊

1505

叫做还是name

1506

然后再判断了name

1507

等于等于什么

1508

然后呢

1509

我要如果它等于了什么

1510

我要重新设的这个类

1511

我要重新设置这个

1512

假如这种情况

1513

这种简单的那么定

1514

再重新定义一个rift的值

1515

就有点儿就是有点儿

1516

大材小用了

1517

大材小用

1518

因为我们可以用C的name就完全可以解决

1519

怎么解决呢

1520

就是通过传递一个方法的形式

1521

我直接通过传递一个方法

1522

然后呢

1523

嗯

1524

衣服

1525

等于一灯

1526

飞机灯

1527

然后呢

1528

就是

1529

加一个什么

1530

什么2022随便加个

1531

事故给大家拉出来

1532

做一个区分

1533

就这两种写法

1534

假如是一种比较简单的场景

1535

这这肯定有的

1536

这种场景是肯定存在的

1537

我就遇到过很多次

1538

本来这样很简单

1539

就是判断它有一种特殊场景的时候

1540

我需要给他加个东西

1541

对吧

1542

逻辑就这么简单

1543

但是这因为要依赖一个

1544

依赖它的内部的变化

1545

不能娶不到最新的值

1546

所以导致一个死循环

1547

导致一个死循环你你会发现代码会被卡死

1548

而这里大家看我的依赖并没有

1549

我并没有把name传进去

1550

那我name怎么拿到最新的值呢

1551

就是在CD name这个方法的

1552

我传给他这个方法中

1553

他会给你填充这种

1554

他会给你默认填充一个值

1555

而这个值就是这个name

1556

所以我在他的这个C的name的方法里方法其中

1557

可以做到这样的一件事情

1558

那这就sorry

1559

这就

1560

这直接就是return

1561

这里面肯定不能再调一次

1562

就那个直接就是return

1563

这种也是可以的

1564

但是呢

1565

它的场景是用并没有瑞福那么多

1566

如果你不会这种

1567

那么你掌握瑞福一种也就够了

1568

能理解吗

1569

能理解可以各一

1570

让你姐开个呢

1571

OK

1572

好

1573

好

1574

下面

1575

这个

1576

使循环对循环也是

1577

经常遇到的

1578

经常遇到的问题

1579

我们九点了休息五分钟吧

1580

09:05的时候继续

1581

大家可以去喝点水

1582

好了

1583

同学们都回来了吗

1584

我们继续看下一个问题吧

1585

进度好像有点慢

1586

这个急了

1587

我们就可以来看源码了

1588

这个锁完了就来看源码

1589

Capture value capture value一开始也是REC hooks所怎么说呢

1590

带来的一个问题

1591

我们可以

1592

也是大概的

1593

大概的演示一下

1594

其实这应该是

1595

稍等稍等

1596

这是金

1597

是上节课

1598

上一个信

1599

那就把拷过来吧

1600

比如这个

1601

是不是把答案都写

1602

都写出来

1603

什么是开票value

1604

就是还是从一个问题还是一个问题给大家解说

1605

大家解说

1606

比如这个

1607

a级吧

1608

就是a级

1609

然后背景

1610

我这儿

1611

假如我在这里赛特埃及埃及加一对吧

1612

我一看刚开始是零吗

1613

看看是他

1614

一开始假如四个零四个零

1615

然后再

1616

点这个方法的时候

1617

那么给他先加个一

1618

加一

1619

那么再过三秒

1620

C33他猫的三秒之后

1621

然后打印这个a的值

1622

打印这个a的值会是多少

1623

大约会是多少

1624

三秒后打印出来

1625

这个a的值会是多少

1626

大家可以给一下答案

1627

三为啥子撒

1628

还有吗

1629

就正常就觉得大家第一第一眼觉得是什么就是什么

1630

0123我肯定只有一个值

1631

好吧

1632

正确答案是零正确答案是零

1633

这个为什么是你

1634

因为你的埃及

1635

这个就是所谓的capture value了

1636

开了字面意思就是什么

1637

快照变量快照变量

1638

我来给大家解释一下

1639

发生了什么事情

1640

为什么会是零

1641

大家觉得可能是怎么都都该是个一

1642

对不对

1643

如果按照在class component里面的经验

1644

他怎么了

1645

这个是个一

1646

但实际上这个零原因是在

1647

进行这个u SCO back的时候

1648

我给大家

1649

来理一遍

1650

理一遍再account

1651

点击APP的时候

1652

假如一开始aid ma是零点几的CAD的时候

1653

那么首先掉了一个C的age

1654

对不对

1655

掉了一个age

1656

调了这个C的age之后

1657

然后掉了一个set timeout

1658

而这个system out13秒钟之后才执行的

1659

我这个C的age

1660

他实际上是发起了一次更新

1661

大家理解吧

1662

大家和class函数

1663

Class函数里调用CS的是一样的

1664

发起一次更新

1665

而我这次更新之后

1666

可能他时他的时间应该还没有三秒

1667

他发起更新的时间

1668

一直到他渲染完都没不会有三秒对不对

1669

一般我们我们的经验是这样子

1670

然后他发起一次更新之后

1671

他发几次更新之后

1672

他就会

1673

走到我们白天所讲到的那些流程上去

1674

叫做

1675

对吧

1676

Schedule or对不对

1677

然后再re consider里面的begin work里

1678

他又重新把这个函数

1679

他又重新把这个函数给创建了

1680

这个函数重新被render了

1681

被执行掉

1682

被执行了

1683

被执行了之后

1684

被执行了之后

1685

因为a级变化了

1686

同学们

1687

我们的变化了对不对

1688

A级变化了

1689

那么我们的这个account他就变成了一个新的函数

1690

是不是

1691

是不是一个新的函数儿

1692

这个cmos恶心的函数

1693

同样一个三毛儿

1694

变成了新的函数之后

1695

我们整个整个组件也就全部更新到页面上了

1696

不要着急嘛

1697

整个组件也更新到页面上了

1698

但是

1699

按理说旧的旧的这个

1700

因为我们ad现在是一个新的函数了

1701

大家理解吧

1702

ADD是一个新的函数

1703

就是函数按理说应该要被销毁掉

1704

就的函数应该按理说是要被销毁掉的

1705

可是由于我们的system out的存在

1706

它一直把这个

1707

他一直是把这个里面的a级变量是持有的

1708

他持有的这个内内存变量

1709

形成了一个臂包对形成了一个臂包

1710

所以

1711

所以在老的老的这个account并没有当时并没有立刻把他给杀掉

1712

而这个是他特MT持有的这个B包

1713

还是之前的那个

1714

A等于零的那个a级已经不是这个新的APP了

1715

所以这个a级永远是零

1716

大家能理解吗

1717

能理解的可以各一

1718

理解可以零

1719

两者两者区别在所以所以这个情况它实际上它的影响它的原因是闭包是闭包

1720

可是可是由于直接在hooks中间有这个问题

1721

空间有这个问题

1722

所以所以官方把它命名为一个名字叫做kept

1723

就是快到变量你的这个

1724

你就算再有spike里

1725

在APP里

1726

你无论赛他妈的怎样

1727

System out

1728

输了他妈的多久

1729

你的这个a级永远不会变

1730

因为你刷新了之后

1731

你的这个心已经是一个新的东西了

1732

已经是一个新的函数了

1733

你这个旧的函数的值

1734

它保存着

1735

他所用的这个APP还永远是老的那个a级

1736

而不是新的那个a级

1737

所以它叫做快照变量

1738

叫做capture capture变量

1739

对这个意思

1740

这一次就是官方就是官网里边儿其实也老也讲过这个问题

1741

也讲讲讲过这个问题

1742

那怎么解决这个问题呢

1743

怎么解决这个问题

1744

其实也是通过riff

1745

因为riff是不受这样的限制

1746

比如这个riff对吧

1747

你就瑞府里面所以热

1748

你就感觉他是一个

1749

很多时候

1750

很多时候什么你感觉出现了大问题

1751

你就用ref Le你就用riff

1752

你会发现

1753

非常好

1754

非常好解决

1755

Billionaire if

1756

你如果一定要这么死

1757

也是能死的

1758

对

1759

平面也行

1760

快走也可以解决

1761

你用riff

1762

这他就变成一

1763

它就变成一

1764

就没这问题了

1765

那么有同学就问了

1766

只有胡才有吗

1767

其实就是闭包

1768

但是在class component里它不会存在这个问题

1769

大家在class component里从来没遇到过

1770

对不对

1771

S e class component里有this

1772

他有this这个东西我们所有的state都保存在地上的

1773

所以他不会丢

1774

他不会丢

1775

但是函数逐渐的他一个函数一个坑

1776

韩束一变

1777

那么它内存自然就变了

1778

内存地址都不一样了

1779

是的是的

1780

这就是cap

1781

所谓capture value其实就是这个样子

1782

如果说

1783

那个什么面试官可能会老会这么问题

1784

你在用hosts里面有没有遇到一些让你比较印象深刻的问题

1785

你就在

1786

看这俩打一个

1787

然后呢

1788

紫郡华达一个

1789

然后那个我们的那个

1790

A regular member he used back

1791

这个来用它来作

1792

用它来做钱比较打一个基本上答完了之后

1793

基本上答完了之后

1794

问题就是基本上就挺比较过关了

1795

比较过关老师

1796

这个不相当于一个局部的臂包吗

1797

是啊

1798

我就说他是闭包

1799

是不是hooks欠的太多

1800

什么意思

1801

Whose欠的太多

1802

闭包也会很多

1803

那如何优化

1804

那如果他调完了之后

1805

三秒之后

1806

他现在这个B包之所以存在

1807

是因为他妈的他持有了吗

1808

大家能理解吗

1809

原本的如果没有在他们的这个东西

1810

他肯定会被销毁掉

1811

就比如说如果你没有他

1812

如果你没有他

1813

那么他的GC就是把这个回收的

1814

如果没有这个

1815

就算是比如发起了一次C的age

1816

对吧

1817

发起了一次次的age

1818

他是age

1819

那么重新render之后

1820

我们的我们的account变成了一个新的函数

1821

那么这个函数因为已经没有持有了吗

1822

他后面自然就会被JC给回收掉

1823

因为它的引用技术已经清零了

1824

同学乙用激素它已经没了

1825

这只所以它存在这个背包是他mote这个东西存在吗

1826

它这个功能还还在

1827

还一直把他持有的

1828

所以说这个变量

1829

所以就导致就导致他的这个方法也被持有了

1830

就是也也没有办法被销毁掉

1831

那当他调完了之后

1832

帮他调完了之后

1833

那么就没有地方在

1834

只有他了

1835

他后面还是会那么的GC可能不会立刻

1836

但是呢

1837

下一次就把他给干掉了

1838

对吧

1839

没问题了吧

1840

这块儿

1841

如果有多个遍

1842

你写多个就好了吧

1843

写多个就好了吗

1844

每一个hooks都可以定义多个同学

1845

你定义N个都行

1846

你自己随便命个名吧

1847

对吧

1848

AA级

1849

妹妹啊

1850

你随便秘密就行了

1851

都每个都可以定义很多个了

1852

只是他要求你一定要在一定要在函数组件的头部定义就行

1853

好

1854

大概

1855

大概就是hooks的

1856

怎么算

1857

用法我们就先讲到这么多

1858

就先讲了这么多

1859

其实

1860

来面对一般的利润

1861

一般那个问护士的问题

1862

其实也都已经够了

1863

已经够了

1864

接下来的话

1865

我们才才要开始正式的进入我们的那个圆满的一个

1866

简单的分析了

1867

原版那个简单的分析

1868

我们来看一下

1869

如果要简版的实现一个

1870

简版的实现一个use date

1871

我们回顾一下use什么功能

1872

首先它接受一个值

1873

对吧

1874

接受一个参数

1875

它返回了两个值

1876

一个是变量

1877

另外一个是更改变量的方法

1878

那么如果要写一个非常非常简短的

1879

如果不依

1880

不把他给挂载在

1881

REC的就是

1882

Black的那个整体架构之上

1883

那么其实很简单

1884

对

1885

逻辑非常简单

1886

秘密秘密一个全局变量

1887

秘密的钱

1888

这也不是全局变量

1889

秘密一个外部的臂包吗

1890

外部的一个变量

1891

然后呢

1892

通过use date

1893

这就是这就传进一个默认的值

1894

然后呢

1895

如果这个值不存在的时候

1896

就是C的不存在的

1897

就是没有被复制过

1898

就让它等于默认的字

1899

否则

1900

就等于芯子

1901

就等于最新的值

1902

然后这个stage就是更改他的

1903

对不对

1904

这有可能是这个schedule是什么呢

1905

这个schedule是rock里边儿的

1906

Rock里边儿它的更新一个词的时候

1907

会需要他引引起整个

1908

需要他引起一次更新

1909

所以就会掉一次

1910

schedule在这里是不需要的

1911

我只是之前好像写写成这样

1912

之前写成这个样子

1913

那么这就是一个最简版的X的一个实现

1914

但是呢

1915

这个最简单的弧线真的是太简单了

1916

原因是啥

1917

第一它只能够在一个

1918

函数的使用

1919

而且只能定义一个X

1920

大家看到没有

1921

他此人定义一个state

1922

因为它就只有一个值吗

1923

所以这个实在太简陋了

1924

如果我们想要给他

1925

如果我们想要给他搞得稍微复杂一点点

1926

搞得稍微复杂一点点

1927

那么就需要把他的

1928

状态堆和上下文堆在储存多个状态

1929

来让多个函数都可以进行调用

1930

就是要把这个扩展一下

1931

那么就需要有一个上下文债的概念

1932

为什么要用上下文债

1933

其实在react它里边儿用的也是上下文件

1934

但是他用的比较和和我们这个数组的方式不太一样

1935

因为它原本是链表嘛

1936

所以他只有他会再进入的时候

1937

在record里

1938

他在进入那个函数之前

1939

我们刚刚我们白天的时候就讲过

1940

他会他会注册hooks

1941

对不对

1942

在执行函数的函数体之前

1943

他会先把hooks给他注册上

1944

Hooks给他住

1945

就是hooks的上下文先给他注册上

1946

然后等函数执行完了之后

1947

他又把那个上下文给他销毁掉

1948

这其实也是一个

1949

类似的一个上下文的堆栈

1950

而他注册了一个上下文

1951

就是当前要处理的那个fiber

1952

就是我们这个是一样的

1953

这儿的这个上下文对待就是你要处理的那个函数

1954

它就会把它放到最后一个

1955

放在速度的最后一个

1956

我们可以轻易拿到

1957

我们可以非常轻松的拿到它

1958

他是第一个还是最后一个

1959

所以这也是一个三角形的

1960

如果有了它

1961

那么

1962

理论上来说

1963

我们可以通过用visit的方式来给大家进行包裹

1964

你看大家看我们这儿用with state

1965

这儿这个方法用visit

1966

就是就类似于我们在react那个源码中的

1967

用源码中的注册hooks那个概念

1968

它在调用真正的方法之前就是这个function

1969

调用真正的方法之前

1970

他先把他

1971

他他先把当前的这个上下文

1972

我们这个是states什么

1973

当前这个函数的需要用的state

1974

它当前的上下文给它压进去

1975

对不对

1976

然后当然后再执行执行他执行完了之后

1977

再把它给弹出来

1978

再把他扛起来

1979

都是用这种方式

1980

其实这个简版写法也是非常精妙的

1981

对这个简版写法也是非常精妙的

1982

一般来讲

1983

如果说让你在十分钟之内让你把它copy

1984

让你把它给敲出来

1985

还是有一定难度的

1986

还是有一定的难度的

1987

我们可以来看一下

1988

这个大体逻辑的话

1989

其实

1990

最要紧的其实就是这样

1991

就是这个吗

1992

Directly这样的写法

1993

也给大家看了很多了

1994

也给大家看了很多了

1995

就比如那个啥

1996

设置设置那个什么执行上下文QQ什么can cure a t con text对吧

1997

设置执行三角纹也是这样设的

1998

也是在调用他真实的方法之前

1999

给它加上射完了之后给他干掉

2000

给他干掉就是这样

2001

这里visit state就是包裹的

2002

我们调用的时候就用with state

2003

如果想要在

2004

这里面用hooks

2005

我们就给他包裹一下

2006

稍微包裹一下

2007

那么他就可以使用use date了

2008

那这里的方法

2009

大家看就是因为有了这个

2010

有了context

2011

有了contact

2012

所以他能够做到什么呢

2013

能够做到支持

2014

多就是多函数

2015

多个函数都可以调

2016

多个函数都可以调

2017

这个state也给它更新了一下

2018

上面的state只是一个什么

2019

上面的这只是一个单个的值

2020

所以只能定义一个state

2021

这个state

2022

这个state可以是一个对象

2023

这是一个对象

2024

那么他可以定义多个state

2025

定义多个sit

2026

那么通过这几行代码我们的

2027

我们的单

2028

就是多组件使用护士

2029

还有

2030

一个组件内使用多个hooks的功能就都实现了

2031

大概我们可以来大致的大致的盘一盘

2032

首先这个方形

2033

大家看这个方式

2034

肯定就是我们要用的函数组件

2035

但是类似这个VC

2036

它只是一个简版的

2037

这个只是一个简版的

2038

他并不是真正的实现

2039

真正的实现我们待会还会看

2040

还会看到真正的实现

2041

但是我觉得这个展板的实现也非常的精妙

2042

而且这个脚本的时间对于我们来说

2043

要把它实现出来的话

2044

也并没有特别困难

2045

我们只需要了解他的逻辑

2046

然后呢

2047

然后呢把它给记住

2048

后面自己也就能实现了

2049

我们看

2050

Wei to state

2051

这有一个

2052

对

2053

UC的方法

2054

这个方法

2055

只有在包被包裹在VC的时候

2056

里边的函数才能用

2057

原因是为啥

2058

原因是因为你只有被包裹在VCD里

2059

你才有上下文

2060

你如果没有上下文就不能调这个和

2061

这个和react里真正的逻辑是一模一样的

2062

你没有上下文你就调不了

2063

所以他只有包裹起来

2064

包裹起来做一件事情

2065

好先把他先把3000给他压进去对不对

2066

三下午给他压进去

2067

进去之后他就有了一个空的state

2068

大家看一个空的state

2069

这个就类似于我们我们函数组件里的那个

2070

储存储存hooks的那个链表链表他但这是一个对象

2071

这是一个对象

2072

这个对象可以帮助我们

2073

可以帮助我们定义

2074

我们定义多个stay的也没有问题

2075

所以呀

2076

进去的就是一个空的

2077

一个空的一个对象

2078

这就是来储存他的state的一个位置

2079

然后我们再来用对不对

2080

我传了一个默认值

2081

这个和上面逻辑是一样的

2082

然后拿到他的第一件事情

2083

拿到它的上下文

2084

拿到上下文

2085

然后呢

2086

如果第一个第一个state

2087

那么这个

2088

No就是number嘛

2089

就是零

2090

然后后面就一直加一直加

2091

那么得到第一个值

2092

它就是等于零是多少

2093

STATE1是多少岁的

2094

二是多少

2095

然后

2096

然后这个呢

2097

就相当于类似于一个Stuart

2098

这个state就类似于一个包裹多个state的一个集合吗

2099

对吧

2100

多个C的集合

2101

你你要哪个的话

2102

你就肯定不一样

2103

就拿到哪个这赛特赛特states他也会

2104

他也是根据你的当前这个B包的值

2105

到底是什么

2106

它就会给你更改哪一个的值

2107

更改一个值

2108

这样就实现了

2109

你

2110

第一个use date

2111

那么N140

2112

那么你的

2113

比如我掉了这一行代码

2114

那么它内部就变成了

2115

我们可以给大家模拟一下

2116

假如这样的代码

2117

那么a是多少

2118

A是零

2119

那么states呢

2120

就变成了

2121

零零

2122

这个铃是这个铃是它的值

2123

而这个零是它的前面这个妞

2124

对不对

2125

而如果我们在掉了第二个hooks

2126

我们在第二个X

2127

我们又变化了

2128

它就变成了一

2129

然后呢

2130

我们总的state里就有了一

2131

Name

2132

如果有第三个、第四个

2133

就以此类推

2134

他同同样的也能拿到所有的内容的

2135

就是所有的state的值

2136

它都是可以拿到的

2137

有一个state就是不同的变化

2138

你的妞

2139

No

2140

每一次他都会把它作为一个B包

2141

把它放在那儿

2142

对不对

2143

就这个no

2144

它的c EST里实际上就持有了这个B包

2145

他们因为这个B包已经持有了

2146

所以他总能找到和他对应的那个值

2147

那么你这就算定义多个也没有问题

2148

那么这个就是相比于上面那个简版

2149

这个他实际上功能更加强大

2150

我甚至觉得这个基地已经非常的精妙

2151

已经可以

2152

如果是一个非常简单的裤子的话

2153

都可以直接拿来用了

2154

这个直接拿来用了

2155

大家可以学习一下这种代码后面后面可以尝试写一写

2156

这能理解吗

2157

能理解的扣个一

2158

不能理解的扣一个零

2159

对

2160

这个with state he he

2161

Use的这个东西

2162

OK

2163

好

2164

这个代码我个人觉得还是很妙的妙

2165

比如state就

2166

大概最简版的方式我们就已经实现了

2167

然后

2168

Use effect use effect的功能我刚刚讲已经讲过了

2169

功能第一个

2170

第一个还第一个参数是一个function

2171

是一个call back

2172

第二个参数是一个依赖

2173

那么实际上它

2174

当依赖变化的时候

2175

我们要做的有两件事情

2176

没有依赖的时候

2177

只执行一次依赖变化的时候

2178

那么我们也要值依赖变化的时候

2179

要执行一次

2180

同时要把这个

2181

同时要把同时要在函数里面要需要得到他最新的值

2182

对吧

2183

所以我们在这个you the fact哩

2184

他要七分

2185

他要七分首先

2186

你的这个依赖速度如果为空

2187

对了

2188

有一种情况

2189

刚刚我给大家说了

2190

如果在record里这么写

2191

这个是不能不能这么写的

2192

如果你不传依赖函数

2193

这就是非常严重的一个问题

2194

你如果不传这个依赖数组

2195

那么无论任何属性的变化

2196

你的这个函数题都是会执行的

2197

同学们

2198

这个依赖宿主是必须要传的

2199

而你如果想让他执行一次

2200

是要传空

2201

而不是不传

2202

不传的话是每一次都会执行

2203

这个大家要注意

2204

没有依赖宿主

2205

实际上

2206

实际上它的性能开销是非常大非常大

2207

因为你任何一次变化它都会执行

2208

他都会自行

2209

这也是这样

2210

如果没有依赖速度

2211

就是如果没有依赖速度的情况下

2212

没有依赖数字

2213

那么他每次都要执行这个call back

2214

对没有依赖数字

2215

第二就是依赖速度变化的时候

2216

它执行这个bug

2217

什么是依赖速度变化呢

2218

依赖速度的变化

2219

他会去递归

2220

就是他们不是递归

2221

他是去对这个数组

2222

然后呢

2223

每一项和每一项和当前的那个值进行对比

2224

对比中有任何一项改变了

2225

这就是有

2226

这是有任何一项改变

2227

只要有一个改变了

2228

那么就说明

2229

有依赖变化

2230

只要有一来一遍

2231

对吧

2232

只要有依赖一遍那么

2233

我最可怕的叫自信

2234

折扣要执行

2235

这个其实就是you z u the fact减半的时限是这么实现的

2236

但是呢

2237

在hooks里

2238

在那个write books里

2239

他逻辑并没有这么简单

2240

为什么呢

2241

因为他除了J这点功能之外

2242

他有其他的功能是它无所无法实现的

2243

比如UCUCH

2244

它最主要的一个他是要他是要发起一次更新的

2245

再发起一次更新

2246

在离开react他就发起不了

2247

你必须在react里

2248

你知道它实际上属于wrecked独有的逻辑

2249

是独有的逻辑

2250

而这个you the fact同样也是

2251

那么他的执行实际在哪里

2252

那么这个也是需要在我们真正的rock的源码中缺少答案的他

2253

你没有办法

2254

你没有办法只通过

2255

这么个简版就就看

2256

虽然简版它可以帮助我们把逻辑理得更清楚明白一些

2257

但是他没有办法

2258

完全完全完全的让我们理解的这个东西

2259

所以我们接下来要看VIP的真正的原版的分析

2260

我就只分析稍微难一点的这两个u state he you the fact

2261

比如像use rift

2262

其实非常的简单

2263

You school back就是缓存一下

2264

都非常简单

2265

就没有没有把这两个讲明白了

2266

剩下的大家可以自己下去看

2267

非常简单

2268

非常简单

2269

就这两个

2270

我觉得稍微会困难一些

2271

困难一些

2272

那我们就开始讲解那个use data

2273

它原本的逻辑到底是怎么样的

2274

首先

2275

我们就直接现在直接大家带大家跳代码啦

2276

Use

2277

大家跳代码啦

2278

就看得明白一些

2279

看一下

2280

Books that looks

2281

Realize father whose

2282

大家看

2283

在我们在找到这个护士源码的时候

2284

会发现他这个u state不光不光值

2285

它是把蒙特

2286

好

2287

Update是严格的区分开的

2288

就是第一次的时候

2289

对use来讲

2290

他第一次就是MT阶段

2291

他就执行mount set

2292

如果是更新的时候

2293

就有自信更心碎的

2294

他们两块的逻辑还不太一样

2295

不太一样的我们看MT阶段的时候发生了什么

2296

MT

2297

好

2298

这就是我们第一次

2299

注册一个use date

2300

注册use的时候我们会传一个

2301

初始值

2302

这个初始值可以是一个

2303

可以是一个基本类型或者对象数组

2304

同时它也可以是一个function

2305

他也是一个function

2306

这两个方式都可以

2307

再创建一个amount of working progress MT MT a work in progress fiber

2308

我看一下

2309

大家看他这实际上创建了一个户口

2310

所有的不管是you stayed也好

2311

还是you the fact也好

2312

他都会创建这么一个对象

2313

这个对象就是就是一个hooks对象

2314

这是一个湖的对象

2315

也就是我们所谓的一个一个

2316

Hooks

2317

我们所谓的一个hooks

2318

她就是指的是他

2319

是不是这样的一个hook对象

2320

我们可以来看一下

2321

所以他是一个链表

2322

当然是一个

2323

他一个next

2324

对不对

2325

他next就是指向下一个hooks

2326

这儿有一个memory state

2327

这个memory state是来存放

2328

对于我们的u state来讲

2329

它是存放我们的state的

2330

这儿有个base seat

2331

对我们来说它是纯

2332

它也是穿S的

2333

但是它的区别在哪儿

2334

它区别在于这个有可能是拿来做优化用的

2335

就他可memory state

2336

一在某一个阶段他会

2337

在某一个阶段

2338

他们并不完全相等

2339

他他们并不完全相等

2340

但是在最后是相等的

2341

因为这个

2342

他会在浏览器有空闲的时候

2343

如果浏览器有空闲的时候

2344

他会考虑

2345

提前执行那个setup

2346

比如city name that age函数题可能会提前执行

2347

提前执行之后

2348

他就会把直线存在这儿

2349

然后后面的时候再付给他

2350

对这个实际上是一个优化项

2351

是一个优化项这

2352

Queen

2353

这个queen就是更新的更新队列

2354

就是牛发情有哪些更新

2355

有哪些更新

2356

有更新的队列

2357

OK

2358

这就是创建了一个hook

2359

参见hooks

2360

然后呢

2361

Working progress look等于浪的时候

2362

就

2363

就把这个顾客就相当于是把这个新产品的户口复制复制给复制给他嘛

2364

就复制给他

2365

因为这个

2366

Currently render fiber其实就是我们的filed节点

2367

同学们这个发怒的节点

2368

这个就指的是当前要处理的FAB的节点

2369

这个发展的节点有一个属性

2370

我刚刚不是说

2371

我刚刚在说他们只能够在顶层使用

2372

然后说道有一个属性会来存整个hooks列表

2373

就是这个member state

2374

这个绝对给大家说过的

2375

我们可以

2376

可以看一下

2377

在这个地方

2378

可能当时提了一嘴

2379

然后现在给大家再

2380

再把音箱给

2381

再把印象给

2382

换起来

2383

这儿有一个叫做对看

2384

这个是一个发怒的节点的节点

2385

Filed的节点里有一个属性叫做memories date

2386

这个memory的state里存放的就是hooks

2387

Box列表

2388

Looks and

2389

所以没有的时候就把它放在列表上

2390

有

2391

那么就把它放在下一个

2392

放到当前列表的最后一个

2393

对

2394

放在当前任务的最后一个

2395

这个就是

2396

MT working progress hook所做的事情我们可以看到

2397

我们可以看到

2398

根据我们刚刚的分析

2399

他做了什么事情

2400

也创建了一个

2401

创建了一个

2402

box对象对不对

2403

福克斯

2404

列表对象

2405

然后存放在

2406

尘封在那个

2407

Fiber node的

2408

MEM mor rise the state

2409

史姓钟

2410

属性中为什么要讲这么详细

2411

因为因为这块儿可能如果大家以后遇到了问题要调试的时候

2412

遇到问题需要调试的时候就会比较有帮助

2413

这就是一个户口

2414

然后这一步

2415

这个然后如果是一个函数

2416

那么就把它执行一下

2417

得到得到值

2418

然后初始值把它放在hooks大家看

2419

这个hook的memories date

2420

而不是filed的memories的我

2421

我一开始看的时候被这两个属性搞晕了

2422

我一开始看的时候被这两个属性直接搞晕了

2423

这是怎么回事

2424

一会儿又放在他怎么有两个妹妹state

2425

他们怎么可以放两个完全不同的东西

2426

后面我再一看

2427

发现他们这个是hooked memories date

2428

而这个地方它是把它存在范本

2429

诺德的memories这里他们两个属性的名字一样

2430

我觉得这个有点坑

2431

老师我觉得这个有点坑

2432

他们两个的名字一样

2433

但是成的东西完全不一样

2434

挺坑的

2435

然后放在里面

2436

第三

2437

新建一个query

2438

为什么要建一个呢

2439

这个就是reactor里边儿的

2440

如果record里发起一次的更新

2441

它就把它放在一个教会里面

2442

包括

2443

Class里面的选CC的他同样会发起一次叫做queen

2444

他同样会发起一个Z

2445

重新发起一个

2446

他新建了一个更新

2447

就说明我们有更新嘛

2448

很正常

2449

因为我们本来就是要更新state的

2450

然后呢

2451

把这个微信传递给dispatch

2452

最后把我们的默认值

2453

因为默认值已经付给了他

2454

对不对

2455

然后这个despite就是更改默认值的值

2456

更改默认值的方法

2457

这里大家看这里绑定了两个东西

2458

一个就是当前的这个fiber

2459

一个就是当前这个fiber

2460

另外一个就是这个要发起

2461

到底具体要发起的是哪个更新

2462

OK

2463

和这一样

2464

大家看和这里是一样的

2465

大家看这个state

2466

这个C的C的它里面是不是

2467

里边同样也依赖了一个叫做a的变量

2468

这个new的变量就类似于它绑定的这个变量

2469

你必须要找

2470

因为你只有通过他

2471

你才能够准确的找到是哪个版本

2472

你只能能找到是哪个发

2473

不然你你你再多个组件里用fiber

2474

你他就会混

2475

他就混掉

2476

肯定是要把它

2477

这两个是唯一的唯一确定能力

2478

他们这两个值

2479

那唯一确定的

2480

你要更改的那个hooks是谁是谁

2481

谁返回了当前值和despite

2482

这个是MT阶段做的事情

2483

我们来整理一下

2484

整理一下

2485

其实在这边也整理整理的有

2486

你直接看吗

2487

的

2488

默认如果是一个函数

2489

就执行函数得到初始state

2490

所得state存放在memory state新建一个queen

2491

把queen传递给dispatch

2492

然后返回默认值和dispatch

2493

这是慢的阶段要做的事情

2494

其实我大概把UC的拆成了三个阶段

2495

就是我擅自把它拆成了三个阶段

2496

第一个MT就是注册

2497

因为在这个时候我们实际上还是没有发起更新的

2498

第二个我认为就是发起更新也是我们把这个use date这整个流程串起来看

2499

就发现有初始的state就是

2500

初始值啊

2501

给它设初始值

2502

那么第二个阶段就是更改它的值

2503

第三个阶段就是更改了它的值

2504

更新

2505

我们要更新state

2506

要怎么更新呢

2507

我把它分为这三个阶段

2508

第一个阶段他大概就这么就做了这件事情

2509

就做了这件事情

2510

还是非常的简单的

2511

还是非常简单的

2512

我们可以

2513

看一下第二个

2514

第二个

2515

如果是第二个的话

2516

就是dispatch action

2517

Dispatch action

2518

大概也做了

2519

这大概做了四件事情

2520

但是他最重要的事情是

2521

这个链接看一下

2522

挨

2523

了好几次了

2524

行

2525

嗯

2526

Dispatch action其实就是跟他叫这个名字

2527

这个是他在L的名字

2528

你你我们一般用它的时候就是用什么

2529

就是那个

2530

CTECTEA减

2531

类似类似这个调用

2532

吊他了

2533

这样就在更新直根性的这个方法

2534

其实就是这个dispatch action

2535

我们来看一下

2536

Despite the action

2537

他到底做了什么呢

2538

嗯

2539

DV1先把它去掉

2540

首先创建了一个update

2541

大家看这里终于创建了一个update了

2542

因为我们本来就是要更新吗

2543

所以他创建一个update

2544

这个是合乎常理的

2545

然后这里给他设了一个烂

2546

剩了一个烂

2547

然后action这个action来看这个action是什么

2548

这个action就是我们的c aged的传递那个参数

2549

比如我们c age啦

2550

我可以给他传值

2551

我刚才讲过对不对

2552

我可以传值

2553

也可以传一个函数都可以

2554

那么他在这里面的命名就是一个action

2555

把这个action也给到了这个update

2556

他在后面调查这个有个m EST he l reduce or

2557

这个就是来闲暇的时候计算state的

2558

同样

2559

如果你有多个对吧

2560

假如你有多个

2561

你更新了多个

2562

那么你同样也可以有一个LIST1列表

2563

这是创建一个对

2564

那么既然创建对的

2565

他是不是应该把它添加到我们的那个

2566

更新队列里面去

2567

更新队列里面去对

2568

然后它就会把这个APP的添加到我们的更新对面这个喷顶

2569

就是代表这个队列需要做的更新是哪些

2570

会把添加到更新队列中

2571

这就是把添加更新最终这第二件事情

2572

第一件事情传给update

2573

第二件事情添加到更新队列中

2574

每一个更新都是这么干的

2575

同学们

2576

只是之前我没有给大家

2577

没有给大家挑代码

2578

给大家代码

2579

所以这个不要晕

2580

不要晕

2581

你就理解这个queen

2582

他就是L内部的常规操作

2583

他常规操作就是有一个更新队列

2584

每发其实更新就会创建这么一个方法

2585

就创建这么一个对象

2586

然后呢

2587

会把这个对象给添加到队列里面去

2588

添丁里面去

2589

然后

2590

如果说当前队列为空

2591

这个时候是根据什么

2592

是根据

2593

是根据

2594

当前是否处于共享

2595

就是是否react

2596

我们的j c j c rat里没有任务

2597

这个是reg没有其他的任务

2598

那么他就会提前大家看它就会提前把

2599

把这个action给执行了

2600

把值给计算出来

2601

保存在F里

2602

但这是一个优化项

2603

其实一般严格来说

2604

他不会在这里执行

2605

这是一个优化项

2606

如果说有空

2607

就是有空的时候

2608

他就先把state计算出来

2609

保存在这里边儿

2610

拿不动

2611

最后最重要的一部

2612

最最重要一步

2613

在这里调用一次schedule update on fiber

2614

进入调度触发方式

2615

重新进行一次

2616

这里边儿他进了哪里

2617

他就进了

2618

大家看熟不熟悉

2619

看看这个函数有没有很熟悉

2620

Scheduled on favor

2621

看到这样的代码

2622

Priority re等于think ly

2623

然后呢

2624

Execution context

2625

Render con tax on budget con tax不等于

2626

No context

2627

大家看这个是不是就是我一开始给大家粘的热热代码

2628

一开始schedule later代码对不对

2629

他是不是进来了

2630

他是不是就进到了right的主流程中间来了

2631

嗨

2632

走到这儿来了

2633

对不对

2634

是不是就进到我们的三大模块中的第一块了

2635

然后判断它是否是就是判断他是不是需要立即执行

2636

然后呢

2637

优先级优先级这块儿

2638

所以就进来了

2639

优先级走完了之后

2640

我们会会发现它会掉什么performance single肉

2641

它就会掉到这里边来了

2642

对不对

2643

他调到re consider里面来了

2644

嗯

2645

可能这个文件写的太多了

2646

他已经他已经杀不过来了

2647

他就调到re con c Lai re currently

2648

我们都知道又要重新构建fairytale

2649

大家发一个发一个tree

2650

是不是又会重新执行begin work呀

2651

直线BTS了之后

2652

我们的函数体是不是重新更新了

2653

然后就回到了我们

2654

回到了我们上节课所讲的流程中去了

2655

所以我说所以我说如果说我们单看来护士源码其实真的很难看懂

2656

因为你永远不知道

2657

因为如果直接单开那个会员吗

2658

你根本不知道

2659

这段代码一调

2660

到底发生了什么

2661

与我们前两节课的铺垫我们就知道了

2662

OK

2663

他下一次这张代码一掉

2664

那么它首先会进入优先级的判断

2665

优先级的判断完了之后

2666

等下他要重新构建

2667

纷纷退了

2668

构建反而去之后

2669

韩束体会重新运行

2670

函数题如果重新运行了之后

2671

我们的就是不是就进入到我们的

2672

又重新进入函数体的更新了

2673

那么他就会来到这里

2674

重新执行我们的函数题

2675

重新执行函数题

2676

那么我们就要调一次这个use date

2677

掉到了UC的时候

2678

这这个时候

2679

这个时候他就会执行update的

2680

不对

2681

是这个时候

2682

这个时候就相当于第二次第三次

2683

那么他就直接up的

2684

我们来看一下update的set a

2685

他是把它作为了update to reduce or的一个特殊的一个姐

2686

相当于他是他的一个B

2687

它是它的一个特殊类型

2688

特殊类型

2689

同样这是update working progress hooks差不多

2690

然后这个这

2691

这这就是为啥

2692

同学们这就是为啥

2693

我说

2694

之前介绍了

2695

就是只能够在能够把它放在

2696

不能够把胡子放在衣服L这样的判断逻辑之中

2697

大家看

2698

大家看

2699

他就是一个一个找的

2700

他就直接是等于next

2701

如果比如说你第一个他就是拿第一个

2702

你第一个没有

2703

第二个拿过了

2704

他就拿next

2705

然后就点next的next

2706

所以它就是按顺序拿

2707

你如果

2708

他就是按顺序拿

2709

你如果顺序一遍

2710

那么他就拿不到最新的

2711

能理解吗

2712

这块逻辑和我们的

2713

我们之前讲的那一块儿联系起来了

2714

Upset

2715

Update

2716

那么他拿着这个户口

2717

就是按顺序来

2718

按顺序拿到之前存的X

2719

他就是点next

2720

它算不它不是个数组

2721

所以他用他是个列表一点next

2722

然后拿到

2723

Queen

2724

之后呢

2725

如果说你的你的那个被洗存在

2726

这个不是不是这样

2727

我们看一下这个逻辑

2728

那第一位先不管第一位先不管

2729

这是

2730

这里有个优先级的判断

2731

优先级的判断

2732

如果优先级

2733

如果有更高优先级

2734

这意味着有更高优先级的过来

2735

还是存在被打断的逻辑

2736

还是能被打断的逻辑

2737

这这其实就是优先级的一个简单的一个判断

2738

一个判断她也是通过

2739

怎么说呢

2740

他也是通过

2741

二进制二进制比较二进制比较

2742

来做的

2743

我在想给大家找的是找的是那个队

2744

这里如果你的update的点

2745

Egg or reduce or

2746

给了reduce or

2747

那就说明你曾你之前已经处理过

2748

就是egg a state

2749

这个m EST我刚刚讲过

2750

就是在

2751

Wrecked

2752

空闲的时候

2753

那个时候就是发起发起一次写着age写成name这样

2754

那么如果当时浏览器还是就是我们浏览器处于空闲

2755

没有REC其他的任务

2756

那么他就会先给你计算好

2757

放在这里边儿

2758

大家看放在里面

2759

他现在用了

2760

如果有他就用了

2761

如果没有的话

2762

咨询一下他的action

2763

大

2764

牛state

2765

然后递归

2766

第一个这个就这个样子

2767

之后再把它反馈回来这个despite

2768

大家看这个despite并不会返回新的

2769

这还是返回老的

2770

只是这个值会刷新

2771

这个执事会刷新的值刷新了despite不刷新

2772

所以我们可以把这三块儿

2773

当我们把它连起来看的时候

2774

才算是一个整体

2775

Mon EST

2776

首先

2777

Mana c的他创建第一步

2778

他叫什么

2779

我先写个零吧

2780

创建

2781

创建hooks列表

2782

放在那个什么fiber

2783

诺德的

2784

MEM or eyes

2785

state

2786

属性你

2787

这是他做第一步

2788

第二步

2789

那如果是function

2790

执行function c的

2791

放在memories

2792

新建queen

2793

把queen传递dispatch

2794

然后返回默认之后dispatch

2795

这是MT阶段做的事情

2796

其实很简单

2797

其实很简单

2798

只不过这个第一步就是要写下来

2799

他还是为了和后面的update update进行联动

2800

然后我们创建完之后

2801

当我们有一个时间需要更新一个APP的时候

2802

那么他会创建一个update

2803

然后呢

2804

把它添加到昆呢

2805

如果空闲的时候提前计算出最新的state去保存一下

2806

最后一次调用一次schedule up down fiber

2807

这次就会进入schedule流程出发进入schedule之后还会

2808

那么就会进入

2809

Re consider a

2810

出发

2811

出发方形会重新执行一次

2812

这样的方式重新执行了之后

2813

是不是就来到了up

2814

第二次再调used a的时候

2815

他就用update

2816

还是一个零

2817

零零的话就是

2818

按顺序

2819

按顺序获得找到之前的

2820

X

2821

所以因为这个原因

2822

所以他没办法放在

2823

代码块里就是代码块的逻辑分支里

2824

然后呢

2825

第一个执行update

2826

计算最新的state

2827

复制给默默state

2828

这个就是use date

2829

的逻辑

2830

其实整体来讲

2831

他比我们刚刚那个简版要复杂一些

2832

之所以复杂是因为它必须要挂载在整个rock的主流程之上

2833

这样子的话

2834

他的逻辑才是完整的

2835

这块大家能理解吗

2836

就这三块儿能理解吗

2837

能理解扣个一

2838

不能理解扣个零

2839

其他同学呢

2840

信息有点大

2841

也能理解代码客户

2842

代码客户还要研究下

2843

对

2844

原因是因为因为REC的这个

2845

这个流程比较复杂

2846

但是中间有一块儿原因

2847

你们现在还能理解的原因是中间有一块儿

2848

这个队友说这个逻辑我其实不用怎么给大家讲

2849

大家都明白

2850

对不对

2851

这块我不用怎么给大家讲

2852

大家都明白

2853

但其实这块是最难的

2854

而且我们前两节课讲了两节

2855

前两节课讲了两节才把他给捋明白

2856

其实大家要理解这个usage的过程

2857

你最好是这这么

2858

最好是这么来

2859

这是第一次

2860

要把它分为第一次

2861

执行

2862

我给大家再捋一捋第一次执行比如说APP函数

2863

那么第二次

2864

执行APP函数

2865

第一次之前比分数

2866

第二次执行APP函数

2867

那么第一次执行APP函数

2868

比如我们的u state

2869

那么他就用的是MT MT state

2870

他就调的是mind EST

2871

那么因为他是从零到有吗

2872

所以他会创建列表

2873

然后呢

2874

默认值这这

2875

然后会把state放在mistake

2876

然后建一个queen

2877

然后就返回这个其实我就是我们通过代码就是代码的调用

2878

应该能明白这个事情

2879

然后返回

2880

最终是创建一个创建一个hooks

2881

对不对

2882

代码内部创建了一个hooks

2883

然后

2884

返回一个默认值

2885

返回一个默认值和

2886

更改

2887

默认值的

2888

Dispatch action

2889

而且给他绑定了绑定了当前的fiber

2890

好

2891

可以这样子

2892

能够唯一地找到

2893

能够唯一地确定我们的X

2894

我们的那个是哪个函数下的hooks

2895

那么

2896

这是这是第一步

2897

那么第二步当调用

2898

那么当调用dispatch action的时候

2899

第二个场景

2900

调用dispatch action的

2901

也就是我们所谓的

2902

发起字要更新state的时候嘛

2903

对吧

2904

要更新state的时候要更新state

2905

他这儿就创建一个更新

2906

添加的困呢

2907

把这个更新

2908

这个更新就要更改这个值

2909

更改那个state

2910

看一下state

2911

然后呢

2912

我们先不管优化

2913

那么它最要紧的一步就是发起调用这个

2914

我们先不管优化多少级优化

2915

它就是会提前计算的

2916

这个先不管由于调用了schedule up down cyber

2917

所以我们的APP函数一定会在更新一次

2918

对不对

2919

我们的APP函数一定会再更新一次

2920

那么它更新了一次之后

2921

他首先找到之前的户口

2922

他首先找到之前的户口

2923

然后

2924

返回

2925

就是计算

2926

计算那个action

2927

得到

2928

如果没有

2929

没有优化的情况下得到最新的值

2930

然后还是返回

2931

返回一个最新的值

2932

和

2933

Dispatch action

2934

Dispatch action要把它

2935

如果我们把它当作两次更新来看

2936

是会不会清晰一些

2937

这样会不会清晰一些对

2938

现在能理解吗

2939

因为你这最关键一点就是你

2940

需要通过这个dispatch action把他们两个给关联起来

2941

关联起来

2942

他们并不是一个割裂的过程

2943

这就是react代码里比较难懂的一部分

2944

你必须得

2945

你必须得把他的

2946

你你你你如果想要完整的调试他的话

2947

你就得把它整个

2948

就是整个那个价格都得有个大概的了解才可以

2949

不然他后面如果再加一个什么新的功能

2950

我相信他还是必须要依附在我们整个FAB价格之上

2951

来做

2952

来做这样来实现的新功能

2953

所以同样有依赖感

2954

新建的queen他是一个更新队列

2955

同学们理解为是一个更新队列

2956

然后你可以往你更新队列里面添加好几个更新

2957

参加很多的更新

2958

这些更新其实这些更新就是比如说你的a组件的name变了

2959

B组建的

2960

名字变了

2961

那么他都是他都会认为是一个更新

2962

对不对

2963

这样的一个更新

2964

后面的话会在

2965

会在schedule up down files里

2966

那么begin work里面的时候他就会

2967

它就会创建fiber吗

2968

创建新的fiber

2969

然后呢

2970

来给他计算他的更新是什么

2971

到底该怎么处理这样子

2972

所以每发几次更新

2973

这个其实最right

2974

也是一个常规操作

2975

无论你是sits date也好

2976

还是这个护士的这个这个的产品也好

2977

它都是有一个queen

2978

有个queen的depend喷的那个喷的里面

2979

都会有一个更新的队列

2980

就这样放下

2981

好

2982

我们hooks you state大概就讲这么多

2983

接下来讲个you the fact

2984

就讲这两个他们真的源码

2985

You the fact

2986

也比较简单

2987

有有

2988

但是他他和他和UC一样

2989

他也是把

2990

Mount阶段和up的阶段区分的非常的开

2991

区分得非常开

2992

比如浪子阶段的时候我们看一下

2993

现在去看一下

2994

Use effect

2995

我们在看这些逻辑的时候

2996

一定要牢记它的用法

2997

我们要牢记它的用法才行

2998

MT的时候

2999

他要传一个函数

3000

还差一个函数

3001

第一个是一个函数

3002

第二个是一个依赖数组

3003

对不对

3004

是依赖数组

3005

在忙的阶段要做什么

3006

忙的阶段

3007

首先蒙阶段

3008

毫无疑问

3009

他并不需要怎么样了

3010

同学们

3011

他并不需要对比你的依赖值的变化

3012

你直接无脑需要执行一遍

3013

无脑执行一遍就行

3014

但是呢

3015

他可能会有什么

3016

他可能会有自己的

3017

Destroy

3018

那个destroy就是它的类似于component will UN mount的东西

3019

所以我们还是需要好好的

3020

好的给它那个那个啥也行

3021

的

3022

嗯

3023

我在这里先给大家捋一遍吧

3024

免得一跳代码又蒙了

3025

Use effect

3026

我们用法是咋样

3027

The fact

3028

这样对不对

3029

这是1FACT

3030

同学们

3031

这是effect

3032

然后这是他的comeback

3033

我们在调这个you the fact的时候

3034

外面这个use effect就是注册阶段去注册的时候

3035

毫无疑问她是在begin work的时候

3036

begin work掉

3037

APP的

3038

函数题的时候是不是注册的u ti fact

3039

把那个优积分给他注册上了吗

3040

他这个当然他是Co BAC的执行还是在那个

3041

页面渲染完成之后

3042

页面渲染完成之后

3043

所以当掉

3044

所以当执行这块逻辑

3045

当执行这个MT effect这个逻辑的时候

3046

肯定在begin work里

3047

对

3048

在begin work那个阶段

3049

对不对

3050

那么在这我们看MT effect in July

3051

这里同样也是创建一个户口

3052

春节后可到这里

3053

处理他的依赖

3054

他的那个依赖值是多少

3055

大家看这儿会给他设置一个flex

3056

这个flag他认为因为这就是一个副作用

3057

对不对

3058

它本身you the flag

3059

它本身就是一个副作用

3060

所以无脑给他打成一个flag

3061

再无脑给他打成一个flag

3062

然后这个湖北的memories

3063

大家看我这写了

3064

有个注意事项

3065

对于这个memory state

3066

对于United States

3067

我们刚刚讲讲讲过

3068

对于United States来讲

3069

它的memory state是存放它的初始值的

3070

但是我们的u z fec他并没有初始值

3071

他这个mistake它存放的是这样的一个对象

3072

这样的一个对象

3073

这个就是you the fact

3074

的这个对象就是这个一负作用对象

3075

这个tag我们讲一下

3076

他肯定就是他的还是

3077

节点的类型

3078

Create

3079

这个create就是

3080

就是这个函数题

3081

这个就是create

3082

这个回调就是create

3083

然后destroy destroy它实际上是这个

3084

Create执行之后获得的

3085

也就是说

3086

那么在初始化的时候

3087

他肯定是没有的题

3088

所以后面我们会讲会看到他的在哪复制的

3089

会看他在哪儿负责

3090

他其实就是我们的

3091

我们如果说

3092

再给大家看

3093

假如我在这里再扔一个

3094

赞助他那个东西

3095

那么这个return的这个函数

3096

这个函数那么就是destroy

3097

只是他现在还没有被赋值

3098

Defense依赖next

3099

下一个OK

3100

这些都是常见的

3101

这些都是常见的照

3102

那么我们在MT阶段的时候

3103

其实做的事情非常有限

3104

出发地穿非常直接执行它本身的逻辑

3105

打上了一个flex标记

3106

然后呢

3107

Push了一个effect

3108

大家注意

3109

他打上了标记

3110

铺起了一个effect就完了

3111

大家之前有同学就问了

3112

就说老师他的函数题怎么没有执行

3113

就是它的这个它这个回调怎么没有执行

3114

这别晕

3115

它回调不是在这个阶段执行的

3116

他现在还在创建发展阶段

3117

他所以现在只是打上一个标记

3118

他的这个effect呢

3119

肯定要在

3120

当创建之后才会执行

3121

当创建之后才会执行

3122

那么就可以接下来我们就可以来到跟随

3123

跟随我们整个的fiber架构的构建

3124

我们可以来到commit阶段

3125

假如就在layout if it阶段

3126

它就会执行这个方法

3127

然后呢

3128

在这里会执行create的方法

3129

我们可以看一下这就是

3130

真正执行这个函数体的时候

3131

它肯定是在

3132

真正执行这个函数是大家看

3133

Create

3134

对吧

3135

可爱的存在

3136

那么它执行了

3137

然后呢

3138

把它的结果复制给了destroy

3139

结果复制给他的处理

3140

然后再来下一个

3141

然后再慢慢的递归

3142

递归就是说之前有同学有疑问的点在哪执行use effect本身的这个注册逻辑的时候

3143

他只做了这么两件事情

3144

然后有同学就搞不明白

3145

它的它的回调为什么没有执行

3146

就是为什么没有没有代码来执行

3147

原因是因为

3148

原因是因为

3149

原因是因为他不像我们写的那个简单的DEMO

3150

那个样子

3151

那个样子

3152

那么剪

3153

那么简单

3154

它需要把它挂载在整个react

3155

React价格之上来做

3156

那么你只要给他打上一个flag标记

3157

Push了一个effect

3158

那么在layout的这么个阶段里在执行

3159

在执行相对应来处理这个IP的逻辑就行了

3160

因此在我们也看到他执行的快的方法

3161

然后有反馈的就反馈给了destroy

3162

在这儿能理解吗

3163

关于她和她函数和关于you the fact和它的回调

3164

这个执行的时机这块有理解到吗

3165

同学们理解到的扣个一

3166

没理解到扣个零

3167

嗯

3168

所以我们讲hooks

3169

我我觉得他不是很困难的

3170

原因就是我每次讲话时

3171

大家后面都能听明白

3172

听能听明白的一个很大的一个原因就是前面儿是懂了

3173

在前面是懂的

3174

那么这个逻辑就没有问题

3175

不然绝对绝对搞不明白

3176

这第一

3177

不是的

3178

相当于时间表不是

3179

Use effect这个依赖它是一个数组

3180

这儿的是一个数组

3181

它不是列表

3182

比如说ABI

3183

它不是个列表

3184

Hooks列表是啥

3185

Hooks列表是五个fiber对象上

3186

比如说这个February

3187

像他有个属性叫什么state

3188

比如我弟那个use date

3189

它是一个

3190

X

3191

Dinner you the facts you hooks

3192

第10X这个X线表儿

3193

比如这个use effect

3194

它有两个参数嘛

3195

对吧

3196

第一个参数就是它

3197

第二个参数就是它这个是它的依赖速度

3198

这一个数字是指和她有关的

3199

只和她有关的

3200

和这个链表本身没有太大的关系

3201

能理解吗

3202

Use the fact

3203

A commit TE可以发给list month

3204

这个干嘛来着

3205

这个

3206

这个

3207

Commit TE KI fec ti sta MT

3208

这个是在我们所讲白天所讲的这个render过程的这三个阶段

3209

第一个阶段是当操作前

3210

第二个阶段当操作中

3211

第三个阶段操作后

3212

再当操作后之后

3213

这个layout会执行这个come come it lay out the effect

3214

在这个函数里

3215

他对于hooks

3216

就对于对于那个function component

3217

他会再调一个commit或beef at least MT

3218

然后呢

3219

来执行我们的you the fact的这个回调逻辑

3220

也就是因为我们usage相当于component did mount吗

3221

他肯定在这个阶段执行

3222

执行那个回调逻辑

3223

它是把它单独放到这个方法里面的

3224

The fact but

3225

为啥不能直接使用a sync的原因

3226

Call back为啥不能直接使用think

3227

嗯

3228

他这里没有支持

3229

你看大家看

3230

如果你要直线I think的话

3231

那么我这里应该怎么调

3232

那么我这儿是不是要给他写一个sin卡

3233

那我是不是得这么写

3234

我得这么写才行吧

3235

对不对

3236

REC他在处理这个

3237

REC他在处理这个CAD的时候

3238

就是把它当做的是一个同步的方法

3239

同步的方法来做了

3240

所以你没办法直接在里面用think如果你实在想用

3241

那么那么你的最外层肯定

3242

那如果你实在是想用的话

3243

你只能这么写

3244

其实应该你也明白对不对

3245

不然你也不会说直接直接不能直接用

3246

如果你实在想用的话

3247

你可以在你可以在里边定义一个

3248

Pasta

3249

A

3250

等于

3251

来

3252

如果你再想用那些在里面怎么用

3253

这个我我觉得同学应该明白

3254

不然不然不会这么问对吧

3255

但他这他确实没有做支持

3256

但是确实没做支持

3257

我一看到这个逻辑

3258

好了

3259

继续往下讲了

3260

这是MT阶段的事情

3261

然后呢

3262

Update其实就比较简单了

3263

首先给destroy副职

3264

Update effect destroy负责

3265

因为我们这个时候很有可能已经有destroy了

3266

然后就对比依赖有没有变化

3267

这个一样

3268

打上flag标记

3269

这个一样

3270

因为

3271

因为它还是一个副作用

3272

再普及一个you the fact

3273

Up的effect

3274

我们把那个猫的effect加

3275

如果理解了的话

3276

Update就就其实没有什么难度了

3277

再看这同样是找到还是找到

3278

对应的hook

3279

找到对应的户口

3280

这和之前我们那个简版的写法是一样的

3281

看他有没有变化

3282

如果这里只是发生了变化的话

3283

那么就谱写一个新的effect记上去

3284

只发生了变化

3285

这就是因为变化了之后嘛

3286

它它的功能就是变化了之后

3287

要更新要更新对不对

3288

所以才谱写

3289

否则就不谱写

3290

然后第一次错

3291

你看有没有直

3292

如果第一次错有值的话

3293

那么就把这个题是错也不写上去

3294

她在卸载的时候就会调用这个低级错误

3295

其实

3296

这个例子所以就是它调用时机

3297

调用时机就在卸载的那个时候会调用

3298

这个我就不给大家发代码

3299

就很其实就非常简单了

3300

他就在就在where a r MT那个差不多那个位置

3301

把他

3302

然后他的归的归我们所有的effect

3303

看有没有destroy destroy就执行一下

3304

非常简单

3305

然后设置一下塔

3306

这都是一样的

3307

这都是一样的

3308

好

3309

这就是我们

3310

嗯

3311

Effect就是effect

3312

得空了

3313

我再给大家捋一捋

3314

The fact首先

3315

注册的时候

3316

他在begin work里调APP函数体的时候

3317

它会掉这个

3318

它会执行use effect本身的逻辑

3319

什么逻辑呢

3320

打上一个标记

3321

突袭一个

3322

答

3323

打上一个flex标记

3324

然后push一个effect

3325

但是这个时候并不并不执行他的comeback

3326

并不是comeback

3327

然后呢

3328

再commit阶段的layout effect阶段其实也就是

3329

Down更新之后的那个阶段

3330

他执行的这个方法

3331

这个方法就是专门来处理hooks的这个effect的执行的correct有反馈

3332

直接反馈给destroy

3333

就做了这么一件事情

3334

做这件事情

3335

如果state发生了变化

3336

那么

3337

接下来函数体执行的时候

3338

它就会掉update的effect

3339

这个是首先他要给的错误

3340

回去给他赋值

3341

复制之后

3342

把他的所以也复制给那个effect

3343

然后重新发起一个effect

3344

然后打上标记

3345

把它普及一下

3346

然后在lear在咖啡的阶段

3347

那么如果如果说在组件卸载的时候会自行destroy

3348

这个方法其实我给他列在这里了

3349

如果

3350

如果

3351

然后就接着执行那个就是由由于这个存在的时候就是有变化的

3352

有更新的时候

3353

又在执行一次这个方法

3354

去把那个跟右直行是correct

3355

然后如果有的错误有返回值

3356

又把这个返回值赋值给的错误

3357

其实更新阶段相比于

3358

Com BI的阶段

3359

多了一个事情就是依赖只有变化

3360

变化的时候就重新发起一个

3361

Effect

3362

编号

3363

重新发起一个fat

3364

其他的其实都差不多

3365

都差不多一样

3366

而且第二个变化是他可能会有的错儿

3367

他可能有第四

3368

如果有的错的话

3369

就把他的错也复制给这个object就行

3370

就就就这儿不一样的

3371

如果有

3372

但如果有destroy

3373

他的这个destroy也给到了这个IP的内部

3374

嗯

3375

对吧

3376

他也把他就把这个地址可以直接复制给他

3377

那么当需要用到它的时候

3378

就是在逐渐卸载的时候

3379

就把它调一下

3380

所以use the fact he

3381

Use date的源码大概就是这个样子

3382

会比会比我们的那个简版要复杂一点

3383

要复杂的地方主要在哪

3384

主要在于因为主要在于它要是配我们整个react的价格

3385

在哪儿

3386

能理解吗

3387

能理解的扣个一

3388

本人也开个呢

3389

配的应该还好吧

3390

是吧

3391

他其实就多了一点吗

3392

OK

3393

我们就暂时想这两个了

3394

然后我们来看一下

3395

这个时期的

3396

其实这个没有什么好讲的就是

3397

以前的结擦

3398

他新特性吗

3399

这个如果说面试官说X最近有什么新特性

3400

然后有什么新特性

3401

比如REC17讲了

3402

这个旧的JSX转换会把GSX

3403

他那不转变的时候

3404

会把它转变成reckon create element对不对

3405

所以如果我们以前要用的时候

3406

比如我们这样用

3407

所以报错了

3408

为啥他因为他的JESCA

3409

我们转换之后

3410

它就会变成react.create element

3411

所以呢

3412

React必须要引用

3413

明白吗

3414

冉

3415

你必须要加上

3416

你不加上他会报错的

3417

就算你没有感觉你没有用

3418

没有你直接用

3419

但实际上

3420

你用了

3421

但实际上你用了

3422

如果是新的话就不用了

3423

如果是新的REC17

3424

那么它就变成它的编译之后就变异成这个样子

3425

你就不需要

3426

再再引一个react

3427

这个地方

3428

其实它就方便你把GSX这块逻辑也能够给剥离出来

3429

玻璃是加了这么一个东西

3430

然后呢

3431

事件委托也有变化

3432

但是在black事件系统显示他自己封装的事件系统

3433

他这个事件系统呢

3434

他并不是因为rock的live绑定的时候

3435

并不是绑定的真实的当吗

3436

对吧

3437

不是绑定绑定的真实的

3438

所以它是利用的是事件委托

3439

就是把一个就是把真正的

3440

绑定事件绑定在了自己的根节点

3441

绑定之前是绑定在document节点

3442

在以下十十七之前是绑定的document之前哒哒的节点

3443

比如说你在比如你在一个div上

3444

你自己写的div上绑定了一个on click实际上

3445

实际上真实真实的事就是真实的浏览器跑的时候

3446

你的你的那个

3447

那个第二节点上

3448

他确实有一个事件

3449

他确实有一个事件

3450

这个事件

3451

但这个事件是一个空的一个空的

3452

更早的版本是没有

3453

现在是有一个空的

3454

大家可以去看

3455

其实是有的是有

3456

但是是个空的

3457

他用的最终响应事件还是响应的是document.create element document

3458

点那个ADD listener

3459

大概的点呢

3460

添加listener

3461

在document上响应的

3462

然后呢

3463

这个事件委托

3464

这就是一个事件委托

3465

但是如果一考虑到一个问题

3466

你的页面上如果有多个reg版本的话

3467

就会出问题

3468

因为他们都住在顶层的

3469

所以这种嵌套结构阻止的事件冒泡

3470

因此wrecked实际中react不再向document附加事件处理器

3471

而将事件处理器添加到了react树的根当容器之中

3472

也就是说如果我们这样写

3473

我们因为APP里是可以写多个Ren de you

3474

多个人热点忍者都可以对不对那么

3475

这个APP里面的事件都注册在他上

3476

Head里面所有的建筑在踏上

3477

Food里面的建筑在他上

3478

你就算有这样子的话

3479

就把它给区分开了

3480

这是他时间委托做了新的更新

3481

然后现在就是

3482

这两点X17加的

3483

S8

3484

X8也带来了一些新的变化

3485

He人十堰是个啥

3486

嗯

3487

和城市间就是REC的

3488

事件首先来个事件

3489

他并不是我们刚刚讲了REC的他

3490

因为它是属于那个VLAN嘛

3491

对不对

3492

We大

3493

所以它的事件首先是全部利用的事件委托

3494

然后呢

3495

他内部由于他想要

3496

他还要区分

3497

比如说他要区分你的优先级

3498

这个区分优先级

3499

那么它在它的这个事件响应的过程当中

3500

那么他就还会做一些事情

3501

他就还会这些事情

3502

所谓的所谓的那个

3503

和城市间随着合成事件

3504

想一下这个名词是否是

3505

这个名词是否是准确的

3506

还有和四季

3507

看一下看一下这块代码吧

3508

应该能找到

3509

Touch

3510

他真的对吧

3511

当疑问词

3512

他在调这个事件之前谁掉这个事件是通过委托的形式转发的

3513

第二

3514

他在调这个事件之前

3515

他实际上做了一些事情

3516

有这么多的

3517

是这个吗

3518

我看看有点忘了

3519

老同学很棒同学

3520

之前看过原码是吗

3521

很棒

3522

性格问题

3523

三个院子的结实

3524

我要找

3525

我要找那个

3526

挺多的

3527

因为我没找到想要找的东西

3528

嗯

3529

是这个吗

3530

我没有找到想要找的东西

3531

不过大概的逻辑的话

3532

大概逻辑的话

3533

大概逻辑的话是它并不是

3534

它并不是一个就是我们react里面的事件

3535

他和那个圆

3536

它并不是直接就调用的那个浏览器的原生时间

3537

因为我知道

3538

有这

3539

你再把他给

3540

再把它给包了一下是吧

3541

Even TE

3542

你的face

3543

Even interface

3544

他是一个模拟的

3545

模拟的一个事件

3546

模拟一个事件

3547

然后

3548

在这个地方

3549

他实现了几个实践中的几个方法

3550

然后呢

3551

夹杂了一些他自己的逻辑

3552

加载他自己的逻辑

3553

就这些

3554

一个我们每都有一个prevent default

3555

对不对

3556

我们我们拿到REC的的那个event里面有prevent the effort

3557

让他自己实现的

3558

Stopped stopped publication也自己实现的

3559

这个其实也挺有用的

3560

有的时候会处理一些bug来使用

3561

所以好像是LSLS有的时候有点bug

3562

那么会给他一个persistence

3563

Persistence

3564

然后呢

3565

再按click

3566

真实的在调用on click的时候

3567

那么他还会给他

3568

附上那个

3569

这是要按click的时候

3570

他会判判断你的

3571

事件类型到底是什么

3572

比如说it

3573

或者是input

3574

然后呢

3575

他会给你加上不同的

3576

不同的那个优先级

3577

优先级的方式来驱动

3578

然后

3579

再之后再

3580

在调那个

3581

这然后才会掉

3582

他真实的那个会掉

3583

其实就是X和城市间是这么来的

3584

但是掉的那个地方我没有找到

3585

刚刚好像不在这个地方

3586

就给他家优先级那个好像没有在这个地方

3587

大概就这样

3588

意思是reg的事件不是单纯的事件

3589

而是有很多复杂的功能

3590

Record

3591

对啊

3592

他肯定不是

3593

他并不是对同学

3594

他不是直接掉到浏览器原生的都直接掉浏览器原生的功能

3595

它合成了一部分自己的能力

3596

机箱机箱里

3597

比如说你用console log对吧

3598

咱们看的那个

3599

如果你想要

3600

我这只是一个假设

3601

如果你想要重写

3602

如果你想要对所有的抗生素打抗生素的地方

3603

你想要发送日志

3604

那么你要干什么

3605

你要把它

3606

是不是要这么写

3607

Console log

3608

对啊

3609

然后

3610

他说那个等于他react里面不

3611

这个里面并不是

3612

这么简单粗暴的这么干的

3613

但是你不这么简单粗暴干涉

3614

我是举个例子

3615

这个例子比较形象

3616

然后你可以这么干对不对

3617

然后呢

3618

你可以

3619

然后你这里可以上传

3620

或者你打印也行

3621

做什么其他的事情

3622

上传啊

3623

一般可以这么搞

3624

但REC他并不是这么简单粗暴

3625

他不是这么简单粗暴

3626

这个为了方便丢了

3627

我先不刷新吧

3628

先不操心这个

3629

但这个太大了

3630

这个太大

3631

然后他有些有些功能是它自己加的

3632

比如说a click的时候

3633

像我刚刚说了

3634

他会给大家优先级

3635

因为因为因为

3636

你的每一个操作

3637

你的每一个操作来讲

3638

对react他内部来说是不太一样的

3639

是不太一样的

3640

它不然的话

3641

它优先级的判断

3642

对用户的这个优先级的判断是没法谈起

3643

那还有一些

3644

比如像合成的

3645

如果你不用black的话

3646

像fast click

3647

对吧

3648

发丝click这种应该有用过吧

3649

发丝click这种裤

3650

同样

3651

他就也为了解决cn click的这么一些问题

3652

那么他也做了内部也做了非常多的处理

3653

这是他的智力

3654

Max吧

3655

其实我X8功能上

3656

大概有两点有三个吧

3657

我看XX有三个变化

3658

我已经输入不了了

3659

第一

3660

自动的

3661

自动的那个杯茶

3662

对

3663

这什么意思

3664

同学们

3665

在ROCK17中

3666

我还是在这边写吧

3667

这已经要这里感觉已经要卡死了

3668

代码写的太多了

3669

在这里写吧

3670

在X17

3671

钟姐我先写个17

3672

在17里

3673

假如你在hooks里这么写

3674

比如说use date

3675

不

3676

这是Jess a

3677

Use the effect

3678

Effect

3679

假如你sick

3680

我这掉了两个户口

3681

对不对

3682

我这儿发现不是电脑顾客

3683

我这儿发起了两次更新

3684

发现两次更新

3685

还有对比

3686

如果是class里面

3687

假如是class里面

3688

只是看不懂

3689

特

3690

cars里面

3691

比如我在component

3692

did mount component in MT

3693

我通过rest in the state

3694

这个

3695

这个应该大家都懂

3696

大家都懂

3697

的

3698

对吧

3699

如何在卡斯里

3700

那么

3701

我第二两次s data

3702

他会发起一次批处理

3703

批处理就是只执行一次

3704

但是在康

3705

在那个company之间的you the fact

3706

如果发现两次

3707

这并不会出

3708

并不会批处理

3709

同名这里这里是不会批处理的

3710

Cook之前一直是不能批出来的

3711

这个时期也是没办法逼出来的

3712

这就会发起两次发起两次更新

3713

她没有没有给你做到PPT这个功能

3714

之前我如果是我们想让他只发几次怎么办呢

3715

我们可以引入一个方法叫做

3716

Based on the data

3717

我们可以把它包裹在被update里

3718

这个方法是reg down里面暴露出来的

3719

Thread大礼包出来

3720

如果你把它包裹一下

3721

我给它包裹一下

3722

那么他是可以匹配的

3723

这个方法应该在热带里

3724

这个based updates I is on back up is UN stable base updates

3725

你直接通过REC的

3726

当你可以把它调出来

3727

但你可以把它拿出来用

3728

因为它默认不平顺

3729

这个ROM17就是16就有这个问题时期的时候

3730

也有这个问题

3731

但他说要解决

3732

然后呢

3733

在18里面终于解决了

3734

就RIGHT18里

3735

再re acts PA里

3736

那么我们这么写

3737

就没问题了

3738

我们我们这边也就不需要再把它包起来了

3739

Rex PA ni

3740

这样写就是正常的

3741

正常的只发几次

3742

这才解决了这么一个问题

3743

嗯

3744

而且在

3745

C

3746

他帽子就是你把它放在system out Li

3747

嗯

3748

X写

3749

假如这样子写

3750

我把它换一个写法

3751

也是这样的

3752

他如果有system out特

3753

他的批准就失效了

3754

就会失效

3755

但是在X18里

3756

他的这个即使放在cmos里也不会失效

3757

这个是他新增的功能

3758

那比如说像一只loading这种事怎么办

3759

Rack是Rex中直接这样写

3760

不会被批准吧

3761

你在这里吗

3762

你知道这个地方吗

3763

这里吗

3764

可以啊

3765

Class里面是会的

3766

是会比之类的

3767

但是你加了四台帽子

3768

他就不会被批评了

3769

加三八

3770

加那个三八的就不会被批次了吗

3771

然后strikes啪的意思是说

3772

就算这样子写

3773

它同样是会被踢出去的

3774

这个事

3775

所以他加了一个自动

3776

我觉得这个最大的作用是在呼市里面

3777

护士里面

3778

他现在

3779

默认自己支持的话

3780

其实我们还是很方便的

3781

还是很方便的

3782

对吧

3783

这是X吧里有这样的一个更新

3784

所以所以大家要严格区分REX17和18

3785

还是很不一样的

3786

如果面试的时候

3787

面试官问到了批处理这个问题的时候

3788

那么大家就可以说我装逼的时候到了

3789

对吧

3790

你可以扔了17年怎么怎么样

3791

那X心里又区分class组件和com和那个方形com的它们的区别

3792

然后是REC18厘

3793

都批处理辣对吧

3794

然后呢

3795

一般来说就没问题了

3796

一般来说就没问题

3797

这自动的Facebook的一个新的话

3798

我觉得还是挺有用的

3799

我们直接来看看官方的文档吗

3800

其实X18

3801

更新

3802

反正也不赞同

3803

她问我咋实现的

3804

我就懵逼了

3805

这有啥懵逼的

3806

她问

3807

你咋实现的

3808

你就给他讲

3809

你就给他讲那个

3810

你又给俺讲那个

3811

咱们前面讲的

3812

咱们前面讲的那个啥

3813

发个价格

3814

就是讲发表价格

3815

为什么为什么come class component你能批处理

3816

不会让你把逻辑给他写出来的

3817

但是你要知道

3818

它就是我们的两个state之所以能够合并吗

3819

两个C的C的C的合并不就是因为服用了一个fiber嘛

3820

对不对

3821

就是前面的一个发背

3822

后面的复用

3823

后面的那个更新复用了前面的那个cyber

3824

而在而在那个呼呼吸就没有这个逻辑

3825

那当然就不用费用了

3826

Hose也没有这个逻辑

3827

然后18年他就加上了这个逻辑

3828

很简单

3829

有同学问这个

3830

我觉得我觉得好吧

3831

我还是给大家把那个代码找出来看看

3832

免得真的又懵逼了

3833

不太好

3834

为什么17不加

3835

这个问题我还真可以回答

3836

17的时候

3837

他是本来打算是要加的

3838

严格来说16:13的时候

3839

当时就有就有人反映了

3840

就是说为什么hooks里面

3841

没有

3842

就是hooks里面没有做批处理

3843

但是有人说这个功能的话到底要不要加

3844

然后当时

3845

当时那个作者就是说会在未来的版本加上

3846

会在未来的

3847

就是现在可以大家用背下来做未来的版本

3848

会把他加上

3849

但这个未来的版本可能并不在

3850

他排在17的里面来

3851

然后呢

3852

我当时也等了一两个版本

3853

然后还是没等到

3854

我都以为他不加了

3855

然后18的时候

3856

我看到她把她给加上了

3857

这样子就是他实际上时期他知道有这么个问题

3858

但是那个优先级呢

3859

还没有他做的其他事情那么高

3860

这个这些问题都很好回答的

3861

就直接给他吹

3862

而且这个并不是我吹的

3863

这个是那个作者自己回复的

3864

这个自自己回复的

3865

他其实知道这个问题的

3866

他是会在未来的版本加上

3867

不是没想到

3868

16的时候

3869

因为这个户口时是16的时候就开发了吗

3870

是12个的设计开发了

3871

然后呢

3872

有这个问题

3873

17的时候其实就已经有人提过艺术了

3874

希望能加上

3875

希望能加上

3876

但那个时候你你这件事情他肯定有优先级的吗

3877

如果他认为一个优秀的一个功能的优先级

3878

一个feature的优先级比这个更高

3879

那他肯定会做优先级更高的事情

3880

会遇见更高的实际上时期就像就像那个官方说的

3881

感觉上是没有什么新的功能迭代

3882

但其实它内部的

3883

它内部整合了非常多的逻辑

3884

区分了非常多的逻辑

3885

它里面代码都全变了

3886

所以相当于17道和十七十六到17是一个是一个内部重构的一个版本

3887

你可以这么理解

3888

那么这个时候嘉兴功能显然是不太合适的

3889

那不然的话

3890

18是不是还得到了升级了之后

3891

如果是70加上后面是不是还得重新加

3892

我个人是这么理解的

3893

我个人这么理解的

3894

反正

3895

反正就这么回答吗

3896

这问题有啥好问的

3897

问的我一般都不可能会问这些问题

3898

你就在你就在APP上

3899

那个gate户散

3900

然后就找那个他的那个tag的版本就可以找到

3901

大家不就自带耳机吗

3902

对吧

3903

多个多个set的时候

3904

如果你有一个存在的可怕可诺的

3905

那么就直接服用他

3906

不用你发现有的直接费用他

3907

不过注意同学们这个你说这个逻辑的时候

3908

我建议你把这个版本号带上

3909

你如果要如果他问到了你就你要说react多少多少版本里有这个

3910

他可能跟面试官我育

3911

我真遇到个有同学反映这样的问题

3912

就是他说了那个答案他说了

3913

我我讲的答案

3914

然后面试更觉得不太对

3915

然后呢

3916

同学觉得这怎么回事

3917

为什么面试官觉得不太对呢

3918

因为

3919

它里面的那个版本的升级里面的逻辑有的时候是经常变的

3920

有的时候实际上变得你RANK17是这个逻辑

3921

你rock16.8以前

3922

他他就不是这个逻辑

3923

这是另外一个逻辑

3924

所以我建议你要把那个版本号给他

3925

带上你的ROCK17

3926

他是这么干的

3927

他就这么干

3928

Rock自己

3929

Rock时期之前的我没有了解

3930

我只分析了X17

3931

就行了

3932

就算跟他

3933

跟他不一样

3934

那也不是你的问题

3935

是真遇到过

3936

如果是我的话

3937

我就告诉他

3938

X

3939

我我必须要告诉他是哪个版本

3940

版本号里面是怎么写的

3941

如果说真的有疑问的话

3942

那他可以当场查

3943

他可以打他

3944

就算理解的不太一样的情况

3945

有可能是有可能你们两个

3946

所说的事情都是对的

3947

只是版本号没对上而已

3948

理解吗

3949

这不就是吗

3950

这就是

3951

存在从他in directly的吧

3952

以前他有一个expression expression time

3953

他那个expression time

3954

Explosion他在可能在

3955

25毫秒好像是25毫秒内的

3956

它会它会自动给你合并成一次批处理来做

3957

一个expression概念

3958

但REX7已经没有expression to了

3959

理解吗

3960

所以他的逻辑是可能会变得有面试官会把ric的所有历史版的问好问一遍

3961

一不会的不会的

3962

不要担心

3963

没有谁的梦

3964

没有谁那么无聊

3965

考研考得远吗

3966

嗯

3967

这很简单

3968

你就

3969

嗯

3970

嗯

3971

这个就是呆会儿呆会儿稍等一下

3972

就刚刚讲的自动update吗

3973

自动被气

3974

自动自动被自动批处理

3975

来一个全新的API

3976

它的传染性

3977

这个star传染性怎么说

3978

他就是类似于

3979

先带帽子了

3980

就如果说你以后在代码里想要区分一个东西

3981

类似于社团boss

3982

但是他的直线时机又比他就这么用的

3983

大家看就这么用的

3984

它就类似于三帽子

3985

你就得把它换成C3帽子也能使

3986

键立马换成CM里面

3987

在它的直径17

3988

执行时期在CF之前

3989

他是同步的这么个区别

3990

没有机会

3991

但是它又可以把它给放到

3992

到这儿我就是想把它和上面这个

3993

不做一次批处理是吧

3994

想把它们分开处理

3995

因为这个set input value这个逻辑是c de value想立刻展示给用户儿这个C的search queen

3996

并不是要立刻展示给用户的

3997

所以把它分开处理比较好

3998

如果一起处理的话

3999

那么可能还会慢一点给用户展示

4000

所以大家把它给分开

4001

分开的话

4002

那么这个这个就不会

4003

在批处理里面执行

4004

所以他加了个SI star的成型

4005

但你就是没他

4006

你可以用塞他帽子也能使

4007

对不对

4008

也能使

4009

但是他的直接死机在他们的之前一些

4010

也是因为他支持了这个嘛

4011

支持了自动被

4012

所以就要需要这个

4013

如果你不自动备齐的话

4014

因为它默认就不是批处理了

4015

所以这个的使使用它的场景也不是很多

4016

以及类似的regular lady的全新SSR架构

4017

就这三个

4018

我觉得就这个是比较比较屌的

4019

我觉得我比较喜欢这个特性

4020

大家是

4021

这这几个

4022

这几个源码的话

4023

原版的话怎么说

4024

嗯

4025

不太好看的

4026

我们先看一下它的功能是啥吧

4027

好不好

4028

先看一下这个功能

4029

比如这个suspense s2

4030

这些是什么时候用

4031

什么时候什么时候说

4032

就是就问你

4033

最近react有什么新特性

4034

如果在一两年前你就打hooks

4035

因为他就是要问hooks

4036

如果是这样呢

4037

比如今年

4038

React就是那个面试官问题

4039

Correct有什么新特性

4040

那你就不能打boss

4041

他因为已经吃了两年了对不对

4042

已经两年了

4043

那你那你可以打四期

4044

就是X47

4045

你诚心结识他的转换

4046

还有什么

4047

还有事件委托权限的那个事件委托的一个更改

4048

但这两个都是小菜

4049

18才是大菜

4050

比如自动的

4051

被夏被自动的那个批处理

4052

很有很有用

4053

很有

4054

真的很有用

4055

然后一个全新的SSR的架构

4056

这个干嘛呢

4057

这个很这个我觉得很牛逼

4058

我看这几幅图就明白了

4059

我通过这几幅图给大家讲

4060

比如说S3

4061

我们大家都知道

4062

就是直出页面对不对

4063

直出页面

4064

就是直接把游戏里面给你返回吗

4065

直直接出吗

4066

然后但是呢

4067

之前都是直接出一个整体

4068

那假如你页面很复杂

4069

你直接出一个整体同样会很慢

4070

那他要怎么办

4071

那么他可以

4072

那么他可以一部分一部分地出

4073

其实就是类似于老人讲的那个什么pipeline那个玩意儿

4074

他一部分一部分的时候儿

4075

他怎么一部分一部分的书呢

4076

就是依赖于suspense he lazy

4077

Suspense are lazy suspense are lazy之前是不能够在S

4078

就是在那个服务器上使用的

4079

但REC18可以

4080

就suspense away在服务器端使用之后

4081

那么他就会一块儿一块儿给你出

4082

一块儿给你说

4083

那么这块儿就是如果那么这块其实是很有用的

4084

就假如你一整个页面

4085

很大

4086

那么你想让用户优先展示

4087

优先展示某一块儿

4088

优先给用户展示某一块儿

4089

那么你用这个

4090

Suspense he lazy

4091

来

4092

来那个结合SSR

4093

那么就是非常有用的一个特性

4094

比如像他说的

4095

他优先想展示哪块儿

4096

嗯

4097

就这样加了

4098

我有幸在上课

4099

那么这一块儿我我后面再展示也可以

4100

后面的展示也可以

4101

那么它就可以延后展示

4102

更牛逼的是什么呢

4103

更牛的是什么

4104

因为react的SSR大家都明白有一个他的逻辑是什么呢

4105

他都会先展示一个不能点击的

4106

对不对

4107

SSR都会先展示一个不能点击的一个东西

4108

然后

4109

不能展示一个不能点击的东西

4110

然后他慢慢地给他加事件

4111

就是它用户的观感

4112

就是眼睛所看到的

4113

之前出来的

4114

但是在一个时间段内它是不能点击

4115

就是可可交互时间

4116

如果在他的可交付时间之外的话

4117

他是没办法点击的

4118

对不对

4119

那它会慢慢的就就是一个happy的一个过程

4120

就叫做水化

4121

这个就是普通SSR

4122

正常的S2都有这个流程

4123

就是先给你展示一个

4124

展示一个相当于静态页面的东西

4125

你不能点

4126

然后呢

4127

等他把世界重新给你注册上之后

4128

你才能够点

4129

这个是普通的S就这么干的

4130

然后333可以让你干什么可以让你

4131

先展示一部分

4132

先展示一部分

4133

然后再展示另外一部分

4134

而更牛逼的是

4135

就算你现在处于不可点击的状态

4136

就是它这个绿色的就表示给她水化嘛

4137

对吧

4138

给他水化不不是鬼嘉宾头像不是国家拼

4139

这他展示的像是国家拼

4140

但实际上不是

4141

就相当于是

4142

正式的内容真正的内容

4143

这是真正的内容只是

4144

只是他给你区分了几个模块儿

4145

这是几个模块而已

4146

这不是古代片

4147

他就是真正的内容

4148

能理解吗

4149

然后只是说只是真正的内容一开始出来也是没办法点击的

4150

正常情况下

4151

那需要等到happy的

4152

就是水话

4153

就是给他加事件

4154

事件给它加上了之后才能点击

4155

ER

4156

ER

4157

他的这个新的这个sus pen SI就是家里the适用于适用于那个S之后

4158

你看水花的过程也可以就是黑的

4159

就是水花就是加事件的一个过程

4160

它也可以分快加

4161

最关键的是

4162

大家看就算这个地方没有被加上

4163

大家看

4164

如果说如果在这个时候

4165

我的这个我的这个白的地方是明显不能点击的

4166

我这个白色明显按

4167

如果按往常的逻辑

4168

就是普通的SSR

4169

这个白色地方是点击不了的

4170

对不对

4171

点击了没用

4172

然后这个就牛逼了

4173

他会把这个事情给你记住

4174

就你点这个事情给记住等他

4175

还觉得之后

4176

然后他再给你弹出来

4177

就是会慢一点儿

4178

但是你的试卷不会丢

4179

我觉得这个特性特别牛逼

4180

我特别喜欢这个功能

4181

然后等他完全损坏了之后

4182

然后他才会再给你

4183

把那个时间给执行了

4184

中文一句叫水化

4185

中英文叫happy的

4186

嗨

4187

Hedge it

4188

Headed

4189

翻译过来叫水化

4190

反正

4191

很淡很淡的

4192

他不是故意想延迟的

4193

他实际上是把那次事件给你追回来了

4194

法律知识

4195

如果你是普通的SSR

4196

在他喝醉的之前

4197

你是根本点不了的

4198

这能理解吧

4199

你没法点点不动

4200

因为世界都没有没绑定

4201

那现在可以

4202

所以我特别喜欢这个特性

4203

而且我也我也用到了

4204

我也用到了我那一次

4205

那一次那个想做一个我我因为我我的页面就有很多suspense

4206

我就想我thousands不能够在

4207

不能够在那个那个S3里使用这个有点儿有点儿蛋疼

4208

然后我就看到了这个

4209

现在见我就给他用了一把

4210

真挺爽很爽

4211

所以这个我觉得特别爽

4212

你把那个解释清楚就行

4213

然后这边儿

4214

一大段很大段的功能

4215

就是解释这个功能的

4216

大家下来可以看一下

4217

这是我觉得X18

4218

会不会我多吃点接

4219

那最后的执行还是执行最后一次

4220

多次点击你多次点击同一个是吗

4221

这个我倒真没试过

4222

下来我试试看吧

4223

这个我倒真没试过

4224

因为不确定他是不是当作一次还是多次

4225

我得试试看才知道

4226

因为这个算是比较新的一个特性的

4227

新的特性可以了解一下

4228

可以下载

4229

也可以自己写个DEMO试一试

4230

好了

4231

如果要讲新的新的话

4232

大概就是这样了

4233

对吧

4234

大概就这个样子

4235

然后我们的代码基本上就讲完了

4236

逻辑源码就讲的差不多了再回答一个问题

4237

刚刚有同学说

4238

不知道怎么调试

4239

用户误操作

4240

做一些剪辑

4241

用户没有用户不可能有误操作

4242

你用户的每一个

4243

就是用户会认为自己的操作是误操作嘛

4244

如果用户认为自己的操作是一个误操作

4245

那么出来的结果不符合他的预期也是正常的

4246

用户的每一个操作

4247

你都要认为他是一个正常的操作

4248

就是假如说用户真的想点

4249

就是看到他出来真的想点一下

4250

但是他真的想点一下

4251

那这就是一个正常的操作

4252

后面就应该执行正确的逻辑

4253

你说的是假如你点N多次

4254

对吧

4255

你N多次

4256

所以这个如果点多就是同时点多次

4257

这个我确实还不太清楚他到底是怎么发起的

4258

我现在可以看一下

4259

但是用户不应该把用户的操作认为是一个误操作

4260

因为她真的点多次

4261

对于他来说也合理

4262

也合理

4263

如果他认为他不小心点了

4264

结果弹出一个alert

4265

那么

4266

他也应该意识到这是她的

4267

她不小心点击了之后就发在这个操作

4268

这这也不算是一个

4269

就是这个是他所预期的一个误操作

4270

也不会有问题

4271

我觉得

4272

能理解吗

4273

因为这是他自己操作的吗

4274

就算真的出了

4275

就是比如弹那个弹窗

4276

因为你这个按理说

4277

因为你这个页面已经出来了

4278

给用户的感觉就是可怜的

4279

因为他已经出来了吗

4280

对于用户来说

4281

是不是你既然已经出来了

4282

而且有个八层

4283

我是不是可以点一下

4284

那我肯定在用户的角度来说

4285

不能点才奇怪

4286

能点不奇怪

4287

只不过他稍微延迟了一点嘛

4288

他可能会稍微慢一点点

4289

那么但至少是能点的

4290

至少是有

4291

至少是有交互的

4292

已经比以前好很多了

4293

对不对

4294

然后就是有同学说

4295

不知道怎么调试

4296

这个调试很简单

4297

比如说你就这样

4298

房德和节日的操作不是页面的逻辑吗

4299

防抖和节流的操作不是页面的逻辑嘛

4300

是

4301

是事业

4302

一般来说是页面自己写的逻辑

4303

是因为自己写的逻辑

4304

只不过不确定

4305

有点不确定的事你

4306

你那个他他有没有

4307

它会不会对这个也做批处理

4308

这个我不是很确定

4309

一般来说可能不会做

4310

一般来说可能不会对几次操作来做

4311

可能会给用户做

4312

但是

4313

没看吗

4314

这个

4315

这块我也我也没看

4316

所以不是很确定

4317

也没法儿

4318

但是我猜测应该没有

4319

我猜测应该点多下会有多少

4320

我得看一下之后才能有比较准确的回答

4321

有同学说不知道怎么的bug

4322

这个就非常简单嘛

4323

就是

4324

嗯

4325

哎呀

4326

有得买

4327

没有电吗

4328

我想想

4329

嗯

4330

咋没期待吗

4331

谁啊

4332

我看看我以前的电脑能不能合用

4333

这人呢

4334

没了

4335

这个呢

4336

它应该是可以用的吧

4337

对吧

4338

车

4339

这是老袁之前写了一个DEMO

4340

再拿来用一下

4341

比如说

4342

我这个是

4343

在普通地方的地方

4344

这个写写很简单

4345

只是可能会花点时间

4346

所以直接用一个

4347

Compound

4348

还是邓一八

4349

那么

4350

假如

4351

这是这是一个第八个

4352

这个调色还是很简单的

4353

没有人知道

4354

不是这个图片

4355

看着我

4356

直接

4357

打葛

4358

开始

4359

看一下这个C厅

4360

SACD吗

4361

这是跟

4362

然后

4363

Welcome

4364

那个

4365

怎么没提报个数

4366

六七个

4367

完了我直接在这里找吧

4368

我觉得这么一

4369

第八个

4370

云达

4371

好了

4372

看我们这不就打上了吗

4373

电视打上了

4374

来这里

4375

来了

4376

但是我这个地方还是些没用

4377

这些没用

4378

好

4379

那我在这里加一个

4380

component

4381

A city

4382

state1

4383

真的是

4384

然后

4385

然后大家看调试就很简单

4386

比如去找4S的了

4387

就整这个吗

4388

这个就是进去进到一个方法

4389

这个是到下一个断点对吧

4390

这个是到下一行

4391

这个是进入到下一

4392

进入到这个行之内

4393

我就进来了吗

4394

进来了之后

4395

那就找

4396

那就找人

4397

然后

4398

一行一行的调

4399

他原本叫这个schedule work

4400

这个就是我们刚刚看这个是这个是10X16.8

4401

这里面是X9.8

4402

很早以前的

4403

现在我们看的是二月17

4404

他这个schedule work里

4405

其实就是我们那个schedule work on route

4406

他也会掉什么

4407

他也会走到这个地方

4408

嗯

4409

他知道

4410

这个就是刷题调度

4411

发起调度

4412

Our stable schedule call back

4413

Stable schedule back

4414

啧啧啧的下一个

4415

在这里进去

4416

走走走走

4417

啧啧啧

4418

这因为我这个还是我这个代码

4419

和大家看到的可能不太一样

4420

可能不太一样

4421

因为它是16.8的这个schedule work

4422

他在走到school work里

4423

它就会进入那个什么调度流程

4424

他会区分是render还是

4425

就是是那个第一次是那个同步的还是异步的

4426

那个逻辑的那个G逻辑你去

4427

但是这逻辑已经全变了

4428

全改了

4429

调试的话就这么调

4430

这条你要是有问题了

4431

就在某个地方打他一巴掌

4432

直接再或者直接找个那行代码打断你

4433

然后调进去就行了

4434

大概就这样

4435

理解了吗

4436

同学们可以知道吗

4437

天也不早了

4438

就今天我们讲了

4439

来个圆满部分就到此为止吧

4440

今天拖了一个小时

4441

希望大家能够下来再看看吧

4442

下来再看看

4443

这个还是挺难的

4444

在济南呢

4445

朋友们

4446

辛苦了

4447

拜拜

4448

下课

4449

拜拜

