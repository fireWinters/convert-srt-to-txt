1
00:02:36,950 --> 00:02:40,820
哼哼哼哼

2
00:03:41,130 --> 00:03:44,610
蹦蹦蹦蹦蹦蹦蹦蹦蹦蹦蹦蹦蹦蹦

3
00:07:00,370 --> 00:07:00,610
嗯

4
00:08:13,330 --> 00:08:14,890
人都到齐了没

5
00:08:22,840 --> 00:08:23,680
你不困了

6
00:08:24,310 --> 00:08:25,570
我能解困是吧

7
00:08:26,890 --> 00:08:30,940
一看到我就瞬间不困了你这

8
00:08:34,620 --> 00:08:36,300
你们吐完了就不困了是吧

9
00:08:49,320 --> 00:08:49,500
好

10
00:08:49,500 --> 00:08:50,820
咱们开讲

11
00:08:50,820 --> 00:08:51,360
这节课呢

12
00:08:51,360 --> 00:08:55,230
咱们是这个前端前端跨界

13
00:08:55,890 --> 00:08:57,930
前端跨界是啥玩意儿呢

14
00:08:57,930 --> 00:09:00,660
就是和咱们前端相关的

15
00:09:00,660 --> 00:09:02,130
咱们前端能做的

16
00:09:02,130 --> 00:09:03,840
咱们用JS能写的

17
00:09:03,840 --> 00:09:08,160
还有咱们前端相关底层的东西

18
00:09:08,160 --> 00:09:10,110
看着看着和前端不搭边儿

19
00:09:10,110 --> 00:09:10,590
但是呢

20
00:09:10,590 --> 00:09:12,630
和这个前端

21
00:09:12,630 --> 00:09:14,580
但是前端你你要说管他吧

22
00:09:14,580 --> 00:09:17,400
他咱们前端也能管呢

23
00:09:17,400 --> 00:09:20,520
这就是那个前端跨界

24
00:09:20,520 --> 00:09:24,630
比如说像什么这个给弄的

25
00:09:24,630 --> 00:09:25,920
用C语言

26
00:09:25,920 --> 00:09:28,170
给给弄的写个什么

27
00:09:28,170 --> 00:09:29,430
写个扩展

28
00:09:29,430 --> 00:09:31,440
你你说算不算前端

29
00:09:31,680 --> 00:09:32,550
你说算

30
00:09:32,550 --> 00:09:35,130
他不是他不是咱们印象里边儿那种

31
00:09:35,130 --> 00:09:36,000
你说不算吧

32
00:09:36,000 --> 00:09:39,510
他还他还和咱们前端有关系对吧

33
00:09:40,080 --> 00:09:40,680
这个

34
00:09:43,780 --> 00:09:44,290
另外呢

35
00:09:44,290 --> 00:09:47,770
还有那个比如说像那种物联网

36
00:09:47,770 --> 00:09:50,200
物联网咱们也能拿JS去写

37
00:09:50,500 --> 00:09:50,980
还有呢

38
00:09:50,980 --> 00:09:54,640
就是像那个华为的那个操作系统

39
00:09:54,640 --> 00:09:55,810
那个鸿蒙

40
00:09:56,170 --> 00:09:57,040
那个鸿蒙呢

41
00:09:57,040 --> 00:09:59,710
他那个UI就是纯JS的

42
00:10:00,280 --> 00:10:00,670
对吧

43
00:10:00,790 --> 00:10:03,490
不知道你们研究过没有

44
00:10:03,490 --> 00:10:04,540
实际上这个鸿蒙

45
00:10:04,540 --> 00:10:08,200
这个那个鸿蒙用JS写一写的那个UI呢

46
00:10:08,500 --> 00:10:10,810
那个套路和小程序是非常像的

47
00:10:12,850 --> 00:10:15,310
咱们那个所以说呢

48
00:10:15,310 --> 00:10:17,710
咱们那个什么时候那个前端

49
00:10:17,710 --> 00:10:18,610
他不火了

50
00:10:18,610 --> 00:10:20,500
咱们还可以去干点别的

51
00:10:20,500 --> 00:10:22,090
尤尤其是那个

52
00:10:22,090 --> 00:10:25,240
尤其是那个赚钱多的那种

53
00:10:26,190 --> 00:10:30,390
你们这个你你啥啥玩意儿

54
00:10:30,390 --> 00:10:32,520
你这个你这是人话吗

55
00:10:32,520 --> 00:10:36,060
这个什么什么老师您贵姓

56
00:10:36,060 --> 00:10:37,860
你不知道我谁

57
00:10:37,860 --> 00:10:41,460
你你这这这这这这过分了

58
00:10:41,640 --> 00:10:42,630
我是不是进错

59
00:10:42,630 --> 00:10:44,460
我我是不是进错教室了

60
00:10:44,850 --> 00:10:46,830
你们那个

61
00:10:46,830 --> 00:10:48,300
我我没进错吧

62
00:10:48,980 --> 00:10:50,000
没进错吧

63
00:10:51,190 --> 00:10:51,940
拿

64
00:10:52,770 --> 00:10:53,820
没进错

65
00:10:54,900 --> 00:10:59,760
这这这家伙你吓我一跳

66
00:10:59,760 --> 00:11:01,470
你说我记错了教室

67
00:11:01,470 --> 00:11:03,510
你说这尴尬了

68
00:11:04,490 --> 00:11:05,870
咱们那个

69
00:11:06,760 --> 00:11:07,330
呵呵

70
00:11:15,990 --> 00:11:16,560
别闹

71
00:11:16,560 --> 00:11:18,390
都别闹

72
00:11:18,570 --> 00:11:20,310
这个来得有点晚

73
00:11:20,550 --> 00:11:23,130
你这饿得有点晚

74
00:11:23,130 --> 00:11:25,290
但是好好听

75
00:11:25,740 --> 00:11:28,410
咱们这个实际上呢

76
00:11:28,410 --> 00:11:29,730
咱们咱们做前端

77
00:11:29,730 --> 00:11:32,730
有同学可能会说做前端这个C语言呢

78
00:11:32,730 --> 00:11:35,670
那个这个学C语言干啥呀

79
00:11:35,670 --> 00:11:37,200
学习语言很重要

80
00:11:37,200 --> 00:11:42,690
和这个和那个底层相关的这些这些东西

81
00:11:42,690 --> 00:11:45,420
你都逃不出这个C语言去

82
00:11:45,690 --> 00:11:48,360
所以说这个C语言呢

83
00:11:48,360 --> 00:11:50,850
学这个C语言不是学这个语言本身

84
00:11:51,410 --> 00:11:51,950
对吧

85
00:11:52,070 --> 00:11:53,660
不是不是语言本身

86
00:11:53,660 --> 00:11:54,110
而是呢

87
00:11:54,110 --> 00:11:56,840
是和这个和底层相关的C语言

88
00:11:56,840 --> 00:11:59,480
他现在C语言所用的这个领域

89
00:11:59,630 --> 00:12:04,850
他就是他就是那个和底层

90
00:12:04,850 --> 00:12:06,950
这和底层这个关联特别大

91
00:12:06,950 --> 00:12:11,540
还有和这个硬件和这个硬件关联特别大的这种

92
00:12:11,810 --> 00:12:13,550
那么咱们学C语言呢

93
00:12:13,550 --> 00:12:15,530
不讲这个语法层面上的东西

94
00:12:15,530 --> 00:12:18,800
实际上这个语法是很简单的

95
00:12:18,800 --> 00:12:21,050
除了那个结构体和指针

96
00:12:21,050 --> 00:12:21,710
这这两块儿

97
00:12:21,710 --> 00:12:24,110
咱们JS里没有其他的那个语法

98
00:12:24,350 --> 00:12:25,850
和JS很像

99
00:12:26,090 --> 00:12:27,080
而且这个C语言呢

100
00:12:27,080 --> 00:12:28,850
他没有面向对象的一些东西

101
00:12:28,850 --> 00:12:30,680
C语言理事他是没有对象的

102
00:12:30,890 --> 00:12:32,000
只要咱们学了C语言

103
00:12:32,000 --> 00:12:35,930
主要是为了让大家帮助大家去了解这个底层

104
00:12:35,930 --> 00:12:38,630
还有这个内存内这个内存是怎么回事儿

105
00:12:38,630 --> 00:12:41,780
这究竟是怎么内存管理究竟是怎么做的

106
00:12:41,780 --> 00:12:43,670
它那个自动垃圾自动回收

107
00:12:43,670 --> 00:12:46,910
他和那个纯手动的这个回收

108
00:12:46,910 --> 00:12:48,440
这究竟是怎么回事儿

109
00:12:48,440 --> 00:12:49,700
咱们是为了了解这个东西

110
00:12:49,970 --> 00:12:50,390
还有呢

111
00:12:50,390 --> 00:12:51,440
后边咱们

112
00:12:51,730 --> 00:12:53,350
这个下面这两节课呢

113
00:12:53,350 --> 00:12:56,470
咱们还会去看一下他们那个弄得JS

114
00:12:56,470 --> 00:12:58,780
还有这个微吧

115
00:12:58,780 --> 00:13:02,710
还有还有那个web kit的之类的这些源码是吧

116
00:13:02,710 --> 00:13:04,990
咱们dei dei能看懂这个语法

117
00:13:05,200 --> 00:13:07,210
至于说咱们去写个插件儿啥的

118
00:13:07,210 --> 00:13:14,080
这个你需要去下点功夫好好好好好的那个好好的那个学一下

119
00:13:14,140 --> 00:13:14,830
咳

120
00:13:15,360 --> 00:13:15,660
好

121
00:13:15,660 --> 00:13:18,180
咱们那个就开始

122
00:13:18,180 --> 00:13:20,550
那么这个这节课呢

123
00:13:20,550 --> 00:13:22,500
咱们主要呢

124
00:13:22,500 --> 00:13:26,550
先去讲那个CPU和内存

125
00:13:26,550 --> 00:13:31,770
这个这个就是纯纯粹的这个计算机的这个底层层面上的东西然后呢

126
00:13:31,770 --> 00:13:34,950
咱们再再再讲一讲那个汇编

127
00:13:34,950 --> 00:13:36,180
还有这个C语言

128
00:13:36,180 --> 00:13:37,110
让大家了解一下

129
00:13:37,110 --> 00:13:38,760
并不是说去学这东西

130
00:13:38,970 --> 00:13:40,560
去去学这个汇编

131
00:13:40,860 --> 00:13:41,670
还有这机器语言

132
00:13:41,670 --> 00:13:42,690
不不是学这东西

133
00:13:42,960 --> 00:13:45,300
实际上这个这个玩意儿

134
00:13:45,300 --> 00:13:47,520
去去去那个了解一下

135
00:13:47,640 --> 00:13:52,620
帮助咱们去更更好的去理解这个C语言是她是她是怎么回事儿

136
00:13:52,800 --> 00:13:56,460
然后就是然后就是主要是这个指针

137
00:13:57,140 --> 00:14:01,820
指针和内存咱们前边儿咱们后边还要去讲那个数据结构呢

138
00:14:01,820 --> 00:14:06,140
实际上这个数据结构一一一方面是逻辑上的结构

139
00:14:06,140 --> 00:14:16,070
一方面是实现上的结构那么这个不不这个不了解这个内存这个内存机制咱咱们那个实线是比较实现是比较麻烦的

140
00:14:16,520 --> 00:14:16,760
好

141
00:14:16,760 --> 00:14:17,210
然后呢

142
00:14:17,210 --> 00:14:18,980
咱们先看这个学C语言

143
00:14:19,010 --> 00:14:20,870
学这个C语言这个

144
00:14:20,870 --> 00:14:24,530
到底要要要学什么东西实际上咱们这个C语言呢

145
00:14:24,620 --> 00:14:25,730
在前端这一块儿呢

146
00:14:25,730 --> 00:14:28,580
用的是用的还是相当的那个广泛的

147
00:14:28,880 --> 00:14:31,280
那么咱们C语言

148
00:14:31,280 --> 00:14:34,910
有的时候咱们在那个Linux的服务器上的

149
00:14:34,910 --> 00:14:38,090
在Linux服务器上去装一些这个环境的时候

150
00:14:38,090 --> 00:14:40,310
他没有他是没有那个安装包的

151
00:14:40,310 --> 00:14:43,640
他需要需要咱们直接从那个源码去安装

152
00:14:43,640 --> 00:14:46,730
咱们去编译那个源码一编译完了源码以后

153
00:14:46,730 --> 00:14:51,290
然后然后用那个脚本去装这这这就和那个C语言就相关啦

154
00:14:51,290 --> 00:14:54,500
这涉及到那个C语言的那个编译链

155
00:14:55,280 --> 00:14:59,420
那么咱们那个C语言的基本语法和JS挺非常像

156
00:14:59,420 --> 00:15:02,030
也因为那个JS他出现的这个时间

157
00:15:02,030 --> 00:15:06,710
就他他这个出现的时间就很很靠前啦

158
00:15:06,710 --> 00:15:09,020
就就很很久了

159
00:15:09,020 --> 00:15:11,480
那那么那个实际上那个时候的语言呢

160
00:15:11,480 --> 00:15:14,330
基本上都是仿照的这个C语言的语法

161
00:15:14,360 --> 00:15:16,130
另外还有另外一个

162
00:15:16,130 --> 00:15:18,260
还有另外那么一个方向

163
00:15:18,260 --> 00:15:19,220
就是仿照

164
00:15:19,220 --> 00:15:22,640
仿照那个Python语言的那种语法

165
00:15:22,670 --> 00:15:26,330
反正仿照C语言语法的语言是相当多的

166
00:15:26,330 --> 00:15:27,020
之后呢

167
00:15:27,020 --> 00:15:28,550
就是这个指针

168
00:15:28,550 --> 00:15:32,150
指针和C语言里边内内内那些东西了

169
00:15:32,150 --> 00:15:33,770
这个玩意是重中之重

170
00:15:33,770 --> 00:15:35,840
当初我在学那个C语言的时候呢

171
00:15:36,020 --> 00:15:38,390
有那么一本非常薄的那么一本儿书

172
00:15:38,390 --> 00:15:40,010
那本书就就100多页

173
00:15:40,010 --> 00:15:40,880
不到200页

174
00:15:40,880 --> 00:15:41,750
内内叫什么来着

175
00:15:41,750 --> 00:15:43,310
C语言指针陷阱

176
00:15:43,310 --> 00:15:44,990
实际上这个C语言它难吗

177
00:15:44,990 --> 00:15:45,920
它一点儿都不难

178
00:15:45,920 --> 00:15:48,290
难就难在这个指针和内存上

179
00:15:48,290 --> 00:15:50,750
Nei nei内本书是相当经典的

180
00:15:50,750 --> 00:15:51,890
现现在都绝版了

181
00:15:52,610 --> 00:15:53,900
你想买都买不到

182
00:15:55,290 --> 00:15:58,770
那个另外呢

183
00:15:58,770 --> 00:16:03,000
咱们在搞懂这个V8内存管理的时候

184
00:16:03,000 --> 00:16:06,270
他在C语言啥C语言嗨

185
00:16:06,450 --> 00:16:12,390
就是那个指针陷阱C语言指针陷阱这本书

186
00:16:13,410 --> 00:16:15,750
咱们再再那个研究V8的时候

187
00:16:15,750 --> 00:16:17,130
研究V8底层机制的时候

188
00:16:17,130 --> 00:16:21,840
咱们需要去从从那个源码开始看起那个微吧里边儿实际上呢

189
00:16:22,020 --> 00:16:25,170
有好多都是这个数据结构和处理机制

190
00:16:26,080 --> 00:16:28,630
数据结构和处理机制

191
00:16:28,630 --> 00:16:31,840
那个玩意儿咱们得得能读懂它的原码吧

192
00:16:32,140 --> 00:16:32,530
对吧

193
00:16:32,530 --> 00:16:35,020
咱咱咱咱用C语言写不出来的

194
00:16:35,140 --> 00:16:42,130
但是咱得能看懂所以这个玩意儿是那个你你对你这个长城长是非常有帮助的

195
00:16:42,490 --> 00:16:43,960
那么咱们闲话就不多说了

196
00:16:43,960 --> 00:16:45,400
先从这个CPU开始

197
00:16:45,580 --> 00:16:46,840
咱们这CPU

198
00:16:46,840 --> 00:16:48,160
它是怎么回事儿呢

199
00:16:48,250 --> 00:16:52,540
咱们这个计算机里面最重要的两个部件

200
00:16:52,540 --> 00:16:55,360
最重要的两个部件就是CPU和内存呢

201
00:16:55,480 --> 00:16:56,650
那么这个CPU呢

202
00:16:56,710 --> 00:16:59,230
咱们先简单的了解一下

203
00:16:59,320 --> 00:16:59,800
首先呢

204
00:16:59,800 --> 00:17:00,910
这个CPU

205
00:17:00,910 --> 00:17:02,350
它的指令集

206
00:17:02,850 --> 00:17:03,900
不同啊

207
00:17:03,900 --> 00:17:05,010
什么叫指令集

208
00:17:05,010 --> 00:17:05,460
不同啊

209
00:17:05,460 --> 00:17:07,710
比如说咱们那个PC上

210
00:17:07,710 --> 00:17:11,460
或者是那个台机或者普通的那个Windows Windows本儿

211
00:17:11,670 --> 00:17:13,260
那种指令集叫什么呢

212
00:17:13,380 --> 00:17:17,040
他叫X86杠X64指令集

213
00:17:17,040 --> 00:17:18,960
这个就是英特尔的那种指令集

214
00:17:19,230 --> 00:17:20,580
另外还有另外一种

215
00:17:20,580 --> 00:17:22,020
还有另外一种CPU呢

216
00:17:22,020 --> 00:17:22,620
他叫啥呀

217
00:17:22,740 --> 00:17:24,090
他是ARM

218
00:17:24,090 --> 00:17:25,680
它用在咱们这个手机

219
00:17:25,680 --> 00:17:27,090
或者是平板儿等等

220
00:17:27,090 --> 00:17:27,870
还有一部分

221
00:17:27,870 --> 00:17:31,710
一少部分那个笔记本儿也在用那个ARM

222
00:17:31,710 --> 00:17:32,220
另外呢

223
00:17:32,220 --> 00:17:34,170
比如说像那个呢

224
00:17:34,170 --> 00:17:34,890
Apple啊

225
00:17:34,890 --> 00:17:37,080
那个苹果的那个M1

226
00:17:37,080 --> 00:17:37,740
对吧

227
00:17:37,740 --> 00:17:39,600
M1那个那个那个CPU

228
00:17:39,660 --> 00:17:41,220
他也是ARM指令集的

229
00:17:41,340 --> 00:17:43,410
那么这个指令集和指令集

230
00:17:43,410 --> 00:17:44,370
她是不通用的

231
00:17:44,520 --> 00:17:48,930
那也就是说你编译出来的那个二进制的那个程序

232
00:17:49,110 --> 00:17:51,210
你是不能跨CPU去用的

233
00:17:51,240 --> 00:17:53,880
那当然你的代码是可以重新编译的

234
00:17:53,880 --> 00:17:57,240
你你的代码可以针对针对这个X86去编译

235
00:17:57,300 --> 00:17:59,190
也可以针对这个ARM去编译

236
00:17:59,190 --> 00:17:59,850
这叫什么

237
00:17:59,850 --> 00:18:01,200
这叫交叉变异

238
00:18:01,290 --> 00:18:03,120
你在比如说你在Windows平台上

239
00:18:03,180 --> 00:18:06,030
你去编译那个ARM平台上的这个源代码

240
00:18:06,240 --> 00:18:08,190
ARM平台上的这个程序

241
00:18:08,190 --> 00:18:09,180
这叫交叉编译

242
00:18:09,570 --> 00:18:11,730
所以那么这种这种交叉编译呢

243
00:18:11,730 --> 00:18:13,950
可就可以让我们去

244
00:18:14,040 --> 00:18:20,850
可以让我们去跨跨平台那么这个另外还有

245
00:18:20,850 --> 00:18:21,810
比如说像这个map

246
00:18:21,810 --> 00:18:25,170
这个map咱们咱们很少接触了呢

247
00:18:25,170 --> 00:18:27,750
一般用在那个服务器上

248
00:18:27,750 --> 00:18:28,200
还有呢

249
00:18:28,200 --> 00:18:32,490
就是那个龙欣那个隆鑫哈那个

250
00:18:33,980 --> 00:18:35,600
那个龙心内那种芯片

251
00:18:35,600 --> 00:18:37,640
这这这个这个也比较老了

252
00:18:37,640 --> 00:18:40,070
就国产的一国产的一种芯片

253
00:18:40,070 --> 00:18:42,440
他用的也是这个maps这个MIPS指令集

254
00:18:42,440 --> 00:18:46,490
他他这个知识版权比较好搞一些

255
00:18:46,490 --> 00:18:48,350
所以那个隆鑫就用了maps

256
00:18:48,680 --> 00:18:51,770
后来后来龙心就就专攻这个服务器了

257
00:18:51,770 --> 00:18:56,300
他他他就不管他他就不去搞这个个人桌面这这个方向了

258
00:18:56,630 --> 00:19:00,620
另外还有一种叫瑞克瑞斯科教精简指令集

259
00:19:00,740 --> 00:19:09,290
这种指令集是开源的主要的指令集是是是这四种咱们实际上咱们用的咱们用的那个普通的麦克

260
00:19:09,290 --> 00:19:11,900
还有那个Windows本Windows电脑

261
00:19:11,900 --> 00:19:13,310
都都是X86的

262
00:19:13,610 --> 00:19:15,350
那么这个

263
00:19:16,260 --> 00:19:17,280
指令集啊

264
00:19:17,280 --> 00:19:19,680
他就他这个指令集就决定的

265
00:19:19,680 --> 00:19:22,980
就决定了你这个跑的这个系统

266
00:19:22,980 --> 00:19:28,890
他跑跑决定你跑这个系统的主要系统是什么比如说手机上

267
00:19:28,890 --> 00:19:30,300
安卓对吧

268
00:19:30,300 --> 00:19:31,650
他跑跑着Android

269
00:19:31,710 --> 00:19:38,940
只要安卓它底层就是Linux那么这个CPUCPU它的组成是什么样的呢

270
00:19:38,940 --> 00:19:40,560
CPU主要是三部分

271
00:19:41,180 --> 00:19:44,390
咱们是一层一层的往下抽象那么这个图呢

272
00:19:44,390 --> 00:19:46,280
是最简单的一个模型

273
00:19:46,280 --> 00:19:47,690
CPU最简单的一个模型

274
00:19:48,080 --> 00:19:49,940
那这在CPU里边呢

275
00:19:50,000 --> 00:19:50,630
三部分

276
00:19:50,660 --> 00:19:52,910
一个是控制单元是控制单元

277
00:19:52,910 --> 00:19:53,930
控制单元干什么

278
00:19:53,930 --> 00:19:55,430
他就是负责

279
00:19:55,580 --> 00:19:56,900
他就是负责调度的

280
00:19:57,140 --> 00:20:00,110
那控制单元就是就就是这来调度

281
00:20:00,110 --> 00:20:01,130
他调度什么呢

282
00:20:01,460 --> 00:20:02,540
他调度

283
00:20:02,540 --> 00:20:06,470
从存储单元把数据或者是指令拿出来

284
00:20:06,470 --> 00:20:06,950
然后呢

285
00:20:06,950 --> 00:20:07,760
放到晕

286
00:20:08,090 --> 00:20:09,920
然后发给这个运算单元

287
00:20:09,920 --> 00:20:13,070
让运算单元干活运算单元干完了活儿以后呢

288
00:20:13,070 --> 00:20:17,750
控制单元a再把这个数据再放回这个存储单元去呢

289
00:20:17,930 --> 00:20:19,820
他他就是负责来调度这个东西

290
00:20:20,090 --> 00:20:21,560
那么调度这个东西

291
00:20:22,800 --> 00:20:26,430
那么除了去去调度这些去搞调度

292
00:20:26,430 --> 00:20:28,710
实际上他还搞搞其他的一些

293
00:20:28,800 --> 00:20:29,970
还还做其他一室

294
00:20:30,120 --> 00:20:32,100
比如说这个存储单元

295
00:20:32,130 --> 00:20:34,710
它是在CPU的内部

296
00:20:34,710 --> 00:20:35,610
他不是内存

297
00:20:35,760 --> 00:20:36,840
咱们要注意

298
00:20:36,840 --> 00:20:38,130
存储单元它不是内存

299
00:20:38,310 --> 00:20:40,320
内存它在CPU的外边儿呢

300
00:20:40,410 --> 00:20:40,950
对吧

301
00:20:41,130 --> 00:20:43,080
除了这个内内存

302
00:20:43,080 --> 00:20:43,800
除了这个内存

303
00:20:43,800 --> 00:20:45,300
它还有一个存储器

304
00:20:45,330 --> 00:20:46,440
存储器叫什么

305
00:20:46,530 --> 00:20:50,340
叫外存那个外存就是咱们咱们那个硬盘

306
00:20:50,340 --> 00:20:50,910
U盘啊

307
00:20:50,910 --> 00:20:52,650
光盘等等这些东西

308
00:20:52,770 --> 00:20:54,690
实际上这个数据是它是怎么流的

309
00:20:54,690 --> 00:20:55,740
他是怎么流动的呢

310
00:20:55,890 --> 00:20:59,220
从硬盘拿出来放到放到内存里

311
00:20:59,340 --> 00:21:03,810
再从内存放到把这个数据放到存储单元之后呢

312
00:21:03,810 --> 00:21:06,870
再把这个存储单元的数据交给运算单元去处理

313
00:21:06,960 --> 00:21:08,640
那运算单元处理完了以后

314
00:21:08,730 --> 00:21:11,160
再把结果放回到存储单元来

315
00:21:11,310 --> 00:21:15,900
存储单元是因为CPU里边这个存储单元它是很小的

316
00:21:15,900 --> 00:21:17,100
他他非常非常小

317
00:21:17,460 --> 00:21:20,370
那不不可能总是在这个存储单元这儿放着

318
00:21:20,400 --> 00:21:23,040
如果说暂时用不着或或者是她

319
00:21:23,100 --> 00:21:24,060
他就是最终结果

320
00:21:24,060 --> 00:21:26,940
再把这个结果再放到内存里边儿去最后呢

321
00:21:26,940 --> 00:21:28,980
再把这个结构保存到硬盘上

322
00:21:29,160 --> 00:21:32,160
他是这么一个流程那那么这个CPU

323
00:21:32,160 --> 00:21:37,020
可以说这个CPU就是咱们这个计算机的这个核心了那么在CPU

324
00:21:37,020 --> 00:21:39,270
这个CPU主要这这三大块儿

325
00:21:39,270 --> 00:21:40,110
看着挺简单

326
00:21:40,200 --> 00:21:42,390
实际上内部是相当那个

327
00:21:42,870 --> 00:21:44,310
内部是相当复杂的

328
00:21:44,550 --> 00:21:45,780
那么它内部是什么样的

329
00:21:45,780 --> 00:21:48,510
咱们把这个咱们把这个简单的这个模型

330
00:21:48,510 --> 00:21:51,150
把它放大放大以后呢

331
00:21:51,180 --> 00:21:51,990
就变成这样了

332
00:21:52,170 --> 00:21:54,780
那么第二个图咱们就加了点东西

333
00:21:54,930 --> 00:21:55,470
对吧

334
00:21:55,500 --> 00:21:59,640
加点儿东西是CPU在这一块儿这这是把控制单元

335
00:21:59,730 --> 00:22:01,950
控制单元里边儿这给放大了

336
00:22:02,160 --> 00:22:05,280
那大家肯定会会会会想

337
00:22:05,310 --> 00:22:08,490
那么那个数据和指令是怎么拿到CPU里去的

338
00:22:08,490 --> 00:22:10,290
大家肯定会对这个有疑问

339
00:22:10,410 --> 00:22:10,770
对吧

340
00:22:10,980 --> 00:22:12,060
那么在这个图呢

341
00:22:12,090 --> 00:22:15,120
除了把这个CPU这这这个控制单元放大

342
00:22:15,240 --> 00:22:16,440
咱们把这个内存也

343
00:22:16,760 --> 00:22:17,360
也加进来

344
00:22:17,600 --> 00:22:18,710
在之前

345
00:22:18,710 --> 00:22:21,770
咱们给大家讲那个Linux的时候给大家讲过

346
00:22:21,920 --> 00:22:25,100
那么咱们的那个程序放在硬盘上

347
00:22:25,130 --> 00:22:27,590
它是那个点exe对吧

348
00:22:27,650 --> 00:22:29,720
他是个静态的然后呢

349
00:22:29,720 --> 00:22:32,090
把这个点exe放到内存里边儿

350
00:22:32,090 --> 00:22:33,200
它就变成动态的了

351
00:22:33,260 --> 00:22:34,880
那么动态的它叫什么名字

352
00:22:35,030 --> 00:22:37,430
他叫进城对呢

353
00:22:37,430 --> 00:22:38,360
它变成动态的

354
00:22:38,360 --> 00:22:40,280
他就要进他他就要进城了

355
00:22:40,490 --> 00:22:42,530
那么这个进程a

356
00:22:42,560 --> 00:22:44,630
咱们当初也给大家说过

357
00:22:44,720 --> 00:22:46,820
在进程里边儿它分

358
00:22:47,180 --> 00:22:48,530
两块儿呢

359
00:22:48,560 --> 00:22:50,780
一块儿就是指令

360
00:22:50,960 --> 00:22:54,230
那这个指令就是咱们这个程序的代码

361
00:22:54,230 --> 00:22:54,620
对吧

362
00:22:54,740 --> 00:22:56,420
咱们不管是用C写的

363
00:22:56,420 --> 00:22:57,230
用Java写的

364
00:22:57,230 --> 00:22:58,640
用JS写的

365
00:22:58,820 --> 00:23:00,500
只要你扔到这个内存里边

366
00:23:00,500 --> 00:23:04,100
他必定他要转成这个指令另外一部分呢

367
00:23:04,100 --> 00:23:05,690
就是这个数据

368
00:23:05,810 --> 00:23:07,340
那么在这个进程里边

369
00:23:07,340 --> 00:23:09,200
在这个进程的内存空间里边儿

370
00:23:09,530 --> 00:23:12,860
这个把把进程放到内存里边儿去之后

371
00:23:12,980 --> 00:23:15,680
操作系统会给这个进程分配内存空间

372
00:23:15,980 --> 00:23:17,690
那么这个内存空间

373
00:23:17,810 --> 00:23:20,660
它会主要分成两段儿

374
00:23:20,660 --> 00:23:21,590
分成两块儿

375
00:23:22,110 --> 00:23:22,800
分成两块儿

376
00:23:22,950 --> 00:23:24,570
那么放指令的这一块儿

377
00:23:24,570 --> 00:23:25,530
他叫代码段

378
00:23:25,770 --> 00:23:27,120
放数据的那一块儿呢

379
00:23:27,150 --> 00:23:28,230
它叫数据段

380
00:23:28,230 --> 00:23:31,020
比如说那个这这个代码段

381
00:23:31,020 --> 00:23:32,670
就是程程序本身

382
00:23:32,670 --> 00:23:34,530
比如说你写的什么if else啊

383
00:23:34,530 --> 00:23:35,640
还有什么for

384
00:23:35,640 --> 00:23:38,910
For well哈什么阿之类的这些东西

385
00:23:38,910 --> 00:23:40,590
就都都是这个指令

386
00:23:40,950 --> 00:23:42,390
还有什么函数

387
00:23:42,390 --> 00:23:45,180
你实现的一些函数等等都在这一块儿

388
00:23:45,180 --> 00:23:46,470
都都在这个地方

389
00:23:46,470 --> 00:23:47,640
它要执行的是东西

390
00:23:47,850 --> 00:23:48,720
那么数据呢

391
00:23:48,720 --> 00:23:50,340
比如说你那些变量

392
00:23:50,340 --> 00:23:51,330
你什么局部变量

393
00:23:51,330 --> 00:23:51,990
全局变量

394
00:23:51,990 --> 00:23:53,250
还有什么字符串

395
00:23:53,460 --> 00:23:54,300
你的对象

396
00:23:54,300 --> 00:23:56,820
乱七八糟的全都在数据段这

397
00:23:57,210 --> 00:23:57,840
在这儿来的

398
00:23:58,140 --> 00:24:00,150
那么CPU它是怎么处理的呢

399
00:24:00,150 --> 00:24:00,840
首先呢

400
00:24:00,960 --> 00:24:03,300
当这个进程

401
00:24:03,300 --> 00:24:06,300
将这个进程内加载到内存里边儿去以后

402
00:24:06,330 --> 00:24:07,860
操作系统他来调度

403
00:24:08,550 --> 00:24:08,910
对吧

404
00:24:08,970 --> 00:24:10,080
操作系统来调度

405
00:24:10,110 --> 00:24:12,750
那么Linux它本身是一个

406
00:24:12,780 --> 00:24:16,140
本身它是一个那个多任务系统

407
00:24:16,140 --> 00:24:18,750
什么时候轮到这个进程去跑了

408
00:24:18,750 --> 00:24:20,820
然后操作系统就把控制权

409
00:24:21,030 --> 00:24:23,790
就把这个控制权就交给了这个进程

410
00:24:24,030 --> 00:24:25,410
交给进城以后

411
00:24:25,500 --> 00:24:27,120
接下来干什么呢

412
00:24:29,690 --> 00:24:31,100
接下来干什么呢

413
00:24:31,100 --> 00:24:32,090
接下来

414
00:24:33,080 --> 00:24:42,620
那么就要从这个进程的代码段这把指令给取出来取出来以后交给控制单元交给控制单元

415
00:24:42,950 --> 00:24:44,030
那么交给控制单

416
00:24:44,030 --> 00:24:45,710
他怎么知道从哪儿去取呢

417
00:24:45,860 --> 00:24:52,160
操作系统它会得到这个进程的第一条指令所在的地址

418
00:24:52,430 --> 00:24:54,620
那也就是说它在内存当中的那个位置

419
00:24:54,650 --> 00:25:00,020
然后那么这个地址他放在哪儿就放在指令寄存器里边儿

420
00:25:01,300 --> 00:25:05,620
那么CPU他再执行下一条指令的时候

421
00:25:05,620 --> 00:25:07,000
这个指令寄存器

422
00:25:07,000 --> 00:25:08,260
这个指令计数器

423
00:25:08,440 --> 00:25:18,400
她永远她永远是保存的是永远保存的是下一条指令所在的位置在内存当中所在的位置呢

424
00:25:18,460 --> 00:25:22,090
然后根据这个指令寄存器找到这个指令的位置

425
00:25:22,270 --> 00:25:24,340
找到以后把指令拿过来

426
00:25:24,370 --> 00:25:25,630
拿过来放到哪儿呢

427
00:25:25,690 --> 00:25:28,960
放到CPU里的这个指令寄存器里边儿

428
00:25:29,730 --> 00:25:31,020
这个指令寄存器

429
00:25:31,050 --> 00:25:35,400
它就是下一条下一个要执行的这个CPU质量呢

430
00:25:35,460 --> 00:25:38,640
然后根据这个指令来控制

431
00:25:38,670 --> 00:25:41,160
到底是把这个到底是拿数据

432
00:25:41,160 --> 00:25:49,140
还还是还是那个告诉预算单元来来处理数据它根据这条指令来来决定

433
00:25:49,200 --> 00:25:50,190
如果是

434
00:25:50,640 --> 00:25:51,720
要取数据呢

435
00:25:51,960 --> 00:25:53,670
如果他要取数据的话

436
00:25:53,760 --> 00:25:56,850
那么这条指令就要根据根据这个

437
00:25:58,000 --> 00:25:59,410
数据在

438
00:26:00,010 --> 00:26:01,960
这个内存当中的地址

439
00:26:01,960 --> 00:26:03,370
去找到这块数据

440
00:26:03,610 --> 00:26:05,680
那么这个数据的地址在哪儿呢

441
00:26:05,740 --> 00:26:07,930
A也在一个寄存器里

442
00:26:07,930 --> 00:26:09,400
也在CPU的一个寄存器里

443
00:26:09,400 --> 00:26:11,110
CPU里边是有好多寄存器的

444
00:26:11,110 --> 00:26:13,420
这些寄存器还有存指令的

445
00:26:13,480 --> 00:26:15,070
有存数据的

446
00:26:15,580 --> 00:26:20,140
还有那个这个还有找那个下一条指令是什么呢

447
00:26:20,140 --> 00:26:27,280
还有什么预处理指令的一个现代CPU里边大概有会有上百个寄存器

448
00:26:27,490 --> 00:26:32,020
那么那这个数据的这个数据的这个操作

449
00:26:32,020 --> 00:26:35,320
这个数据的这个地址就放在放在另外一个寄存器里

450
00:26:35,380 --> 00:26:38,590
根据另外一个寄存器里找到数据的地址

451
00:26:38,590 --> 00:26:41,620
就从就从这个对应的内存当中拿出来了

452
00:26:41,710 --> 00:26:44,350
拿出来以后扔给存储单元

453
00:26:44,650 --> 00:26:46,210
那么把数据拿过来了

454
00:26:46,210 --> 00:26:48,940
接下来就要处理数据对吧

455
00:26:49,030 --> 00:26:51,520
咱们程序的本质是什么呢

456
00:26:51,520 --> 00:26:54,580
程序的本质就是数据加操作

457
00:26:55,200 --> 00:26:56,640
数据加操作对吧

458
00:26:56,640 --> 00:26:58,320
就是数据结构加算法对吧

459
00:26:58,320 --> 00:26:59,850
数据结构就是数据

460
00:26:59,850 --> 00:27:02,490
算法就是操作那么数据有了

461
00:27:02,490 --> 00:27:03,540
下一个就是操作

462
00:27:03,660 --> 00:27:05,250
那么操作谁来操作

463
00:27:05,280 --> 00:27:06,870
当然是运算单元来操作

464
00:27:06,960 --> 00:27:08,700
实际上计算机里边他怎么操作

465
00:27:08,700 --> 00:27:12,630
他就是他就是加减乘除实际上他到到最终

466
00:27:12,630 --> 00:27:18,150
到最后他就是个加法CPU里边所有的内那些那个运算指令

467
00:27:18,150 --> 00:27:24,270
都是基于加法来都是基于加法来来来那个组装出来的

468
00:27:25,710 --> 00:27:31,530
那么这个这种这种那个处理指令这种处理

469
00:27:31,680 --> 00:27:33,360
全给预算单元去做

470
00:27:33,600 --> 00:27:34,140
那好

471
00:27:34,170 --> 00:27:36,150
那么第一条指令取数据

472
00:27:36,180 --> 00:27:37,950
那第二条指令再娶个数据

473
00:27:37,980 --> 00:27:39,105
比如说一加一等于二

474
00:27:39,105 --> 00:27:39,540
对吧

475
00:27:39,600 --> 00:27:40,770
他的取两个数据

476
00:27:40,800 --> 00:27:43,680
取两个数据都放到放到存储单元这儿

477
00:27:43,800 --> 00:27:45,600
下一个指令就就该干活了

478
00:27:45,600 --> 00:27:46,680
一加一对吧

479
00:27:46,740 --> 00:27:47,400
一加一

480
00:27:47,430 --> 00:27:49,140
那那那加法谁做

481
00:27:49,200 --> 00:27:50,670
当然让预算员做

482
00:27:50,910 --> 00:27:52,650
那么你加法做完了以后

483
00:27:52,650 --> 00:27:54,090
得出一个结果来

484
00:27:54,180 --> 00:27:56,820
这个结果放在哪儿放在存储单元里

485
00:27:57,490 --> 00:27:58,300
你不能总是发

486
00:27:58,390 --> 00:28:00,640
总是让预算单元帮你保存

487
00:28:00,640 --> 00:28:02,380
你你把结果放到存储单元

488
00:28:02,740 --> 00:28:04,210
那么放到存储单元里好

489
00:28:04,270 --> 00:28:05,440
那么这个值有了

490
00:28:05,560 --> 00:28:06,280
这个只有了

491
00:28:06,280 --> 00:28:09,550
那那这个值不能总是在存储单元这儿放着

492
00:28:09,550 --> 00:28:10,690
它的容量是有限的

493
00:28:10,960 --> 00:28:11,680
那怎么办

494
00:28:11,740 --> 00:28:13,540
把这个存储单元的这个数据

495
00:28:13,570 --> 00:28:15,760
再回写到这个内存当中去

496
00:28:16,120 --> 00:28:16,780
最后呢

497
00:28:16,780 --> 00:28:17,860
再根据需要

498
00:28:17,860 --> 00:28:19,720
如果说你这个数据需要保存到文件

499
00:28:19,870 --> 00:28:23,680
那在那再把这个数据把它保存到这个硬盘上去

500
00:28:24,280 --> 00:28:26,050
是这么这么一种流程

501
00:28:26,110 --> 00:28:30,880
所以说这个CPU当中的这个CPU当中的

502
00:28:30,940 --> 00:28:32,290
这三个东西

503
00:28:32,290 --> 00:28:34,150
这三个东西就是最主要的核心

504
00:28:34,850 --> 00:28:38,330
那最主要的三个那个核心单元

505
00:28:38,450 --> 00:28:39,470
一个是控制单元

506
00:28:39,470 --> 00:28:40,280
一个是存储单元

507
00:28:40,280 --> 00:28:41,720
一个是运算单元这

508
00:28:42,900 --> 00:28:44,160
就这就这仨

509
00:28:44,400 --> 00:28:45,780
那么这三个

510
00:28:45,780 --> 00:28:47,580
把这三个再放大

511
00:28:48,420 --> 00:28:50,880
把这三个再放大又是什么样的呢

512
00:28:50,880 --> 00:28:51,570
就是这样的

513
00:28:52,700 --> 00:28:53,390
就是这样了

514
00:28:53,600 --> 00:28:54,530
那么这个

515
00:28:54,530 --> 00:28:56,540
咱们就咱们就不去

516
00:28:56,750 --> 00:28:59,240
咱们就不去讲这个流程了

517
00:28:59,300 --> 00:29:01,160
他不是那个123级缓存

518
00:29:01,160 --> 00:29:03,560
存储单元不是123级缓存

519
00:29:03,560 --> 00:29:06,410
那个缓存它有自己的用处

520
00:29:07,220 --> 00:29:09,020
他是那个做那个数据域

521
00:29:09,200 --> 00:29:12,530
做那个数据预加载的那个缓存

522
00:29:12,590 --> 00:29:13,760
因为你从

523
00:29:13,970 --> 00:29:15,920
你从那个内存这儿

524
00:29:15,920 --> 00:29:16,640
实际上啊

525
00:29:16,760 --> 00:29:18,620
咱们再再再多说两句

526
00:29:18,740 --> 00:29:20,750
你把数据从内存这儿来

527
00:29:20,750 --> 00:29:23,060
把它拿到这个CPU

528
00:29:23,060 --> 00:29:25,220
这实际上这个效率是比较低的

529
00:29:26,120 --> 00:29:28,100
这个数据传输的效率是比较低的

530
00:29:28,310 --> 00:29:30,830
那么这个传输效率

531
00:29:30,830 --> 00:29:33,320
传输效率从高到低它是怎么样呢

532
00:29:33,440 --> 00:29:35,300
在CPU内部

533
00:29:35,300 --> 00:29:39,080
在CPU内部传输数据是最快的然后呢

534
00:29:39,110 --> 00:29:42,560
从内存把数据拿过来拿到CPU里

535
00:29:42,770 --> 00:29:44,150
这个其次呢

536
00:29:44,180 --> 00:29:49,130
然后从硬盘或者是其他的这个外存a把数据拿到内存里边儿

537
00:29:49,160 --> 00:29:50,870
这个这个最慢

538
00:29:51,370 --> 00:29:52,720
那为什么会这样呢

539
00:29:52,810 --> 00:29:55,330
因为在CPU内部处理

540
00:29:55,420 --> 00:29:56,710
这就是他自己的东西

541
00:29:57,010 --> 00:29:59,890
如果说要从CPU

542
00:30:00,130 --> 00:30:02,110
外部去拿数据的话

543
00:30:02,170 --> 00:30:03,280
要走IO

544
00:30:04,450 --> 00:30:07,480
那么这个IO指的是什么东西

545
00:30:07,480 --> 00:30:10,630
到底IO针对的是CPU

546
00:30:11,740 --> 00:30:13,720
IO是什么东西

547
00:30:13,720 --> 00:30:14,710
IOI是什么

548
00:30:14,860 --> 00:30:16,360
Input o呢

549
00:30:16,420 --> 00:30:16,990
Output

550
00:30:17,560 --> 00:30:18,070
对吧

551
00:30:18,340 --> 00:30:21,400
输入输出输入输出是针对谁来说

552
00:30:21,550 --> 00:30:23,650
针对CPU来说的呢

553
00:30:24,340 --> 00:30:27,370
从外部设备把数据拿过来

554
00:30:27,370 --> 00:30:31,150
或者是把内部的数据交给外部数据都要走IO

555
00:30:31,950 --> 00:30:34,800
我看那么对于这种IO

556
00:30:34,830 --> 00:30:39,240
对于内存到CPU走的是主板上的那个线路

557
00:30:39,240 --> 00:30:42,450
实际上他是实际上他是那个

558
00:30:46,010 --> 00:30:48,050
实际上它是那个

559
00:30:50,190 --> 00:30:53,940
那个速度比CPU内部要要慢很多

560
00:30:54,210 --> 00:30:54,960
那么从

561
00:30:55,810 --> 00:30:58,660
硬盘把数据扔给这个内存

562
00:30:58,660 --> 00:31:01,120
那它就不是在主板上了对吧

563
00:31:01,120 --> 00:31:04,930
他他他要你硬盘要接到那个主板上的一个接口上

564
00:31:04,960 --> 00:31:06,940
这个速度更慢

565
00:31:07,090 --> 00:31:08,350
这速度就更慢了

566
00:31:08,560 --> 00:31:09,160
所以呢

567
00:31:09,160 --> 00:31:13,360
就需要当你数据再进行这个

568
00:31:13,780 --> 00:31:17,170
部件和部件之间进行移动的时候需要干什么

569
00:31:17,170 --> 00:31:17,920
需要缓存

570
00:31:18,830 --> 00:31:19,370
对吧

571
00:31:19,520 --> 00:31:20,930
咱们之前

572
00:31:21,050 --> 00:31:23,960
咱们之前再给大家讲那个

573
00:31:25,230 --> 00:31:29,040
之前在给大家讲那个HTP协议的时候

574
00:31:29,040 --> 00:31:30,030
大家还记得吧

575
00:31:30,720 --> 00:31:32,640
讲HDP协议的时候

576
00:31:33,850 --> 00:31:35,350
咱们讲那个缓存

577
00:31:35,920 --> 00:31:36,550
对吧

578
00:31:36,670 --> 00:31:39,160
那个缓存当时我给大家说过

579
00:31:39,400 --> 00:31:40,780
当时给大家怎么说的

580
00:31:40,990 --> 00:31:42,580
这个缓存

581
00:31:42,910 --> 00:31:46,210
它各有它在什么地方都会出现

582
00:31:47,690 --> 00:31:49,790
那么缓存的意义在哪儿呢

583
00:31:50,090 --> 00:31:53,120
就是为了去减少

584
00:31:53,120 --> 00:31:58,400
就是为了去减少这个数据来回倒腾的时候

585
00:31:58,400 --> 00:31:59,570
来回倒腾的时候

586
00:31:59,750 --> 00:32:01,640
你所消耗的那个时间

587
00:32:02,360 --> 00:32:03,290
他他就是一个

588
00:32:03,440 --> 00:32:05,900
他就是一个这暂存区

589
00:32:15,990 --> 00:32:17,400
他就是一个暂存区

590
00:32:17,580 --> 00:32:19,980
哈恶

591
00:32:20,860 --> 00:32:21,580
所以说

592
00:32:21,580 --> 00:32:24,850
这个这个内存不但在HDP那儿有

593
00:32:24,850 --> 00:32:28,000
在网络的底层的那个套接字那儿也有

594
00:32:28,090 --> 00:32:30,430
在CPU内部也有

595
00:32:30,430 --> 00:32:33,010
那个缓存它不是存储单元

596
00:32:33,010 --> 00:32:35,500
他是他是他是为了防止

597
00:32:35,500 --> 00:32:38,080
防止你这个数据来回倒腾

598
00:32:38,080 --> 00:32:42,400
她她那个对时间的这么一个耗损

599
00:32:42,400 --> 00:32:43,330
他干这个用

600
00:32:51,800 --> 00:32:52,130
好

601
00:32:52,130 --> 00:32:53,420
那么咱们接下来

602
00:32:53,420 --> 00:32:54,980
就再看下一个图

603
00:32:58,290 --> 00:32:59,160
再看下一个图

604
00:32:59,280 --> 00:33:00,330
那么这个图

605
00:33:00,330 --> 00:33:03,210
咱就不仔细的去讲他了不仔细的讲了

606
00:33:03,210 --> 00:33:04,290
为什么不仔细讲

607
00:33:04,290 --> 00:33:05,280
因为这个东西

608
00:33:05,280 --> 00:33:09,090
讲起来就太复杂了咱们就了解一下

609
00:33:09,240 --> 00:33:11,670
刚才咱们所说的那个寄存器

610
00:33:11,670 --> 00:33:15,180
刚刚才所说的这个指令G指令寄存器

611
00:33:15,180 --> 00:33:17,190
还有保存数据的寄存器

612
00:33:17,190 --> 00:33:18,990
她在什么地方他在这里

613
00:33:19,860 --> 00:33:23,790
这些这这里属于那个通用寄存器组

614
00:33:24,030 --> 00:33:27,300
那么这个图是是是哪种CPU的图

615
00:33:27,390 --> 00:33:30,180
他是一个非常非常古老的CPU

616
00:33:30,330 --> 00:33:34,530
就是那个叉八六那个CPU的那个第二代

617
00:33:34,530 --> 00:33:35,850
可也可以说是第一代

618
00:33:35,850 --> 00:33:37,560
一袋半是8086

619
00:33:38,310 --> 00:33:40,080
实际上第一代CPU

620
00:33:40,170 --> 00:33:44,430
英特尔第一代CP第一代CPU是什么型号4004

621
00:33:45,270 --> 00:33:46,710
然后是8008

622
00:33:47,810 --> 00:33:49,010
8008

623
00:33:49,130 --> 00:33:51,830
这这是那个英特尔的第一代CPU

624
00:33:51,920 --> 00:33:55,250
然后就然后第二第二代是什么呢

625
00:33:55,250 --> 00:33:56,120
8080

626
00:33:57,110 --> 00:33:57,620
还有呢

627
00:33:57,620 --> 00:33:58,340
8086

628
00:33:59,430 --> 00:34:01,230
这是这是第二代CPU

629
00:34:01,230 --> 00:34:02,610
这个就是第二代

630
00:34:02,610 --> 00:34:06,960
像像这个CPU现在已经很现现在已经很那个啥了

631
00:34:07,530 --> 00:34:14,370
像这种CPU现在现在是已经看在在理论上来说是非常简单的

632
00:34:14,370 --> 00:34:18,600
非是非常简单的这么一种一种CPU了

633
00:34:18,630 --> 00:34:20,130
尽管说简单

634
00:34:20,130 --> 00:34:22,980
但是咱们自己也做不出来那么它

635
00:34:24,350 --> 00:34:25,100
像这个玩意儿呢

636
00:34:25,100 --> 00:34:26,150
也很便宜

637
00:34:26,150 --> 00:34:29,150
也就是现在这个8086这种CPU

638
00:34:29,240 --> 00:34:30,410
他是另外一个型号了

639
00:34:30,470 --> 00:34:32,390
反正那个型号我王乐

640
00:34:32,390 --> 00:34:37,310
反正国内的国国内的那个半导体这个厂家

641
00:34:37,310 --> 00:34:40,250
也是很很轻易的能够把它给做出来

642
00:34:40,610 --> 00:34:42,320
那么这种东西

643
00:34:43,670 --> 00:34:48,470
这种东西大概是那个一两块钱一片现现现在这个8086

644
00:34:48,680 --> 00:34:51,440
在当初可是好几百美元一片

645
00:34:51,740 --> 00:34:53,030
那么这这个东西呢

646
00:34:53,030 --> 00:34:54,830
这个图是从哪儿找的呢

647
00:34:54,860 --> 00:34:55,790
就是当初

648
00:34:55,790 --> 00:34:57,560
当初我在学汇编的时候

649
00:34:57,560 --> 00:35:01,550
他在学那个汇编语言的时候a有一本儿有一本儿教材叫什么

650
00:35:01,640 --> 00:35:07,430
叫80868088088086汇编语言这这这这是那本书里边儿的

651
00:35:07,430 --> 00:35:09,620
他就是为了去去告诉你

652
00:35:09,620 --> 00:35:13,250
这个指令它到底是怎么走的那么在这一块儿

653
00:35:13,430 --> 00:35:15,740
这一块儿就是咱们刚才所说的那个寄存器

654
00:35:15,860 --> 00:35:17,060
然后在这一块儿呢

655
00:35:17,060 --> 00:35:18,530
也是寄存器

656
00:35:18,650 --> 00:35:23,660
那么这一块儿他就释放指令和数据的这一块儿是CPU内部

657
00:35:23,660 --> 00:35:26,810
CPU内部在模块和模块之间进行通信的时候

658
00:35:26,960 --> 00:35:29,690
它用的那么在CPU内部里边儿

659
00:35:29,750 --> 00:35:31,880
像像像像像这些东西

660
00:35:31,880 --> 00:35:32,930
有控制单元

661
00:35:32,930 --> 00:35:34,730
有什么运算单元

662
00:35:35,390 --> 00:35:35,930
另外呢

663
00:35:35,930 --> 00:35:38,300
还有这个寻寻址单元

664
00:35:38,300 --> 00:35:38,990
寻址单元

665
00:35:38,990 --> 00:35:43,220
那个寻址单元就是用来那个操作内存的那么在这

666
00:35:43,280 --> 00:35:44,150
这些单元

667
00:35:44,150 --> 00:35:45,620
这些这些模块之间

668
00:35:45,620 --> 00:35:47,090
他怎么去传输数据呢

669
00:35:47,150 --> 00:35:48,560
由内部总线

670
00:35:48,560 --> 00:35:51,410
由由内部总线来来来负责

671
00:35:51,410 --> 00:35:55,700
这是在全都封装到这个CPU恶CPU的内部里边儿了

672
00:35:56,530 --> 00:36:01,150
所以说所以说在在那个CPU内部呢

673
00:36:01,240 --> 00:36:03,370
那个在在CPU内部呢

674
00:36:06,280 --> 00:36:07,690
它的速度是很快的

675
00:36:07,690 --> 00:36:09,010
全都封装到一起了

676
00:36:09,340 --> 00:36:11,290
那么这个这个图

677
00:36:11,290 --> 00:36:13,210
咱们就那个了解一下

678
00:36:13,210 --> 00:36:18,850
了解一下就够了不不不用去那个深究他深究它也没什么意思对吧

679
00:36:20,960 --> 00:36:21,200
嗯

680
00:36:25,380 --> 00:36:27,240
刚才有同学说哈

681
00:36:27,240 --> 00:36:28,320
你打错字了

682
00:36:29,850 --> 00:36:31,470
那个刚才有同学说

683
00:36:31,470 --> 00:36:32,970
想着自己焊一个对吧

684
00:36:32,970 --> 00:36:34,020
学着自己焊一个

685
00:36:34,020 --> 00:36:35,280
实际上这种事儿

686
00:36:35,280 --> 00:36:36,300
非非得不讨好

687
00:36:36,330 --> 00:36:43,560
对不对你可以用那个半导体元件儿可以用那个半导体元件儿可以自己攒但是呢

688
00:36:43,560 --> 00:36:46,470
那个玩意儿是没有意义没没有太大意义

689
00:36:46,470 --> 00:36:47,790
你又不是学这个东西的

690
00:36:47,790 --> 00:36:50,190
你除了除除非你用来消磨时间

691
00:36:50,370 --> 00:36:52,320
你你有这么几年的业余时间

692
00:36:52,320 --> 00:36:54,120
你拿那个玩意儿去消磨时间

693
00:36:54,300 --> 00:36:55,080
这可以

694
00:36:57,590 --> 00:36:57,920
好

695
00:36:57,920 --> 00:36:58,910
然后接下来

696
00:36:58,970 --> 00:37:00,320
接下来咱们CPU

697
00:37:00,320 --> 00:37:03,590
CPU给大家那个说完了之后呢

698
00:37:03,590 --> 00:37:04,940
就是这个计算机

699
00:37:04,940 --> 00:37:06,920
计算机语言它的本质是什么

700
00:37:07,040 --> 00:37:09,290
计算机的本质就是二进制

701
00:37:09,290 --> 00:37:10,250
就是二进制数据

702
00:37:10,280 --> 00:37:12,350
那么这个二进制数据

703
00:37:12,350 --> 00:37:14,180
他要对应的那个

704
00:37:14,180 --> 00:37:16,550
他要对应那个CPU的指令

705
00:37:17,360 --> 00:37:19,490
这这个数据它对应的是那个CPU的指令

706
00:37:19,880 --> 00:37:24,350
那么这个指令它这个指令它是什么样的呢

707
00:37:24,500 --> 00:37:26,660
实际上那个CPU的指令

708
00:37:26,720 --> 00:37:28,130
她就是0101

709
00:37:28,130 --> 00:37:30,320
他有自己的这么一套编码方式

710
00:37:31,120 --> 00:37:32,110
这个编码方式呢

711
00:37:32,110 --> 00:37:33,640
有兴趣有兴趣的同学

712
00:37:33,790 --> 00:37:35,230
可以去百度一下

713
00:37:35,320 --> 00:37:37,390
内那个咱就不详细说了

714
00:37:37,510 --> 00:37:40,180
一一说那个大家都都晕了

715
00:37:40,720 --> 00:37:41,920
只要在CPU内部

716
00:37:41,920 --> 00:37:43,150
它的编码

717
00:37:43,150 --> 00:37:46,060
它的编码方式是有好好多种的

718
00:37:46,060 --> 00:37:51,580
比如说什么什么那个什么什么什么那个反码补码儿

719
00:37:51,580 --> 00:37:53,140
还这是给数据编码的

720
00:37:53,170 --> 00:37:55,990
还有还有什么BDC码等等

721
00:37:56,080 --> 00:37:58,270
另外这个指令

722
00:37:58,330 --> 00:38:02,500
怎样让这个怎样让这个指令他不产生歧义

723
00:38:03,240 --> 00:38:05,700
对吧保证它的唯一性

724
00:38:05,700 --> 00:38:06,120
而且呢

725
00:38:06,120 --> 00:38:07,350
让他的处理更快

726
00:38:07,350 --> 00:38:09,690
它有自己独特的这么一套指令编码

727
00:38:09,900 --> 00:38:11,160
这个咱们不深究

728
00:38:11,160 --> 00:38:13,200
感兴趣的同学可以自己去百度一下

729
00:38:13,440 --> 00:38:14,460
然后呢

730
00:38:15,280 --> 00:38:16,990
然后这种指令

731
00:38:17,020 --> 00:38:19,480
这种指令它它叫什么呢

732
00:38:19,510 --> 00:38:21,730
它叫机器指令

733
00:38:21,730 --> 00:38:23,020
这种二进制数据

734
00:38:23,020 --> 00:38:24,580
他就是机器质量

735
00:38:24,700 --> 00:38:26,680
大家看到后边儿这个痛苦指数了

736
00:38:26,740 --> 00:38:27,820
对对吧

737
00:38:27,880 --> 00:38:29,290
他不是那个图零机

738
00:38:29,290 --> 00:38:30,280
他不是那个图灵机

739
00:38:30,280 --> 00:38:32,410
图灵机是一种计算机模型

740
00:38:33,220 --> 00:38:37,630
等一会儿给大家说一下这个图零机是怎么回事儿如果说你感兴趣

741
00:38:37,630 --> 00:38:39,250
感兴趣的话可以给你说一下

742
00:38:40,850 --> 00:38:44,660
那么这个机器指令本身就是那个0101

743
00:38:44,660 --> 00:38:48,440
就是就是他CPU内部他他所做的那个编码

744
00:38:48,590 --> 00:38:51,290
你要用这个东西去去编码的话

745
00:38:51,380 --> 00:38:54,020
你要用这个玩意儿去去编程的话

746
00:38:54,080 --> 00:38:57,890
那你就那你估计你你脑袋上那个头发

747
00:38:57,890 --> 00:38:59,060
是一根都不剩

748
00:38:59,060 --> 00:39:00,320
为什么一根都不剩

749
00:39:00,440 --> 00:39:01,940
很容易出错

750
00:39:01,940 --> 00:39:04,100
你0101满满眼都是这个

751
00:39:04,250 --> 00:39:06,290
要么是个圈一

752
00:39:06,290 --> 00:39:07,610
要么是个一

753
00:39:07,610 --> 00:39:08,300
对吧

754
00:39:09,020 --> 00:39:09,620
肯定啊

755
00:39:09,620 --> 00:39:10,790
肯定让人崩溃

756
00:39:11,090 --> 00:39:14,090
那么最早给计算机去编程

757
00:39:14,090 --> 00:39:15,500
最早给计算机编程

758
00:39:15,500 --> 00:39:16,550
他是怎么编程

759
00:39:16,730 --> 00:39:19,700
就是这么一条这么一条纸带

760
00:39:19,700 --> 00:39:20,870
在这个纸袋上干什么

761
00:39:20,870 --> 00:39:23,600
打孔在纸带上打孔

762
00:39:24,050 --> 00:39:26,540
这个打孔的位置就是一

763
00:39:26,540 --> 00:39:28,070
没打孔的位置就是零

764
00:39:28,130 --> 00:39:28,730
然后呢

765
00:39:28,760 --> 00:39:30,080
专门有那么一排

766
00:39:30,080 --> 00:39:33,950
专门有一排那个其他的那个孔是是为了让齿轮

767
00:39:33,950 --> 00:39:34,640
把这个纸

768
00:39:34,670 --> 00:39:36,680
把这个纸袋往机器里去送的

769
00:39:36,800 --> 00:39:40,250
送进去以后用光电设备去照射这些

770
00:39:40,280 --> 00:39:41,150
照射这些位置

771
00:39:41,150 --> 00:39:42,320
固定的位置

772
00:39:42,560 --> 00:39:44,450
能够接收到信号的

773
00:39:44,450 --> 00:39:46,730
那就是一接收不到信号的就是零

774
00:39:46,730 --> 00:39:48,320
就这样通过这种方式

775
00:39:48,320 --> 00:39:50,270
把这个程序给输入到计算机里

776
00:39:50,750 --> 00:39:53,240
当初就就是就就是在这上面打孔

777
00:39:53,450 --> 00:39:55,280
所以说这个非常非常痛苦

778
00:39:56,000 --> 00:39:57,080
不建议

779
00:39:57,080 --> 00:39:58,580
这个不建议让大家去

780
00:39:58,730 --> 00:40:02,900
不建议用这种方式去去那个编程

781
00:40:03,940 --> 00:40:04,660
然后呢

782
00:40:04,660 --> 00:40:06,370
就是那个

783
00:40:06,370 --> 00:40:06,940
然后呢

784
00:40:07,090 --> 00:40:08,950
这种方式很很很麻烦

785
00:40:08,980 --> 00:40:10,630
也也很容易出错

786
00:40:10,690 --> 00:40:11,470
那怎么办

787
00:40:11,530 --> 00:40:12,970
用这个汇编指令

788
00:40:12,970 --> 00:40:14,050
汇编指令是什么呢

789
00:40:14,050 --> 00:40:23,320
汇编指令就是机器指令助记符汇编指令的汇编的这个中文完整的中文叫机器指令助记符

790
00:40:23,650 --> 00:40:28,330
实际上它和机器指令比起来是换汤不换药

791
00:40:28,330 --> 00:40:29,890
怎么叫换汤不换药呢

792
00:40:29,950 --> 00:40:33,220
就是每一个机器指令它都对应着

793
00:40:33,580 --> 00:40:36,760
他都对应着这么一个这么一个单词

794
00:40:37,800 --> 00:40:39,120
一个单词的缩写

795
00:40:39,180 --> 00:40:40,410
比如说你做加法

796
00:40:40,500 --> 00:40:42,660
做加法的指令是什么

797
00:40:43,020 --> 00:40:43,980
ADD对吧

798
00:40:44,070 --> 00:40:45,930
然后你把一个数据

799
00:40:45,930 --> 00:40:48,810
你把一个数据把他一把

800
00:40:48,810 --> 00:40:51,450
把他放到内存当中的某一个位置

801
00:40:51,450 --> 00:40:53,040
用什么指令mov

802
00:40:53,600 --> 00:40:53,810
对吧

803
00:40:53,810 --> 00:40:54,890
这是木对吧

804
00:40:54,920 --> 00:40:55,910
MV啊

805
00:40:56,090 --> 00:40:57,140
还有什么你在

806
00:40:57,230 --> 00:41:00,590
你你要是跳转到某一条某一条指令的位置

807
00:41:00,590 --> 00:41:02,660
你想执行某一条指令呢

808
00:41:02,660 --> 00:41:03,020
对吧

809
00:41:03,080 --> 00:41:06,020
比如说像那个像那个放循环

810
00:41:06,020 --> 00:41:08,570
循环他怎么回到那个放循环那儿去

811
00:41:09,020 --> 00:41:10,190
是GMP

812
00:41:11,000 --> 00:41:13,130
DMP对吧

813
00:41:13,130 --> 00:41:14,480
就是这个玩意儿

814
00:41:14,510 --> 00:41:15,560
就就就这东西

815
00:41:15,710 --> 00:41:16,610
实际上这个东西

816
00:41:16,610 --> 00:41:19,430
和那个机器指令是一一对应的

817
00:41:19,430 --> 00:41:20,570
这些东西一一对应

818
00:41:20,690 --> 00:41:23,600
仍然是按照CPU的思思路

819
00:41:23,600 --> 00:41:27,080
按照CPU的思思思路来做说到这儿呢

820
00:41:27,080 --> 00:41:29,720
给大家介绍一个好玩的游戏

821
00:41:29,720 --> 00:41:31,520
给大家介绍一个好玩的游戏

822
00:41:31,520 --> 00:41:32,900
这个好玩儿的游戏叫什么

823
00:41:33,200 --> 00:41:34,640
叫那个我看一下手机

824
00:41:34,640 --> 00:41:35,480
这这个游戏

825
00:41:35,960 --> 00:41:38,300
这个游戏我当初那个花钱买

826
00:41:39,360 --> 00:41:42,900
这个游戏当初当初花了花了六块钱

827
00:41:42,900 --> 00:41:45,120
好像是我找一下

828
00:41:45,240 --> 00:41:48,480
这个叫那个叫叫啥来着

829
00:41:48,480 --> 00:41:49,440
我打开

830
00:41:49,680 --> 00:41:53,790
我看一下这个实际上这个游戏呢

831
00:41:53,790 --> 00:41:57,690
就是叫程序员升职记这这个游戏

832
00:41:58,140 --> 00:41:59,580
程序员升职记

833
00:42:01,590 --> 00:42:04,410
那个回头我那个截个图

834
00:42:04,440 --> 00:42:07,470
回头我那个截个图发到那个群里

835
00:42:07,710 --> 00:42:09,120
程序员升职记呢

836
00:42:09,120 --> 00:42:12,030
这个这谁用iPhone的同学

837
00:42:12,030 --> 00:42:18,300
去去搜一下就能找到它里边用这个东西去去学算法是是是非常好的

838
00:42:18,510 --> 00:42:21,210
那个程序员升职记用用它来学算法

839
00:42:23,030 --> 00:42:24,320
特别好

840
00:42:24,410 --> 00:42:25,550
你你用那个东西

841
00:42:25,550 --> 00:42:26,990
就是就是让你完成一个任务

842
00:42:27,020 --> 00:42:29,210
然后就用几条那个指令

843
00:42:29,510 --> 00:42:32,660
由内几条指令去去完成那个任务

844
00:42:32,660 --> 00:42:35,630
这你既要顾及到那个空间复杂度

845
00:42:35,630 --> 00:42:39,740
也要顾及到这个时间复杂度时间复杂度就是操作步骤

846
00:42:39,740 --> 00:42:42,260
操操作次数空间复杂度

847
00:42:42,380 --> 00:42:46,970
空间复杂度就是那个你你用的那个质量指令的数量

848
00:42:47,060 --> 00:42:48,200
那个挺好玩儿的

849
00:42:48,230 --> 00:42:50,960
大家大家有时间去去下载下来玩玩呢

850
00:42:51,170 --> 00:42:52,790
实际上这个汇编指令

851
00:42:52,820 --> 00:42:55,820
汇编和机器指令就是一一对应

852
00:42:55,820 --> 00:42:56,930
换汤不换药啊

853
00:42:57,080 --> 00:42:58,640
那么唯一的好处是什么

854
00:42:58,640 --> 00:42:59,660
就是不是零一啦

855
00:43:00,260 --> 00:43:01,610
不是零一了

856
00:43:01,610 --> 00:43:05,840
就就是和就就是那个英文缩写了

857
00:43:05,960 --> 00:43:06,530
但是呢

858
00:43:06,530 --> 00:43:09,650
仍然很难不不是人类的这个思维

859
00:43:10,550 --> 00:43:12,380
那么这个东西那

860
00:43:13,240 --> 00:43:14,380
刚才有同学问

861
00:43:14,380 --> 00:43:15,760
汇编是国产的吗

862
00:43:15,940 --> 00:43:17,470
你别开玩笑

863
00:43:17,470 --> 00:43:18,940
别开玩笑

864
00:43:19,210 --> 00:43:20,440
这个汇编

865
00:43:20,560 --> 00:43:23,050
这个汇编

866
00:43:23,050 --> 00:43:29,230
除非你的CPU是国产的那那个那那个CPU专用的那个语言

867
00:43:29,230 --> 00:43:34,300
那个专用的那个语言那个它它是国产的对吧

868
00:43:34,900 --> 00:43:35,710
别开玩笑

869
00:43:35,920 --> 00:43:37,900
然后这这俩这俩东西

870
00:43:38,140 --> 00:43:39,730
就因为这两种语言

871
00:43:39,760 --> 00:43:40,930
他非常的反人类

872
00:43:41,500 --> 00:43:41,980
所以呢

873
00:43:41,980 --> 00:43:43,330
后边就出现了啥呀

874
00:43:43,420 --> 00:43:45,640
就出现了不那么反人类的语言

875
00:43:45,640 --> 00:43:46,600
就是高级语言

876
00:43:46,900 --> 00:43:49,780
那么这个高级语言它有一个主要特征是什么呢

877
00:43:49,780 --> 00:43:50,620
面向过程

878
00:43:51,350 --> 00:43:52,280
面向过程

879
00:43:52,280 --> 00:43:54,620
这种高级语言的典型代表是什么

880
00:43:54,620 --> 00:43:56,060
就是C语言

881
00:43:56,120 --> 00:43:56,870
就是C语言

882
00:43:56,870 --> 00:43:59,510
还有什么Pascal等等等这些语言

883
00:43:59,630 --> 00:44:02,270
这些语言是相对来说还是比较古老的

884
00:44:02,450 --> 00:44:05,870
另外还有一个非常非常古老的叫什么叫fortune

885
00:44:05,870 --> 00:44:06,650
叫fortune

886
00:44:06,860 --> 00:44:08,540
那个东西现在几乎没人用了

887
00:44:08,570 --> 00:44:10,760
只是非常老的那个系统里边有

888
00:44:11,000 --> 00:44:12,380
比如说银行对吧

889
00:44:12,440 --> 00:44:14,540
内银行那个系统非常非常老

890
00:44:14,600 --> 00:44:20,180
那可能可能比咱们这个年龄也要要要大一倍是吧

891
00:44:20,180 --> 00:44:21,200
那种系统

892
00:44:21,200 --> 00:44:23,720
那种老系统跑的还是fortune

893
00:44:25,240 --> 00:44:26,140
那个非常老了

894
00:44:26,260 --> 00:44:28,150
应该就是上个世纪的

895
00:44:28,150 --> 00:44:29,290
70年代

896
00:44:29,290 --> 00:44:32,020
上个世纪70年代那个时候的这个语言

897
00:44:32,170 --> 00:44:35,770
当当时那个当时咱还没出生呢

898
00:44:35,920 --> 00:44:36,340
对吧

899
00:44:36,460 --> 00:44:37,720
当时还没出生呢

900
00:44:38,830 --> 00:44:41,830
那么这种高级语言它的特性就是面向过程

901
00:44:42,510 --> 00:44:44,550
面向过程那么高级语言

902
00:44:44,730 --> 00:44:46,890
那到从到了高级语言

903
00:44:46,890 --> 00:44:48,480
它是一个跨越

904
00:44:48,630 --> 00:44:53,340
那也就是说这个门槛儿就这个门槛就降低了

905
00:44:53,340 --> 00:44:55,710
们这个这个编程的门槛就降低了

906
00:44:55,710 --> 00:44:58,230
他不是不不要求不是那么高了

907
00:44:58,260 --> 00:45:00,540
但是仍然是是要专业人员对吧

908
00:45:00,570 --> 00:45:03,540
然后最后后来又出现了第四代语言

909
00:45:03,660 --> 00:45:06,000
第四代语言是面向对象语言呢

910
00:45:06,060 --> 00:45:08,460
比典型代表就是C加加

911
00:45:08,460 --> 00:45:10,680
C加加Java

912
00:45:11,160 --> 00:45:15,000
Java还有什么go语言等等这些东西

913
00:45:15,060 --> 00:45:16,800
这这这属于这个第四代语言

914
00:45:16,890 --> 00:45:18,510
实际上这个go语言

915
00:45:18,540 --> 00:45:20,430
他应该属于四代半

916
00:45:20,430 --> 00:45:22,110
Go语言应该算是四代办了

917
00:45:22,170 --> 00:45:24,120
他更他更往前那个走了一步

918
00:45:24,420 --> 00:45:25,980
典型代表是C加加和Java

919
00:45:26,130 --> 00:45:29,280
他是怎么典型的面向对象有同学说

920
00:45:29,280 --> 00:45:29,910
有同学说

921
00:45:29,940 --> 00:45:31,380
那那那JS呢

922
00:45:31,500 --> 00:45:32,820
JS不算

923
00:45:32,820 --> 00:45:33,540
JS不算

924
00:45:33,750 --> 00:45:36,450
JS应该可以算到第五袋里面去了

925
00:45:37,270 --> 00:45:41,200
JS可以算到第五代了JS它是基于对象

926
00:45:41,200 --> 00:45:44,770
他他他不是面向对象另外第五代呢

927
00:45:44,770 --> 00:45:46,480
像那个拍萨拍撒

928
00:45:46,570 --> 00:45:47,800
还有这个JS

929
00:45:47,860 --> 00:45:49,060
可以算是第五代了

930
00:45:49,300 --> 00:45:51,790
那么这种第五代语言它的特性是什么

931
00:45:51,850 --> 00:45:53,140
对普通人友好

932
00:45:53,890 --> 00:45:54,850
普通人友好

933
00:45:55,060 --> 00:45:59,740
那第三代第四代是对专业人专业程序员友好

934
00:45:59,920 --> 00:46:01,360
那JS和Python呢

935
00:46:01,570 --> 00:46:03,850
对对那个普通人就有好了

936
00:46:03,850 --> 00:46:04,870
尤其是Python

937
00:46:04,960 --> 00:46:12,400
由Python就就就跟你用英用英语去纯粹就是在用英语去写代码更加友好

938
00:46:13,030 --> 00:46:14,560
那么这这种语言

939
00:46:14,560 --> 00:46:16,180
他弟弟五第四代语言

940
00:46:16,180 --> 00:46:17,800
第四代语言他就是

941
00:46:18,470 --> 00:46:20,270
它有内置的酷

942
00:46:20,300 --> 00:46:22,940
像这个面向互联网天然支持数据库

943
00:46:23,060 --> 00:46:27,620
它都是依赖他那内置的那个内置的那个语言库

944
00:46:27,620 --> 00:46:28,850
他的那个什么包儿

945
00:46:28,850 --> 00:46:29,180
对吧

946
00:46:29,180 --> 00:46:31,160
咱们JS里边儿那个包儿

947
00:46:31,580 --> 00:46:33,980
他的那个库来来提供的

948
00:46:34,160 --> 00:46:36,410
那么第五代的那个包就更丰富了

949
00:46:36,440 --> 00:46:38,450
而且对普通人更加友好

950
00:46:38,450 --> 00:46:42,290
当然第五代这种这种断代方式呢

951
00:46:42,290 --> 00:46:43,490
在在业内

952
00:46:43,550 --> 00:46:45,530
没有一个严格的说法

953
00:46:45,530 --> 00:46:51,440
有有说有有有的那个有的人用有的资料上说用第五代

954
00:46:51,470 --> 00:46:52,430
但是有的资料呢

955
00:46:52,430 --> 00:46:54,710
把这个JS拍上仍然是算在第二

956
00:46:54,740 --> 00:46:59,240
仍然是算在这个第四代里边的这个这个这个业内呢

957
00:46:59,240 --> 00:47:00,650
还没有完全统一

958
00:47:00,860 --> 00:47:02,810
那么接下来呢

959
00:47:02,810 --> 00:47:04,700
咱们先了解一下这个汇编

960
00:47:05,410 --> 00:47:06,910
先了解一下这个汇编语言

961
00:47:07,180 --> 00:47:10,630
那么这个汇编语言就知知道一下就行了有兴趣的话呢

962
00:47:10,750 --> 00:47:11,680
你有兴趣的话

963
00:47:11,680 --> 00:47:15,940
你可以把这段代码的录入进去录入进去试试

964
00:47:16,300 --> 00:47:19,390
那么这个汇编它是最贴近底层的这个不用多说

965
00:47:19,630 --> 00:47:22,750
那么这个汇编语言它是直接操作硬件

966
00:47:22,750 --> 00:47:25,630
它就是CPU自己的语言CPU的语言

967
00:47:25,810 --> 00:47:27,760
那其他语言呢

968
00:47:27,760 --> 00:47:30,640
其他语言你需要去进行那个编译

969
00:47:31,400 --> 00:47:33,710
尔这个汇编当然也需要编译

970
00:47:33,710 --> 00:47:36,230
但是这个编译就是一个简单的转换

971
00:47:36,230 --> 00:47:37,730
把汇编的这个东西转

972
00:47:37,820 --> 00:47:39,950
把汇编的这个这个英文

973
00:47:39,950 --> 00:47:41,960
直接转成那个机器指令

974
00:47:41,960 --> 00:47:43,760
这直接转成这个二进制

975
00:47:43,760 --> 00:47:45,620
她就是做一步转换就行了

976
00:47:45,920 --> 00:47:47,090
那其他的语言呢

977
00:47:47,150 --> 00:47:48,740
那需要编译

978
00:47:48,740 --> 00:47:50,600
需要需要真正的编译

979
00:47:50,600 --> 00:47:54,290
先把那个先把那个比如说C语言

980
00:47:54,290 --> 00:47:56,960
先把C语言要把它转成那个汇编

981
00:47:56,990 --> 00:48:02,390
然后汇编再再变成那个机器指令这这这那个就复杂了

982
00:48:02,480 --> 00:48:04,250
当然JS就不是这样了

983
00:48:04,340 --> 00:48:06,620
这JS他有自己的那个字节码

984
00:48:07,320 --> 00:48:08,460
他就不是这个套路了

985
00:48:08,550 --> 00:48:10,170
然后这个汇编语言呢

986
00:48:10,170 --> 00:48:12,930
就是纯粹的就是指令和数据

987
00:48:12,930 --> 00:48:13,710
没有语句

988
00:48:13,890 --> 00:48:15,210
它它是没有雨具的

989
00:48:15,330 --> 00:48:16,770
什么是语句

990
00:48:16,800 --> 00:48:21,270
比如说像那个VAR a等于十这是语句

991
00:48:22,040 --> 00:48:22,520
对吧

992
00:48:22,640 --> 00:48:24,050
还有什么fall

993
00:48:24,050 --> 00:48:25,580
然后小括号什么什么什么

994
00:48:25,580 --> 00:48:26,990
这这也叫语句

995
00:48:28,010 --> 00:48:30,380
像像那个汇编里边是没有这种东西的

996
00:48:30,530 --> 00:48:31,640
他很不直观

997
00:48:31,820 --> 00:48:36,020
那就就是等于你手把手的告诉这个CPU

998
00:48:36,020 --> 00:48:41,780
你该怎么去做手把手的告诉CPUCPU里边有有内存

999
00:48:41,780 --> 00:48:42,590
有寄存器

1000
00:48:42,590 --> 00:48:43,880
有有有有啥的

1001
00:48:43,940 --> 00:48:45,440
你就告诉CPU

1002
00:48:45,560 --> 00:48:47,030
首先你抬起左手

1003
00:48:47,030 --> 00:48:51,230
然后张开张开这个手势是是张开的一个手指

1004
00:48:51,410 --> 00:48:52,010
然后呢

1005
00:48:52,010 --> 00:48:53,150
放到杯子旁边儿

1006
00:48:53,180 --> 00:48:53,840
然后呢

1007
00:48:53,840 --> 00:48:55,250
再把这个杯子握住

1008
00:48:55,340 --> 00:48:56,450
然后向上抬

1009
00:48:56,510 --> 00:48:57,950
再向左边儿这边儿移动

1010
00:48:57,980 --> 00:48:59,900
然后稍微倾斜一点儿

1011
00:48:59,900 --> 00:49:00,650
张嘴

1012
00:49:00,740 --> 00:49:02,900
然后把水倒灌到嘴里

1013
00:49:02,900 --> 00:49:06,800
然后你然后你把这个水往肚子里咽

1014
00:49:06,950 --> 00:49:10,460
实际上你让你让计算机去去做这个喝水

1015
00:49:10,460 --> 00:49:11,810
要完成喝水这个动作

1016
00:49:11,810 --> 00:49:12,860
你就得这样

1017
00:49:12,860 --> 00:49:13,880
事无巨细

1018
00:49:13,910 --> 00:49:15,950
每一个动作你都得描述清楚

1019
00:49:16,250 --> 00:49:17,810
如果是高级语言呢

1020
00:49:17,810 --> 00:49:19,760
高级语言就发一个指令

1021
00:49:19,880 --> 00:49:21,080
就就一条语句

1022
00:49:21,200 --> 00:49:21,920
拿起杯子

1023
00:49:22,010 --> 00:49:23,180
然后呢

1024
00:49:23,210 --> 00:49:24,320
喝水呢

1025
00:49:24,320 --> 00:49:26,450
就这这就是语句

1026
00:49:26,570 --> 00:49:27,710
所以说汇编

1027
00:49:27,710 --> 00:49:31,190
汇编是非常非常繁琐的另外还有一点我们要注意

1028
00:49:31,250 --> 00:49:34,160
汇编他受到硬件平台的限制

1029
00:49:34,160 --> 00:49:35,840
也就是说一种CPU

1030
00:49:35,840 --> 00:49:38,600
比如说咱们前面给大家说的这些指令集

1031
00:49:38,660 --> 00:49:39,710
一个指令集

1032
00:49:39,710 --> 00:49:43,220
每种指令集它都有自己的呢

1033
00:49:43,220 --> 00:49:45,950
他都有自己的这个汇编

1034
00:49:46,560 --> 00:49:47,760
那因为这个指令集

1035
00:49:47,760 --> 00:49:49,590
他的这个二进制的指令

1036
00:49:49,590 --> 00:49:50,580
它它是不一样的

1037
00:49:51,710 --> 00:49:54,290
每一种CPU他都得每一种指定机

1038
00:49:54,290 --> 00:49:55,670
它都有自己的这个汇编

1039
00:49:55,760 --> 00:49:59,090
所以他是真专门针它是针对这个特定硬件儿的

1040
00:49:59,210 --> 00:50:04,460
那可一致性是很低的你你8086的这个汇编你是放不到

1041
00:50:04,460 --> 00:50:07,910
你你是很难移植到这个ARMARM上边儿的

1042
00:50:07,910 --> 00:50:10,460
因为你的寄存器它都不一样对吧

1043
00:50:10,550 --> 00:50:12,950
当然大多数指令是是类似的

1044
00:50:13,070 --> 00:50:14,780
大多数指令是是一样的

1045
00:50:14,780 --> 00:50:16,640
但是寄存器的不一样

1046
00:50:17,750 --> 00:50:18,890
那么这种东西

1047
00:50:18,890 --> 00:50:20,210
了解这个会编

1048
00:50:20,210 --> 00:50:25,280
对咱们了解这个理解运算运这个计算机的这个内存

1049
00:50:25,430 --> 00:50:26,630
是非常有好处的

1050
00:50:26,750 --> 00:50:27,800
那怎么有好处呢

1051
00:50:27,890 --> 00:50:28,910
看一下

1052
00:50:28,910 --> 00:50:32,300
看一下这段程序这段程序当初我在打字的时候

1053
00:50:32,300 --> 00:50:33,950
因为有自动补齐

1054
00:50:34,160 --> 00:50:36,860
这多了个一木这个J语法

1055
00:50:36,860 --> 00:50:37,820
这多了个一

1056
00:50:38,630 --> 00:50:39,950
如果说你感兴趣的话

1057
00:50:39,950 --> 00:50:42,380
你可以把这段程序把它复制一下

1058
00:50:42,380 --> 00:50:43,250
保存成文本

1059
00:50:43,280 --> 00:50:43,820
然后呢

1060
00:50:43,910 --> 00:50:45,980
在Linux下编译一下

1061
00:50:46,130 --> 00:50:47,600
编译一下他他干什么

1062
00:50:47,690 --> 00:50:48,530
就是个hello world

1063
00:50:49,390 --> 00:50:52,210
咱们用JS去输出j hello word

1064
00:50:52,210 --> 00:50:53,830
就是抠点lock

1065
00:50:53,830 --> 00:50:54,700
然后hello word

1066
00:50:55,280 --> 00:50:56,900
玩了对吧

1067
00:50:56,990 --> 00:51:01,070
那么这个汇编去去hello world得事无巨细

1068
00:51:01,070 --> 00:51:03,920
咱们咱们逐条给大家讲一下

1069
00:51:04,130 --> 00:51:08,240
逐条给大家讲一下那个这这段代码究竟怎么回事儿

1070
00:51:09,620 --> 00:51:11,270
那么在计算机里边儿

1071
00:51:11,780 --> 00:51:14,540
计算机这个程序前面咱们说了

1072
00:51:14,540 --> 00:51:16,670
咱们再回到前面这个图这儿来

1073
00:51:16,790 --> 00:51:18,020
再再回到这儿来

1074
00:51:18,200 --> 00:51:20,000
这个程序它是分两段的

1075
00:51:20,560 --> 00:51:20,890
对吧

1076
00:51:20,950 --> 00:51:22,210
一段是代码段

1077
00:51:22,210 --> 00:51:23,200
一段是数据段儿

1078
00:51:23,380 --> 00:51:27,730
那么咱们用这个汇编去写去写去写这个代码的时时候呢

1079
00:51:27,820 --> 00:51:29,650
也得给它分成两段

1080
00:51:29,650 --> 00:51:31,090
手动给它分成两段儿

1081
00:51:31,210 --> 00:51:33,730
纯粹的是手动去管理你的内存

1082
00:51:33,940 --> 00:51:35,890
也就是说当你的这个程序

1083
00:51:36,560 --> 00:51:39,470
当你的这个程序放到内存里边儿的时候

1084
00:51:39,560 --> 00:51:42,290
这个程序它是什么样的

1085
00:51:42,290 --> 00:51:44,000
你也得手动去指定

1086
00:51:44,880 --> 00:51:49,320
你就告诉他这这这一块儿是数据段

1087
00:51:49,350 --> 00:51:50,940
这一这这一块儿呢

1088
00:51:50,970 --> 00:51:53,340
是那个是那个代码段

1089
00:51:54,210 --> 00:51:55,710
你得手动给他分段

1090
00:51:56,450 --> 00:52:00,170
飞非常那个非常非常贴近底层了

1091
00:52:00,350 --> 00:52:01,640
那么先看那个数据段

1092
00:52:01,640 --> 00:52:03,140
数据段里面放的是什么呢

1093
00:52:03,290 --> 00:52:04,640
放的是一个字符串

1094
00:52:05,630 --> 00:52:07,280
在数据段里面放的字符串

1095
00:52:07,280 --> 00:52:08,390
放的什么字符串

1096
00:52:08,480 --> 00:52:09,110
Hello word

1097
00:52:09,440 --> 00:52:11,330
咱们console log点儿

1098
00:52:11,330 --> 00:52:14,060
扣点log点儿

1099
00:52:14,060 --> 00:52:14,780
acouncil.log啊

1100
00:52:14,810 --> 00:52:15,530
抠点log

1101
00:52:15,530 --> 00:52:16,130
然后呢

1102
00:52:16,190 --> 00:52:17,030
Hello word啊

1103
00:52:17,030 --> 00:52:20,390
那个hello word实际上你要放到里边儿去

1104
00:52:20,420 --> 00:52:21,710
在计算机里边儿

1105
00:52:21,800 --> 00:52:24,410
在这个计算机里边这个字符串

1106
00:52:24,440 --> 00:52:27,980
只要这个字符串儿你在代码当中给他指定了

1107
00:52:28,130 --> 00:52:29,540
实际上在内存里边儿

1108
00:52:29,990 --> 00:52:31,550
当那个程序它在启动的时候

1109
00:52:31,550 --> 00:52:32,660
在内存里面它就有

1110
00:52:33,300 --> 00:52:34,980
那它是一个静态的

1111
00:52:35,370 --> 00:52:36,870
那他是个静态的数据

1112
00:52:37,320 --> 00:52:38,460
只要程序一启动

1113
00:52:38,490 --> 00:52:40,380
内存里面就有这个字符串了

1114
00:52:40,380 --> 00:52:41,910
只要你指定了它呢

1115
00:52:42,180 --> 00:52:45,030
那么在这个地方我们要指定

1116
00:52:45,030 --> 00:52:46,800
这个hello冒号是什么呢

1117
00:52:47,300 --> 00:52:48,710
这是伪指令

1118
00:52:48,710 --> 00:52:52,100
像这个section.data这也是伪指令

1119
00:52:52,100 --> 00:52:53,480
伪指令哪个伟

1120
00:52:53,510 --> 00:52:54,590
不是尾巴的尾

1121
00:52:54,620 --> 00:52:55,820
是这个伟

1122
00:52:55,820 --> 00:52:56,780
真伪的为

1123
00:52:56,780 --> 00:52:57,530
这叫伪指令

1124
00:52:57,740 --> 00:52:59,510
这个伪指令干什么用

1125
00:52:59,570 --> 00:53:02,060
告诉汇编的编译器

1126
00:53:02,060 --> 00:53:04,670
你要做一个这告诉汇编的编译器

1127
00:53:06,350 --> 00:53:07,910
恶来标注

1128
00:53:07,910 --> 00:53:09,500
标注这个行号儿

1129
00:53:09,500 --> 00:53:11,930
或者说标注这个代码结构

1130
00:53:11,930 --> 00:53:14,150
它不是它不是真正的这个汇编

1131
00:53:14,150 --> 00:53:15,410
他不是真正的汇编指令

1132
00:53:15,830 --> 00:53:18,830
那么这些东西section.data

1133
00:53:18,950 --> 00:53:19,790
这是干什么

1134
00:53:19,820 --> 00:53:23,300
这是一个这是一个内存区域的一个标标记

1135
00:53:24,070 --> 00:53:27,160
数据段内存区域起始位置是data

1136
00:53:27,370 --> 00:53:29,620
这个点儿data对应的是一个地址

1137
00:53:29,860 --> 00:53:30,610
然后呢

1138
00:53:30,640 --> 00:53:35,740
A section点儿taxi text a这又是一个

1139
00:53:35,740 --> 00:53:41,470
这又是内内存区域里面一个一个区域这个区这个区域是在干什么

1140
00:53:41,530 --> 00:53:44,830
是是那个变量是这个这个变量

1141
00:53:45,430 --> 00:53:47,170
是这个字符串这个变量

1142
00:53:47,900 --> 00:53:50,330
用用一个什么样的

1143
00:53:50,330 --> 00:53:56,600
用一个内存空间来保存这个字符串的那个那个那个那个不不是

1144
00:53:57,200 --> 00:54:03,410
这是那个这这这这这个变量这个变量就是告诉告诉CPU

1145
00:54:03,500 --> 00:54:06,080
这个程序第一条指令在什么地方

1146
00:54:07,820 --> 00:54:10,190
那么这个global girls chart

1147
00:54:11,100 --> 00:54:11,910
是什么意思

1148
00:54:12,600 --> 00:54:15,870
下划线starch他就是这个

1149
00:54:16,560 --> 00:54:18,900
代码起始的这个位置

1150
00:54:18,900 --> 00:54:20,280
他也是个地址

1151
00:54:20,280 --> 00:54:21,780
也是个内存地址

1152
00:54:21,960 --> 00:54:23,760
那么CPU在执行的时候

1153
00:54:23,760 --> 00:54:26,880
就从starch来对应的这个内存地址开始执行

1154
00:54:28,380 --> 00:54:29,250
这是分段

1155
00:54:29,250 --> 00:54:31,710
后边儿这个这个东西就是来这这一块儿

1156
00:54:31,890 --> 00:54:33,300
他就是那个代码段

1157
00:54:34,260 --> 00:54:35,130
这一块儿

1158
00:54:35,130 --> 00:54:39,270
这一块儿是那个数据段其他的其他的这这些玩意儿

1159
00:54:39,270 --> 00:54:40,050
这这些玩意儿

1160
00:54:40,660 --> 00:54:41,560
都是那个为指令

1161
00:54:41,740 --> 00:54:44,230
然后这个hellohello是什么

1162
00:54:44,230 --> 00:54:44,980
是一个地址

1163
00:54:45,870 --> 00:54:48,960
这这是一个地址用实际上它是一个标签

1164
00:54:48,960 --> 00:54:51,030
这个标签就对应了一一个地址

1165
00:54:51,150 --> 00:54:52,440
还有hello re

1166
00:54:52,440 --> 00:54:55,410
这也是一个地址也是一个地址

1167
00:54:55,590 --> 00:55:00,120
这个只带标签的这么一个地址后边儿呢

1168
00:55:00,180 --> 00:55:01,470
Hello word

1169
00:55:01,470 --> 00:55:04,530
这是这是要把它放到内存里面的东西

1170
00:55:04,530 --> 00:55:06,300
这是放到内存里面字符串

1171
00:55:06,330 --> 00:55:08,190
然后这个东西呢

1172
00:55:08,310 --> 00:55:09,150
这个东西呢

1173
00:55:09,360 --> 00:55:11,730
这个东西是字符串的长度

1174
00:55:12,630 --> 00:55:13,470
字符串的长度

1175
00:55:13,770 --> 00:55:17,760
因为计算机不知道你这个字符串到底有多长

1176
00:55:17,760 --> 00:55:22,200
所以说你得你得把这个字符串长度得放到内存里边儿要你要

1177
00:55:22,230 --> 00:55:23,100
要不然呢

1178
00:55:23,430 --> 00:55:25,350
这你再拿这个字符串的时候

1179
00:55:25,350 --> 00:55:27,360
究竟拿多少个字节不知道

1180
00:55:28,060 --> 00:55:29,770
CPU不知道你得告诉他

1181
00:55:29,770 --> 00:55:32,710
这就拿就就就拿这么几个字节

1182
00:55:33,450 --> 00:55:34,140
告诉CPU

1183
00:55:34,260 --> 00:55:36,420
你不告诉CPUCPU不知道

1184
00:55:36,420 --> 00:55:38,250
不知道究竟拿几个

1185
00:55:38,430 --> 00:55:41,160
拿十个不够对吧

1186
00:55:41,550 --> 00:55:46,860
拿50个超了他就不是这个字符串了所所所以说

1187
00:55:47,010 --> 00:55:50,400
必须得详细地去描述这个去描述这个

1188
00:55:51,300 --> 00:55:54,090
这个数据是什么样的然后后边儿

1189
00:55:54,150 --> 00:55:56,040
程序执行的时候从这儿执行

1190
00:55:56,430 --> 00:55:58,110
那么他在干什么呢

1191
00:55:58,170 --> 00:56:00,660
先看哈这段代码

1192
00:56:00,660 --> 00:56:05,190
这段代码先看MVMVX4

1193
00:56:05,190 --> 00:56:05,970
这是什么意思呢

1194
00:56:06,120 --> 00:56:10,830
就是把四这个把四这个数放到AX寄存器里

1195
00:56:11,590 --> 00:56:13,570
那么这个四代表什么呢

1196
00:56:13,660 --> 00:56:16,540
四代表操作系统的一个API

1197
00:56:17,360 --> 00:56:18,410
也就是系统调用

1198
00:56:19,530 --> 00:56:22,200
四代表的是操作系统的一个API

1199
00:56:22,230 --> 00:56:24,180
实际上咱们什么也没写

1200
00:56:24,420 --> 00:56:25,530
调用的是什么

1201
00:56:25,590 --> 00:56:27,300
调用用汇编

1202
00:56:27,300 --> 00:56:30,390
咱们调用操作系统的那个console log

1203
00:56:31,670 --> 00:56:33,380
调用操作系统的console log

1204
00:56:33,500 --> 00:56:36,020
咱们看那得用多少条儿

1205
00:56:39,110 --> 00:56:42,290
你的那个操作系统的那个API

1206
00:56:42,290 --> 00:56:43,640
也就是系统调用

1207
00:56:43,700 --> 00:56:44,930
它究竟是哪个

1208
00:56:44,930 --> 00:56:46,130
他是以编号为

1209
00:56:47,360 --> 00:56:49,790
用编号来区分的四号对吧

1210
00:56:49,790 --> 00:56:51,170
四号API

1211
00:56:51,410 --> 00:56:52,760
先把它放到寄存器里

1212
00:56:52,940 --> 00:56:54,110
然后来

1213
00:56:54,530 --> 00:56:55,580
然后又一个

1214
00:56:55,580 --> 00:56:57,410
又一个MV

1215
00:56:57,410 --> 00:56:59,600
把一放到1BX啊

1216
00:56:59,600 --> 00:57:00,740
这是另外一个寄存器

1217
00:57:00,950 --> 00:57:02,120
这个一是什么呢

1218
00:57:02,210 --> 00:57:02,900
依旧是

1219
00:57:03,690 --> 00:57:04,620
文件描述符

1220
00:57:05,740 --> 00:57:09,070
那么计算机里边儿几个基本的描述符是什么呢

1221
00:57:09,130 --> 00:57:10,330
01234

1222
00:57:11,140 --> 00:57:12,850
他们分别代代表什么呢

1223
00:57:12,880 --> 00:57:14,590
标准输入标准输出

1224
00:57:14,590 --> 00:57:21,610
标准错误等等等等这些东西这代表这些标准输入是是那个键盘

1225
00:57:21,610 --> 00:57:24,280
标准输出就是显示器

1226
00:57:24,310 --> 00:57:29,260
标准错误就是那个就是那个错误处理用的你看

1227
00:57:30,060 --> 00:57:31,860
那么标准输出他输出到哪儿

1228
00:57:31,860 --> 00:57:35,250
就是输出到显示器里告诉告诉这个头

1229
00:57:35,250 --> 00:57:37,560
这这个API你吧

1230
00:57:37,560 --> 00:57:39,960
我我要往这个显示器去输出

1231
00:57:40,110 --> 00:57:40,950
要输出东西

1232
00:57:41,130 --> 00:57:42,300
那输出什么东西呢

1233
00:57:42,360 --> 00:57:43,380
那再往后看

1234
00:57:43,500 --> 00:57:47,160
又是一个MOVMOV把hello

1235
00:57:47,160 --> 00:57:50,340
放到e c X Li hello是个什么东西在这儿

1236
00:57:50,720 --> 00:57:51,080
对吧

1237
00:57:51,140 --> 00:57:51,440
Hello

1238
00:57:51,440 --> 00:57:52,250
他是个标签儿

1239
00:57:52,370 --> 00:57:54,230
这个标签儿它对应的是个地址

1240
00:57:54,260 --> 00:57:56,420
也就是说把这个字符串的地址

1241
00:57:56,540 --> 00:57:59,450
把字符串的首地址放到XX里

1242
00:57:59,840 --> 00:58:00,470
然后呢

1243
00:58:00,470 --> 00:58:01,880
又一个MV

1244
00:58:01,910 --> 00:58:03,020
放到了

1245
00:58:03,050 --> 00:58:04,370
放到了又一个

1246
00:58:04,400 --> 00:58:05,720
放到了又一个寄存器里

1247
00:58:07,100 --> 00:58:08,960
是总共用了四个寄存器

1248
00:58:08,960 --> 00:58:10,700
这个第四个寄存器放到什么

1249
00:58:10,700 --> 00:58:12,860
字符串的长度告诉这个操作

1250
00:58:13,040 --> 00:58:15,320
告诉这个操作系统的这个API

1251
00:58:15,500 --> 00:58:16,700
这你呢

1252
00:58:16,700 --> 00:58:18,800
我要把这个字符串

1253
00:58:18,800 --> 00:58:24,440
在这个位置上的字符串要输出这个字符串多长输出到这个显示器上

1254
00:58:25,220 --> 00:58:30,650
相当于这个操作系统的这个这个系统调用的这个三个参数呢

1255
00:58:30,800 --> 00:58:31,970
这是这是准备

1256
00:58:32,540 --> 00:58:34,730
那这是准备然后干什么呢

1257
00:58:34,760 --> 00:58:37,340
然后告诉操作系统

1258
00:58:37,400 --> 00:58:38,750
你去调用

1259
00:58:38,750 --> 00:58:41,540
调用告诉操作系统你去吊用

1260
00:58:41,540 --> 00:58:43,130
他怎么调用去

1261
00:58:43,700 --> 00:58:45,320
去调用这个软中断

1262
00:58:47,520 --> 00:58:49,350
他不是整形的意思

1263
00:58:49,410 --> 00:58:52,770
在汇编里边这个ENT它不是整形的意思

1264
00:58:52,770 --> 00:58:53,670
在C语言里边儿

1265
00:58:53,880 --> 00:58:54,930
Inch是Intel

1266
00:58:55,080 --> 00:58:55,500
对吧

1267
00:58:55,530 --> 00:58:57,990
它是整数类型那么在汇编里边

1268
00:58:57,990 --> 00:59:01,590
这个这个N它是软中断

1269
00:59:01,590 --> 00:59:03,540
它实际上就是干什么在干什么

1270
00:59:03,570 --> 00:59:04,650
告诉操作系统呢

1271
00:59:04,650 --> 00:59:06,120
我这儿准备好了

1272
00:59:06,210 --> 00:59:07,830
然后你调一个函数

1273
00:59:07,830 --> 00:59:09,030
我按你的要求

1274
00:59:09,030 --> 00:59:11,100
按你的规格把这些

1275
00:59:11,280 --> 00:59:12,600
把这个数据都填进去了

1276
00:59:12,600 --> 00:59:15,060
然后你就你你就执行函数吧

1277
00:59:15,060 --> 00:59:18,060
就是告诉操作系统这个这个ins是什么恶

1278
00:59:18,150 --> 00:59:19,710
他对应的单词是什么呢

1279
00:59:19,830 --> 00:59:20,850
是interrupt

1280
00:59:21,350 --> 00:59:23,060
Interrupt就是中断

1281
00:59:23,970 --> 00:59:25,260
就是中断的意思

1282
00:59:25,350 --> 00:59:28,110
这个中断分软中断和和那个硬中断

1283
00:59:28,200 --> 00:59:30,120
这个感兴趣你可以百度一下

1284
00:59:30,120 --> 00:59:32,220
咱在这儿步步深入去解释了

1285
00:59:32,280 --> 00:59:36,270
实际上就是两种调用方式

1286
00:59:36,270 --> 00:59:37,920
这是这是在干什么

1287
00:59:37,950 --> 00:59:39,810
这是hello word啊

1288
00:59:39,810 --> 00:59:44,220
这是hellowordcouncil.log然后hello word写了这么多行

1289
00:59:45,020 --> 00:59:46,190
然后干什么呢

1290
00:59:46,250 --> 00:59:48,560
后边儿还有又掉了一个函数

1291
00:59:48,680 --> 00:59:49,730
这个函数是什么

1292
00:59:49,790 --> 00:59:51,560
这个函数是退出

1293
00:59:51,590 --> 00:59:53,600
退出程序就是告诉操作系统

1294
00:59:53,600 --> 00:59:54,680
我这个程序结束了

1295
00:59:54,800 --> 00:59:58,880
你可以把资源回收掉回收什么资源包括

1296
00:59:59,360 --> 01:00:00,290
这个数据

1297
01:00:00,290 --> 01:00:05,030
包括这个他他自己本他自己这个指令本身呢

1298
01:00:05,120 --> 01:00:06,440
告诉操作系统我结束了

1299
01:00:06,590 --> 01:00:11,210
你内存里边不要不要再保存我的数据你你回收吧

1300
01:00:11,210 --> 01:00:16,130
这这就是这三个那么这个是是在调什么

1301
01:00:16,220 --> 01:00:20,510
调CCS exit这个系统调用这这就是一个函数

1302
01:00:20,600 --> 01:00:21,290
然后呢

1303
01:00:21,320 --> 01:00:22,100
这个是返回值

1304
01:00:22,130 --> 01:00:23,840
这个返回值返回给谁

1305
01:00:23,900 --> 01:00:25,250
返回给操作系统

1306
01:00:25,250 --> 01:00:26,420
就是说我这儿正常结束

1307
01:00:26,740 --> 01:00:29,230
然后在INTERRUPT80H

1308
01:00:30,360 --> 01:00:31,440
又interact巴黎

1309
01:00:31,440 --> 01:00:33,270
又是又是告诉操作系统

1310
01:00:33,270 --> 01:00:34,710
你你去调用

1311
01:00:34,740 --> 01:00:36,360
然后这个hello word

1312
01:00:36,940 --> 01:00:38,380
这么长这么麻烦

1313
01:00:38,380 --> 01:00:42,280
每一步都很每一步都很都很繁琐

1314
01:00:42,670 --> 01:00:46,240
而且他还而且这段这段代码

1315
01:00:46,390 --> 01:00:49,720
而且这段代码就是调了操作系统的两个函数

1316
01:00:51,300 --> 01:00:54,960
还没有说你这个字符串我怎么从内存里去取

1317
01:00:54,990 --> 01:00:55,440
对吧

1318
01:00:55,560 --> 01:00:57,660
我我然后我这个字符串我怎么处理

1319
01:00:57,660 --> 01:01:03,270
然后怎么一个一个的输出到这个这个显示器上还没有涉及到这些东西呢

1320
01:01:04,050 --> 01:01:05,340
你你就可以看到

1321
01:01:05,340 --> 01:01:06,480
汇编是多么繁琐

1322
01:01:07,110 --> 01:01:09,780
实际上咱们写的那些程序

1323
01:01:09,930 --> 01:01:11,610
不管你是用什么语言写的

1324
01:01:11,730 --> 01:01:12,960
在CPU里边儿

1325
01:01:13,020 --> 01:01:15,210
他都是按照这种套路去做的

1326
01:01:15,480 --> 01:01:17,820
只不过咱们的那些语言呢

1327
01:01:18,120 --> 01:01:22,050
更加贴合咱们这个更加人性化

1328
01:01:24,390 --> 01:01:26,760
所以咱们那个更加人性化

1329
01:01:26,760 --> 01:01:28,230
咱们还掉头发是吧

1330
01:01:28,230 --> 01:01:30,540
您让咱们这样去写呢

1331
01:01:30,720 --> 01:01:33,000
那真的是一根头发都没了呢

1332
01:01:33,000 --> 01:01:34,560
肯定那个脑袋是锃光瓦亮

1333
01:01:34,770 --> 01:01:37,890
如果说你要想想想执行一下

1334
01:01:37,890 --> 01:01:39,480
想执行一下这个

1335
01:01:39,480 --> 01:01:42,840
你你把我这个抄错的这个单词把它把它改掉

1336
01:01:43,400 --> 01:01:44,060
把它改掉

1337
01:01:44,960 --> 01:01:45,950
然后干什么呢

1338
01:01:46,010 --> 01:01:50,330
在Linux下去去安装这个NSNSM啊

1339
01:01:50,330 --> 01:01:50,960
然后呢

1340
01:01:51,110 --> 01:01:52,370
用用这个

1341
01:01:52,670 --> 01:01:55,370
用这条命令去去编译然后呢

1342
01:01:55,400 --> 01:01:56,570
这个是连接

1343
01:01:56,600 --> 01:01:57,950
这是编译过程

1344
01:01:58,010 --> 01:01:59,060
连接过程

1345
01:01:59,210 --> 01:01:59,990
然后呢

1346
01:02:00,020 --> 01:02:01,400
输出的这个程序

1347
01:02:01,430 --> 01:02:03,380
输出的这个程序名就是a

1348
01:02:03,380 --> 01:02:04,970
你可以去改这个名字

1349
01:02:05,030 --> 01:02:07,250
然后然后干什么呢

1350
01:02:08,900 --> 01:02:09,950
然后执行

1351
01:02:09,950 --> 01:02:13,370
就就就这么一行忙活了半天对吧

1352
01:02:13,370 --> 01:02:14,060
忙活了半天

1353
01:02:14,060 --> 01:02:15,230
就就这么个

1354
01:02:15,320 --> 01:02:16,340
这么就这么个玩意儿

1355
01:02:16,430 --> 01:02:17,990
现在当然有汇编了

1356
01:02:17,990 --> 01:02:19,370
当然有汇编工程师了

1357
01:02:19,640 --> 01:02:21,980
只不过这种工程师很少了

1358
01:02:22,190 --> 01:02:28,130
现在很少在在那个整体的这个在整体的这个比例当中占比很少

1359
01:02:28,160 --> 01:02:29,390
但是那个数量

1360
01:02:29,630 --> 01:02:34,100
但是这个绝对数量比以前会多一些

1361
01:02:34,130 --> 01:02:36,050
比很久以前会多一些

1362
01:02:36,200 --> 01:02:38,660
因为这个活儿多了吗

1363
01:02:39,240 --> 01:02:39,900
活儿多了

1364
01:02:39,900 --> 01:02:41,550
但是整从整体上看

1365
01:02:41,550 --> 01:02:43,170
这个这个比例是很小很小的

1366
01:02:43,560 --> 01:02:47,070
应该是1万个里边也找不到一个估计

1367
01:02:51,600 --> 01:02:53,550
也算是比较高吧

1368
01:02:53,550 --> 01:02:55,770
会汇编工程师也算是比较高

1369
01:02:56,970 --> 01:02:59,970
但是但是你不好跳槽

1370
01:02:59,970 --> 01:03:01,860
反正就是那么几个公司

1371
01:03:01,860 --> 01:03:02,670
就是那么几个公司

1372
01:03:02,670 --> 01:03:04,080
你跳来跳去

1373
01:03:04,170 --> 01:03:05,760
你没地方跳

1374
01:03:06,610 --> 01:03:07,840
你要真想那个

1375
01:03:08,020 --> 01:03:08,860
你要真想跳

1376
01:03:08,860 --> 01:03:10,600
你你跳那个什么地方

1377
01:03:10,600 --> 01:03:14,440
你你去跳那个硬件厂商

1378
01:03:14,440 --> 01:03:15,700
比如说啊

1379
01:03:15,700 --> 01:03:20,440
比如说那个恶英伟达哈

1380
01:03:20,470 --> 01:03:21,520
英特尔

1381
01:03:21,670 --> 01:03:22,330
AMD

1382
01:03:23,260 --> 01:03:26,020
还有一些那个做那个底层设备的

1383
01:03:26,570 --> 01:03:29,180
你你你就这么几个选择

1384
01:03:29,300 --> 01:03:30,530
你就就这么几个选择

1385
01:03:30,560 --> 01:03:34,010
而且这这这些公司互相还是竞争关系

1386
01:03:34,340 --> 01:03:35,210
你还不好跳

1387
01:03:35,390 --> 01:03:35,840
对吧

1388
01:03:36,110 --> 01:03:38,030
你想从华为跳四颗

1389
01:03:38,030 --> 01:03:40,970
或者说或者说思科跳华为还真不好跳

1390
01:03:41,650 --> 01:03:42,100
不好跳

1391
01:03:42,100 --> 01:03:43,090
这真的不好跳

1392
01:03:43,090 --> 01:03:43,930
这是过去

1393
01:03:43,990 --> 01:03:44,770
过过去

1394
01:03:44,770 --> 01:03:50,020
这个过去这个圈子里边儿都这个圈里的人都知道你你你原来思科的

1395
01:03:50,020 --> 01:03:50,830
你想去华为

1396
01:03:51,280 --> 01:03:52,930
人人不要

1397
01:03:52,930 --> 01:03:54,430
人怕你是间谍

1398
01:03:54,790 --> 01:03:57,670
还有华为的想去思科人也不要

1399
01:04:00,010 --> 01:04:00,190
好

1400
01:04:00,190 --> 01:04:01,150
咱们不说这个了

1401
01:04:01,180 --> 01:04:02,560
刚才有同学就问

1402
01:04:02,560 --> 01:04:04,360
问那个图灵机

1403
01:04:04,390 --> 01:04:05,950
问那个图零机是怎么回事儿

1404
01:04:06,040 --> 01:04:07,660
那个图零机

1405
01:04:09,740 --> 01:04:11,030
那个图零机

1406
01:04:11,390 --> 01:04:13,610
他不是会编

1407
01:04:13,610 --> 01:04:15,890
它是一种计算机模型

1408
01:04:15,890 --> 01:04:17,630
模型什么样的模型

1409
01:04:17,630 --> 01:04:20,420
就是当初图灵在设计

1410
01:04:20,420 --> 01:04:22,820
他当初图灵他在思考

1411
01:04:23,180 --> 01:04:25,880
他在考虑这个计算机能不能

1412
01:04:26,270 --> 01:04:31,100
能不能人类能不能造出一种能够思考的机器

1413
01:04:31,100 --> 01:04:34,550
他在他在想这个问题的时候提出的这个概念

1414
01:04:34,550 --> 01:04:35,960
提出的图灵机这个概念

1415
01:04:36,290 --> 01:04:38,090
那么图灵机是什么样的

1416
01:04:38,120 --> 01:04:39,170
图灵机很简单

1417
01:04:39,840 --> 01:04:40,590
很简单

1418
01:04:40,770 --> 01:04:41,790
单是什么

1419
01:04:42,030 --> 01:04:43,920
他就是个这东西

1420
01:04:44,520 --> 01:04:45,510
就是一个

1421
01:04:46,080 --> 01:04:46,950
就是一个

1422
01:04:47,920 --> 01:04:51,460
非常非常长的这么一个存储器

1423
01:04:53,330 --> 01:04:55,160
一个纸条简单一点

1424
01:04:55,160 --> 01:04:57,440
这个纸条纸条上干什么

1425
01:04:57,500 --> 01:04:59,540
写满了写满了指令

1426
01:05:00,100 --> 01:05:01,090
那写满了指令

1427
01:05:01,150 --> 01:05:05,770
然后还有一个东西是专门儿在纸条上读指令的

1428
01:05:06,710 --> 01:05:08,480
这这么一个小部件儿

1429
01:05:08,780 --> 01:05:11,150
然后这个读这个指令

1430
01:05:11,180 --> 01:05:17,600
根据这个指令去做一个操作这个指令比如说你跳到什么地方去

1431
01:05:17,660 --> 01:05:19,610
然后再再去读这个指令

1432
01:05:19,610 --> 01:05:21,800
然后再跳到什么地方去

1433
01:05:21,800 --> 01:05:23,090
在在干什么

1434
01:05:23,210 --> 01:05:27,590
当然背后封装的就是那个封装的就是那个CPU里边的东西

1435
01:05:28,940 --> 01:05:33,800
就是那个前面给大家讲nei nei nei nei3个模块那么这个纸条呢

1436
01:05:33,800 --> 01:05:34,790
实际上就是内存

1437
01:05:35,600 --> 01:05:37,820
是这个图零机就是

1438
01:05:38,400 --> 01:05:42,420
描述的是CPU和内存他们之间的这个工作

1439
01:05:42,420 --> 01:05:44,430
他这个工作工作原理

1440
01:05:44,760 --> 01:05:47,760
那么这个图灵机面临的一个问题是什么呢

1441
01:05:48,340 --> 01:05:49,300
停机问题

1442
01:05:50,150 --> 01:05:51,350
什么叫停机问题

1443
01:05:51,620 --> 01:05:53,990
就是它执行了若干步以后

1444
01:05:54,080 --> 01:05:55,760
要么就停止执行了

1445
01:05:55,790 --> 01:05:58,460
要么就舍陷入到一个死循环里

1446
01:05:58,460 --> 01:06:00,590
这叫图灵机的停机问题

1447
01:06:00,800 --> 01:06:03,620
实际上这个问题要讲起来

1448
01:06:03,680 --> 01:06:06,020
这个问题要要要要说起来

1449
01:06:06,020 --> 01:06:07,940
它涉及到哲学层面上的东西了

1450
01:06:09,300 --> 01:06:11,670
这就涉及到这个封闭系统

1451
01:06:11,670 --> 01:06:14,340
或者还有这个开放系统等等这些东西

1452
01:06:16,900 --> 01:06:20,980
比如说还有涉及到这个这个熵增问题

1453
01:06:20,980 --> 01:06:22,630
涉及到好多东西了

1454
01:06:22,690 --> 01:06:27,820
有兴趣有兴趣的同学可以去看一看这看一看这方这方面的资料

1455
01:06:29,410 --> 01:06:29,890
好

1456
01:06:29,890 --> 01:06:33,550
然后前面咱们给大家讲的就是那个CPU

1457
01:06:33,550 --> 01:06:35,770
还有这个汇编

1458
01:06:35,770 --> 01:06:37,150
实际上就是最底层的东西

1459
01:06:37,180 --> 01:06:38,230
然后后边儿呢

1460
01:06:38,230 --> 01:06:40,900
就是这个C语言了C语言这一块儿呢

1461
01:06:40,960 --> 01:06:43,000
咱们着重给大家讲这个指针

1462
01:06:43,700 --> 01:06:45,230
着重讲指针

1463
01:06:45,260 --> 01:06:47,930
然后告诉大家怎么去学这个

1464
01:06:47,930 --> 01:06:49,610
怎么去学这个C语言

1465
01:06:49,640 --> 01:06:51,380
只要学这个C语言的话呢

1466
01:06:51,380 --> 01:06:52,310
也不难

1467
01:06:52,310 --> 01:06:58,940
难的就是在那个内存内存操作这一块儿好然后咱们那个先先休息五分钟

1468
01:06:58,940 --> 01:06:59,990
休息五分钟以后呢

1469
01:06:59,990 --> 01:07:02,870
就是这个C语言的1C语言的一部分

1470
01:08:24,670 --> 01:08:24,880
What

1471
01:09:21,610 --> 01:09:22,750
我的国

1472
01:09:22,930 --> 01:09:23,710
国国

1473
01:09:55,510 --> 01:09:55,720
What

1474
01:09:58,050 --> 01:09:59,190
我我我

1475
01:11:52,150 --> 01:11:57,790
Miss me like I was made for you stand in your in your

1476
01:11:59,500 --> 01:12:09,400
eyes get for me because of an I was just mi you cannot escape from me that when I was just mi hello

1477
01:12:10,540 --> 01:12:18,430
hello

1478
01:12:47,090 --> 01:12:53,180
Once the size of its next thing anymore dream

1479
01:12:56,870 --> 01:12:58,280
I started

1480
01:13:01,130 --> 01:13:02,240
reading

1481
01:13:07,700 --> 01:13:08,990
that always b

1482
01:13:23,600 --> 01:13:23,840
好

1483
01:13:23,840 --> 01:13:24,680
咱们继续

1484
01:13:24,830 --> 01:13:26,090
大家都回来了吗

1485
01:13:52,220 --> 01:13:52,430
好

1486
01:13:52,430 --> 01:13:53,510
咱们接着来

1487
01:13:55,830 --> 01:13:56,580
滑板鞋

1488
01:13:56,580 --> 01:13:57,630
你别滑板鞋

1489
01:13:57,630 --> 01:13:58,320
滑板鞋呢

1490
01:13:58,320 --> 01:13:59,430
属于精神污染

1491
01:14:00,400 --> 01:14:01,120
熵增

1492
01:14:01,150 --> 01:14:05,350
你这个这个熵增是那个啥

1493
01:14:05,350 --> 01:14:06,190
化学里也有

1494
01:14:06,190 --> 01:14:07,570
物理学里也有

1495
01:14:08,080 --> 01:14:11,320
可以说那个化学是浅层的物理学

1496
01:14:12,160 --> 01:14:15,610
物理学那个物理学那个是深层的化学

1497
01:14:15,610 --> 01:14:16,480
哈哈

1498
01:14:19,820 --> 01:14:20,390
浙商

1499
01:14:20,420 --> 01:14:21,710
这个商指的是什么

1500
01:14:21,710 --> 01:14:23,330
伤指的是混乱程度

1501
01:14:24,080 --> 01:14:25,610
在一个封闭系统里边儿

1502
01:14:25,820 --> 01:14:29,690
这个混乱程度总是趋近于混乱的

1503
01:14:29,720 --> 01:14:32,510
这个混乱程度总是那个趋近于最高

1504
01:14:32,870 --> 01:14:33,950
这是在胡说八道

1505
01:14:33,950 --> 01:14:35,450
物理的尽头是宗教

1506
01:14:35,450 --> 01:14:36,440
这是胡说八道

1507
01:14:40,260 --> 01:14:41,850
只不过是那个啥

1508
01:14:41,850 --> 01:14:44,010
只只不过为什么有这句话

1509
01:14:44,010 --> 01:14:49,800
只不过是因为因为这个当前的这个技术水平还还理解不了

1510
01:14:49,800 --> 01:14:51,300
还理解不了

1511
01:14:51,300 --> 01:14:53,430
所以他就认为是是宗教了

1512
01:14:53,700 --> 01:14:55,080
为理解不了了

1513
01:14:55,080 --> 01:14:56,760
所以说就是上帝阿

1514
01:14:56,760 --> 01:15:00,990
上帝设计的对吧

1515
01:15:00,990 --> 01:15:02,130
所以就出这个

1516
01:15:02,400 --> 01:15:05,130
然后现在人就把这句话开始滥用

1517
01:15:05,130 --> 01:15:07,380
说什么说什么引力波儿

1518
01:15:07,380 --> 01:15:16,980
人人家那个佛教里边很久很早之前就就就就说过这个引力波怎么怎么地了这纯粹就是那个牵强牵强附会

1519
01:15:16,980 --> 01:15:19,350
这纯粹是扯纯粹就是扯淡

1520
01:15:19,830 --> 01:15:23,400
在封闭系统里边儿伤伤伤增不可逆

1521
01:15:24,040 --> 01:15:24,490
咳

1522
01:15:25,550 --> 01:15:26,630
物理

1523
01:15:26,630 --> 01:15:30,710
物理的镜头不是也不是数学和物理的劲头儿

1524
01:15:30,710 --> 01:15:33,320
物理的尽头就是是那个啥

1525
01:15:33,350 --> 01:15:35,150
是那个死记

1526
01:15:35,150 --> 01:15:37,190
是死记

1527
01:15:37,190 --> 01:15:42,170
就是那个是是非常混乱非常混乱的这么一个

1528
01:15:42,440 --> 01:15:45,290
除非你证明这个宇宙它它不是封闭的

1529
01:15:46,160 --> 01:15:47,300
咱不提这个了

1530
01:15:47,300 --> 01:15:48,860
咱们说这个C语言

1531
01:15:49,070 --> 01:15:50,060
这个C语言呢

1532
01:15:52,190 --> 01:15:53,150
这个C语言呢

1533
01:15:53,150 --> 01:15:57,320
是那个一种是一种比较古老的

1534
01:15:57,380 --> 01:16:00,020
比较古老的这么一种语言了

1535
01:16:00,020 --> 01:16:00,620
最早呢

1536
01:16:00,620 --> 01:16:03,650
它是用来写操作系统的

1537
01:16:03,770 --> 01:16:05,930
用来写那个unix

1538
01:16:05,930 --> 01:16:09,800
那么这个unix最早是那个贝尔实验室两个两个人

1539
01:16:09,800 --> 01:16:13,400
他们写出来的最早是用什么语言写的

1540
01:16:13,400 --> 01:16:19,310
用B语言写的B语言你看后来发现用B语言写出来这个东西太大哈

1541
01:16:19,460 --> 01:16:21,500
你操作系统这玩意写出来这么大

1542
01:16:21,500 --> 01:16:22,910
这这玩意咋整

1543
01:16:23,090 --> 01:16:26,240
后来他们又他们又在B语言的基础之上

1544
01:16:26,240 --> 01:16:27,380
重新设计了一下

1545
01:16:27,560 --> 01:16:33,830
产生的这个C语言这这这意思就是说这个C语言势必语言的那个下一代

1546
01:16:33,830 --> 01:16:35,180
这这么个意思

1547
01:16:35,180 --> 01:16:37,070
然后就拿这个东西来写unix

1548
01:16:37,610 --> 01:16:38,630
那最早呢

1549
01:16:38,630 --> 01:16:39,380
可以说

1550
01:16:39,380 --> 01:16:42,050
可以说这个C语言是最流行的

1551
01:16:42,050 --> 01:16:44,600
原来我就是做这个C语言

1552
01:16:44,600 --> 01:16:46,310
就是就是就是写这个C语言的

1553
01:16:46,340 --> 01:16:49,760
后来后来写这个Java

1554
01:16:49,880 --> 01:16:51,290
后来跟老袁来了

1555
01:16:51,500 --> 01:16:53,870
来讲那个前端

1556
01:16:53,870 --> 01:16:58,370
实际上这个JS到现在我我我我仍然学的不深入

1557
01:16:58,370 --> 01:17:03,470
也也也是懒得去懒得去深入的去搞那个

1558
01:17:03,860 --> 01:17:05,480
深入的去看那个JS了

1559
01:17:07,560 --> 01:17:10,080
因为那个JS的封装了风

1560
01:17:10,380 --> 01:17:13,170
他那个隐藏了太多的细节

1561
01:17:13,170 --> 01:17:15,660
是那个JS隐藏了太多的细节

1562
01:17:15,870 --> 01:17:19,050
而且是也是有大量的坑

1563
01:17:19,050 --> 01:17:21,570
那个内很多坑都是匪夷所思的

1564
01:17:23,290 --> 01:17:24,970
像那个C语言里面有坑吗

1565
01:17:24,970 --> 01:17:25,930
有坑

1566
01:17:25,930 --> 01:17:27,550
C语言里面坑也挺多的

1567
01:17:27,760 --> 01:17:29,350
但是C语言里边的坑

1568
01:17:29,350 --> 01:17:30,850
他不是天生的坑

1569
01:17:30,850 --> 01:17:33,160
而是因为这个C语言太灵活了

1570
01:17:33,160 --> 01:17:33,910
你想怎么

1571
01:17:34,060 --> 01:17:36,940
你想怎么用就怎么用

1572
01:17:36,940 --> 01:17:38,110
就是因为太灵活了

1573
01:17:38,110 --> 01:17:39,550
缺乏一种规范

1574
01:17:39,550 --> 01:17:41,920
所以说很容易很容易用错

1575
01:17:42,100 --> 01:17:43,600
像那个Java语言呢

1576
01:17:43,780 --> 01:17:45,010
坑就很少

1577
01:17:45,010 --> 01:17:46,810
坑就相当少

1578
01:17:46,960 --> 01:17:49,420
因为他他的规范性是很强的

1579
01:17:49,480 --> 01:17:51,280
Go语言那个坑就更少了

1580
01:17:51,700 --> 01:17:54,040
越往后这个语言里边坑就越少

1581
01:17:55,730 --> 01:17:56,870
因为规范

1582
01:17:56,870 --> 01:17:57,980
就是因为规范

1583
01:17:58,340 --> 01:18:04,250
那么那个这个C语言现在好像是那个一九

1584
01:18:04,250 --> 01:18:05,510
一九版

1585
01:18:05,780 --> 01:18:09,440
那个这这个东西也一直在更新

1586
01:18:09,440 --> 01:18:11,990
这C语言的这个它的这个规则

1587
01:18:12,260 --> 01:18:13,670
他的那个语言规范

1588
01:18:13,670 --> 01:18:16,070
也在也在不同不停的更新

1589
01:18:16,070 --> 01:18:25,490
但是一直到现在更新只是更新你这个编译器应该怎么去怎么去写语法层面上的东西也就几乎没什么更新

1590
01:18:25,490 --> 01:18:37,460
根本就没好像是从那个从那个从一零版还是还是还是哪一版王乐还是九八版开始这个语法就语法本身他就不更新了

1591
01:18:37,580 --> 01:18:40,460
更新的就是编译器内部实现的时候

1592
01:18:40,550 --> 01:18:43,340
按照一个什么样的规则去实现

1593
01:18:43,340 --> 01:18:48,500
都变成这个了还有这个C加加也是这样不添加新语法了

1594
01:18:48,650 --> 01:18:49,640
还有就是

1595
01:18:49,640 --> 01:18:52,400
这个库你可以加一个什么样的函数

1596
01:18:52,400 --> 01:18:53,630
加个什么样的功能

1597
01:18:53,630 --> 01:18:55,490
现在那个都变成这样了

1598
01:18:55,730 --> 01:18:55,970
那么

1599
01:18:56,730 --> 01:18:58,110
JSJS的这个规范

1600
01:18:58,110 --> 01:19:00,450
仍然是在那个语法上

1601
01:19:00,450 --> 01:19:04,380
语法上仍然仍然是在仍然是在发展

1602
01:19:06,760 --> 01:19:09,550
那么这个咱们在这张图上

1603
01:19:09,550 --> 01:19:11,290
可以看到很多其他的语言

1604
01:19:11,290 --> 01:19:13,360
比如说这个前面所说的这个fortune

1605
01:19:13,390 --> 01:19:14,290
很很少见了

1606
01:19:14,440 --> 01:19:15,220
还有这个Pascal

1607
01:19:15,220 --> 01:19:19,150
实际上pasco也是一种非常优秀的这个语言了

1608
01:19:19,150 --> 01:19:20,140
那么这个pass Co

1609
01:19:20,140 --> 01:19:20,830
后来呢

1610
01:19:20,890 --> 01:19:23,470
后来就衍生出了这个带飞

1611
01:19:23,470 --> 01:19:26,440
那这个德尔菲也也是非常非常优秀的

1612
01:19:26,560 --> 01:19:28,120
就是从命令行

1613
01:19:28,120 --> 01:19:29,260
这种编程

1614
01:19:29,410 --> 01:19:31,390
从字符界面这种编程

1615
01:19:31,390 --> 01:19:32,770
一直到这个图形界面

1616
01:19:32,770 --> 01:19:35,590
到图形界面上出现的那个

1617
01:19:36,700 --> 01:19:37,330
一种语言

1618
01:19:37,330 --> 01:19:38,380
就是戴妃

1619
01:19:38,380 --> 01:19:40,090
戴妃用的就是Python语法

1620
01:19:40,720 --> 01:19:43,120
那么这个basicbasic不用多说了

1621
01:19:43,120 --> 01:19:44,260
最最早微软

1622
01:19:44,260 --> 01:19:45,220
微软就靠这个

1623
01:19:45,490 --> 01:19:46,960
就是靠这玩意儿起家的

1624
01:19:47,020 --> 01:19:47,440
对吧

1625
01:19:47,440 --> 01:19:48,910
微软靠两个东西起家

1626
01:19:49,000 --> 01:19:49,690
一个是boss

1627
01:19:49,690 --> 01:19:50,890
一个是basic

1628
01:19:51,610 --> 01:19:52,180
然后呢

1629
01:19:52,180 --> 01:19:56,020
他他就在Windows时代就就就出现了这个VD啊

1630
01:19:56,020 --> 01:19:56,890
Visio basic

1631
01:19:57,310 --> 01:19:58,420
那么C语言

1632
01:19:58,420 --> 01:20:00,490
C语言这这个东西

1633
01:20:01,540 --> 01:20:04,960
后来后来衍生出来的这个语言呢

1634
01:20:04,960 --> 01:20:07,030
都是以C语言的语法为基础

1635
01:20:07,060 --> 01:20:08,110
比如说C加加

1636
01:20:08,110 --> 01:20:10,060
C加加扩展的C语言的语法

1637
01:20:10,060 --> 01:20:11,350
然后加了这个面向对象

1638
01:20:11,590 --> 01:20:12,250
Java呢

1639
01:20:12,340 --> 01:20:16,810
Java实际上是那个C加加的恶侄外甥

1640
01:20:16,810 --> 01:20:19,390
可以说是是C加加的外省

1641
01:20:20,170 --> 01:20:23,050
实际上归根结底也是也是用的C语言语法

1642
01:20:23,080 --> 01:20:23,950
包括咱们

1643
01:20:23,980 --> 01:20:25,090
包括咱们JS

1644
01:20:25,680 --> 01:20:26,610
包括咱们JS

1645
01:20:26,760 --> 01:20:27,930
像那个C加加

1646
01:20:27,960 --> 01:20:30,840
C加加语言没有垃圾自动回收机制

1647
01:20:30,840 --> 01:20:32,430
Java里边儿加上这个喇

1648
01:20:32,460 --> 01:20:34,740
垃圾回收了C加加呢

1649
01:20:34,770 --> 01:20:38,880
仍然是需要手动去管理内存的但是呢

1650
01:20:38,880 --> 01:20:40,830
它里边也有一种东西叫什么呢

1651
01:20:40,830 --> 01:20:42,330
叫智能指针

1652
01:20:42,330 --> 01:20:43,200
也就是说呀

1653
01:20:43,200 --> 01:20:47,490
它可以在一定程度上用智能指针来帮助你去管理内存

1654
01:20:47,550 --> 01:20:53,400
比如说你脱离了作用域了可以帮助你去释放这个释放这个内存

1655
01:20:53,490 --> 01:20:59,250
或者是说你的这个或者说你的J这块内存是他的引用数

1656
01:20:59,250 --> 01:21:00,210
变成零了

1657
01:21:00,210 --> 01:21:02,850
它可以帮助你去释放当然这种释放

1658
01:21:02,850 --> 01:21:03,720
它是实时的

1659
01:21:04,730 --> 01:21:05,780
它是实时的释放

1660
01:21:05,960 --> 01:21:10,130
而这个Java还有这个JS的这种释放内存的机制

1661
01:21:10,340 --> 01:21:14,000
它是隔一小段时间他去释放一遍

1662
01:21:14,000 --> 01:21:21,350
隔一小段时间是放一遍这样能够这样会导致导致这个程序的这个暂停

1663
01:21:21,350 --> 01:21:23,060
你你在清理内存的时候

1664
01:21:23,060 --> 01:21:25,490
这个程序它是不能走的

1665
01:21:25,670 --> 01:21:27,830
那么C加加的这个智能指针

1666
01:21:27,830 --> 01:21:34,280
实际上就在这个程序的这个这个这个他工作的时候就在程序的主线程里

1667
01:21:34,760 --> 01:21:41,360
而这个Java还有JS等等这些动态这些那个带有GC的这种语言

1668
01:21:41,600 --> 01:21:44,030
他们在进行这个垃圾回收的时候呢

1669
01:21:44,030 --> 01:21:46,430
垃圾回收再一个独立的线程里

1670
01:21:46,460 --> 01:21:48,110
所以说垃圾回收的时候

1671
01:21:48,110 --> 01:21:48,860
你程序

1672
01:21:48,920 --> 01:21:50,450
必须得暂停

1673
01:21:50,510 --> 01:21:53,600
回收完了你程序才能继续运行

1674
01:21:53,750 --> 01:21:54,320
所以呢

1675
01:21:54,320 --> 01:21:57,320
这个GCRGCGC策略是有很多种的

1676
01:21:57,590 --> 01:21:59,000
看你的这个程序

1677
01:21:59,180 --> 01:22:00,830
看你的程序的要求

1678
01:22:00,950 --> 01:22:03,170
如果说你要求实时性高

1679
01:22:03,260 --> 01:22:04,310
用用一种策

1680
01:22:04,400 --> 01:22:06,080
略实时性不高

1681
01:22:06,080 --> 01:22:07,430
用另外一种策略

1682
01:22:07,550 --> 01:22:08,570
这是根据十根

1683
01:22:08,570 --> 01:22:10,160
根据那个实际情况

1684
01:22:10,310 --> 01:22:12,560
你来选择这个GC的这个

1685
01:22:13,670 --> 01:22:14,810
GC的这种策略

1686
01:22:15,170 --> 01:22:18,200
这种东西咱们那个知道就行

1687
01:22:18,230 --> 01:22:19,640
然后呢

1688
01:22:19,640 --> 01:22:20,870
然后JS

1689
01:22:20,870 --> 01:22:24,830
C语言和JS他们的这个相同点和区别呢

1690
01:22:24,920 --> 01:22:26,570
首先第一个区别

1691
01:22:26,780 --> 01:22:28,760
C语言是编译型的语言

1692
01:22:28,790 --> 01:22:29,900
而这个JS呢

1693
01:22:29,900 --> 01:22:31,130
它是解释性语言

1694
01:22:31,400 --> 01:22:33,350
那当然咱们不说那个啥

1695
01:22:33,470 --> 01:22:36,110
不说那个j it啊

1696
01:22:36,110 --> 01:22:38,060
咱们咱不提这件事儿

1697
01:22:39,390 --> 01:22:41,070
如果说你要提这个的

1698
01:22:41,070 --> 01:22:43,350
他就不是纯粹性解释语言了

1699
01:22:43,800 --> 01:22:46,440
他不是纯粹性的解释型语言了

1700
01:22:46,590 --> 01:22:48,780
它有一部分是编译型的

1701
01:22:48,780 --> 01:22:51,870
有一部因为它有一部分要编译成了字节码

1702
01:22:53,830 --> 01:22:56,380
游戏那么的其他部分呢

1703
01:22:56,380 --> 01:22:58,810
其他部布一部分编译成字节码

1704
01:22:58,810 --> 01:23:00,970
另外一部分仍然是解释的呢

1705
01:23:00,970 --> 01:23:02,200
现在这个JS

1706
01:23:02,380 --> 01:23:03,790
也是比较复杂了

1707
01:23:04,300 --> 01:23:05,230
那么C语言呢

1708
01:23:05,230 --> 01:23:07,030
就是纯粹型的编译语言

1709
01:23:07,060 --> 01:23:09,070
什么叫纯粹型的编译型语言呢

1710
01:23:09,280 --> 01:23:10,990
咱们JS代码

1711
01:23:11,050 --> 01:23:12,160
咱们去写代码的时候

1712
01:23:12,310 --> 01:23:13,990
JS代码写出来以后

1713
01:23:13,990 --> 01:23:15,730
直接扔给no的

1714
01:23:15,730 --> 01:23:18,460
或者直接扔给那个浏览器

1715
01:23:18,490 --> 01:23:20,740
它是可以直接直直接执行的

1716
01:23:20,740 --> 01:23:22,870
你不需要对代码本身进行任何处理

1717
01:23:23,170 --> 01:23:24,700
但是C语言不行

1718
01:23:24,700 --> 01:23:25,420
C语言不行

1719
01:23:25,600 --> 01:23:26,740
C语言怎么办呢

1720
01:23:26,800 --> 01:23:28,360
C语言你先写代码

1721
01:23:28,360 --> 01:23:29,410
写完代码以后

1722
01:23:29,410 --> 01:23:32,200
你必须得用编译器来进行编译

1723
01:23:33,030 --> 01:23:34,470
编译器是什么东西呢

1724
01:23:34,470 --> 01:23:36,390
是GC语言的编译器

1725
01:23:36,390 --> 01:23:36,960
是GCC

1726
01:23:37,230 --> 01:23:40,020
编译出来以后是目标程序

1727
01:23:40,200 --> 01:23:42,120
那目标程序他就是那个二进制

1728
01:23:42,330 --> 01:23:42,930
但是呢

1729
01:23:42,930 --> 01:23:46,800
因为咱们写程序是要按照模块化去做的模块的话呢

1730
01:23:46,800 --> 01:23:49,980
最简单的模块的话就是有好多这个点C文件

1731
01:23:50,740 --> 01:23:51,100
对吧

1732
01:23:51,220 --> 01:23:54,460
那你一个点C文件就要生成一个点OBG啊

1733
01:23:54,550 --> 01:23:55,900
你两个点C文件呢

1734
01:23:55,900 --> 01:23:57,640
就要产产生两个点OBD

1735
01:23:57,880 --> 01:24:00,940
那么这两个点OBD他都是二进制代码

1736
01:24:00,940 --> 01:24:02,770
但是你你没法执行

1737
01:24:03,480 --> 01:24:03,990
对吧

1738
01:24:04,020 --> 01:24:06,990
你得把这两个二进制代码得合并成一个

1739
01:24:07,140 --> 01:24:09,060
那你合并的过程叫什么呢

1740
01:24:09,090 --> 01:24:09,720
叫连接

1741
01:24:09,930 --> 01:24:11,070
连接是什么呢

1742
01:24:11,100 --> 01:24:11,640
叫link

1743
01:24:12,700 --> 01:24:19,060
连接连接这个程序是link用在用先用GCC处理产生二进制

1744
01:24:19,120 --> 01:24:19,660
然后呢

1745
01:24:19,660 --> 01:24:22,420
用link把产生了好多二进制

1746
01:24:22,480 --> 01:24:23,590
给合并成一个

1747
01:24:23,620 --> 01:24:26,050
就是咱们最终的那个点exe

1748
01:24:26,830 --> 01:24:28,660
这是C语言的那个

1749
01:24:29,440 --> 01:24:31,750
这是C语言的那个过程

1750
01:24:31,870 --> 01:24:33,520
它的那个编译过程

1751
01:24:33,670 --> 01:24:35,710
那么这个C语言

1752
01:24:35,710 --> 01:24:37,210
因为它是很古老的

1753
01:24:37,210 --> 01:24:38,170
他比较古老

1754
01:24:38,620 --> 01:24:40,180
你要这样去做

1755
01:24:40,880 --> 01:24:41,840
有一个问题

1756
01:24:41,870 --> 01:24:42,740
问题是什么

1757
01:24:42,860 --> 01:24:43,550
跨平台

1758
01:24:44,000 --> 01:24:45,260
那跨平台问题

1759
01:24:45,440 --> 01:24:46,940
你挎一个平台

1760
01:24:46,940 --> 01:24:48,590
你就要重新编译一次

1761
01:24:48,590 --> 01:24:50,000
再跨一个又要程序编译一次

1762
01:24:50,000 --> 01:24:52,310
比如说Windows和Linux

1763
01:24:52,310 --> 01:24:53,300
这两种操作

1764
01:24:53,570 --> 01:24:54,560
这两种操作系统

1765
01:24:54,650 --> 01:24:55,640
你同一套代码

1766
01:24:55,670 --> 01:24:59,150
你得针对两个操作系统分别进行编译

1767
01:24:59,330 --> 01:25:02,900
你在你在那个8086这个CPU上

1768
01:25:03,200 --> 01:25:04,130
这个程序

1769
01:25:04,130 --> 01:25:09,230
8086的Linux这个这个程序和那个ARM上的那个那个程序

1770
01:25:10,090 --> 01:25:12,010
和那个R上的那个程序

1771
01:25:12,130 --> 01:25:15,640
这你你你你又要编译两次

1772
01:25:15,640 --> 01:25:16,960
所以说它的跨平台

1773
01:25:16,960 --> 01:25:19,960
你想让它跨平台那是比较麻烦的

1774
01:25:21,020 --> 01:25:22,640
那么这个JS的JS

1775
01:25:22,640 --> 01:25:26,120
他就根本就没有这个跨平台问题对吧

1776
01:25:26,150 --> 01:25:28,010
因为跨平台谁帮你跨了

1777
01:25:28,250 --> 01:25:29,450
浏览器帮你跨了

1778
01:25:29,540 --> 01:25:32,540
弄得JS帮你跨了只要有这个环境

1779
01:25:32,720 --> 01:25:34,250
那你同一套代码

1780
01:25:34,250 --> 01:25:36,290
你在什么操作系统都弄好

1781
01:25:36,290 --> 01:25:41,060
这是JS的那个优势那这个

1782
01:25:42,150 --> 01:25:47,010
C语言这个C语言说到C语言就不能不说C加加

1783
01:25:47,010 --> 01:25:48,180
咱们说这个东西

1784
01:25:48,180 --> 01:25:49,770
也是要放一块儿说的

1785
01:25:49,800 --> 01:25:50,460
对吧

1786
01:25:50,550 --> 01:25:51,390
放一块儿说

1787
01:25:51,540 --> 01:25:52,920
那么你放一块儿说

1788
01:25:53,070 --> 01:25:56,820
那C和C加加他们有什么区别

1789
01:25:56,820 --> 01:25:58,380
他们区别在什么地方呢

1790
01:25:58,590 --> 01:26:03,270
咱们不能简单的是简单的认为C加加是C

1791
01:26:03,270 --> 01:26:04,260
带类的C

1792
01:26:04,260 --> 01:26:10,950
你不能这样简单的去恶简单的这样的认为带类的C另有语言

1793
01:26:10,950 --> 01:26:12,120
那种语言叫什么

1794
01:26:12,150 --> 01:26:13,560
叫object c

1795
01:26:14,080 --> 01:26:20,440
叫面向对象C就是OC就是那个在那个给给那个苹果

1796
01:26:20,440 --> 01:26:21,670
给给那个苹果设备

1797
01:26:21,670 --> 01:26:26,740
他他原来用的是用来他原来用的是这这个套路

1798
01:26:32,930 --> 01:26:35,960
那么那个C语言和C加加

1799
01:26:35,990 --> 01:26:38,930
是两种完全不同的语言

1800
01:26:38,930 --> 01:26:41,720
他不是他不是扩展

1801
01:26:41,720 --> 01:26:44,750
这这点一定要注意C加加

1802
01:26:45,690 --> 01:26:46,380
C加加

1803
01:26:46,380 --> 01:26:48,000
当然C加加的编译器

1804
01:26:48,000 --> 01:26:49,500
是可以编译C语言

1805
01:26:50,040 --> 01:26:51,930
是可以编译C语言代码的

1806
01:26:51,930 --> 01:26:54,150
但是你不能把这两种东西等同起来

1807
01:26:54,510 --> 01:27:00,060
因为C加加它比C语言更复杂很多C加加

1808
01:27:00,520 --> 01:27:02,830
C加加复杂到什么程度呢

1809
01:27:03,160 --> 01:27:04,870
C加加这个语言

1810
01:27:04,870 --> 01:27:07,210
它的作者曾经说过

1811
01:27:07,210 --> 01:27:11,260
尽管说C加加是我发明出来的

1812
01:27:11,260 --> 01:27:12,910
是我那个造出来的

1813
01:27:13,000 --> 01:27:14,410
但是可以说

1814
01:27:14,500 --> 01:27:17,230
我也不是完全理解

1815
01:27:17,230 --> 01:27:20,410
我也不是完全的这个精通这个C加加

1816
01:27:20,740 --> 01:27:21,400
哈哈

1817
01:27:21,580 --> 01:27:24,970
就连作者他都说不完全精通

1818
01:27:24,970 --> 01:27:28,000
就可见C加加是多么的复杂

1819
01:27:28,180 --> 01:27:30,220
那么JC加加它复杂到什么地方

1820
01:27:30,220 --> 01:27:32,260
就是它的面向对象特性复杂

1821
01:27:32,610 --> 01:27:34,470
你看比如说什么

1822
01:27:34,560 --> 01:27:35,370
多继承

1823
01:27:35,940 --> 01:27:36,210
对吧

1824
01:27:36,210 --> 01:27:37,650
他不是多重继承

1825
01:27:37,800 --> 01:27:39,270
多重继承是什么样儿的

1826
01:27:39,630 --> 01:27:43,500
多重继承是比如说有一个类a

1827
01:27:43,530 --> 01:27:43,980
然后呢

1828
01:27:43,980 --> 01:27:45,360
有一个类B呢

1829
01:27:45,360 --> 01:27:48,270
你要继承的时候由B继承自a

1830
01:27:48,300 --> 01:27:48,990
然后呢

1831
01:27:49,140 --> 01:27:52,500
再在CIC在继承自毙

1832
01:27:52,500 --> 01:27:54,510
这叫多重继承

1833
01:27:55,410 --> 01:27:57,120
你分了好几个层次

1834
01:27:57,360 --> 01:27:58,740
这叫多重继承

1835
01:27:58,950 --> 01:28:00,330
多继承是什么意思

1836
01:28:00,690 --> 01:28:02,640
有一个A1

1837
01:28:02,700 --> 01:28:03,870
有一个A2

1838
01:28:04,510 --> 01:28:05,290
然后呢

1839
01:28:05,530 --> 01:28:10,360
B这个类同时从A1和A2继承过来

1840
01:28:10,720 --> 01:28:13,210
这叫多继承

1841
01:28:13,210 --> 01:28:14,500
这叫多继承

1842
01:28:15,160 --> 01:28:17,170
现在面向对象语言里边儿

1843
01:28:17,380 --> 01:28:19,600
你见不到这种多继承

1844
01:28:19,600 --> 01:28:20,740
见不到多继承那种

1845
01:28:20,740 --> 01:28:23,260
盖着这这种概念

1846
01:28:23,260 --> 01:28:24,190
比如说Java

1847
01:28:24,190 --> 01:28:25,420
什么勾这之类的

1848
01:28:25,420 --> 01:28:26,740
JS更不用说对吧

1849
01:28:26,740 --> 01:28:28,240
JS根本就没有继承

1850
01:28:28,330 --> 01:28:30,040
JS他他就不是面向对象的

1851
01:28:31,790 --> 01:28:36,830
那么这个多继承很容易引发混乱多继承很容易

1852
01:28:37,010 --> 01:28:38,780
也也很容易混乱

1853
01:28:38,990 --> 01:28:43,820
但是多继承这种特性也需但有时候也也需要用到

1854
01:28:44,780 --> 01:28:45,920
也需要用到

1855
01:28:45,920 --> 01:28:46,670
那怎么办

1856
01:28:46,790 --> 01:28:48,440
有一个拐弯儿

1857
01:28:48,440 --> 01:28:50,300
有一个拐弯儿的这么一种方法

1858
01:28:50,540 --> 01:28:51,830
拐弯怎么拐弯儿

1859
01:28:51,890 --> 01:28:53,690
你可以多继承

1860
01:28:53,720 --> 01:28:54,860
但是你从哪儿继承

1861
01:28:54,860 --> 01:28:56,030
从接口继承

1862
01:28:56,590 --> 01:28:58,960
比如说一个接口a一个类a

1863
01:28:59,560 --> 01:29:03,310
然后这个B你具备的特性

1864
01:29:03,310 --> 01:29:05,170
也具备a的特性

1865
01:29:05,260 --> 01:29:07,360
但是这个接口里面它不实现代码

1866
01:29:07,960 --> 01:29:08,800
不实现代码

1867
01:29:09,040 --> 01:29:13,060
这样就就不会产生这种多继承的这种东西

1868
01:29:13,150 --> 01:29:14,530
TS也可以多继承吗

1869
01:29:14,530 --> 01:29:15,640
这个我倒不知道

1870
01:29:15,880 --> 01:29:17,260
TS我不熟

1871
01:29:17,290 --> 01:29:18,430
我就简单的看了

1872
01:29:18,760 --> 01:29:20,200
我就简单的看了看

1873
01:29:20,260 --> 01:29:21,010
TS不熟

1874
01:29:21,610 --> 01:29:23,650
这真的真的TS可以多继承吗

1875
01:29:23,980 --> 01:29:24,940
回头我得看看

1876
01:29:25,240 --> 01:29:26,440
既然你这么说了

1877
01:29:26,770 --> 01:29:29,650
实际上那个TS是一个非常奇怪的语言

1878
01:29:30,260 --> 01:29:32,390
Ts of ts非常非常的奇怪

1879
01:29:32,720 --> 01:29:36,320
对那个前端非常不友好的

1880
01:29:36,650 --> 01:29:38,870
那么那个C语言

1881
01:29:38,870 --> 01:29:39,950
面向过程

1882
01:29:39,980 --> 01:29:41,510
C加加面向对象

1883
01:29:41,750 --> 01:29:44,240
而且这两种语言都有标准库

1884
01:29:44,330 --> 01:29:45,860
C语言用在什么地方呢

1885
01:29:45,860 --> 01:29:50,390
C语言现在用的这个用的这个领域

1886
01:29:50,390 --> 01:29:51,410
比较窄了

1887
01:29:51,440 --> 01:29:52,910
原来用的非常非常宽

1888
01:29:52,940 --> 01:29:53,930
比如说原来

1889
01:29:54,140 --> 01:29:55,850
比方说很久以前写那个啥

1890
01:29:55,850 --> 01:29:57,980
写那个超市用的那个POS系统

1891
01:29:57,980 --> 01:29:59,060
就是用那个C写的

1892
01:29:59,060 --> 01:30:00,050
写业务

1893
01:30:00,050 --> 01:30:02,660
可以用用C写那个业务对吧

1894
01:30:02,870 --> 01:30:05,330
现在很少用C去写写业务了

1895
01:30:07,040 --> 01:30:10,280
那么那个C语言一般用在这个底层

1896
01:30:10,280 --> 01:30:12,350
底层网络或者是嵌入式

1897
01:30:12,350 --> 01:30:14,300
比如说像那个X对吧

1898
01:30:14,360 --> 01:30:16,490
X你你去下载下来这个源码

1899
01:30:16,490 --> 01:30:20,420
它就是C语言还有还那么这个C加加呢

1900
01:30:20,420 --> 01:30:22,670
C加加写这个引擎

1901
01:30:22,670 --> 01:30:25,490
写这个引擎和和那个应用软件呢

1902
01:30:25,640 --> 01:30:27,590
比如说像引擎是什么

1903
01:30:27,590 --> 01:30:28,640
比如说V8

1904
01:30:29,270 --> 01:30:30,800
对吧

1905
01:30:30,800 --> 01:30:32,630
V8V8就是那个JS解释引擎吗

1906
01:30:32,630 --> 01:30:33,350
AC加加血

1907
01:30:33,500 --> 01:30:35,300
还有很多那个游戏引擎

1908
01:30:35,300 --> 01:30:36,560
比如说什么Unity

1909
01:30:37,100 --> 01:30:39,560
这样一些东西也是用用用那个C加加去写

1910
01:30:39,920 --> 01:30:41,180
还有那个应用软件

1911
01:30:41,180 --> 01:30:42,500
比如说什么Photoshop

1912
01:30:42,500 --> 01:30:42,920
对吧

1913
01:30:43,100 --> 01:30:44,750
还有什么autocad

1914
01:30:44,750 --> 01:30:46,340
这这这些玩意儿应用软件

1915
01:30:46,790 --> 01:30:48,200
那么这个C语言

1916
01:30:48,230 --> 01:30:50,900
那C语言咱们必须得学

1917
01:30:50,900 --> 01:30:51,710
学一学

1918
01:30:51,710 --> 01:30:52,610
必须得学一学

1919
01:30:52,850 --> 01:30:54,650
恶语法你必须得会

1920
01:30:54,650 --> 01:30:56,450
简单的小程序你能写出来

1921
01:30:56,810 --> 01:30:59,510
那么咱们写这个C语言的那个环境

1922
01:30:59,510 --> 01:31:02,600
咱们要注意就写环境Windows上

1923
01:31:03,390 --> 01:31:06,000
用最好的环境是VCWINDOWS10

1924
01:31:06,000 --> 01:31:09,210
最好的环境是VCVC的编译器叫什么呢

1925
01:31:09,210 --> 01:31:10,620
叫EMSVC

1926
01:31:11,740 --> 01:31:17,350
VCVC的编译器那个程序的名字叫MSVC就是微软的

1927
01:31:17,410 --> 01:31:19,180
微软的那个C编译器

1928
01:31:19,540 --> 01:31:21,010
那么Linux下呢

1929
01:31:21,040 --> 01:31:22,570
就就是GC啊

1930
01:31:22,570 --> 01:31:23,800
Unix下也是

1931
01:31:23,830 --> 01:31:25,780
苹果下也是

1932
01:31:26,110 --> 01:31:31,000
那么那个unix下的C加加编译器呢

1933
01:31:31,000 --> 01:31:34,690
就是记加加GC是C编译器

1934
01:31:34,690 --> 01:31:35,830
G加加是

1935
01:31:35,830 --> 01:31:36,640
C加加编译器

1936
01:31:36,940 --> 01:31:39,550
那么在Windows下有没有GCC呢

1937
01:31:39,550 --> 01:31:40,750
可不可以用GCC呢

1938
01:31:40,750 --> 01:31:41,620
可以啊

1939
01:31:41,740 --> 01:31:42,700
他不叫GC

1940
01:31:42,700 --> 01:31:43,300
它叫什么呢

1941
01:31:43,330 --> 01:31:44,110
它叫明哥为

1942
01:31:44,820 --> 01:31:49,890
明隔壁室温度下的这个GCGCC编译器是开源的

1943
01:31:49,890 --> 01:31:56,580
他是他是那个遵循那个go规范的go是那个一个开源组织

1944
01:31:57,090 --> 01:31:58,290
它遵循那个go

1945
01:31:58,560 --> 01:32:02,040
他就是开那个go组织他们弄出来的

1946
01:32:02,820 --> 01:32:03,960
那么那个麦克呢

1947
01:32:03,960 --> 01:32:05,580
麦克他本身就是unix

1948
01:32:06,550 --> 01:32:07,270
对吧

1949
01:32:07,270 --> 01:32:08,410
所以他也用GCC

1950
01:32:08,650 --> 01:32:09,940
那么这个插扣的呢

1951
01:32:09,940 --> 01:32:11,680
插扣的他就是个ID

1952
01:32:11,680 --> 01:32:13,780
相当于那个studio

1953
01:32:14,170 --> 01:32:16,840
那咱们学学这个C语言的话呢

1954
01:32:16,840 --> 01:32:19,870
就就是在那个link或者是麦克下去学就行了

1955
01:32:20,020 --> 01:32:21,790
为什么不在Windows下学呢

1956
01:32:21,790 --> 01:32:26,080
Windows那个那个VCVC那个环境配置起来很复杂

1957
01:32:27,170 --> 01:32:30,020
内内比较简单的就是VC6

1958
01:32:30,020 --> 01:32:31,460
但是VC6不好找了

1959
01:32:31,670 --> 01:32:35,360
你要装那个video内装老半天

1960
01:32:35,360 --> 01:32:37,460
而且你平时还不一定用得着

1961
01:32:37,640 --> 01:32:39,890
占好大的那个硬盘空间

1962
01:32:39,890 --> 01:32:41,420
给你装一堆乱七八糟的库

1963
01:32:42,410 --> 01:32:43,340
那个没必要

1964
01:32:43,340 --> 01:32:44,390
还是Linux

1965
01:32:44,990 --> 01:32:47,960
LYNX或者麦克用用那个GC

1966
01:32:48,020 --> 01:32:50,030
然后咱们把这个环境

1967
01:32:50,030 --> 01:32:51,560
咱们解决这个环境问题以后

1968
01:32:51,710 --> 01:32:52,550
之后呢

1969
01:32:52,580 --> 01:32:55,760
先不说这个指针和和那个内存

1970
01:32:55,760 --> 01:32:57,020
这个咱们稍后再说

1971
01:32:57,140 --> 01:32:59,630
先说一下这个语法C语言的语法

1972
01:32:59,720 --> 01:33:02,390
C语言的语法是啥样儿的呢

1973
01:33:02,390 --> 01:33:03,260
我浏览器呢

1974
01:33:08,080 --> 01:33:10,390
C语言的语法是吧

1975
01:33:10,510 --> 01:33:11,650
我那个

1976
01:33:11,680 --> 01:33:15,670
因为咱们是有这个JS还有TS的这个基础

1977
01:33:16,210 --> 01:33:16,690
对吧

1978
01:33:16,810 --> 01:33:17,950
有这个基础

1979
01:33:18,010 --> 01:33:20,530
更何况咱们一开始还学过这个批只批

1980
01:33:20,920 --> 01:33:21,670
所以呢

1981
01:33:21,670 --> 01:33:24,130
咱们所以咱们那个

1982
01:33:26,820 --> 01:33:27,930
学这个C语言呢

1983
01:33:27,930 --> 01:33:29,580
就就容易一些

1984
01:33:29,580 --> 01:33:30,930
容易到什么地步呢

1985
01:33:31,080 --> 01:33:32,760
给大家看一份文档

1986
01:33:32,760 --> 01:33:37,020
这个文档就是给大家先给大家推荐一个网站叫learn

1987
01:33:39,940 --> 01:33:40,540
嫩

1988
01:33:42,090 --> 01:33:42,690
X

1989
01:33:43,340 --> 01:33:43,880
因

1990
01:33:44,830 --> 01:33:45,940
X in

1991
01:33:46,570 --> 01:33:47,260
Y

1992
01:33:49,850 --> 01:33:51,080
In one minute

1993
01:33:54,910 --> 01:33:55,600
是这么写吗

1994
01:33:55,660 --> 01:33:56,200
拼错了

1995
01:33:56,200 --> 01:33:56,800
可能是

1996
01:33:57,730 --> 01:33:58,810
还是百度一下吧

1997
01:34:16,650 --> 01:34:17,100
这个

1998
01:34:18,400 --> 01:34:21,070
另外minutes不是minute minutes

1999
01:34:22,540 --> 01:34:24,040
少写S

2000
01:34:24,040 --> 01:34:24,970
这个网站

2001
01:34:25,240 --> 01:34:28,180
这个网站是非常非常好的

2002
01:34:28,180 --> 01:34:31,660
强烈强烈强烈强烈

2003
01:34:33,760 --> 01:34:34,780
我这强烈

2004
01:34:35,530 --> 01:34:36,850
这墙给列了

2005
01:34:38,170 --> 01:34:40,780
原来引用了那个Google的Google的CDN了

2006
01:34:44,540 --> 01:34:47,000
这个网站这个网站是什么呢

2007
01:34:47,180 --> 01:34:51,470
这个网站就是快速入门编程语言的

2008
01:34:52,060 --> 01:34:55,750
不要提那个事儿不要提那个事儿不要提这个东西

2009
01:34:56,020 --> 01:34:58,540
你那个J容易被平台封

2010
01:34:58,900 --> 01:35:00,010
千万不要提

2011
01:35:04,280 --> 01:35:07,070
那么这个这个网站

2012
01:35:07,070 --> 01:35:09,710
Learn X in y minutes啊

2013
01:35:09,770 --> 01:35:10,880
单位是分钟

2014
01:35:11,060 --> 01:35:11,870
他干什么

2015
01:35:11,870 --> 01:35:13,370
他就是咱们去学

2016
01:35:13,370 --> 01:35:14,600
去学任意一种语言

2017
01:35:14,600 --> 01:35:16,250
这语言很多很多的

2018
01:35:16,250 --> 01:35:17,420
咱们可以看这么多

2019
01:35:17,450 --> 01:35:19,250
包括什么HTMLCS啊

2020
01:35:19,490 --> 01:35:21,560
还有什么Java go r c c啊

2021
01:35:21,560 --> 01:35:22,280
C加加等等

2022
01:35:22,550 --> 01:35:25,370
而且这里边儿这个语言我们可以选啦

2023
01:35:25,400 --> 01:35:25,910
对吧

2024
01:35:25,970 --> 01:35:26,570
选什么

2025
01:35:26,570 --> 01:35:28,940
选CH杠CN

2026
01:35:29,150 --> 01:35:29,960
选这个

2027
01:35:30,200 --> 01:35:30,680
选这个

2028
01:35:33,300 --> 01:35:34,110
网址啊

2029
01:35:34,350 --> 01:35:35,190
网址发给你们

2030
01:35:35,190 --> 01:35:36,570
有人发出来了是吧

2031
01:35:36,600 --> 01:35:39,180
然后这个咱们就找啥呀

2032
01:35:39,180 --> 01:35:40,140
找C

2033
01:35:40,140 --> 01:35:41,460
找CC在这儿

2034
01:35:41,490 --> 01:35:43,890
然后咱们就直接CH杠CN

2035
01:35:44,160 --> 01:35:47,310
还有后边还有C加加也恶这个c h Gang cn

2036
01:35:48,730 --> 01:35:49,360
这两个

2037
01:35:50,670 --> 01:35:51,930
这玩意儿太讨厌

2038
01:35:53,520 --> 01:35:55,230
你把人CDN疯了干啥呀

2039
01:35:55,650 --> 01:35:58,020
这是吃饱撑的

2040
01:36:02,200 --> 01:36:02,920
太慢

2041
01:36:09,800 --> 01:36:11,480
这个这个网站

2042
01:36:11,480 --> 01:36:14,570
最适合咱们最适合咱们用

2043
01:36:14,570 --> 01:36:15,890
咱们会了一种语言

2044
01:36:15,890 --> 01:36:23,120
然后通过这这这在这个上面去去学那个去去快速的入门一种语言先从C开始

2045
01:36:23,180 --> 01:36:25,820
C语言它是以什么形式

2046
01:36:25,820 --> 01:36:31,700
他就是以代码形式来来教我们告就是教我们这些语法还有语句

2047
01:36:31,880 --> 01:36:32,810
教我们这些东西

2048
01:36:32,990 --> 01:36:33,590
比如说啊

2049
01:36:33,590 --> 01:36:36,860
我们开始a柱是对吧

2050
01:36:36,860 --> 01:36:40,370
注释还有看到的那些什么defy是什么意思对吧

2051
01:36:40,370 --> 01:36:41,090
这是干什么

2052
01:36:41,090 --> 01:36:42,380
定义一个宏

2053
01:36:42,440 --> 01:36:45,230
后边咱们再给大家讲代码的时候

2054
01:36:45,230 --> 01:36:48,380
我会给大家在再去讲一些这个相关的这个语法

2055
01:36:48,380 --> 01:36:51,860
一边讲这个VBA的代码或还有note的代码

2056
01:36:51,860 --> 01:36:57,290
一边给大家再讲这个C加加的C加加的语法咱们先先看一下

2057
01:36:57,440 --> 01:36:59,150
那么这个在这个里边

2058
01:36:59,150 --> 01:37:01,640
C语言里边儿它的基本数据类型

2059
01:37:01,640 --> 01:37:05,360
要要注意在JS里面它是它它是没有类型的

2060
01:37:05,770 --> 01:37:06,310
对吧

2061
01:37:06,310 --> 01:37:07,360
这里边没有类型

2062
01:37:08,140 --> 01:37:08,890
有同学说

2063
01:37:08,890 --> 01:37:09,730
他不是有类型吗

2064
01:37:09,730 --> 01:37:10,810
有有什么字符串

2065
01:37:10,810 --> 01:37:13,030
有有什么数字等等这些东西

2066
01:37:13,030 --> 01:37:14,500
那不是类型

2067
01:37:14,500 --> 01:37:15,190
那不是个类型

2068
01:37:15,190 --> 01:37:16,480
那是个对象

2069
01:37:16,480 --> 01:37:17,140
他不是类型

2070
01:37:17,470 --> 01:37:18,910
真正的类型是什么样的

2071
01:37:18,970 --> 01:37:21,190
真正的类型这是C加加里边儿类型

2072
01:37:21,280 --> 01:37:22,150
它里边儿有啥呀

2073
01:37:22,150 --> 01:37:23,350
它里边有枚举

2074
01:37:23,840 --> 01:37:24,950
哪枚举是它的

2075
01:37:24,950 --> 01:37:28,070
它它里边儿就是这么一种类型了

2076
01:37:28,250 --> 01:37:29,390
另外还有什么

2077
01:37:29,420 --> 01:37:31,250
就是整形

2078
01:37:31,400 --> 01:37:32,990
还有什么字符型

2079
01:37:33,020 --> 01:37:35,810
整型又分好多个种类

2080
01:37:35,810 --> 01:37:37,310
短整型长整型

2081
01:37:37,310 --> 01:37:39,020
还有那个F64等等

2082
01:37:39,020 --> 01:37:40,490
还有有符号儿无符号儿

2083
01:37:40,760 --> 01:37:42,770
还有什么浮点型

2084
01:37:42,770 --> 01:37:43,790
单精度浮点型

2085
01:37:43,790 --> 01:37:45,560
双精度浮点型等等这些东西

2086
01:37:45,770 --> 01:37:47,990
第一步先把这些类型搞清楚

2087
01:37:48,290 --> 01:37:50,570
那么这些类型代表什么呢

2088
01:37:50,720 --> 01:37:55,490
这类型代表你在你的数据在内存当中是什么样的

2089
01:37:56,710 --> 01:37:57,820
你要你要记住

2090
01:37:58,000 --> 01:37:59,920
类型本质上的

2091
01:37:59,950 --> 01:38:05,500
本质上就是在描述你的数据在内存里边儿是什么样儿的

2092
01:38:05,500 --> 01:38:06,790
梦回大一

2093
01:38:07,090 --> 01:38:09,820
你们大学的时候老师肯定不这么说

2094
01:38:10,950 --> 01:38:13,500
老师肯定不不不说这个

2095
01:38:13,560 --> 01:38:14,430
他就是说什么

2096
01:38:14,520 --> 01:38:15,930
就是说这个类型

2097
01:38:15,930 --> 01:38:20,970
有哪几种类型这就是强类型语言C加加就是强类型语言

2098
01:38:21,360 --> 01:38:25,800
那类型的本质就是你的数据在内存里边儿

2099
01:38:25,830 --> 01:38:26,760
它是什么样

2100
01:38:26,790 --> 01:38:28,230
它长什么样呢

2101
01:38:28,260 --> 01:38:29,250
它长什么样呢

2102
01:38:29,310 --> 01:38:30,510
比如说一个整形

2103
01:38:30,630 --> 01:38:32,460
一个整型占四个字节

2104
01:38:32,890 --> 01:38:34,840
那那么它在内存里边儿

2105
01:38:34,930 --> 01:38:35,950
内存是什么

2106
01:38:35,950 --> 01:38:37,930
内存咱们前面给大家讲过是吧

2107
01:38:39,020 --> 01:38:40,580
给给大家讲过多次

2108
01:38:41,330 --> 01:38:42,350
那么在内存里边儿

2109
01:38:42,350 --> 01:38:44,060
它是一个又一个的小格子

2110
01:38:44,620 --> 01:38:47,560
对不对一个小格子是多大

2111
01:38:47,620 --> 01:38:49,210
一个字节

2112
01:38:49,210 --> 01:38:51,340
一个字节是八个比特是吧

2113
01:38:51,460 --> 01:38:54,190
那么内存的基本单位实际上就是字节

2114
01:38:54,190 --> 01:38:56,350
他不是他不是比特是字节

2115
01:38:56,350 --> 01:39:03,010
因为操作的时候就按字节拿的那一个整形它就是连续的这么四个

2116
01:39:03,540 --> 01:39:03,930
四个字

2117
01:39:04,170 --> 01:39:04,950
四个字节

2118
01:39:05,100 --> 01:39:08,310
这四个字节他就是去一个数

2119
01:39:08,310 --> 01:39:09,450
代表一个数

2120
01:39:09,870 --> 01:39:10,830
那么这个

2121
01:39:11,620 --> 01:39:13,690
整形那么浮点型呢

2122
01:39:13,690 --> 01:39:15,010
又分单精度浮点

2123
01:39:15,010 --> 01:39:15,850
双精度浮点

2124
01:39:16,000 --> 01:39:17,080
那么单精度浮点

2125
01:39:17,080 --> 01:39:21,580
双精度浮点它是什么意思浮点是什么意思

2126
01:39:21,790 --> 01:39:27,310
浮点就是小数点是浮动的咱们咱咱们往后看

2127
01:39:27,340 --> 01:39:29,290
A到H哪去了

2128
01:39:29,950 --> 01:39:31,450
那个那个浮点呢

2129
01:39:32,730 --> 01:39:34,500
浮点浮点

2130
01:39:35,800 --> 01:39:36,670
浮点

2131
01:39:36,670 --> 01:39:37,630
这个浮点

2132
01:39:38,540 --> 01:39:39,740
浮点的特性了

2133
01:39:40,190 --> 01:39:41,390
浮点的类型呢

2134
01:39:44,870 --> 01:39:45,830
查找一下吧

2135
01:39:47,400 --> 01:39:48,870
那

2136
01:39:54,200 --> 01:39:55,250
浮点在这儿

2137
01:39:56,000 --> 01:39:58,820
Float是单精度浮点数双

2138
01:39:58,850 --> 01:39:59,750
那么W呢

2139
01:39:59,750 --> 01:40:00,980
是双精度浮点数

2140
01:40:01,190 --> 01:40:03,590
单精度浮点数是四个字节

2141
01:40:03,770 --> 01:40:06,200
双精度是八个字节

2142
01:40:06,440 --> 01:40:09,320
那么浮点是什么意思

2143
01:40:09,650 --> 01:40:11,030
夫夫点是什么意思

2144
01:40:11,210 --> 01:40:12,590
咱们回想一下

2145
01:40:13,020 --> 01:40:16,740
回想一下在上中学的时候吧

2146
01:40:16,740 --> 01:40:17,130
对吧

2147
01:40:17,190 --> 01:40:18,270
初中的时候

2148
01:40:18,300 --> 01:40:19,320
咱们学过什么

2149
01:40:19,380 --> 01:40:20,610
科学计数法

2150
01:40:21,000 --> 01:40:22,470
科学计数法是什么样的

2151
01:40:22,620 --> 01:40:25,800
比如说比如说510

2152
01:40:25,800 --> 01:40:28,170
510用科学计数法是什么

2153
01:40:28,260 --> 01:40:35,160
是是怎么表示5.1乘十的二次方

2154
01:40:36,050 --> 01:40:37,700
对吧

2155
01:40:37,700 --> 01:40:38,930
5.1乘十的二次方

2156
01:40:39,080 --> 01:40:40,970
这是科学计数法

2157
01:40:41,210 --> 01:40:44,510
它写成他还有一种表示方法是什么呢

2158
01:40:44,570 --> 01:40:48,410
不写十的二次方a写成什么呢

2159
01:40:48,410 --> 01:40:48,860
5.1

2160
01:40:48,890 --> 01:40:49,700
然后呢

2161
01:40:50,420 --> 01:40:51,380
一二

2162
01:40:52,310 --> 01:40:55,580
这个一二代表就是十的二次方

2163
01:40:56,210 --> 01:40:58,010
这是科学计数法

2164
01:40:58,250 --> 01:41:02,660
那么五点儿510可以写成5.1乘十的平方

2165
01:41:02,780 --> 01:41:04,100
也可以写成什么

2166
01:41:04,430 --> 01:41:06,830
也可以写成51

2167
01:41:06,890 --> 01:41:07,760
然后呢

2168
01:41:08,790 --> 01:41:09,690
一

2169
01:41:10,930 --> 01:41:11,530
对吧

2170
01:41:11,860 --> 01:41:14,350
也可以写成五十一五一一

2171
01:41:14,960 --> 01:41:16,820
他变成科学计数法

2172
01:41:16,820 --> 01:41:20,570
就是51乘十的一次方

2173
01:41:20,840 --> 01:41:22,070
还可以写成什么

2174
01:41:22,220 --> 01:41:27,440
零点儿五一乘十的三次方

2175
01:41:27,560 --> 01:41:30,500
来科学计数法回想起来了吧

2176
01:41:30,770 --> 01:41:31,610
那么咱们看

2177
01:41:31,610 --> 01:41:36,620
500亿用科学计数法可以表示成这么多种方式

2178
01:41:37,060 --> 01:41:37,660
对吧

2179
01:41:38,450 --> 01:41:39,590
那么这个小数点儿

2180
01:41:39,590 --> 01:41:41,210
他在一直在动

2181
01:41:42,240 --> 01:41:42,780
对不

2182
01:41:42,990 --> 01:41:44,550
小数点儿一直在动

2183
01:41:44,700 --> 01:41:45,450
这叫什么

2184
01:41:45,480 --> 01:41:51,090
这叫浮点浮点浮点小数点在浮动浮动的小数点儿

2185
01:41:51,330 --> 01:41:54,420
那么这个浮点数在计算机里边儿表示

2186
01:41:55,070 --> 01:41:57,800
在在计算机里面表示他是什么样的

2187
01:41:57,860 --> 01:41:59,330
在内存里面什么样的

2188
01:41:59,880 --> 01:42:00,750
比如说啊

2189
01:42:00,870 --> 01:42:02,400
比如说这个

2190
01:42:03,260 --> 01:42:03,920
浮点数

2191
01:42:03,980 --> 01:42:06,080
浮点数在内存里边儿站

2192
01:42:06,640 --> 01:42:07,450
四个字节

2193
01:42:08,340 --> 01:42:12,960
四个字节它占32位32个比特位

2194
01:42:13,410 --> 01:42:15,120
那么这32个比特位

2195
01:42:15,150 --> 01:42:18,090
第一个比特位干什么用表示

2196
01:42:18,940 --> 01:42:19,840
正负号

2197
01:42:20,360 --> 01:42:28,040
第一个比特位是正还是负然后第二个到第多少个我王乐

2198
01:42:28,130 --> 01:42:28,820
他这个

2199
01:42:28,880 --> 01:42:30,890
这个区域怎么那个那个标准

2200
01:42:30,890 --> 01:42:32,810
我王乐到第若干位

2201
01:42:33,950 --> 01:42:35,150
它代表什么呢

2202
01:42:35,450 --> 01:42:36,800
它就代表

2203
01:42:37,680 --> 01:42:38,160
这个

2204
01:42:39,320 --> 01:42:40,400
他就代表这个

2205
01:42:42,910 --> 01:42:45,820
不是一前面这个数字

2206
01:42:45,820 --> 01:42:47,260
他就代表一前面这个

2207
01:42:47,440 --> 01:42:50,800
然后后边儿剩下的代表什么呢

2208
01:42:51,040 --> 01:42:54,310
后边儿代表IE后边这个数字

2209
01:42:54,310 --> 01:42:56,020
全都是按二进制去表示

2210
01:42:56,640 --> 01:43:00,570
那这是浮点数在内存里边儿的样子

2211
01:43:00,840 --> 01:43:02,040
先是正负号

2212
01:43:02,040 --> 01:43:04,260
然后是一前边儿的二进制表示

2213
01:43:04,290 --> 01:43:06,060
然后示意后边的二进制表示

2214
01:43:06,390 --> 01:43:08,100
那么一后边儿的二进制表示

2215
01:43:08,250 --> 01:43:09,270
那么在这个里边

2216
01:43:09,270 --> 01:43:11,430
这个这个一它不是石蜡

2217
01:43:11,940 --> 01:43:12,390
对吧

2218
01:43:12,510 --> 01:43:13,710
在计算机里边

2219
01:43:13,710 --> 01:43:14,970
这个一它不是时

2220
01:43:15,150 --> 01:43:15,960
他是什么

2221
01:43:16,140 --> 01:43:16,890
它是二

2222
01:43:17,220 --> 01:43:17,790
它是二

2223
01:43:18,180 --> 01:43:20,010
那这个就是

2224
01:43:21,750 --> 01:43:23,490
一个数字

2225
01:43:24,050 --> 01:43:26,390
这个a是这这一段

2226
01:43:26,690 --> 01:43:28,490
然后乘以什么呢

2227
01:43:28,520 --> 01:43:29,900
乘以二的

2228
01:43:30,460 --> 01:43:31,210
B次方

2229
01:43:31,360 --> 01:43:32,290
那么这个B

2230
01:43:32,920 --> 01:43:33,820
它在这儿表示

2231
01:43:34,400 --> 01:43:35,390
正负号呢

2232
01:43:35,420 --> 01:43:37,100
正负号在这儿表示来

2233
01:43:37,100 --> 01:43:43,340
这是计算机里边儿去表示小数点儿代表是小数这浮点数那么

2234
01:43:44,170 --> 01:43:45,040
这个double呢

2235
01:43:45,130 --> 01:43:46,750
Double占的内存更长

2236
01:43:46,780 --> 01:43:48,430
它的精度更高

2237
01:43:48,430 --> 01:43:51,100
因为你能表示的数字它就这么长

2238
01:43:51,730 --> 01:43:52,120
对吧

2239
01:43:52,210 --> 01:43:53,170
超过这个范围

2240
01:43:53,170 --> 01:43:54,670
它它就不准了

2241
01:43:54,760 --> 01:43:55,810
她就表示不出来了

2242
01:43:55,990 --> 01:43:57,070
那么64位呢

2243
01:43:57,070 --> 01:44:00,850
它它它这个数可表能够表示有效数字

2244
01:44:00,880 --> 01:44:03,280
能够表示的这个有效数字他更多

2245
01:44:04,550 --> 01:44:08,630
他更多这个a它就是个整数二进制的整数

2246
01:44:09,840 --> 01:44:12,630
二进制的整数后边儿这个事儿是指数

2247
01:44:13,840 --> 01:44:14,530
这是指数

2248
01:44:15,070 --> 01:44:16,210
它可以表示

2249
01:44:16,210 --> 01:44:18,730
它可以表示它可以表示所有的数字

2250
01:44:19,930 --> 01:44:21,550
表示可以表示所有的数字

2251
01:44:23,420 --> 01:44:23,660
好

2252
01:44:23,660 --> 01:44:24,080
然后呢

2253
01:44:24,080 --> 01:44:28,310
咱们那个这是那个浮点数浮点数这个类型呢

2254
01:44:28,490 --> 01:44:31,490
那么这个这个什么长整型

2255
01:44:31,490 --> 01:44:32,180
短整型

2256
01:44:32,180 --> 01:44:33,530
还有字符型等等

2257
01:44:33,710 --> 01:44:35,360
这些都是整形的一种

2258
01:44:35,390 --> 01:44:36,260
它们的区别呢

2259
01:44:36,260 --> 01:44:38,150
就是占用内存的大小不一样

2260
01:44:38,510 --> 01:44:40,640
正常的整型占四个字节

2261
01:44:40,640 --> 01:44:42,770
短整型占两个字节

2262
01:44:43,640 --> 01:44:45,200
短整型占两个字节

2263
01:44:45,320 --> 01:44:48,050
那那么那个字符型呢

2264
01:44:48,110 --> 01:44:49,490
字符型占一个字节

2265
01:44:50,430 --> 01:44:52,110
那字符型占一个字节

2266
01:44:52,290 --> 01:44:54,180
你不能不能不能一副数

2267
01:44:54,180 --> 01:44:57,090
你负数你复述不就变成分数了吗

2268
01:44:58,320 --> 01:44:58,800
对吧

2269
01:44:59,040 --> 01:45:00,870
你复数就变成分数了吧

2270
01:45:01,290 --> 01:45:02,910
就就就哈哈

2271
01:45:15,960 --> 01:45:17,790
具体有那个规范

2272
01:45:18,120 --> 01:45:18,870
有那个规范

2273
01:45:18,870 --> 01:45:20,670
在那个公众号里边儿发过这个东西

2274
01:45:21,240 --> 01:45:23,280
发过这个浮点数相关的东西

2275
01:45:23,550 --> 01:45:24,660
那个那个叫啥规范

2276
01:45:24,660 --> 01:45:28,350
叫IE1多少多少编号儿王乐

2277
01:45:33,640 --> 01:45:34,270
就是这个

2278
01:45:34,820 --> 01:45:37,160
具体的咱们看那个看那个规范

2279
01:45:37,920 --> 01:45:38,610
浮点数

2280
01:45:39,420 --> 01:45:42,720
阿琪是这个

2281
01:45:42,720 --> 01:45:46,350
754IE754他他就是浮点数的这个规范

2282
01:45:46,440 --> 01:45:47,400
就是这个东西

2283
01:45:47,400 --> 01:45:49,410
具体他怎么弄的仔细看那个

2284
01:45:50,270 --> 01:45:52,370
具体怎么具体具体看这个了

2285
01:45:55,220 --> 01:45:55,430
好

2286
01:45:55,430 --> 01:45:56,690
然后咱们再回来

2287
01:45:57,080 --> 01:45:58,640
再回到回到这儿来

2288
01:45:58,820 --> 01:45:59,390
回到这儿来

2289
01:45:59,390 --> 01:46:00,980
然后是整形

2290
01:46:00,980 --> 01:46:01,700
Inch型

2291
01:46:01,700 --> 01:46:02,510
Short型

2292
01:46:02,510 --> 01:46:03,140
Char型

2293
01:46:03,140 --> 01:46:04,100
还有long

2294
01:46:04,370 --> 01:46:05,060
Long呢

2295
01:46:05,060 --> 01:46:07,790
具体的具体的都都在这说明了

2296
01:46:07,790 --> 01:46:09,410
他都在这儿有所说明

2297
01:46:09,500 --> 01:46:11,120
另外还有长长整型

2298
01:46:11,120 --> 01:46:11,960
朗朗啊

2299
01:46:11,960 --> 01:46:13,250
朗朗是64位的

2300
01:46:15,000 --> 01:46:16,140
占八个字节

2301
01:46:17,830 --> 01:46:19,090
那么后边儿还有什么呢

2302
01:46:19,090 --> 01:46:25,480
有符号整型和无符号整型有符号整型就是表能够表示正负数儿

2303
01:46:25,480 --> 01:46:26,890
这个无符号整型呢

2304
01:46:26,920 --> 01:46:29,110
就是不能表示负数

2305
01:46:29,880 --> 01:46:35,370
他这个C语言这些那C语言里边这这这些类的类型分的是很细的

2306
01:46:35,370 --> 01:46:37,320
非常非常的非常非常的细

2307
01:46:37,590 --> 01:46:43,320
那么当然我们还可以去创建自己的类型后边咱们那个下节课

2308
01:46:43,320 --> 01:46:45,960
下节课给大家去讲怎么去创建自己的类型

2309
01:46:46,850 --> 01:46:50,540
自己的类型是你什么花样都有

2310
01:46:50,810 --> 01:46:51,230
还有呢

2311
01:46:51,230 --> 01:46:52,250
各种各样的

2312
01:46:52,310 --> 01:46:54,140
各种各样的这个语句

2313
01:46:54,140 --> 01:46:56,090
还有怎么去声明这个字符串

2314
01:46:56,090 --> 01:46:58,100
怎么去声明数组

2315
01:46:58,190 --> 01:46:59,780
这这这些东西

2316
01:47:01,220 --> 01:47:03,410
基本的语法有点耐心

2317
01:47:03,410 --> 01:47:06,950
把它给看完半小时半小时就看完了

2318
01:47:06,980 --> 01:47:08,300
然后后边儿呢

2319
01:47:08,330 --> 01:47:11,930
后边儿需要后边需要咱们去那个啥的

2320
01:47:12,170 --> 01:47:15,320
需要咱们去那个稍微费点儿时间呢

2321
01:47:15,320 --> 01:47:16,640
就是那个指针

2322
01:47:16,700 --> 01:47:17,990
而这个指针呢

2323
01:47:18,050 --> 01:47:19,070
它可以指向

2324
01:47:19,870 --> 01:47:22,930
指向那个可以指向数据

2325
01:47:22,960 --> 01:47:24,520
也可以指向函数

2326
01:47:25,700 --> 01:47:26,690
可以指向数据

2327
01:47:26,690 --> 01:47:28,310
也可以指向函数

2328
01:47:28,430 --> 01:47:30,350
TS跟他可不一样

2329
01:47:30,590 --> 01:47:32,330
TS跟他可一点儿都不一样

2330
01:47:32,330 --> 01:47:35,420
就是就是语法上看上去看上去像

2331
01:47:35,420 --> 01:47:37,670
实际上TS是啥呀

2332
01:47:38,420 --> 01:47:41,690
TSTS就是一种编译型的脚本语言

2333
01:47:42,690 --> 01:47:45,780
他是编译成另外一种脚本的

2334
01:47:46,360 --> 01:47:46,900
脚本

2335
01:47:47,460 --> 01:47:47,970
He

2336
01:47:48,300 --> 01:47:48,660
他

2337
01:47:48,660 --> 01:47:49,920
他就在那儿拐弯儿

2338
01:47:52,430 --> 01:47:55,370
那个实际上那个这个这个指针部分

2339
01:47:55,370 --> 01:47:58,700
指针部分是是比较难以理解的

2340
01:47:58,700 --> 01:48:00,890
但是咱们了解了内存以后呢

2341
01:48:00,920 --> 01:48:02,270
去学这个指针

2342
01:48:02,360 --> 01:48:03,350
那就轻松

2343
01:48:03,380 --> 01:48:05,990
那就会轻松很多那么轻松

2344
01:48:06,050 --> 01:48:08,750
那这个指针主要就是两种

2345
01:48:08,750 --> 01:48:10,130
一类是指向

2346
01:48:10,690 --> 01:48:13,120
指向函数的一类是指向数据的

2347
01:48:13,480 --> 01:48:15,940
指向数据咱们好理解对吧

2348
01:48:16,000 --> 01:48:17,830
这个数据在内存里面什么位置

2349
01:48:17,860 --> 01:48:19,810
那指向函数是什么意思呢

2350
01:48:20,140 --> 01:48:22,540
函数本身它就是代码

2351
01:48:23,350 --> 01:48:26,140
对不对函数本身是代码a

2352
01:48:26,290 --> 01:48:31,390
那么指向函数的指针实际上就是指向代码的指针那个指针

2353
01:48:31,960 --> 01:48:32,770
有了指针

2354
01:48:32,770 --> 01:48:36,040
你可以随意的去操作这个内存呢

2355
01:48:36,250 --> 01:48:37,420
在很久以前

2356
01:48:37,480 --> 01:48:39,070
那个程序员很无聊

2357
01:48:39,070 --> 01:48:40,450
无聊的时候干什么

2358
01:48:40,660 --> 01:48:42,760
他们他们还写代码

2359
01:48:42,850 --> 01:48:48,520
只不过他们用这个代码去去那个去去去做游戏

2360
01:48:49,520 --> 01:48:51,290
他们用代码做游戏呢

2361
01:48:51,290 --> 01:48:52,130
游戏是什么

2362
01:48:52,130 --> 01:48:53,390
叫代码大战

2363
01:48:54,460 --> 01:48:56,590
叫叫内存大战不要代码大战

2364
01:48:56,590 --> 01:48:57,460
叫内存大占

2365
01:48:57,880 --> 01:48:59,800
内存大战是怎么玩儿的

2366
01:49:00,010 --> 01:49:01,810
就是这么一块内存

2367
01:49:01,810 --> 01:49:04,720
让操作系统分出一块内存来之后

2368
01:49:05,890 --> 01:49:08,920
之后两个人写两段代码

2369
01:49:09,250 --> 01:49:10,150
写两段代码

2370
01:49:10,180 --> 01:49:12,820
然后这两段代码干什么呢

2371
01:49:13,400 --> 01:49:14,660
这两段代码干什么

2372
01:49:15,170 --> 01:49:17,870
比如说a代码还有B代码

2373
01:49:17,870 --> 01:49:19,010
这么两段两个人

2374
01:49:19,370 --> 01:49:23,540
然后他们要想办法让自己活下来

2375
01:49:23,630 --> 01:49:25,430
然后呢把对方搞死

2376
01:49:25,900 --> 01:49:27,280
怎么把对方搞死

2377
01:49:27,370 --> 01:49:28,450
就是操作内存

2378
01:49:29,460 --> 01:49:31,680
去找到对方所在的内存

2379
01:49:31,680 --> 01:49:33,960
然后把这个内存把它改掉

2380
01:49:33,960 --> 01:49:35,220
然后就把对方搞死了

2381
01:49:35,310 --> 01:49:35,880
同时呢

2382
01:49:35,880 --> 01:49:36,810
要保护自己

2383
01:49:36,930 --> 01:49:38,160
他怎么保护自己

2384
01:49:38,400 --> 01:49:41,670
要把自己移动到内存的其他方式呢

2385
01:49:41,670 --> 01:49:42,750
其他的位置

2386
01:49:43,280 --> 01:49:45,740
那这就产生了好多策略呢

2387
01:49:45,740 --> 01:49:48,020
比如说有的代码它干什么

2388
01:49:48,110 --> 01:49:51,620
去他去在他给自己去复制

2389
01:49:51,620 --> 01:49:55,580
他就他把自己复制复制多份复制多份

2390
01:49:55,640 --> 01:49:56,390
然后呢

2391
01:49:56,510 --> 01:50:01,040
他要保存它要保存自己在这多份当中的这个位置

2392
01:50:01,100 --> 01:50:02,900
然后别人去去覆盖它

2393
01:50:02,900 --> 01:50:03,830
覆盖了这个

2394
01:50:03,890 --> 01:50:08,120
然后其他的还活着这是一种策略

2395
01:50:08,240 --> 01:50:09,440
还有这是保存

2396
01:50:09,590 --> 01:50:10,880
这是那个存活策略

2397
01:50:11,000 --> 01:50:12,740
还有一种策略就是攻击策略

2398
01:50:12,830 --> 01:50:14,300
攻击策略怎么攻击

2399
01:50:14,540 --> 01:50:19,430
随机随机去把自己写到内存当中的某一个位置

2400
01:50:19,430 --> 01:50:23,270
当然不能把自己覆盖掉这这这这是那个内存大站

2401
01:50:23,450 --> 01:50:28,670
那你玩内存大战就得去就得去把这个指针玩的溜溜的

2402
01:50:29,820 --> 01:50:31,290
那就得把指针玩的溜溜的

2403
01:50:31,290 --> 01:50:32,310
这是C语言的

2404
01:50:32,310 --> 01:50:35,250
这C语言的C加加C加加玩儿不了这个

2405
01:50:35,340 --> 01:50:37,200
C加加完这个比较难

2406
01:50:37,470 --> 01:50:38,520
这叫内存大战

2407
01:50:38,550 --> 01:50:39,810
有这个模拟器

2408
01:50:40,600 --> 01:50:42,100
很久以前我还玩儿过

2409
01:50:48,520 --> 01:50:49,450
有模拟器

2410
01:50:57,430 --> 01:50:59,170
现在不好找了

2411
01:50:59,170 --> 01:51:00,880
内存大战的模拟器不好找了

2412
01:51:02,790 --> 01:51:05,010
这个玩意儿

2413
01:51:05,490 --> 01:51:07,320
真的是不好找了

2414
01:51:07,560 --> 01:51:09,990
这这玩意儿以前那个一搜一搜都是

2415
01:51:09,990 --> 01:51:12,030
现在都是什么都是什么东西

2416
01:51:14,240 --> 01:51:15,740
不找了

2417
01:51:16,280 --> 01:51:19,550
回来回到这个C语言这儿来呢

2418
01:51:19,760 --> 01:51:21,170
那么这个指针

2419
01:51:21,170 --> 01:51:22,370
咱们咱们这节课呢

2420
01:51:22,370 --> 01:51:25,070
先给大家讲一下这个指针

2421
01:51:25,070 --> 01:51:26,900
指针的这个二级指针

2422
01:51:26,930 --> 01:51:29,690
一级指针和二级指针然后下节课呢

2423
01:51:29,690 --> 01:51:31,190
详细给大家去讲

2424
01:51:31,400 --> 01:51:35,000
详细给大家去讲那个指向指向函数的指针

2425
01:51:35,000 --> 01:51:37,730
还有那个结构体那个结构体

2426
01:51:37,730 --> 01:51:40,820
有点儿像对象结构体有点儿像对象

2427
01:51:40,820 --> 01:51:41,210
但是呢

2428
01:51:41,210 --> 01:51:48,620
和那个对象有着本质的区别对象里边是可以有数据又可以可以有函数的

2429
01:51:48,620 --> 01:51:51,200
但是结构体里边儿只能有数据不能有函数

2430
01:51:52,240 --> 01:51:54,310
你非要让里边有函数怎么办

2431
01:51:54,430 --> 01:51:55,450
你在里边儿

2432
01:51:55,510 --> 01:51:58,300
得去加上一个特殊数据

2433
01:51:58,330 --> 01:52:03,310
特殊数据就是指向函数的指针用用那个东西去模拟

2434
01:52:03,520 --> 01:52:04,450
这是C语言的

2435
01:52:04,630 --> 01:52:05,830
而这个C加加呢

2436
01:52:05,950 --> 01:52:07,690
C加加就很复杂了

2437
01:52:07,690 --> 01:52:09,190
语法和C差不多

2438
01:52:09,190 --> 01:52:09,730
但是呢

2439
01:52:09,730 --> 01:52:12,970
多了好多面向对象的特性这这些特性呢

2440
01:52:13,180 --> 01:52:16,180
咱们那个也是后边的课给大家说

2441
01:52:16,210 --> 01:52:18,550
然后咱们那个先说啥呢

2442
01:52:18,550 --> 01:52:23,650
先说这个内存和指针那么这个指针是什么东西呢

2443
01:52:23,650 --> 01:52:27,160
只真是个什么东西这个指针分广义的

2444
01:52:27,600 --> 01:52:29,250
解释和狭义的解释

2445
01:52:30,580 --> 01:52:33,130
指针分广义的解释和狭义的解释

2446
01:52:33,280 --> 01:52:34,810
狭义的解释是什么呢

2447
01:52:34,900 --> 01:52:38,320
狭义的解释指针它实际上就是一个变量

2448
01:52:38,320 --> 01:52:41,020
这个变量里面保存的是内存地址

2449
01:52:41,020 --> 01:52:42,070
这是狭义的解释

2450
01:52:42,340 --> 01:52:43,600
那么广义的解释呢

2451
01:52:43,660 --> 01:52:46,390
广义的解释就直接认为

2452
01:52:47,070 --> 01:52:48,540
指针就是地址

2453
01:52:49,630 --> 01:52:50,620
这是广义解释

2454
01:52:50,890 --> 01:52:55,030
那么狭义解释更能体现出它的这个特性来这个指针的特性来

2455
01:52:55,240 --> 01:52:59,770
只要那个指针指针他确实是个地址没错但是呢

2456
01:52:59,770 --> 01:53:01,690
这个地址你把它保存在哪儿呢

2457
01:53:01,780 --> 01:53:05,320
你得把它保存到指针类型的变量里

2458
01:53:06,330 --> 01:53:07,230
这是指针

2459
01:53:07,230 --> 01:53:08,580
这这是狭义呢

2460
01:53:08,850 --> 01:53:10,710
必须得了解这个狭义呢

2461
01:53:10,710 --> 01:53:14,220
这个狭义的概念那么这个内存

2462
01:53:14,220 --> 01:53:17,460
内存他要有内存地址对吧

2463
01:53:17,520 --> 01:53:19,140
内存它是什么样

2464
01:53:19,260 --> 01:53:22,050
非常非常长的这么一个纸条儿

2465
01:53:22,050 --> 01:53:24,840
原来给大家做过这个相关的这个比喻

2466
01:53:24,990 --> 01:53:26,760
内存是一个非常非常长的纸条

2467
01:53:26,790 --> 01:53:28,620
上面有好多好多的小格子

2468
01:53:28,710 --> 01:53:30,450
一个小格子就是一个字节

2469
01:53:30,720 --> 01:53:33,450
那么我们要找这个小格子里边的数据

2470
01:53:33,480 --> 01:53:35,670
必须先得找到这个格子是吧

2471
01:53:35,670 --> 01:53:37,440
找数据必须得找到这个格子

2472
01:53:37,560 --> 01:53:39,090
你怎么找到这个格子

2473
01:53:39,150 --> 01:53:40,950
从你得数数

2474
01:53:40,950 --> 01:53:43,260
从前往后数第几个格子

2475
01:53:43,410 --> 01:53:44,550
ID几个格子

2476
01:53:44,730 --> 01:53:46,740
第100个格子是吧

2477
01:53:46,800 --> 01:53:47,430
然后呢

2478
01:53:47,460 --> 01:53:52,890
这是第这是第210个格子这是第250个格子对吧

2479
01:53:52,890 --> 01:53:55,260
这个一百二百一二百五

2480
01:53:55,260 --> 01:53:56,010
这是什么

2481
01:53:56,130 --> 01:53:58,590
这是那个地址

2482
01:53:59,180 --> 01:54:00,470
他是第几个格子

2483
01:54:00,500 --> 01:54:01,700
它就是这个地址

2484
01:54:01,700 --> 01:54:04,040
这个内存地址是是是这么回事儿

2485
01:54:04,370 --> 01:54:05,630
那么接下来呢

2486
01:54:05,630 --> 01:54:09,830
是指针地址和引用这三个概念是什么东西

2487
01:54:10,070 --> 01:54:11,000
这三个概念

2488
01:54:11,150 --> 01:54:12,860
指针刚才说了对吧

2489
01:54:12,890 --> 01:54:14,480
地址刚才也说了

2490
01:54:14,480 --> 01:54:16,340
指针狭义的解释

2491
01:54:16,340 --> 01:54:20,600
狭义的解释就是一就是这个保存这个地址的这么一个变量

2492
01:54:21,170 --> 01:54:22,430
那么饮用呢

2493
01:54:22,460 --> 01:54:23,720
引用是什么东西

2494
01:54:23,930 --> 01:54:25,820
引用他是一个高级特性

2495
01:54:25,850 --> 01:54:28,100
在C语言里面是没有用的

2496
01:54:28,100 --> 01:54:29,030
大家要记住

2497
01:54:29,090 --> 01:54:31,040
C语言里边儿是没有用的

2498
01:54:31,420 --> 01:54:32,920
在C加加里用引用

2499
01:54:32,950 --> 01:54:34,480
C语言里没有

2500
01:54:34,570 --> 01:54:35,620
在JS

2501
01:54:35,620 --> 01:54:36,250
Java啊

2502
01:54:36,250 --> 01:54:37,330
什么乱七八糟的

2503
01:54:37,330 --> 01:54:38,260
这些语言里边有

2504
01:54:38,620 --> 01:54:39,760
为什么要引用呢

2505
01:54:39,850 --> 01:54:41,500
因为指针

2506
01:54:41,530 --> 01:54:43,060
他非常的强大

2507
01:54:43,090 --> 01:54:44,530
也非常的灵活

2508
01:54:44,860 --> 01:54:48,370
但是随之而来的问题是什么

2509
01:54:48,800 --> 01:54:50,870
非常容易出错

2510
01:54:51,320 --> 01:54:53,210
实际上你在用指针的时候

2511
01:54:53,330 --> 01:54:55,730
你是在计算这个地址

2512
01:54:55,730 --> 01:54:57,020
你在计算这个地址

2513
01:54:57,170 --> 01:54:59,660
究竟我下一个内存的地址

2514
01:54:59,690 --> 01:55:02,270
我该操作操作哪一个地址啦

2515
01:55:02,300 --> 01:55:04,700
我得算出来给算出来

2516
01:55:05,060 --> 01:55:05,600
那么

2517
01:55:07,440 --> 01:55:08,730
这块数据

2518
01:55:08,730 --> 01:55:10,890
如果说你是动态申请的内存

2519
01:55:10,890 --> 01:55:12,270
你用完了这块儿

2520
01:55:12,270 --> 01:55:13,230
这块内存用完了

2521
01:55:13,230 --> 01:55:14,250
你得释放掉

2522
01:55:14,250 --> 01:55:15,630
你得还给操作系统

2523
01:55:15,990 --> 01:55:17,490
要不然就会造成内存泄漏

2524
01:55:18,120 --> 01:55:20,010
就是因为他有这么多特性

2525
01:55:20,160 --> 01:55:22,290
所以很容易出错

2526
01:55:22,470 --> 01:55:23,610
那怎么办

2527
01:55:24,030 --> 01:55:26,250
用引用把这个指针给封装起来

2528
01:55:26,850 --> 01:55:29,580
那那么引用把地址封装起来以后

2529
01:55:29,580 --> 01:55:32,700
你就不用去算这个地址究竟是什么了

2530
01:55:32,700 --> 01:55:34,530
究竟是在在什么地方了

2531
01:55:34,680 --> 01:55:35,400
直接

2532
01:55:36,790 --> 01:55:37,870
通过引用

2533
01:55:37,870 --> 01:55:40,420
它自动就给你算出来

2534
01:55:40,480 --> 01:55:41,290
在什么位置

2535
01:55:41,320 --> 01:55:43,330
然后你就找到这个数据了

2536
01:55:43,510 --> 01:55:46,390
所以饮用是对指针的封装

2537
01:55:47,100 --> 01:55:49,800
高级语言里边儿就不让你动指针

2538
01:55:50,740 --> 01:55:53,590
很多高级语言里边儿不让你动指针呢

2539
01:55:53,590 --> 01:55:55,420
只有少量的语言

2540
01:55:55,420 --> 01:55:57,790
只有少数的语言里面还保存着指针

2541
01:55:58,030 --> 01:55:58,720
但是呢

2542
01:56:00,000 --> 01:56:02,340
人家不建议你去乱用

2543
01:56:02,340 --> 01:56:04,290
能用引用就用引用

2544
01:56:04,290 --> 01:56:05,010
为什么呢

2545
01:56:05,130 --> 01:56:06,030
很容易出错

2546
01:56:06,120 --> 01:56:06,390
对吧

2547
01:56:06,390 --> 01:56:08,130
但是你你要操作一些

2548
01:56:08,160 --> 01:56:09,900
你要写一些偏底层的东西

2549
01:56:10,020 --> 01:56:10,890
要效率的东西

2550
01:56:10,890 --> 01:56:11,850
你还得用指针

2551
01:56:12,690 --> 01:56:13,620
这是为了这事

2552
01:56:13,620 --> 01:56:15,420
为了平衡这是为了平衡

2553
01:56:15,690 --> 01:56:18,810
但咱们JS一般都是写应用

2554
01:56:18,810 --> 01:56:19,290
对吧

2555
01:56:19,530 --> 01:56:24,540
JS一般写应用所所以说你就根本就不让你用指针你用了指针呢

2556
01:56:24,540 --> 01:56:25,680
那鸡怎么办

2557
01:56:25,920 --> 01:56:26,550
对吧

2558
01:56:26,640 --> 01:56:28,980
你你只针把把那个内呢

2559
01:56:28,980 --> 01:56:31,350
把那个数据移了位置了

2560
01:56:31,350 --> 01:56:32,430
JC不知道

2561
01:56:32,430 --> 01:56:33,720
GC到时候他释放不了

2562
01:56:33,720 --> 01:56:34,590
这这就乱套了

2563
01:56:35,880 --> 01:56:37,050
那么这个接着呢

2564
01:56:37,050 --> 01:56:38,700
就是这个指针的

2565
01:56:38,700 --> 01:56:40,110
这个指针的类型了

2566
01:56:40,170 --> 01:56:42,120
指针的类型

2567
01:56:42,880 --> 01:56:46,540
三种指针的类型有主主要是三种

2568
01:56:46,630 --> 01:56:48,580
第一是指向变量的指针

2569
01:56:48,580 --> 01:56:50,320
只要这个变量就是数据

2570
01:56:50,530 --> 01:56:51,130
对吧

2571
01:56:51,400 --> 01:56:53,350
变量就是数据然后呢

2572
01:56:53,350 --> 01:56:55,360
第二种是指向指针的指针

2573
01:56:56,060 --> 01:56:57,860
这个指针他也是一个变量

2574
01:56:58,480 --> 01:56:58,870
对吧

2575
01:56:58,870 --> 01:56:59,890
狭义的解释里边

2576
01:56:59,890 --> 01:57:01,390
指针它也是一个变量

2577
01:57:01,510 --> 01:57:02,800
这是指向指针的指针

2578
01:57:03,010 --> 01:57:03,610
第三个呢

2579
01:57:03,610 --> 01:57:04,870
是指向函数的指针

2580
01:57:04,960 --> 01:57:06,250
A指向函数的指针

2581
01:57:06,250 --> 01:57:07,150
它就是指向代码

2582
01:57:07,180 --> 01:57:11,680
因为代码也在内存里边儿那么咱们就先先干什么

2583
01:57:11,830 --> 01:57:14,200
这节课先把这俩搞清楚

2584
01:57:14,200 --> 01:57:16,600
下节课再给大家说这个指向函数的指针

2585
01:57:16,600 --> 01:57:19,360
咱们看代码是不是看到这个再给大家讲

2586
01:57:19,630 --> 01:57:21,970
然后咱们就看右边这个图

2587
01:57:21,970 --> 01:57:23,380
看右边的右边的图

2588
01:57:23,590 --> 01:57:24,790
那么左边

2589
01:57:24,850 --> 01:57:26,080
然后看右边

2590
01:57:26,420 --> 01:57:28,700
分成了两半儿分成两半儿

2591
01:57:28,880 --> 01:57:30,500
那么右边这个就是内存

2592
01:57:31,430 --> 01:57:32,330
右边这个是内存

2593
01:57:32,330 --> 01:57:33,830
只不过他被竖起来了

2594
01:57:33,950 --> 01:57:34,880
然后左边儿

2595
01:57:35,440 --> 01:57:39,310
有一个变量P有一个变量P

2596
01:57:40,540 --> 01:57:42,970
这个变量里面保存这个变量P

2597
01:57:42,970 --> 01:57:44,050
它是一个啥呀

2598
01:57:44,230 --> 01:57:47,020
他就是一个指针变量

2599
01:57:47,020 --> 01:57:48,460
它是个指针变量

2600
01:57:48,700 --> 01:57:50,980
这个指针变量里边保存的就是

2601
01:57:51,940 --> 01:57:54,250
数据在内存当中的地址

2602
01:57:54,820 --> 01:57:55,300
是吧

2603
01:57:55,450 --> 01:57:58,300
这个这个指针这个指针

2604
01:57:59,320 --> 01:58:00,340
P这个指针

2605
01:58:01,190 --> 01:58:02,720
它保存的这个变量

2606
01:58:03,590 --> 01:58:04,490
它的值

2607
01:58:05,920 --> 01:58:07,810
是用P来表示

2608
01:58:07,840 --> 01:58:10,150
用这个用这个P来表示

2609
01:58:10,330 --> 01:58:12,010
这个P实际上就是一个数字

2610
01:58:12,400 --> 01:58:17,890
数字就是对内存的编号那么这个这一块内存

2611
01:58:17,950 --> 01:58:20,500
这个内存它前边儿的这个

2612
01:58:21,190 --> 01:58:23,110
这个内存他的地址是什么呢

2613
01:58:23,140 --> 01:58:24,010
就是PI减一

2614
01:58:24,740 --> 01:58:25,820
那P减一

2615
01:58:26,300 --> 01:58:28,100
那地址减一对吧

2616
01:58:28,280 --> 01:58:31,790
它后边儿往后边儿隔着一个是什么

2617
01:58:31,850 --> 01:58:32,390
七加二

2618
01:58:32,510 --> 01:58:34,460
ID只加二这是

2619
01:58:35,610 --> 01:58:38,370
这就是那个指针的运算

2620
01:58:38,370 --> 01:58:40,740
指针只能加和减

2621
01:58:41,550 --> 01:58:44,760
那指针运算只能加和减

2622
01:58:44,790 --> 01:58:48,330
其他的运算是完全没有意义的

2623
01:58:48,330 --> 01:58:49,350
就好像是什么

2624
01:58:49,590 --> 01:58:50,850
就好像是那个

2625
01:58:51,500 --> 01:58:52,220
门牌号

2626
01:58:53,310 --> 01:58:53,760
对吧

2627
01:58:53,760 --> 01:58:57,630
你一条大街上面有好多有好多这个房子

2628
01:58:57,660 --> 01:58:59,850
每一个房子给他编一个门牌号

2629
01:59:00,120 --> 01:59:01,620
那么你要找

2630
01:59:01,650 --> 01:59:03,150
比如说你要找12号

2631
01:59:03,640 --> 01:59:04,000
对吧

2632
01:59:04,060 --> 01:59:05,500
你走到十号了

2633
01:59:05,650 --> 01:59:06,820
你你再往前

2634
01:59:07,030 --> 01:59:11,950
你在往前走两号儿这是加你你你你走到14号了

2635
01:59:11,950 --> 01:59:12,670
你走过了

2636
01:59:12,670 --> 01:59:15,580
你你得往回走两号

2637
01:59:15,580 --> 01:59:18,250
这叫简你要乘是什么意思

2638
01:59:18,430 --> 01:59:19,810
程他是没有意义的

2639
01:59:20,610 --> 01:59:21,210
对吧

2640
01:59:21,270 --> 01:59:22,560
你要歪打正着

2641
01:59:22,560 --> 01:59:25,980
你可能你大概能够找到那个位置

2642
01:59:26,130 --> 01:59:27,420
有可能能够找到位置

2643
01:59:27,630 --> 01:59:31,380
但是大部分时间是找不到的除就更没意义了

2644
01:59:31,740 --> 01:59:33,030
那么这个地址

2645
01:59:33,060 --> 01:59:34,290
他是从零开始的

2646
01:59:34,410 --> 01:59:35,940
我们要我们要注意

2647
01:59:36,210 --> 01:59:38,490
地址他没有付他没有付的

2648
01:59:38,580 --> 01:59:41,400
所以这个指针它的本质是个什么

2649
01:59:41,490 --> 01:59:45,120
它的本质是个无符号整数

2650
01:59:45,640 --> 01:59:47,110
无符号整数

2651
01:59:48,280 --> 01:59:53,950
指针它的值是一个无符号整型这么一个这么一个变量

2652
01:59:55,310 --> 01:59:57,560
但是他是但是但是他

2653
01:59:58,460 --> 01:59:59,720
是指针

2654
01:59:59,780 --> 02:00:01,010
但是它是指针类型

2655
02:00:02,720 --> 02:00:04,580
这是指针的那个

2656
02:00:04,610 --> 02:00:07,640
表示还有指针的运算加或者是减

2657
02:00:07,820 --> 02:00:10,400
然后咱们接着往后看

2658
02:00:10,580 --> 02:00:13,400
接着往后看那么这个指针

2659
02:00:13,760 --> 02:00:15,620
那么这个指针首先呢

2660
02:00:15,710 --> 02:00:18,740
咱们先说指向变量的指针

2661
02:00:19,610 --> 02:00:21,290
先说指向变量的指针

2662
02:00:21,290 --> 02:00:21,920
比如说呀

2663
02:00:22,070 --> 02:00:23,840
咱们这张图是什么意思呢

2664
02:00:24,050 --> 02:00:27,260
这张图咱们写代码是这样

2665
02:00:27,500 --> 02:00:28,730
In TEin TE

2666
02:00:29,240 --> 02:00:30,950
In TE还还写的太

2667
02:00:31,640 --> 02:00:33,050
我直接在那儿写吧

2668
02:00:33,200 --> 02:00:35,570
我直接在这儿写吧

2669
02:00:36,560 --> 02:00:37,220
比如说啊

2670
02:00:37,520 --> 02:00:40,310
咱们那个写一行

2671
02:00:40,310 --> 02:00:41,720
写一行代码

2672
02:00:43,280 --> 02:00:44,480
写一行代码

2673
02:00:44,810 --> 02:00:46,550
咱们有一个变量

2674
02:00:46,550 --> 02:00:49,670
变量是a in TE a

2675
02:00:50,590 --> 02:00:52,630
等于十

2676
02:00:52,630 --> 02:00:55,930
这是这是那个这是一行语句啦

2677
02:00:55,930 --> 02:00:58,150
C这C的语句

2678
02:00:58,690 --> 02:01:01,510
然后写完了这一行

2679
02:01:02,000 --> 02:01:03,830
那在内存里面是什么样呢

2680
02:01:04,040 --> 02:01:06,680
这个a这个变量

2681
02:01:07,100 --> 02:01:10,520
它会在内存里边儿找一个位置

2682
02:01:10,520 --> 02:01:11,510
找一个位置

2683
02:01:11,540 --> 02:01:12,230
然后呢

2684
02:01:12,350 --> 02:01:16,400
这个位置它的值给它设定成什

2685
02:01:16,940 --> 02:01:19,340
那么这个位置谁说了算呢

2686
02:01:19,610 --> 02:01:20,570
谁说了算呢

2687
02:01:20,570 --> 02:01:21,530
咱说了不算

2688
02:01:22,310 --> 02:01:23,030
谁说了算

2689
02:01:23,120 --> 02:01:25,490
编译器还有操作系统说了算

2690
02:01:26,410 --> 02:01:28,330
编译器他

2691
02:01:29,350 --> 02:01:31,270
他会他会干什么

2692
02:01:31,270 --> 02:01:32,920
在你的代码里边儿

2693
02:01:32,920 --> 02:01:34,480
某一行

2694
02:01:34,750 --> 02:01:38,050
代码里边这个二进制这个代码

2695
02:01:38,050 --> 02:01:39,460
二进制的这个代码

2696
02:01:39,940 --> 02:01:43,120
某一个位置给你设定成这个时儿

2697
02:01:43,120 --> 02:01:44,200
操作系统呢

2698
02:01:44,350 --> 02:01:48,520
操作系统把你的这个代码装到内存里边儿

2699
02:01:48,520 --> 02:01:49,630
装到内存里边儿去

2700
02:01:49,840 --> 02:01:50,680
装到内存里边儿

2701
02:01:50,680 --> 02:01:55,690
他不可能顶着你这个内存头儿这儿开始它会在内存中间找一个位置

2702
02:01:55,690 --> 02:01:59,800
这这是这是你这是你这个代码在在内存当中的位置

2703
02:01:59,890 --> 02:02:00,940
然后呢

2704
02:02:00,940 --> 02:02:03,670
他会给你计算出一个偏移量来

2705
02:02:04,600 --> 02:02:08,380
给你算出这个这个位置真正的这个偏移量

2706
02:02:08,380 --> 02:02:09,640
来算出这个偏移量

2707
02:02:09,640 --> 02:02:11,020
他就是真正内存的位置

2708
02:02:12,080 --> 02:02:16,700
那这一行咱们把这一行代码写完了

2709
02:02:16,880 --> 02:02:19,160
在内存里边儿某一个地址

2710
02:02:19,190 --> 02:02:21,260
这个就是内存的地址

2711
02:02:21,260 --> 02:02:22,370
他是16进制的

2712
02:02:22,520 --> 02:02:24,590
要注意这个地址16进制标志

2713
02:02:24,650 --> 02:02:25,580
然后这个呢

2714
02:02:25,580 --> 02:02:28,760
就是变量付给便赋给变量a的值

2715
02:02:29,000 --> 02:02:32,660
然后然后咱们该该用那个指针了

2716
02:02:32,750 --> 02:02:34,700
用指针怎么去用呢

2717
02:02:34,790 --> 02:02:39,590
咱们得有一个整数类型的指针P

2718
02:02:40,000 --> 02:02:44,050
那前面ins星黛表示整型指针

2719
02:02:44,640 --> 02:02:47,310
那整型指针这是一个类型

2720
02:02:47,340 --> 02:02:47,910
这是C

2721
02:02:47,940 --> 02:02:49,380
这是C语言里面一个类型

2722
02:02:49,650 --> 02:02:53,520
这个类型就是整数指针类型这个这个

2723
02:02:54,400 --> 02:02:57,760
变量P就是整数只新指针类型的一个变量

2724
02:02:58,060 --> 02:02:58,690
然后

2725
02:02:59,880 --> 02:03:01,830
这个有了这一行

2726
02:03:01,920 --> 02:03:05,430
在在内存里边儿也会有这个P的位置

2727
02:03:06,150 --> 02:03:07,890
也会有这个指针P的位置

2728
02:03:08,250 --> 02:03:10,950
那么指针P的位置有了

2729
02:03:10,950 --> 02:03:14,250
指针P里边它保存的值是谁

2730
02:03:14,490 --> 02:03:16,860
保存的值咱们看这个图

2731
02:03:17,010 --> 02:03:19,380
指针P它保存的这个值

2732
02:03:19,440 --> 02:03:21,360
那是变量a的地址

2733
02:03:21,390 --> 02:03:21,900
对吧

2734
02:03:21,930 --> 02:03:26,400
这两个值是一样的这而这个而这个指针P这个值

2735
02:03:26,960 --> 02:03:28,220
而且就是就是他

2736
02:03:28,760 --> 02:03:30,260
那后边的代码怎么写呢

2737
02:03:30,260 --> 02:03:31,310
后边儿代码是这样

2738
02:03:31,310 --> 02:03:33,560
你得给这个指针变量赋值

2739
02:03:33,560 --> 02:03:36,920
给它赋值怎么赋值P等于

2740
02:03:36,980 --> 02:03:38,570
那这个地址怎么来

2741
02:03:38,870 --> 02:03:39,800
从哪儿来的

2742
02:03:39,980 --> 02:03:42,710
咱们得找变量a的地址

2743
02:03:43,650 --> 02:03:44,880
得找变量a的地址

2744
02:03:45,090 --> 02:03:47,220
但是这样写是不行的

2745
02:03:47,220 --> 02:03:49,140
你不能让他等于爱

2746
02:03:49,290 --> 02:03:50,130
你等于爱

2747
02:03:50,130 --> 02:03:51,480
实际上是把这个值

2748
02:03:51,510 --> 02:03:53,640
是把a里边的值给父

2749
02:03:53,640 --> 02:03:54,510
给这个指针了

2750
02:03:55,140 --> 02:03:56,490
这就错了

2751
02:03:56,490 --> 02:03:57,960
编译器会给你报错的

2752
02:03:58,050 --> 02:03:59,550
它会告诉你类型

2753
02:03:59,670 --> 02:04:00,510
类型不匹配

2754
02:04:00,990 --> 02:04:02,370
那怎么去找他呢

2755
02:04:02,430 --> 02:04:03,270
怎么去找他

2756
02:04:03,390 --> 02:04:06,090
要取变量I的地址

2757
02:04:06,450 --> 02:04:07,560
那怎么取呢

2758
02:04:07,680 --> 02:04:08,970
用爱的符号

2759
02:04:09,800 --> 02:04:12,830
再一个变量前边儿用and的符号

2760
02:04:12,890 --> 02:04:14,390
它是取这个变量的地址

2761
02:04:14,940 --> 02:04:16,350
当然这一个APP

2762
02:04:16,350 --> 02:04:17,760
他还有其他的用法

2763
02:04:19,340 --> 02:04:20,120
其他的用法

2764
02:04:20,180 --> 02:04:20,870
比如说呀

2765
02:04:20,900 --> 02:04:23,480
在两个变量中间儿

2766
02:04:23,510 --> 02:04:26,390
这两个变量或者两个两个这个常量中间

2767
02:04:26,420 --> 02:04:27,290
比如说一

2768
02:04:29,070 --> 02:04:30,300
AND2这是在干什么

2769
02:04:30,300 --> 02:04:31,980
这是在做被运算

2770
02:04:32,130 --> 02:04:32,700
但是呢

2771
02:04:32,700 --> 02:04:36,480
你在一个变量的前边儿用这个and

2772
02:04:36,630 --> 02:04:38,190
它就是取这个变量的地址

2773
02:04:38,580 --> 02:04:40,890
所以说这一行代码

2774
02:04:40,920 --> 02:04:43,500
就是把变量a的地址取出来

2775
02:04:43,530 --> 02:04:44,280
然后呢

2776
02:04:44,400 --> 02:04:50,190
把这个地址赋值给指针P来在内存里边儿就是这个样子了

2777
02:04:51,260 --> 02:04:52,280
这是蜜

2778
02:04:52,280 --> 02:04:55,040
这是指向变量的指针

2779
02:04:55,850 --> 02:04:57,740
那指向变量的指针

2780
02:04:58,840 --> 02:05:01,210
那指针在内存里面是这样

2781
02:05:02,210 --> 02:05:03,620
在内存里边儿这样表示

2782
02:05:03,920 --> 02:05:04,940
这个好理解

2783
02:05:05,580 --> 02:05:06,300
对吧

2784
02:05:06,360 --> 02:05:07,710
这个好理解

2785
02:05:07,800 --> 02:05:09,030
就是在内存里边儿

2786
02:05:09,030 --> 02:05:10,680
我给你找一个变量

2787
02:05:10,740 --> 02:05:12,780
在内存里边儿有一个变量

2788
02:05:12,780 --> 02:05:14,640
这个变量它是一个整数的变量

2789
02:05:14,700 --> 02:05:15,270
然后呢

2790
02:05:15,270 --> 02:05:18,300
在内存另外一个地方还有一个变量

2791
02:05:18,300 --> 02:05:19,560
那个是指针的变量

2792
02:05:19,710 --> 02:05:21,600
然后指针变量它

2793
02:05:22,060 --> 02:05:28,060
通过指针变量找到那个那个那个那个那个普通的那个变量

2794
02:05:28,240 --> 02:05:29,290
找到它的位置

2795
02:05:29,960 --> 02:05:33,800
这是这这是那个普通的指针

2796
02:05:34,810 --> 02:05:36,070
指向变量的指针

2797
02:05:36,340 --> 02:05:40,900
那么这种指针它还有另外一个名字叫叫一级指针

2798
02:05:41,890 --> 02:05:43,240
指向变量的指针

2799
02:05:43,240 --> 02:05:45,010
它叫一级指针呢

2800
02:05:45,190 --> 02:05:46,510
另外还有什么呢

2801
02:05:47,370 --> 02:05:49,530
指向指针的指针

2802
02:05:50,530 --> 02:05:54,280
指向指针的指针指向指针的指针叫二级指针

2803
02:05:55,270 --> 02:05:58,060
那么这种二级指针是怎么回事儿

2804
02:05:58,090 --> 02:05:58,900
仍然是

2805
02:05:58,900 --> 02:06:02,860
咱们这儿这J这张图上就有代码了

2806
02:06:02,860 --> 02:06:04,840
前面in a等于十

2807
02:06:05,110 --> 02:06:05,500
对吧

2808
02:06:05,530 --> 02:06:07,270
A和前面是一模一样的

2809
02:06:07,450 --> 02:06:11,140
和刚才那个指向变量的指针试一试是一模一样的

2810
02:06:11,260 --> 02:06:12,070
然后呢

2811
02:06:12,070 --> 02:06:13,930
我们这儿有了一个一级指针

2812
02:06:13,960 --> 02:06:15,280
这是一级指针对吧

2813
02:06:15,280 --> 02:06:16,990
印特星P这是一级指针

2814
02:06:17,140 --> 02:06:19,150
它是指向的是a

2815
02:06:19,330 --> 02:06:19,930
他

2816
02:06:20,300 --> 02:06:22,340
它里面保存的是一个变量的地址

2817
02:06:22,550 --> 02:06:25,820
这个变量a把它给放到这儿了

2818
02:06:26,060 --> 02:06:26,630
然后呢

2819
02:06:26,630 --> 02:06:32,300
我们后面又有一个ins星星屁ins星星PF星星P是什么

2820
02:06:32,570 --> 02:06:35,900
指向指针变量的指针

2821
02:06:37,460 --> 02:06:39,350
指向指针变量的指针

2822
02:06:40,560 --> 02:06:45,300
那么这个P1这个ins星星PE这个指向指针的

2823
02:06:46,030 --> 02:06:48,040
指向指针变量的这个指针

2824
02:06:48,130 --> 02:06:49,300
他的名字是P1

2825
02:06:49,660 --> 02:06:53,680
那么这个P1它里边儿只能放屁的地址

2826
02:06:55,020 --> 02:06:57,180
那么这个P本身也是一个变量吗

2827
02:06:57,240 --> 02:07:00,810
通过N的符号把这个P的变量拿出来

2828
02:07:01,170 --> 02:07:01,920
把它放到这儿

2829
02:07:03,160 --> 02:07:05,950
那这个是P内存

2830
02:07:05,950 --> 02:07:08,890
这个是这个是P这个变量内存的样子

2831
02:07:10,280 --> 02:07:11,300
PP1

2832
02:07:11,300 --> 02:07:13,880
这个是P1这个变量内存里边的样子

2833
02:07:14,330 --> 02:07:16,220
那么PE的地址是她

2834
02:07:17,330 --> 02:07:18,440
PE的地址是她

2835
02:07:18,680 --> 02:07:20,570
PP的地址呢

2836
02:07:20,900 --> 02:07:22,190
P的地址是这个

2837
02:07:23,860 --> 02:07:25,600
那么PE的值呢

2838
02:07:25,630 --> 02:07:26,680
就是PD值

2839
02:07:27,100 --> 02:07:28,780
然后P的值

2840
02:07:28,960 --> 02:07:31,420
P的值是谁是变量a的地址

2841
02:07:32,970 --> 02:07:35,640
这是通过二级指针

2842
02:07:35,880 --> 02:07:38,520
然后去指向一级指针

2843
02:07:38,520 --> 02:07:41,100
一级指针再指向这个变量

2844
02:07:41,100 --> 02:07:42,840
中间跨了这么一下

2845
02:07:42,840 --> 02:07:43,800
中间跨了一下

2846
02:07:44,100 --> 02:07:45,270
那有同学说了

2847
02:07:45,300 --> 02:07:48,240
那你这么弄他多麻烦

2848
02:07:48,570 --> 02:07:49,860
这能干什么用

2849
02:07:50,630 --> 02:07:51,200
对吧

2850
02:07:51,290 --> 02:07:52,340
这能干什么用

2851
02:07:52,670 --> 02:07:54,170
这要就要回到哪儿了

2852
02:07:54,170 --> 02:07:55,040
回到计算

2853
02:07:55,070 --> 02:07:56,240
回到那个计算机

2854
02:07:57,090 --> 02:07:58,020
基本原理呢

2855
02:07:58,600 --> 02:08:00,910
Na在计算机里边儿

2856
02:08:01,180 --> 02:08:03,280
你去在内存

2857
02:08:03,310 --> 02:08:06,130
你去在内存当中去找数据

2858
02:08:06,810 --> 02:08:08,190
依靠的是什么

2859
02:08:08,430 --> 02:08:10,980
依靠的是寻址方式

2860
02:08:11,520 --> 02:08:13,230
寻址方式

2861
02:08:13,800 --> 02:08:15,120
什么寻址方式

2862
02:08:16,420 --> 02:08:17,080
这几个字

2863
02:08:22,040 --> 02:08:25,310
寻址那么在前边儿

2864
02:08:25,400 --> 02:08:28,010
在前面咱们给大家看了这个

2865
02:08:28,010 --> 02:08:29,630
看到这个东西

2866
02:08:29,870 --> 02:08:32,300
这个这个图从哪出来的

2867
02:08:32,330 --> 02:08:33,110
还记得吗

2868
02:08:33,170 --> 02:08:34,220
给大家说过

2869
02:08:34,280 --> 02:08:34,820
叫什么

2870
02:08:34,910 --> 02:08:37,640
8088杠8086汇编

2871
02:08:37,880 --> 02:08:40,430
那这本书这本教材里边儿是吧

2872
02:08:40,550 --> 02:08:41,390
非常经典

2873
02:08:41,390 --> 02:08:42,770
清华大学出版社的

2874
02:08:43,100 --> 02:08:44,270
当时我学的就是这本

2875
02:08:45,500 --> 02:08:50,750
在那本书里边就讲那个808086的这个

2876
02:08:50,750 --> 02:08:54,110
8086这个CPU的寻址方式讲了多少种

2877
02:08:55,200 --> 02:08:57,930
讲了多少种讲了16种

2878
02:08:58,550 --> 02:09:00,320
讲了16种寻址方式

2879
02:09:01,680 --> 02:09:02,250
有什么

2880
02:09:02,250 --> 02:09:04,770
有机制有立即寻址

2881
02:09:05,310 --> 02:09:06,300
现在这16种

2882
02:09:06,300 --> 02:09:07,920
我我记不得多少个了

2883
02:09:07,920 --> 02:09:08,820
哈哈

2884
02:09:08,820 --> 02:09:09,900
已经亡了很多了

2885
02:09:09,900 --> 02:09:12,570
我就记住几个就记住几个

2886
02:09:12,870 --> 02:09:14,970
第一个就是立即寻址

2887
02:09:15,330 --> 02:09:16,860
立即寻址就是这个

2888
02:09:17,650 --> 02:09:19,030
就是通过变量a

2889
02:09:19,620 --> 02:09:24,480
那就是通过变量a去得到去得到这个值

2890
02:09:24,810 --> 02:09:25,650
立即寻址

2891
02:09:26,680 --> 02:09:27,550
第二种呢

2892
02:09:27,550 --> 02:09:28,930
是间接寻址

2893
02:09:30,070 --> 02:09:32,020
第二种是间接寻址

2894
02:09:32,580 --> 02:09:34,410
间接寻址是啥呀

2895
02:09:34,590 --> 02:09:36,120
就是一级指针

2896
02:09:36,510 --> 02:09:39,720
先通过先找到变量的地址

2897
02:09:39,750 --> 02:09:44,160
再通过变量的地址去拿这个变量的值这是间接寻址

2898
02:09:45,190 --> 02:09:47,860
然后这个二级指针它也是间接寻址

2899
02:09:49,830 --> 02:09:50,430
但是呢

2900
02:09:50,430 --> 02:09:52,350
他是做的是两次

2901
02:09:52,900 --> 02:09:55,720
他做的是两次间接寻址

2902
02:09:55,720 --> 02:09:59,290
第一次间接寻址找的是指针P的地址

2903
02:09:59,560 --> 02:10:00,010
对吧

2904
02:10:00,040 --> 02:10:01,900
通过地址找比指针P的值

2905
02:10:02,230 --> 02:10:08,170
第二次间接寻址是通过指针P的值去找变量a的值

2906
02:10:09,030 --> 02:10:10,740
这是两次间接寻址

2907
02:10:10,890 --> 02:10:11,970
另外还有什么呢

2908
02:10:12,060 --> 02:10:14,790
基址寻址基址寻址

2909
02:10:14,850 --> 02:10:21,360
什么叫基址寻址几指就是找一个基础地址基础地址是不变的

2910
02:10:21,480 --> 02:10:22,860
然后去算偏移量

2911
02:10:23,870 --> 02:10:24,440
机制

2912
02:10:24,440 --> 02:10:27,440
这个机制寻址实际上就是指针的运算

2913
02:10:28,840 --> 02:10:30,490
一开始这个P指针

2914
02:10:30,490 --> 02:10:32,290
P指向的是这对吧

2915
02:10:32,320 --> 02:10:33,250
指向这个地址

2916
02:10:33,280 --> 02:10:37,270
然后在这个地址上进行加或者是减运算

2917
02:10:37,480 --> 02:10:39,880
那就在这个实际上算的就是这个

2918
02:10:40,400 --> 02:10:44,060
这个内存的这个数据在内存里面的偏移量

2919
02:10:44,990 --> 02:10:46,820
这这这叫机智

2920
02:10:47,000 --> 02:10:48,380
其他的我全都忘了

2921
02:10:48,650 --> 02:10:50,150
我就记住这么几种

2922
02:10:50,810 --> 02:10:53,210
当初也没当初也没好好学

2923
02:10:54,860 --> 02:10:56,600
就就学会了前面这么几种

2924
02:10:56,600 --> 02:10:58,850
后边儿的越学越饿

2925
02:10:58,910 --> 02:11:02,840
越学越越那个越麻烦

2926
02:11:02,870 --> 02:11:04,250
干脆就那啥了

2927
02:11:04,250 --> 02:11:05,300
干脆看一看

2928
02:11:05,300 --> 02:11:07,670
直直接翻了翻就就过去了

2929
02:11:07,820 --> 02:11:09,380
好歹那个考试过了

2930
02:11:14,600 --> 02:11:16,130
这就是二级指针了

2931
02:11:16,670 --> 02:11:17,780
然后下节课呢

2932
02:11:17,780 --> 02:11:20,060
给大家敲代码

2933
02:11:20,090 --> 02:11:23,300
下节课给大家敲代码帮助理解最后呢

2934
02:11:23,300 --> 02:11:24,710
就是这个内存

2935
02:11:24,710 --> 02:11:25,910
这个内存的这个

2936
02:11:26,420 --> 02:11:28,220
东的这个内存动态分配

2937
02:11:29,240 --> 02:11:30,350
内存动态分配

2938
02:11:30,350 --> 02:11:33,170
咱们要先了解C语言的内存分区

2939
02:11:34,230 --> 02:11:36,540
C语言的内存分区是啥样儿的

2940
02:11:37,860 --> 02:11:39,090
C语言内存分区

2941
02:11:39,240 --> 02:11:42,450
前面咱们说了程序的程序

2942
02:11:43,230 --> 02:11:44,670
程序在内存里边儿

2943
02:11:44,700 --> 02:11:45,960
它是分两段儿

2944
02:11:45,960 --> 02:11:47,220
一个是代码段

2945
02:11:47,220 --> 02:11:48,780
一个是数据段

2946
02:11:49,140 --> 02:11:53,490
那么C语言的这个内存

2947
02:11:53,520 --> 02:11:54,420
它分几段呢

2948
02:11:54,420 --> 02:11:55,230
分四段

2949
02:11:55,700 --> 02:11:57,590
C语言的内存分四段

2950
02:11:57,830 --> 02:11:58,760
但是呢

2951
02:11:58,850 --> 02:12:02,540
它仍然是基于代码段和数据段去分的

2952
02:12:03,080 --> 02:12:05,270
那那么代码段是什么呢

2953
02:12:05,270 --> 02:12:06,590
是程序代码区

2954
02:12:06,680 --> 02:12:08,720
它对应的是代码段儿

2955
02:12:08,720 --> 02:12:09,710
数据段呢

2956
02:12:09,740 --> 02:12:11,240
对应的是这三个区

2957
02:12:11,300 --> 02:12:12,920
这三个区全都释放数据的

2958
02:12:13,310 --> 02:12:14,360
那这三个区

2959
02:12:14,420 --> 02:12:16,010
一个区是战区

2960
02:12:16,010 --> 02:12:17,240
一个趋势堆区

2961
02:12:17,240 --> 02:12:18,740
还有一个是全局区

2962
02:12:19,950 --> 02:12:21,600
全局区也叫静态区

2963
02:12:22,560 --> 02:12:24,510
那么全局区就放全局变量

2964
02:12:24,510 --> 02:12:27,150
静态变量等等这些地方还有一些常量

2965
02:12:27,150 --> 02:12:28,020
比如说字符串呢

2966
02:12:28,020 --> 02:12:29,010
属于常量

2967
02:12:29,640 --> 02:12:31,200
所以放在这个全局区里

2968
02:12:31,620 --> 02:12:33,030
那战区呢

2969
02:12:33,030 --> 02:12:34,800
战区他就是

2970
02:12:35,380 --> 02:12:36,280
函数调用栈

2971
02:12:36,640 --> 02:12:39,550
那函数调用栈他在韩

2972
02:12:39,580 --> 02:12:41,320
他在那个进行函数调用的时候

2973
02:12:41,500 --> 02:12:45,400
得把当前作用域里边的局部变量的保存起来

2974
02:12:45,700 --> 02:12:46,360
对吧

2975
02:12:46,420 --> 02:12:48,220
保存在哪儿保存在站上

2976
02:12:48,460 --> 02:12:51,400
那咱们平时说一个函数调用栈

2977
02:12:51,400 --> 02:12:53,230
这个变量在调用函数的时候

2978
02:12:53,230 --> 02:12:54,730
那个变量保存在哪儿

2979
02:12:54,730 --> 02:12:57,490
保存在站上那个站指的是这个战区

2980
02:12:58,460 --> 02:12:59,270
另外还有一个呢

2981
02:12:59,270 --> 02:12:59,990
就是堆取

2982
02:13:00,020 --> 02:13:00,650
这个堆呢

2983
02:13:00,650 --> 02:13:05,750
就是用于内存动态分配那么对内存动态分配在C语言里边儿呢

2984
02:13:05,900 --> 02:13:07,700
用这个关键字malloc

2985
02:13:09,400 --> 02:13:10,180
又买lock

2986
02:13:11,800 --> 02:13:13,780
这个关键词看上去是个函数

2987
02:13:14,020 --> 02:13:15,010
看上去是个函数

2988
02:13:15,010 --> 02:13:18,160
实际上它是一个与她是一个关键字

2989
02:13:18,250 --> 02:13:19,360
他不是那个函数

2990
02:13:19,600 --> 02:13:26,380
那你这个就是告诉操作系统我要多么大的它的参数

2991
02:13:26,410 --> 02:13:28,930
在这个参数这儿填一个数字

2992
02:13:28,930 --> 02:13:32,800
必须得是个这必须得是个这个正整数

2993
02:13:32,800 --> 02:13:35,230
不能是零告诉操作系统我要多大

2994
02:13:35,290 --> 02:13:36,610
然后返回了

2995
02:13:36,640 --> 02:13:37,810
返回是个指针

2996
02:13:38,140 --> 02:13:38,950
返回一个指针

2997
02:13:38,950 --> 02:13:41,260
这个指针就是操作系统给你分配的这个内存

2998
02:13:41,260 --> 02:13:43,360
他在内存当中的位置是吧

2999
02:13:43,450 --> 02:13:44,470
返回值是个内存

3000
02:13:44,800 --> 02:13:46,660
它看上去像个函数

3001
02:13:46,840 --> 02:13:47,890
用上去也

3002
02:13:47,890 --> 02:13:50,410
用上去也是按照函数这个样子去用

3003
02:13:50,440 --> 02:13:52,750
但实际上它是C语言的一个关键字

3004
02:13:53,260 --> 02:13:54,700
那你用完了你得释放

3005
02:13:55,390 --> 02:13:55,810
对吧

3006
02:13:55,840 --> 02:13:57,790
你这个数这块内存你不要了

3007
02:13:57,790 --> 02:14:00,820
你得释放怎么释放free用free

3008
02:14:02,280 --> 02:14:03,600
这个关键字

3009
02:14:03,780 --> 02:14:05,610
那么福瑞里边就得放指针了

3010
02:14:06,880 --> 02:14:08,770
那么这个指针这个指针

3011
02:14:09,700 --> 02:14:10,540
是哪儿来的

3012
02:14:10,600 --> 02:14:12,880
从马唠嗑这儿的返回值

3013
02:14:12,880 --> 02:14:15,490
你用完了就要把这个地址

3014
02:14:16,450 --> 02:14:17,710
用free去释放

3015
02:14:17,830 --> 02:14:19,090
释放多大呢

3016
02:14:19,420 --> 02:14:20,710
操作系统知道

3017
02:14:20,710 --> 02:14:22,030
操作系统给你记下来

3018
02:14:22,030 --> 02:14:24,970
操作系统知道你所有请求的这个内存

3019
02:14:25,240 --> 02:14:26,740
你去free什么地方

3020
02:14:26,740 --> 02:14:30,520
操作系统就给你释放那么这一块儿是最容易出错的

3021
02:14:32,210 --> 02:14:33,800
在编码的时候最容易出错

3022
02:14:33,800 --> 02:14:36,680
因为你因为你这个指针是要经过运算的

3023
02:14:36,710 --> 02:14:38,030
如果说你经过运算了

3024
02:14:38,030 --> 02:14:41,600
你把原来的那个那个地址给丢了

3025
02:14:41,600 --> 02:14:42,650
你去福瑞的时候

3026
02:14:42,650 --> 02:14:45,590
操作系统肯定给你报错对吧

3027
02:14:46,070 --> 02:14:47,660
那么这一块儿

3028
02:14:47,660 --> 02:14:49,910
动态分配就是malloc free

3029
02:14:50,180 --> 02:14:51,410
那么C加加呢

3030
02:14:51,530 --> 02:14:54,110
C加加用的是new关键字

3031
02:14:54,500 --> 02:14:57,200
去申请动态申请内存是new关键字

3032
02:14:57,500 --> 02:15:00,500
那你是放就是迪丽特迪丽她

3033
02:15:03,450 --> 02:15:07,020
New关键字一个一个类对吧

3034
02:15:07,230 --> 02:15:09,300
New关键字一个类

3035
02:15:09,480 --> 02:15:10,620
比如说类a

3036
02:15:12,130 --> 02:15:15,880
然后返回值就是这个类a在内存里面的位置

3037
02:15:16,150 --> 02:15:17,170
那你砥砺他呢

3038
02:15:17,230 --> 02:15:19,390
砥砺他要要砥砺他这个地址

3039
02:15:19,780 --> 02:15:21,940
那保存这个地址的变量

3040
02:15:21,940 --> 02:15:23,800
和这这俩套路是一样的

3041
02:15:23,800 --> 02:15:24,850
就是关键字不一样

3042
02:15:25,120 --> 02:15:26,290
那么做这种操作

3043
02:15:26,290 --> 02:15:28,840
做这种操作他的数据在哪操作

3044
02:15:29,080 --> 02:15:30,250
就在堆区操作

3045
02:15:31,210 --> 02:15:32,740
那咱们JS里边呢

3046
02:15:32,860 --> 02:15:35,260
JS里面也有new关键字对吧

3047
02:15:35,650 --> 02:15:36,550
New关键字

3048
02:15:36,670 --> 02:15:38,290
那么你JS new关键字

3049
02:15:38,820 --> 02:15:39,870
他也是

3050
02:15:40,630 --> 02:15:43,660
在堆上只不过V吧

3051
02:15:43,660 --> 02:15:48,610
只不过V8的内存管理和CC语言的内存管理套路是不一样的

3052
02:15:48,610 --> 02:15:49,390
咱们后边儿

3053
02:15:49,390 --> 02:15:54,220
后边的课给大家讲他们的内存管理区别在哪儿

3054
02:15:56,420 --> 02:15:58,400
这个全局区或者静态区

3055
02:15:58,400 --> 02:15:59,540
这个就不用多说了

3056
02:15:59,540 --> 02:16:00,770
你程序初始化的时候

3057
02:16:00,770 --> 02:16:03,200
内全局变量等等就在这个地方

3058
02:16:03,200 --> 02:16:08,720
他只他只初始化一次这是C语言的内存的这个

3059
02:16:09,740 --> 02:16:11,480
这个内存的这个结构

3060
02:16:12,680 --> 02:16:13,760
那下节课呢

3061
02:16:13,820 --> 02:16:18,410
给大家咱们咱们那个带着大家去去那个

3062
02:16:19,470 --> 02:16:24,690
去去去去分析一下那个note JS的那个世界循环

3063
02:16:25,550 --> 02:16:27,050
那个世界循环的代码

3064
02:16:27,170 --> 02:16:27,920
然后呢

3065
02:16:28,070 --> 02:16:29,870
再分析那个代码的时候

3066
02:16:30,020 --> 02:16:31,730
再给大家去奖励

3067
02:16:31,730 --> 02:16:33,200
再深入的去讲这个

3068
02:16:33,530 --> 02:16:35,720
去讲一下这个指针还有呢

3069
02:16:35,720 --> 02:16:37,520
就是C语言的这个结构体

3070
02:16:37,850 --> 02:16:41,390
那那么在在那个时候给大家讲

3071
02:16:42,020 --> 02:16:46,880
C的内存管理和那个弄得JS的这个内存管理

3072
02:16:46,910 --> 02:16:48,740
他们之间的这个区别是什么

3073
02:16:50,100 --> 02:16:52,050
实际上弄得JS这个内存管理

3074
02:16:52,230 --> 02:16:55,980
他是直接向操作系统要来一大块内存

3075
02:16:55,980 --> 02:16:56,940
这一大块内存

3076
02:16:56,940 --> 02:16:59,460
然后就是弄的JS自己玩儿

3077
02:16:59,460 --> 02:17:00,900
他他需要什么内存呢

3078
02:17:00,900 --> 02:17:03,540
它它需要变量的时候

3079
02:17:03,570 --> 02:17:04,620
需要创建变量的时候

3080
02:17:04,620 --> 02:17:06,300
他就在他就直接在

3081
02:17:07,100 --> 02:17:10,010
内内那块儿地存里去去去折腾

3082
02:17:10,010 --> 02:17:11,570
他的堆也在这块儿大内存里

3083
02:17:11,810 --> 02:17:14,150
它就不持续地向操作系统内存了

3084
02:17:14,450 --> 02:17:15,530
而C语言呢

3085
02:17:15,740 --> 02:17:18,920
他要持续不断的向操作系统要内存

3086
02:17:18,920 --> 02:17:22,250
用完了以后要还给操作系统这这是他们两个

3087
02:17:22,520 --> 02:17:26,180
这是他们的这个区别那么在操作系统层面上呢

3088
02:17:26,180 --> 02:17:27,470
就更加复杂了

3089
02:17:27,470 --> 02:17:31,430
比如说操作系统为了高效的去给程序分配内存

3090
02:17:31,520 --> 02:17:35,090
他必须对内存进行一个分页

3091
02:17:35,870 --> 02:17:36,680
进行分页

3092
02:17:36,980 --> 02:17:37,790
然后呢

3093
02:17:37,820 --> 02:17:55,040
还要给这个程序去去那个去做一个那个需去映射一个虚拟地址空间让程序看起来它的它的这个成他的这个内存是连续的实际上操作系统给给内存分配的内存是不连续的

3094
02:17:55,190 --> 02:18:00,500
但是要让要要让程序看起来自己的成自己的内存是连续的

3095
02:18:00,500 --> 02:18:02,300
那就要做这个地址

3096
02:18:02,690 --> 02:18:04,400
空间的这么一个映射

3097
02:18:04,400 --> 02:18:07,160
这这就涉及到那个操作系统的具体实现上了

3098
02:18:07,190 --> 02:18:08,960
这这就很复很复杂了

3099
02:18:09,590 --> 02:18:09,800
好

3100
02:18:09,800 --> 02:18:10,790
今天的内容

3101
02:18:10,790 --> 02:18:11,600
就先讲到这儿

3102
02:18:11,630 --> 02:18:17,270
咱们这个明天后天都是这都是这个相关的内容明天呢

3103
02:18:17,270 --> 02:18:21,170
就是那个世界循环事件循环相关的

3104
02:18:21,170 --> 02:18:21,680
后天呢

3105
02:18:21,680 --> 02:18:24,710
就是那个V8V8的那个代码

3106
02:18:25,550 --> 02:18:25,760
好

3107
02:18:25,760 --> 02:18:26,210
今天啊

3108
02:18:26,210 --> 02:18:27,260
咱们先到这儿

3109
02:18:27,320 --> 02:18:28,880
今天先到这儿都是我讲

3110
02:18:28,910 --> 02:18:29,810
都是我讲

3111
02:18:29,960 --> 02:18:33,680
反正是我原来一开始不是给你给你说了嘛

3112
02:18:33,680 --> 02:18:35,720
也那个一开始不是跟你们说了吗

3113
02:18:35,720 --> 02:18:40,520
就是那个操作系统的网络的协议的

3114
02:18:40,520 --> 02:18:44,420
后端的还有底层的都是我讲

3115
02:18:44,420 --> 02:18:44,840
对吧

3116
02:18:45,530 --> 02:18:47,270
钱反正是前端的

3117
02:18:47,390 --> 02:18:49,430
真正涉及到前端的呢

3118
02:18:49,430 --> 02:18:51,320
那就是老袁了

3119
02:18:53,050 --> 02:18:55,150
那个明天是event

3120
02:18:55,150 --> 02:19:00,220
这就是那个明天是那个那个那个那个我想想

3121
02:19:04,770 --> 02:19:05,790
我课件儿呢

3122
02:19:08,380 --> 02:19:10,030
那个V8

3123
02:19:10,030 --> 02:19:11,080
V8引擎

3124
02:19:11,080 --> 02:19:13,900
就是那个V8和异步机制那个PPT

3125
02:19:13,900 --> 02:19:14,800
明天是那个

3126
02:19:18,850 --> 02:19:31,990
VBA宏任务鸿威任务这个咱们这个咱们暂时先不涉及是这个红任红什么红微任务这个V8这个宏威这个红这个微任务这个这个东西

3127
02:19:31,990 --> 02:19:34,060
在咱们公众号里都有文章

3128
02:19:34,060 --> 02:19:35,050
你可以去翻

3129
02:19:35,050 --> 02:19:36,640
咱们公众号里面啥都有

3130
02:19:36,640 --> 02:19:38,230
就是就是你你们就是不看

3131
02:19:38,760 --> 02:19:39,690
哈哈哈

3132
02:19:44,510 --> 02:19:44,810
对

3133
02:19:44,810 --> 02:19:46,010
明天讲那个

3134
02:19:46,010 --> 02:19:47,750
V8与异步极致

3135
02:19:47,750 --> 02:19:49,160
V8引擎羽翼不极致

3136
02:19:49,400 --> 02:19:50,150
明天讲这个

3137
02:19:50,600 --> 02:19:50,810
好

3138
02:19:50,810 --> 02:19:52,130
今天就先到这儿

3139
02:19:52,130 --> 02:19:53,060
明天咱们继续

3140
02:19:54,020 --> 02:19:54,500
拜拜

