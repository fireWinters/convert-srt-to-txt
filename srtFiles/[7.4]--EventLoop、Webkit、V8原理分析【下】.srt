1
00:01:28,610 --> 00:01:32,030
噔噔噔噔噔噔噔噔噔噔噔噔噔噔噔噔

2
00:05:06,260 --> 00:05:06,800
嗯

3
00:07:28,680 --> 00:07:28,920
What

4
00:08:17,720 --> 00:08:19,100
人都到齐了没

5
00:08:19,860 --> 00:08:21,390
怎么就这么几个人儿

6
00:08:21,900 --> 00:08:22,770
还没一半儿呢

7
00:08:23,250 --> 00:08:23,520
这

8
00:08:23,520 --> 00:08:26,010
这家伙得

9
00:08:29,400 --> 00:08:30,540
你们真够意思

10
00:08:32,380 --> 00:08:33,070
别急

11
00:08:33,070 --> 00:08:34,360
能不急吗这

12
00:08:46,640 --> 00:08:49,790
咱们那个准备了开始啦

13
00:08:49,790 --> 00:08:50,330
今天呢

14
00:08:50,330 --> 00:08:53,780
是那个什么什么人人干啥呢

15
00:08:53,780 --> 00:08:54,950
这莫名其妙的

16
00:09:19,500 --> 00:09:20,220
咱们开始啦

17
00:09:20,220 --> 00:09:22,080
不等他们那个

18
00:09:25,950 --> 00:09:26,400
这节课呢

19
00:09:26,400 --> 00:09:28,620
咱们讲那个V8V8引擎

20
00:09:28,650 --> 00:09:30,870
然后那个V8引擎源码

21
00:09:30,870 --> 00:09:35,280
还有那个上节课咱们提到过的那个lab的那个源码

22
00:09:35,280 --> 00:09:36,450
一个是C的源码

23
00:09:36,450 --> 00:09:38,790
一个是C加加的源码

24
00:09:38,790 --> 00:09:44,040
那个你还替五个点到这个这个这个不许替

25
00:09:44,040 --> 00:09:47,610
咱们先先说这个V8引擎V8引擎呢

26
00:09:48,030 --> 00:09:48,750
这个玩意儿

27
00:09:48,750 --> 00:09:51,120
是个好东西

28
00:09:51,120 --> 00:09:58,050
那个这个东西可以说这个这个就不用夸他了

29
00:09:58,050 --> 00:09:59,490
好到咱们都知道

30
00:10:00,300 --> 00:10:01,200
像那个

31
00:10:01,890 --> 00:10:05,820
像这个这个V8引擎呢

32
00:10:05,820 --> 00:10:06,720
浏览器里

33
00:10:06,720 --> 00:10:10,350
那个Chrome浏览器里边儿嵌嵌入这个东西

34
00:10:10,350 --> 00:10:10,830
另外呢

35
00:10:10,830 --> 00:10:12,720
像那个note JS也嵌入了

36
00:10:12,720 --> 00:10:13,680
这是咱们知道的

37
00:10:13,740 --> 00:10:15,300
实际上还有好多咱们不知道的

38
00:10:15,540 --> 00:10:19,260
不知道的那种那种那个系统里边儿

39
00:10:19,260 --> 00:10:23,280
也欠了这个V8这个V8是欠欠的V8干什么

40
00:10:23,370 --> 00:10:28,410
拿它当解释器有一些那个嵌入式的那种系统

41
00:10:28,410 --> 00:10:31,320
比如说像像一些那个嵌入式的板子

42
00:10:31,320 --> 00:10:36,330
那种那种开发板那种板子上像做开发版的那些厂商呢

43
00:10:36,330 --> 00:10:37,110
它在里边儿

44
00:10:37,380 --> 00:10:38,250
就加了他

45
00:10:38,250 --> 00:10:40,890
他在他给那个他给那个板子呢

46
00:10:40,890 --> 00:10:42,630
就开就开发出那个

47
00:10:43,800 --> 00:10:47,790
开发出那个一个定制出一个专专用的系统来然后呢

48
00:10:47,790 --> 00:10:49,110
你可以用这个JS

49
00:10:49,320 --> 00:10:59,640
你可以用JS去去去给那个板子去去去做开发这JS那种嵌入式那个里边儿他也那个系统里边他也给你欠了这个V8引擎

50
00:10:59,640 --> 00:11:15,060
但只不过他他欠的他他那个他欠的方式就不一样了另外还有好多的那种那些像像像一些那个可以用这种脚本驱动的一些一些系统

51
00:11:15,060 --> 00:11:20,640
你你比如说用用那个JS脚本驱动的内这种系统就太多了

52
00:11:20,670 --> 00:11:23,940
他里边儿也欠这个V8所以说这个这个V8

53
00:11:23,940 --> 00:11:29,760
他是一个神器如果说我们去去去研究一下他这个源码

54
00:11:29,760 --> 00:11:34,410
比如说像像这个是是是在哪儿呢

55
00:11:37,780 --> 00:11:39,610
一我那个那个那个

56
00:11:40,630 --> 00:11:42,760
我这个目录哈

57
00:11:42,760 --> 00:11:44,140
在这儿呢

58
00:11:44,380 --> 00:11:48,040
比如说我们看一眼那个V8的这个这个源码

59
00:11:48,040 --> 00:11:50,200
去找他的那个simple

60
00:11:50,200 --> 00:11:51,310
就是他的例子

61
00:11:51,310 --> 00:11:53,620
我们就可以看到

62
00:11:53,680 --> 00:11:56,110
像像这些用C加加写的

63
00:11:56,110 --> 00:11:58,240
用C加加写的这些这些源码

64
00:11:58,660 --> 00:12:01,270
他就是给你做了一个样子告诉你

65
00:12:01,270 --> 00:12:07,480
怎么在你自己的程序里边儿把这个把这个V8给嵌进去所以说

66
00:12:07,480 --> 00:12:08,650
这这这个东西

67
00:12:08,650 --> 00:12:09,670
这个东西的出现

68
00:12:09,670 --> 00:12:13,000
那那简直是绝了

69
00:12:13,030 --> 00:12:16,750
这这这这这就是整个的那个嵌嵌进去的流程

70
00:12:16,750 --> 00:12:18,670
倩倩进去之后你就不用管它了

71
00:12:18,940 --> 00:12:19,630
所以说呢

72
00:12:19,630 --> 00:12:20,440
那个no的

73
00:12:20,710 --> 00:12:22,780
所以说那个note JS呢

74
00:12:25,190 --> 00:12:26,990
它里边儿一个核心

75
00:12:26,990 --> 00:12:28,880
这这东西他都根本就不用写

76
00:12:29,300 --> 00:12:29,630
对吧

77
00:12:29,630 --> 00:12:31,370
直接拿过来往里一倩行了

78
00:12:31,370 --> 00:12:32,510
弄得JS有了

79
00:12:33,140 --> 00:12:34,760
然后一问他了

80
00:12:34,760 --> 00:12:37,550
把那个lab Le拿过来往里往里一塞

81
00:12:37,730 --> 00:12:40,310
剩下的就是他去写那个班钉子

82
00:12:40,310 --> 00:12:41,330
把benz写写

83
00:12:41,360 --> 00:12:44,960
然后把周围的一些那个库还有接口设计一下

84
00:12:45,050 --> 00:12:46,100
弄的JF就出来了

85
00:12:46,490 --> 00:12:52,010
那这个在讲那个这个微吧之前

86
00:12:52,010 --> 00:12:56,780
咱们先回顾一下原来给大家讲过的这个web kit这个web kit呢

87
00:12:57,420 --> 00:12:59,700
再讲那个浏览器渲染机制的时候

88
00:12:59,850 --> 00:13:00,930
给大家讲过

89
00:13:00,930 --> 00:13:01,920
当时那个图呢

90
00:13:01,920 --> 00:13:03,090
不如这个图的

91
00:13:03,090 --> 00:13:05,250
这个不如这个图复杂

92
00:13:05,370 --> 00:13:07,140
这个图东西更多

93
00:13:07,140 --> 00:13:09,270
当时给大家看的就就那么几大块儿

94
00:13:09,600 --> 00:13:12,540
那么这个渲染引擎里边儿

95
00:13:12,960 --> 00:13:14,610
像那个web k啊

96
00:13:14,610 --> 00:13:15,780
这个渲染引擎里边

97
00:13:15,930 --> 00:13:19,410
他欠的这个JS引擎叫JS号

98
00:13:20,100 --> 00:13:22,140
这个JS靠的是是苹果的

99
00:13:22,140 --> 00:13:24,390
是那个Apple他他们开发的

100
00:13:24,630 --> 00:13:27,420
当然这个Apple开发的这个JS扣呢

101
00:13:27,420 --> 00:13:28,590
它也是开源的

102
00:13:29,650 --> 00:13:31,060
他也开源

103
00:13:31,090 --> 00:13:32,350
但是呢

104
00:13:32,350 --> 00:13:33,340
当时啊

105
00:13:33,340 --> 00:13:35,680
当时那个他他开源晚了

106
00:13:35,680 --> 00:13:36,610
开源的比较晚

107
00:13:36,610 --> 00:13:37,360
V8先开源

108
00:13:37,390 --> 00:13:39,220
然后那个Apple他也开源

109
00:13:39,550 --> 00:13:41,290
所以那个V8有先发优势

110
00:13:41,470 --> 00:13:44,830
当然JS扣和那个V8它们有各自的

111
00:13:44,830 --> 00:13:48,850
他们各自有各自的这个这个特点

112
00:13:48,850 --> 00:13:50,110
他们内部实现的

113
00:13:50,140 --> 00:13:53,110
内部的在在内部这个实现当中呢

114
00:13:53,170 --> 00:13:54,370
也有很多差异

115
00:13:54,370 --> 00:13:55,180
但是呢

116
00:13:55,180 --> 00:13:57,460
他们这个语法支持都都是一样的

117
00:13:57,460 --> 00:14:00,250
都是按照那个规范走的

118
00:14:00,340 --> 00:14:02,080
就是那个JS的那种提案

119
00:14:02,110 --> 00:14:04,600
GS提案一旦一旦去敲定了

120
00:14:04,600 --> 00:14:05,290
一旦敲定了

121
00:14:05,290 --> 00:14:09,010
然后然后大家都都去按照那个提案去去实现

122
00:14:09,340 --> 00:14:11,440
那么这个在Chrome

123
00:14:11,440 --> 00:14:14,410
Chrome这这这这个这个浏览器里边儿

124
00:14:14,500 --> 00:14:18,940
它的这个渲染引擎就是脱胎于web kit这个框架

125
00:14:19,030 --> 00:14:20,800
这个大框架是一模一样的

126
00:14:21,070 --> 00:14:21,850
但是呢

127
00:14:23,370 --> 00:14:23,880
但是呢

128
00:14:23,880 --> 00:14:28,860
他的那个把里边好多东西全都给替换了

129
00:14:28,860 --> 00:14:30,510
内内代码一点一点替换

130
00:14:30,510 --> 00:14:32,130
这这已经十多年了

131
00:14:32,400 --> 00:14:36,030
这这十多年这十多年替换来替换去的

132
00:14:36,030 --> 00:14:44,400
现在原来的代码基本上没什么了那咱们今天那个重点就是就是这一块儿不当然不讲这个JS

133
00:14:44,400 --> 00:14:44,700
靠

134
00:14:44,880 --> 00:14:47,700
是给大家讲那个这个微吧那一块儿的

135
00:14:47,910 --> 00:14:48,540
然后

136
00:14:50,160 --> 00:14:51,720
JS引擎

137
00:14:51,810 --> 00:14:53,940
JS引擎和那个渲染引擎

138
00:14:54,000 --> 00:14:55,140
那在浏览器里边儿

139
00:14:55,200 --> 00:14:57,450
它结合的是非常的

140
00:14:57,750 --> 00:15:04,050
它结合的是非常非常紧密的那他紧密到它紧密到什么程度呢

141
00:15:04,200 --> 00:15:05,130
可以说

142
00:15:05,250 --> 00:15:06,375
是你中有我

143
00:15:06,375 --> 00:15:13,320
我中有你因为咱们再给大家讲那个浏览器渲染机制的时候

144
00:15:13,320 --> 00:15:20,700
咱们去给大家讲那个流程不知道大家还记不记得讲那个流程那个那个页面儿

145
00:15:21,080 --> 00:15:23,000
进入到浏览器里边儿去

146
00:15:23,030 --> 00:15:24,920
进入到这个渲染引擎先干什么

147
00:15:25,280 --> 00:15:30,530
那他先去解析到母解析到母如果说遇到了JS

148
00:15:31,460 --> 00:15:32,810
遇到了JS怎么办

149
00:15:32,870 --> 00:15:37,880
他会暂停解析盗墓当时给大家讲为什么会这样呢

150
00:15:37,880 --> 00:15:38,480
对吧

151
00:15:38,570 --> 00:15:40,850
为什么会会暂停

152
00:15:40,940 --> 00:15:43,580
因为当时给大家给大家说

153
00:15:43,580 --> 00:15:45,830
这是由于这两这两个引擎

154
00:15:45,830 --> 00:15:50,720
JS引擎和那个和盗墓解析内两块儿他们的

155
00:15:51,390 --> 00:15:54,120
这个他们之间这个同步的这个

156
00:15:54,740 --> 00:15:57,230
同步的机制造成的

157
00:15:57,230 --> 00:15:58,910
至于那个同步机制是咋回事呢

158
00:15:58,910 --> 00:16:03,680
咱们现在给大家说这个那么那个渲染引擎

159
00:16:03,710 --> 00:16:07,490
实际上渲染引擎他是依赖这个JS引擎的

160
00:16:08,420 --> 00:16:09,500
要要注意

161
00:16:09,560 --> 00:16:11,900
渲染引擎是依赖JS引擎

162
00:16:12,080 --> 00:16:13,400
那是内内上节课

163
00:16:13,400 --> 00:16:18,620
咱们不是给大家讲那个那个那个异步机制的时候

164
00:16:18,620 --> 00:16:21,530
给大家提了一下那个UML对吧

165
00:16:21,530 --> 00:16:25,370
简单的给大家讲了一下那个那个那个类图

166
00:16:25,400 --> 00:16:27,500
实际上这种这两个引擎

167
00:16:27,560 --> 00:16:29,630
这两个引擎他们之间的关系

168
00:16:29,630 --> 00:16:33,290
如果说用那个用那个类图画怎么画呢

169
00:16:33,410 --> 00:16:34,610
咱们画两个框

170
00:16:35,610 --> 00:16:36,420
画两个框

171
00:16:36,450 --> 00:16:37,200
然后呢

172
00:16:37,320 --> 00:16:42,000
这个是这个是渲染引擎render对吧

173
00:16:42,000 --> 00:16:43,170
咱们用R来表示

174
00:16:43,260 --> 00:16:47,520
然后这个是JSJJJS引擎咱们用G来表示

175
00:16:47,640 --> 00:16:50,190
然后它们之间的依赖

176
00:16:50,220 --> 00:16:53,460
是渲染引擎

177
00:16:53,490 --> 00:16:55,890
他依赖JS引擎

178
00:16:55,890 --> 00:16:57,270
是是这么一个关系

179
00:16:58,080 --> 00:16:58,950
那是这么关系

180
00:16:58,950 --> 00:17:09,090
并不是说这个JS引擎就就就是是并不是说JS引擎属于这这个这这个渲染引擎一部分不是不是这样

181
00:17:10,050 --> 00:17:11,190
就是两个独立的

182
00:17:11,460 --> 00:17:12,570
那也就是说呢

183
00:17:12,570 --> 00:17:15,900
既然渲染引擎要要依赖

184
00:17:16,400 --> 00:17:17,240
JS引擎

185
00:17:17,390 --> 00:17:18,890
那就是渲染引擎

186
00:17:18,890 --> 00:17:21,380
它要去掉JS引擎的接口

187
00:17:22,230 --> 00:17:23,940
这是直接掉

188
00:17:23,940 --> 00:17:26,130
直接去调这个接口是吧

189
00:17:26,460 --> 00:17:26,970
那么

190
00:17:28,370 --> 00:17:30,410
在咱们最最开始

191
00:17:30,410 --> 00:17:32,390
我把原来那个PPT也打开

192
00:17:32,390 --> 00:17:35,780
咱们对照着看那个PPT

193
00:17:35,780 --> 00:17:39,170
那个那个渲染机制的那个PPT

194
00:17:41,670 --> 00:17:43,350
渲染机制

195
00:17:45,120 --> 00:17:46,530
渲染机制呢

196
00:17:52,750 --> 00:17:53,230
坏了

197
00:17:53,230 --> 00:17:54,040
找不着了

198
00:18:06,530 --> 00:18:07,730
显然

199
00:18:10,150 --> 00:18:12,820
这俩不在一个地方

200
00:18:19,020 --> 00:18:19,980
等等我想想

201
00:18:19,980 --> 00:18:22,050
那个那个PPT放在哪儿了

202
00:18:31,470 --> 00:18:33,120
渲染机制

203
00:18:41,890 --> 00:18:42,790
找不见了

204
00:18:44,020 --> 00:18:45,010
稍等一分钟

205
00:18:45,010 --> 00:18:47,170
我我我那个找一下

206
00:18:47,830 --> 00:18:48,190
嗯

207
00:19:02,970 --> 00:19:04,080
在性能优化这

208
00:19:24,620 --> 00:19:25,400
在这儿

209
00:19:25,610 --> 00:19:26,360
在这个地方

210
00:19:28,220 --> 00:19:29,060
在这个地方

211
00:19:29,300 --> 00:19:32,510
那么那个渲染在在那个

212
00:19:33,630 --> 00:19:36,630
咱们将刚才讲到讲到这儿

213
00:19:36,690 --> 00:19:46,080
渲染引擎它是直接调JS引擎的这个接口儿来处理那个来处理里边儿那个那个结果

214
00:19:46,200 --> 00:19:47,130
然后呢

215
00:19:51,980 --> 00:19:52,880
然后呢

216
00:19:53,000 --> 00:19:54,740
在咱们的这个图里边儿

217
00:19:54,740 --> 00:19:57,650
咱们当时还给大家说过

218
00:19:57,710 --> 00:20:03,020
像那个AJS的这个解释器和

219
00:20:03,800 --> 00:20:05,510
到母树这个数据

220
00:20:05,540 --> 00:20:08,150
他们之间哈是个双向箭头

221
00:20:09,370 --> 00:20:09,820
对吧

222
00:20:09,850 --> 00:20:11,140
这是个双向箭头

223
00:20:11,350 --> 00:20:12,550
那说明什么呢

224
00:20:12,550 --> 00:20:19,150
也就是说JS引擎他还会反过来影响这个盗墓数咱们在解析盗墓的时候

225
00:20:19,150 --> 00:20:20,680
遇到JS这样去掉

226
00:20:20,680 --> 00:20:21,850
按照这个方向就过来

227
00:20:22,120 --> 00:20:22,810
然后呢

228
00:20:22,930 --> 00:20:24,670
当这个JS代码

229
00:20:24,880 --> 00:20:27,400
JS代码需要用到

230
00:20:27,400 --> 00:20:33,010
需要用到那个这个这个这个盗墓的结构的时候

231
00:20:33,100 --> 00:20:36,190
就要这样去回去那么这时候

232
00:20:36,190 --> 00:20:37,750
咱们在编码的时候

233
00:20:37,900 --> 00:20:43,480
这种情况咱们在编码的时候就会就会遇到一个麻烦这个麻烦叫什么

234
00:20:43,480 --> 00:20:45,100
叫循环调用

235
00:20:45,760 --> 00:20:46,990
他叫循环调用

236
00:20:46,990 --> 00:20:48,160
也就是说你掉我

237
00:20:48,160 --> 00:20:49,435
然后我再调你

238
00:20:49,435 --> 00:20:50,230
我调了你

239
00:20:50,230 --> 00:20:54,460
你再回来调我这叫双方互双方互相去掉

240
00:20:54,610 --> 00:20:58,720
那么这种循环调用将会导致一个非常严重的后果

241
00:20:58,720 --> 00:20:59,500
这个后果呢

242
00:20:59,500 --> 00:21:01,300
就是死锁

243
00:21:01,300 --> 00:21:02,590
就会死住了

244
00:21:02,740 --> 00:21:04,570
那它就相当于什么呢

245
00:21:04,780 --> 00:21:05,110
那

246
00:21:06,630 --> 00:21:07,800
它就相当于什么呢

247
00:21:07,890 --> 00:21:10,890
渲染引擎调调这个JS

248
00:21:10,920 --> 00:21:13,920
然后JS直接接口去掉

249
00:21:14,100 --> 00:21:17,130
然后JS反过来再去

250
00:21:18,230 --> 00:21:20,810
调这个渲染引擎里边的东西

251
00:21:21,200 --> 00:21:22,940
那这样转了一个圈

252
00:21:23,120 --> 00:21:24,590
那转圈的时候

253
00:21:24,680 --> 00:21:28,520
如果说JS在正在吊着这个渲染引擎的时候

254
00:21:28,520 --> 00:21:34,280
渲染引擎又回来去再去调这个JS反复的多次去掉这个JS2JS呢

255
00:21:35,250 --> 00:21:36,840
这这这一块儿还没调完呢

256
00:21:36,870 --> 00:21:38,370
然后渲染你又来调

257
00:21:38,580 --> 00:21:42,090
这个时候必定产生死锁必定产生死锁

258
00:21:42,240 --> 00:21:42,990
所以呢

259
00:21:43,080 --> 00:21:44,370
要解决这个问题

260
00:21:45,100 --> 00:21:47,350
要要那那怎么去解决呢

261
00:21:47,530 --> 00:21:51,790
在这个这在这个这个浏览器里边儿

262
00:21:51,790 --> 00:21:55,300
它用了一个特殊的这么一个方式这个方式是什么

263
00:21:55,330 --> 00:21:57,190
就是桥街街口

264
00:21:57,860 --> 00:21:59,000
桥接接口

265
00:21:59,330 --> 00:22:01,460
那么这个桥接接口是什么意思呢

266
00:22:01,610 --> 00:22:05,330
并不是说渲染引擎然后直接过来

267
00:22:05,330 --> 00:22:09,770
并不是说JS引擎直接过来去去去改这个渲染引擎里边东西

268
00:22:09,860 --> 00:22:10,580
而是呢

269
00:22:10,580 --> 00:22:12,920
中间来一个中间商

270
00:22:13,780 --> 00:22:14,830
来个中间商

271
00:22:14,860 --> 00:22:17,530
然后这个中间商干什么呢

272
00:22:17,710 --> 00:22:21,880
JS引擎像这个条街街口去发消息

273
00:22:21,880 --> 00:22:22,990
我要去改

274
00:22:23,020 --> 00:22:25,390
我要去改动哪一个

275
00:22:25,960 --> 00:22:28,240
到这个盗墓节点

276
00:22:28,270 --> 00:22:29,110
然后呢

277
00:22:29,140 --> 00:22:30,340
我不亲自改

278
00:22:30,700 --> 00:22:32,680
你给我把这个话传过去

279
00:22:32,680 --> 00:22:33,880
传到渲染引擎

280
00:22:33,880 --> 00:22:36,550
让渲染引擎去去给我处理a

281
00:22:36,670 --> 00:22:38,320
通过这种方式

282
00:22:38,590 --> 00:22:42,310
通过这种方式咱们就可以

283
00:22:44,450 --> 00:22:48,110
咱们就可以避免这个循环调用的这个问题

284
00:22:48,440 --> 00:22:51,950
那他的这个流程是是是是怎么样的呢

285
00:22:52,010 --> 00:22:56,330
首先渲染引擎它就解析到母解析盗墓的

286
00:22:56,330 --> 00:22:58,130
解析到JS的时候

287
00:22:58,190 --> 00:23:00,500
通过JS的调用接口

288
00:23:00,530 --> 00:23:01,130
然后呢

289
00:23:01,280 --> 00:23:05,630
把这个JS代码传给JS引擎这是

290
00:23:06,080 --> 00:23:08,270
这是这是在这儿对吧

291
00:23:08,270 --> 00:23:09,950
这是向下的那个箭头

292
00:23:10,130 --> 00:23:12,170
到亩数和这个解释器

293
00:23:12,170 --> 00:23:13,910
JS解释器向下的这个箭头

294
00:23:13,940 --> 00:23:14,960
然后呢

295
00:23:15,020 --> 00:23:18,230
JS引擎他就要执行这段代码了

296
00:23:18,440 --> 00:23:21,620
那你要用这段代码去操作一个到目的节点呢

297
00:23:21,890 --> 00:23:24,980
那那你你去操作到我们节点的话

298
00:23:24,980 --> 00:23:25,640
那好

299
00:23:25,760 --> 00:23:27,770
你把这个操作

300
00:23:28,750 --> 00:23:31,180
操作的这个规则

301
00:23:31,180 --> 00:23:36,160
通过桥接接口儿传回来再传回来

302
00:23:37,290 --> 00:23:38,610
那实际上呢

303
00:23:38,610 --> 00:23:40,890
这是发了一个数据过去

304
00:23:41,100 --> 00:23:43,050
或者说发了一个命令

305
00:23:43,050 --> 00:23:44,580
发了一个指令过去

306
00:23:44,790 --> 00:23:46,590
并不是直接通过

307
00:23:46,770 --> 00:23:51,810
并不是直接通过那个接口去掉的那这样呢

308
00:23:51,810 --> 00:23:52,350
咱就

309
00:23:53,100 --> 00:23:55,200
这样咱就不会死所了

310
00:23:55,380 --> 00:23:59,580
那么这个调用方式它究竟是怎么实现的呢

311
00:23:59,760 --> 00:24:07,260
还还记不记得上节课上节课给大家给给给大家讲讲那个疑问句luck的时候

312
00:24:07,440 --> 00:24:10,560
给大家提到了这个东西MFC

313
00:24:11,420 --> 00:24:11,990
对吧

314
00:24:12,110 --> 00:24:14,240
给大家提到了这个MFC

315
00:24:14,480 --> 00:24:18,110
那么这个MFC他用的是消息传递机制

316
00:24:18,350 --> 00:24:22,280
那么实际上这一套规则和那个消息传递机制

317
00:24:22,280 --> 00:24:24,380
有点儿像有点儿像

318
00:24:24,380 --> 00:24:28,640
但不完全像那个消息传递机制他是个大消息循环

319
00:24:28,640 --> 00:24:34,430
它里边儿她她她她也跟那个跟那个F的那个机制类似

320
00:24:34,550 --> 00:24:35,060
但是呢

321
00:24:35,060 --> 00:24:35,810
这个地方呢

322
00:24:35,810 --> 00:24:37,820
它它没有那个消息循环了

323
00:24:37,820 --> 00:24:39,710
你就直就直接消息传过来

324
00:24:39,710 --> 00:24:43,910
他在这儿被动的去被动的去那个去接收指令

325
00:24:43,910 --> 00:24:45,590
然后然后去做事儿就行了

326
00:24:46,220 --> 00:24:48,440
就按照按按和这个

327
00:24:49,230 --> 00:24:50,190
消息是差不多

328
00:24:50,190 --> 00:24:52,230
那么他传的消息是什么呢

329
00:24:52,380 --> 00:24:54,660
怎么操作什么分仍然是分两块儿

330
00:24:54,750 --> 00:24:56,280
一个是指令部分

331
00:24:56,340 --> 00:24:57,270
一个是指令部分

332
00:24:57,270 --> 00:24:59,430
一个是数据部分就是干什么

333
00:24:59,490 --> 00:25:01,050
删除节点对吧

334
00:25:01,080 --> 00:25:02,700
或者说移动节点

335
00:25:02,730 --> 00:25:04,290
或者说增加节点

336
00:25:04,290 --> 00:25:05,640
这是那个指令

337
00:25:05,820 --> 00:25:08,670
那么你要删除删除哪个节点

338
00:25:08,670 --> 00:25:09,300
这是数据

339
00:25:09,810 --> 00:25:10,290
对吧

340
00:25:10,350 --> 00:25:11,460
然后移动节点

341
00:25:11,460 --> 00:25:14,160
你要把哪个节点移动到什么地方

342
00:25:14,160 --> 00:25:15,630
这也是数据

343
00:25:15,630 --> 00:25:18,840
你要你要你要那个增加结点

344
00:25:18,840 --> 00:25:23,670
增加的节点增加到哪儿那增加的那个节点他长什么样

345
00:25:23,820 --> 00:25:25,200
这这也是数据

346
00:25:25,200 --> 00:25:26,070
所以说呢

347
00:25:27,490 --> 00:25:28,600
所以说呢

348
00:25:28,780 --> 00:25:30,430
用这种方式

349
00:25:31,040 --> 00:25:37,010
用这种方式并不是JS引擎直接去调渲染引擎的接口了

350
00:25:37,010 --> 00:25:41,420
而是走这个桥街中间搭了个桥

351
00:25:41,600 --> 00:25:42,530
中间搭了个桥

352
00:25:42,530 --> 00:25:51,530
我不直接去掉这这叫桥接那么这种这种东西是咱们那个在各种系统里边

353
00:25:51,530 --> 00:25:53,120
在这个底层开发里边儿

354
00:25:53,150 --> 00:25:55,790
各种系统里边都是都是比较常见的

355
00:25:56,090 --> 00:25:59,180
比如说在Linux里边儿也有类似的这个

356
00:25:59,180 --> 00:26:00,470
也有类似的这个机制

357
00:26:00,530 --> 00:26:00,950
他叫什么

358
00:26:00,950 --> 00:26:01,610
他叫slot

359
00:26:02,670 --> 00:26:04,560
这这这这种Linux

360
00:26:04,560 --> 00:26:06,360
你去做这个

361
00:26:06,630 --> 00:26:08,070
你去做那个界面儿

362
00:26:08,310 --> 00:26:09,240
界面儿那个开发

363
00:26:09,240 --> 00:26:11,040
他没有消息循环对吧

364
00:26:11,130 --> 00:26:12,990
他给你提供这个slot

365
00:26:13,140 --> 00:26:15,090
他叫什么槽他叫曹

366
00:26:15,210 --> 00:26:16,650
这个东西在在在哪儿呢

367
00:26:16,650 --> 00:26:19,230
就是QT哈内那个QT

368
00:26:20,810 --> 00:26:21,350
QT呢

369
00:26:21,350 --> 00:26:24,200
这这这这个开发工具里边给给提供的

370
00:26:24,200 --> 00:26:25,580
它也是封装的

371
00:26:25,580 --> 00:26:26,840
也是封装的这个东西

372
00:26:26,870 --> 00:26:29,810
实际上他底层它底层是恶风

373
00:26:29,810 --> 00:26:32,540
装的是啥啥啥玩意儿信号

374
00:26:33,280 --> 00:26:37,660
通过信号去那个啥桥接会有就会有啥作用

375
00:26:37,660 --> 00:26:38,770
我刚讲完

376
00:26:39,040 --> 00:26:41,770
我刚讲完你就问桥接会有啥作用

377
00:26:41,890 --> 00:26:45,970
桥接就是你不用为了防止这个死锁

378
00:26:45,970 --> 00:26:47,590
你在调用的时候死所

379
00:26:49,370 --> 00:26:52,610
你渲染引擎掉了JS引擎的API

380
00:26:52,610 --> 00:26:55,820
然后你在这个APIJSAPI里边儿

381
00:26:55,820 --> 00:26:58,580
你在反过来调渲染引擎

382
00:26:58,700 --> 00:26:59,990
这必定死所不信

383
00:26:59,990 --> 00:27:01,250
你自己写写个代码

384
00:27:01,250 --> 00:27:02,480
是是你写两个函数

385
00:27:02,510 --> 00:27:03,680
函数一调函数二

386
00:27:03,680 --> 00:27:05,060
然后函数二再调函数一

387
00:27:05,090 --> 00:27:06,170
你试试呢

388
00:27:06,170 --> 00:27:07,670
必定你的程序就不动了

389
00:27:08,000 --> 00:27:09,350
那100%它不动了

390
00:27:09,890 --> 00:27:14,030
你这这这这这这活是不能这么干的

391
00:27:14,090 --> 00:27:15,800
有会有啥作用呢

392
00:27:15,800 --> 00:27:16,790
就是这作用

393
00:27:16,790 --> 00:27:18,800
防止这种防止这种情况

394
00:27:19,070 --> 00:27:21,140
那因为这种这种工作

395
00:27:21,140 --> 00:27:23,990
是是有有两个模块儿配合

396
00:27:24,380 --> 00:27:26,120
有两个模块配合去完成的

397
00:27:27,220 --> 00:27:30,580
你你你还要防止这个恶锁住

398
00:27:30,670 --> 00:27:31,390
那那不得了

399
00:27:31,390 --> 00:27:32,680
你你等我做完

400
00:27:32,680 --> 00:27:34,720
我也等你做完来互相等

401
00:27:34,960 --> 00:27:37,240
那那就那就玩不了了

402
00:27:37,990 --> 00:27:40,030
这就是为了这个

403
00:27:51,380 --> 00:27:52,940
那么这个JS引擎

404
00:27:52,970 --> 00:27:54,440
JS引擎和那个

405
00:27:55,320 --> 00:27:57,990
渲染引擎他们之间的这个调用关系

406
00:27:57,990 --> 00:28:00,660
咱咱们咱们聊聊解了之后

407
00:28:01,050 --> 00:28:01,590
然后呢

408
00:28:01,590 --> 00:28:04,500
咱们看咱们就到那个JS引擎内部

409
00:28:05,490 --> 00:28:07,410
看看它内部的那个

410
00:28:07,410 --> 00:28:08,550
它内部的工作流程

411
00:28:08,760 --> 00:28:09,930
这个渲染引擎

412
00:28:11,110 --> 00:28:12,190
咳咳

413
00:28:13,570 --> 00:28:15,190
这个这个JS引擎

414
00:28:15,250 --> 00:28:16,780
那他原来

415
00:28:16,780 --> 00:28:18,820
最很早之前那个JS引擎

416
00:28:18,850 --> 00:28:22,690
他和现在他那个内部实现机制是完全不一样的

417
00:28:23,720 --> 00:28:25,460
那在V8出现之前

418
00:28:25,520 --> 00:28:27,920
也有很多的这个JS引擎的

419
00:28:27,920 --> 00:28:32,780
比比如说像那个像那个华为华为那个鸿蒙对吧

420
00:28:32,900 --> 00:28:35,360
原来也给大家也给大家提过

421
00:28:35,450 --> 00:28:36,890
那个鸿蒙系统呢

422
00:28:36,890 --> 00:28:39,560
他做他做那个界面的

423
00:28:39,560 --> 00:28:46,430
他他他他他自己提供的那个做做界面的那个那个功能它实际上和和那个小程序是类似的

424
00:28:46,940 --> 00:28:47,480
对吧

425
00:28:47,510 --> 00:28:53,000
和小程序那个和小程序的那个内套机制是类似的

426
00:28:53,000 --> 00:28:54,320
那是类似的

427
00:28:54,320 --> 00:28:57,170
你你就你就只能用JS去给他写界面

428
00:28:57,410 --> 00:29:02,600
那么那个鸿蒙再再再那个发布的那天

429
00:29:02,600 --> 00:29:03,290
发布的那天

430
00:29:03,290 --> 00:29:04,550
然后我去研究它的代码

431
00:29:04,550 --> 00:29:07,880
研究到那个凌晨一点

432
00:29:07,880 --> 00:29:09,260
我在干什么

433
00:29:09,260 --> 00:29:14,330
我就在在找她那个我我就看他一个模块一个模块地看然后呢

434
00:29:14,330 --> 00:29:16,100
就看到他那个UI部分

435
00:29:16,250 --> 00:29:17,690
UI部分一看

436
00:29:17,690 --> 00:29:20,270
赫赫小程序的架构是是类似的

437
00:29:20,420 --> 00:29:23,030
那他肯定肯定需要JS引擎

438
00:29:23,240 --> 00:29:25,040
然后我就找他那个JS引擎

439
00:29:25,040 --> 00:29:26,720
我看他引的是哪一个库

440
00:29:26,720 --> 00:29:27,770
我看了半天

441
00:29:27,770 --> 00:29:29,330
发现不是note JS啊

442
00:29:29,420 --> 00:29:33,590
而是一个叫什么quick JS叫quick JS

443
00:29:33,710 --> 00:29:34,490
那个东西

444
00:29:34,730 --> 00:29:39,380
像这种这种JS引擎特别特别特别多

445
00:29:39,380 --> 00:29:40,100
非常非常多

446
00:29:40,250 --> 00:29:43,790
但是那个quick JS比那个代码量是非常非常少的

447
00:29:43,790 --> 00:29:45,320
比这个VBA的代码量呢

448
00:29:45,320 --> 00:29:47,120
那少的不少的呢

449
00:29:47,260 --> 00:29:49,840
可能是那可以说是两个数量级

450
00:29:49,840 --> 00:29:51,430
那可以可以说俩数量急了

451
00:29:51,760 --> 00:29:55,360
那但是那个quick he s he hev8比起来

452
00:29:55,480 --> 00:29:56,440
她差在哪儿呢

453
00:29:56,710 --> 00:29:57,910
那他差在哪儿呢

454
00:29:57,970 --> 00:30:00,640
他就差在内存内存管理上

455
00:30:01,530 --> 00:30:03,090
那个quick JS的内存管理

456
00:30:03,090 --> 00:30:06,330
他恶他可以交给别人去做

457
00:30:06,330 --> 00:30:07,260
他可以教给别人

458
00:30:07,440 --> 00:30:08,655
他他自己不去管

459
00:30:08,655 --> 00:30:09,930
它就是实现什么

460
00:30:09,930 --> 00:30:12,060
它就是实现语法的解释

461
00:30:12,060 --> 00:30:13,200
他也没有字节码

462
00:30:13,880 --> 00:30:15,890
KGS他他也不弄字节码

463
00:30:15,890 --> 00:30:17,180
那个是一个比较简陋的

464
00:30:17,330 --> 00:30:18,260
实际上那个KDS

465
00:30:18,260 --> 00:30:19,670
你你把那个包下载下来

466
00:30:20,450 --> 00:30:21,350
你看那个

467
00:30:22,430 --> 00:30:24,170
你你看那个

468
00:30:24,170 --> 00:30:25,970
你看一下它的大小

469
00:30:25,970 --> 00:30:27,530
压缩包就几十K

470
00:30:27,860 --> 00:30:30,620
那么这个V8的这个源代码呢

471
00:30:30,620 --> 00:30:31,550
VBA源代码呢

472
00:30:31,670 --> 00:30:32,810
那可大了去了

473
00:30:33,320 --> 00:30:33,800
对吧

474
00:30:34,010 --> 00:30:37,190
H我那个那个咋又没了

475
00:30:37,910 --> 00:30:38,930
又找不着了

476
00:30:42,940 --> 00:30:46,150
V8的源码我们看V8

477
00:30:47,270 --> 00:30:48,500
看一下微微吧

478
00:30:48,500 --> 00:30:49,580
源码有有多大

479
00:30:49,580 --> 00:30:50,510
31兆

480
00:30:51,250 --> 00:30:52,450
31压缩包

481
00:30:52,450 --> 00:30:52,990
31赵

482
00:30:52,990 --> 00:30:58,090
Quick quick he s就几十K这这差了四四个数量级

483
00:30:58,720 --> 00:30:59,110
对吧

484
00:30:59,200 --> 00:31:01,930
X的四个数量级也就是差了四个零的

485
00:31:03,190 --> 00:31:03,940
所以呢

486
00:31:04,090 --> 00:31:06,220
就看它的功能看它的功能

487
00:31:06,340 --> 00:31:09,220
那么JS引擎发展到今天

488
00:31:09,280 --> 00:31:11,080
它在虚拟计划

489
00:31:11,850 --> 00:31:13,710
他像虚拟机那个方向发展

490
00:31:13,890 --> 00:31:14,940
那虚拟机话

491
00:31:14,940 --> 00:31:15,840
它就像啥了

492
00:31:15,900 --> 00:31:17,160
它就像Java了

493
00:31:17,580 --> 00:31:21,510
那咱们那个去去做那个Java开发的时候

494
00:31:21,510 --> 00:31:23,370
实际上Java它本身是跨平台的

495
00:31:23,610 --> 00:31:24,360
那对吧

496
00:31:25,050 --> 00:31:26,970
当然JS他也是跨平台的

497
00:31:27,120 --> 00:31:30,780
但是早期JS跨平台和Java跨平台

498
00:31:30,900 --> 00:31:32,370
他们的实现机制是不一样的

499
00:31:32,840 --> 00:31:35,810
那JS这个Java跨平台

500
00:31:35,960 --> 00:31:40,400
他是给你弄出一个虚拟虚拟机来

501
00:31:40,400 --> 00:31:42,320
然后他有自己的那个

502
00:31:44,060 --> 00:31:47,990
Java他有自己的那个虚拟机的质量

503
00:31:48,110 --> 00:31:49,190
那么JS呢

504
00:31:49,190 --> 00:31:51,230
JS就是个解释器

505
00:31:51,320 --> 00:31:55,550
那么这个解释器它就直接去调用底层的相关的这个函数

506
00:31:55,550 --> 00:31:57,680
它就给你隔了一层

507
00:31:57,680 --> 00:31:58,730
就给你隔了这么一层

508
00:31:59,000 --> 00:32:03,740
那这这样这这这两种在初期看上去a都是跨平台

509
00:32:03,770 --> 00:32:04,400
但是呢

510
00:32:04,430 --> 00:32:05,570
底层实现不一样

511
00:32:05,690 --> 00:32:06,680
但是现在呢

512
00:32:06,680 --> 00:32:10,370
JS引擎越来越像那个Java虚拟机

513
00:32:10,370 --> 00:32:11,390
Java虚拟机叫什么

514
00:32:11,390 --> 00:32:12,680
叫GM对吧

515
00:32:12,920 --> 00:32:15,470
那JS引擎哪像Java虚拟机了

516
00:32:15,530 --> 00:32:17,480
她也加上了这个字节码

517
00:32:18,040 --> 00:32:19,060
也有了自解码

518
00:32:19,330 --> 00:32:21,790
那么Java虚拟机在很久之前

519
00:32:21,880 --> 00:32:24,280
它的性能是比较低的

520
00:32:24,280 --> 00:32:28,180
所以说要性能的那种那种系统还是用

521
00:32:28,790 --> 00:32:30,470
用C加加做的多

522
00:32:30,500 --> 00:32:31,220
后来呢

523
00:32:31,250 --> 00:32:34,430
Java不断的去不断的去那个

524
00:32:36,600 --> 00:32:39,840
Java不断的去进行优化优化以后呢

525
00:32:39,840 --> 00:32:41,340
Java把j it加上了

526
00:32:42,100 --> 00:32:47,680
那加上j it它的那个性能就和C加加的那个性能就差不多了

527
00:32:48,600 --> 00:32:49,080
对吧

528
00:32:49,110 --> 00:32:50,430
就他他就差不多了

529
00:32:50,610 --> 00:32:51,990
而这个JS呢

530
00:32:52,050 --> 00:32:54,540
A发展到了今天

531
00:32:54,540 --> 00:32:56,100
JS发展到了今天

532
00:32:56,130 --> 00:32:57,120
然后呢

533
00:32:57,390 --> 00:32:59,910
他也把那个玩意儿给夹上了

534
00:33:01,190 --> 00:33:03,440
也把JSJS也加上了

535
00:33:03,470 --> 00:33:04,100
然后呢

536
00:33:04,100 --> 00:33:05,240
在JS引擎里面

537
00:33:05,240 --> 00:33:07,190
他也有这个字节码

538
00:33:07,340 --> 00:33:08,780
这两个东西

539
00:33:08,780 --> 00:33:14,750
他他们这是这个这他们他们之间这个这个实现

540
00:33:14,840 --> 00:33:17,660
这个实实现机制是越来越像

541
00:33:17,900 --> 00:33:18,710
所以说呢

542
00:33:18,770 --> 00:33:22,760
这个到今天这个JS

543
00:33:22,760 --> 00:33:26,090
这个JS这个解释器

544
00:33:26,150 --> 00:33:27,680
他就不能叫解释器了

545
00:33:27,680 --> 00:33:29,270
越看越像虚拟机

546
00:33:29,750 --> 00:33:31,700
那么在这个JS解释器里边儿

547
00:33:31,700 --> 00:33:35,510
它究竟是究竟是怎么个处理方式呢

548
00:33:35,510 --> 00:33:39,980
他怎么他他是他他是那个流程是个什么样的呢

549
00:33:41,160 --> 00:33:42,540
那首先呢

550
00:33:42,600 --> 00:33:44,640
我们JS也好

551
00:33:44,640 --> 00:33:45,690
Java也好

552
00:33:45,690 --> 00:33:46,050
对吧

553
00:33:46,050 --> 00:33:48,420
像像像像这些东西呢

554
00:33:49,050 --> 00:33:50,880
你都必须有原代码

555
00:33:50,910 --> 00:33:53,190
Java还有C语言这些源代码

556
00:33:53,190 --> 00:33:54,000
你必须得编译

557
00:33:54,180 --> 00:33:57,600
那编译成那个过对应的那个机械码或者字节码

558
00:33:57,750 --> 00:33:58,710
但是JS呢

559
00:33:58,710 --> 00:34:00,180
直接扔进去

560
00:34:00,300 --> 00:34:03,960
扔进去最早是交给解释器的

561
00:34:04,140 --> 00:34:08,310
那么解释器这一步他得做一个动作

562
00:34:08,830 --> 00:34:09,760
做什么动作呢

563
00:34:09,850 --> 00:34:10,450
做

564
00:34:11,060 --> 00:34:13,280
生成抽象语法树

565
00:34:14,650 --> 00:34:15,700
生成这个东西

566
00:34:16,060 --> 00:34:17,590
那么这个东西是啥呀

567
00:34:17,710 --> 00:34:21,280
它是属于编译原理里边的东西呢

568
00:34:21,400 --> 00:34:22,810
那么它干什么用呢

569
00:34:22,900 --> 00:34:25,420
我们写的这个源代码

570
00:34:25,480 --> 00:34:29,650
源代码就是就就就就这个样子一行一行的

571
00:34:29,830 --> 00:34:31,300
那么这个编译器

572
00:34:31,300 --> 00:34:35,560
他怎么把你的源代码给你转换成a

573
00:34:35,620 --> 00:34:38,200
转换成那个解释器

574
00:34:38,200 --> 00:34:41,170
还有虚拟机能够理解的东西呢

575
00:34:41,920 --> 00:34:43,570
怎么去转得

576
00:34:44,990 --> 00:34:49,340
经过经过一个中间的数据结构

577
00:34:49,340 --> 00:34:52,010
这个数据结构就是抽抽象语法树

578
00:34:52,370 --> 00:34:54,830
那么这个抽象语法树它究竟

579
00:34:55,380 --> 00:34:56,460
是什么样的呢

580
00:34:56,580 --> 00:35:00,660
那他树结构它是个树结构

581
00:35:00,780 --> 00:35:01,500
但是呢

582
00:35:01,560 --> 00:35:05,070
和我们平时所想象的那个树结构不一样

583
00:35:05,190 --> 00:35:07,470
我们平时所看到的树结构是啥样的

584
00:35:07,470 --> 00:35:08,880
比如说二叉树

585
00:35:08,940 --> 00:35:09,780
对吧

586
00:35:09,840 --> 00:35:11,970
二叉树是这样的二叉树

587
00:35:11,970 --> 00:35:16,140
这这这画了一个那个平衡二叉树

588
00:35:16,140 --> 00:35:18,420
玩画画一个完全二叉树

589
00:35:19,380 --> 00:35:21,930
然后这这是个满二叉树对对吧

590
00:35:22,200 --> 00:35:23,070
二叉树这样的

591
00:35:23,190 --> 00:35:26,760
那那你那个这个N叉树对吧

592
00:35:26,850 --> 00:35:30,360
N叉树咱咱咱咱咱咱就这么就这么分差去

593
00:35:30,510 --> 00:35:32,010
这是咱们一般

594
00:35:32,010 --> 00:35:33,510
这是咱们一般的那个

595
00:35:34,770 --> 00:35:37,950
一般理解的那个那个那个二叉树

596
00:35:38,190 --> 00:35:40,650
那这个抽象语法树

597
00:35:40,710 --> 00:35:42,240
他他长得

598
00:35:42,510 --> 00:35:43,860
尽管他也是个数

599
00:35:43,890 --> 00:35:47,040
但是它长得和我们平时所想的这个

600
00:35:47,930 --> 00:35:50,600
这个结构差区别还挺大

601
00:35:50,960 --> 00:35:52,220
他更像个什么

602
00:35:52,610 --> 00:35:56,210
他更像一个鸡毛掸子鸡毛掸子什么样

603
00:35:56,210 --> 00:35:58,340
中间一根棍儿对吧

604
00:35:58,340 --> 00:36:01,070
大家应该都见过鸡毛掸子中间一根棍儿

605
00:36:01,070 --> 00:36:01,610
然后呢

606
00:36:01,640 --> 00:36:03,860
上面有好多那个羽毛

607
00:36:03,860 --> 00:36:08,120
好多好多羽毛这这这这这样的

608
00:36:08,900 --> 00:36:11,510
然后弄成这些鸡毛掸子

609
00:36:11,840 --> 00:36:13,910
那个抽象语法树更像个这个东西

610
00:36:14,180 --> 00:36:18,560
那也就是说那个抽象语法树它长成这样有根节点

611
00:36:18,800 --> 00:36:20,030
然后呢

612
00:36:20,030 --> 00:36:21,740
又又有那个下级节点

613
00:36:21,740 --> 00:36:25,910
下节点a分两叉分若干个差

614
00:36:26,000 --> 00:36:26,480
对吧

615
00:36:26,510 --> 00:36:27,260
分若干个差

616
00:36:27,260 --> 00:36:29,000
然后还有下级节点a

617
00:36:29,060 --> 00:36:30,230
然后下级节点

618
00:36:30,320 --> 00:36:33,350
下节点它是有一条链儿给串下来

619
00:36:34,190 --> 00:36:37,070
这个鸡毛掸子是有一条链儿给串下来

620
00:36:37,190 --> 00:36:38,960
自始至终给串下来

621
00:36:39,140 --> 00:36:39,950
然后呢

622
00:36:39,980 --> 00:36:41,660
中间的这些节点

623
00:36:41,660 --> 00:36:47,390
他给你分差这就像这是不是就像那个鸡毛掸子了对吧

624
00:36:47,510 --> 00:36:50,960
他和咱们平时所想的那个数他是不一样的

625
00:36:51,710 --> 00:36:56,180
它是有很大的那个在在这个形状是有很大的区别

626
00:36:56,180 --> 00:36:58,160
但它仍然是个数对吧

627
00:36:58,220 --> 00:37:00,740
仍然是个数这这这个是没问题

628
00:37:01,040 --> 00:37:03,320
那么生成这种结构干什么

629
00:37:03,530 --> 00:37:05,030
那这种结构

630
00:37:05,030 --> 00:37:11,960
就要从那个编译原理开始开始说起了那么这种东西实际上涉及到一种那个逻辑

631
00:37:11,960 --> 00:37:14,090
涉涉及到这个语法上的一个逻辑

632
00:37:14,150 --> 00:37:17,030
实际上这种这种语言上的一种逻辑

633
00:37:17,120 --> 00:37:25,100
在两千两三千年之前就有哲学家在考虑比如说像那个古希腊西方那些哲学家

634
00:37:25,100 --> 00:37:28,640
他们在他们在2000多年前就开始就开始思考这个

635
00:37:28,790 --> 00:37:29,420
然后呢

636
00:37:29,450 --> 00:37:30,860
一直发展到今天

637
00:37:30,950 --> 00:37:35,090
就是就生成就就就形成这么一套体系

638
00:37:35,820 --> 00:37:39,180
形成了这么一套那个语言学上的这种逻辑体系

639
00:37:39,390 --> 00:37:41,340
它那他们是想干什么

640
00:37:41,340 --> 00:37:42,540
他们研究这个干什么

641
00:37:42,690 --> 00:37:44,520
因为人的语言

642
00:37:44,700 --> 00:37:46,890
它是会产生歧义的

643
00:37:48,040 --> 00:37:48,550
对吧

644
00:37:48,580 --> 00:37:49,690
它会产生歧义

645
00:37:49,810 --> 00:37:51,550
比如说你去算个命

646
00:37:51,610 --> 00:37:52,300
你去算命

647
00:37:52,810 --> 00:37:55,630
那个算命的看看你一眼

648
00:37:55,660 --> 00:37:56,260
然后呢

649
00:37:56,320 --> 00:37:59,680
说你你你说那个你你算算我

650
00:37:59,680 --> 00:38:02,260
哥几个算命的说什么

651
00:38:02,590 --> 00:38:06,070
桃园三结义孤独一支对吧

652
00:38:06,100 --> 00:38:07,210
这是有歧义的

653
00:38:07,300 --> 00:38:08,740
那你怎么理解

654
00:38:08,770 --> 00:38:12,490
你要说你你就搁一个对吧

655
00:38:12,700 --> 00:38:13,270
他说什么

656
00:38:13,270 --> 00:38:14,440
本来应该有撒

657
00:38:14,530 --> 00:38:15,010
但是呢

658
00:38:15,010 --> 00:38:16,930
就孤独初拟一个来

659
00:38:16,990 --> 00:38:17,890
这是一种解释

660
00:38:18,100 --> 00:38:19,660
你要说搁俩呢

661
00:38:19,780 --> 00:38:21,190
本来要要有撒

662
00:38:21,250 --> 00:38:21,640
但是呢

663
00:38:21,640 --> 00:38:23,290
给孤独下一个去

664
00:38:23,380 --> 00:38:25,060
你要说有哥仨呢

665
00:38:25,060 --> 00:38:25,660
哥仨呢

666
00:38:25,660 --> 00:38:28,180
就是这不桃园三结义

667
00:38:28,180 --> 00:38:29,470
全在一个根儿上

668
00:38:29,470 --> 00:38:30,460
你要哥四个呢

669
00:38:30,490 --> 00:38:31,480
本来是哥仨

670
00:38:31,510 --> 00:38:33,310
然后又孤独出一个来对吧

671
00:38:33,490 --> 00:38:35,140
这是自然语言

672
00:38:35,140 --> 00:38:38,620
咱们咱们这个自然语言的一个一个问题呢

673
00:38:38,620 --> 00:38:39,790
它会产生歧义

674
00:38:40,000 --> 00:38:42,910
但是你让机器去执行这种东西的话

675
00:38:43,090 --> 00:38:44,830
是不能有歧义的

676
00:38:44,830 --> 00:38:46,630
尤其是这玩意儿它是底层的

677
00:38:46,870 --> 00:38:47,530
所以呢

678
00:38:47,590 --> 00:38:47,830
就

679
00:38:48,280 --> 00:38:50,350
必须得用那种逻辑

680
00:38:50,350 --> 00:38:54,370
用那种逻辑方式去生成这个语法树是吧

681
00:38:54,490 --> 00:38:56,440
那么这个语法树

682
00:38:56,440 --> 00:38:57,310
生成了以后

683
00:38:57,310 --> 00:38:59,560
他应该是非常严密的

684
00:38:59,620 --> 00:39:00,970
算命的都是大忽悠

685
00:39:00,970 --> 00:39:02,770
那可不都是大忽悠吗

686
00:39:02,770 --> 00:39:03,850
对吧

687
00:39:03,970 --> 00:39:05,590
你要听听那个啥

688
00:39:05,590 --> 00:39:08,530
这这个段子是是那个侯宝林说的

689
00:39:08,530 --> 00:39:11,260
侯宝林的那个相声里边儿的

690
00:39:11,260 --> 00:39:12,880
桃园三结义孤独一支

691
00:39:12,880 --> 00:39:14,020
还有还有什么呢

692
00:39:14,020 --> 00:39:16,810
还有就是那个什么负债母先死

693
00:39:16,810 --> 00:39:20,170
就是说那个家里家里老人谁还在

694
00:39:20,200 --> 00:39:21,490
对吧

695
00:39:21,970 --> 00:39:26,800
那个是是是老爷子在还是还是老太太在父在母先死

696
00:39:26,800 --> 00:39:27,850
这也有歧义

697
00:39:28,530 --> 00:39:29,490
对吧

698
00:39:29,520 --> 00:39:30,510
所以说就要

699
00:39:30,600 --> 00:39:33,000
所以说就要就要消除这些奇异

700
00:39:33,090 --> 00:39:34,590
生成这个语法抽象树

701
00:39:34,590 --> 00:39:35,880
就是消除歧义

702
00:39:35,910 --> 00:39:36,630
然后呢

703
00:39:36,690 --> 00:39:38,580
给下一步去做准备

704
00:39:38,820 --> 00:39:40,410
那么生成这个东西

705
00:39:40,440 --> 00:39:41,820
生成的语法抽象树

706
00:39:42,000 --> 00:39:44,130
它是按照一个什么样的规则

707
00:39:44,160 --> 00:39:45,930
规则去去生成的呢

708
00:39:45,930 --> 00:39:48,090
比如说咱们咱们到这个代码这儿

709
00:39:48,120 --> 00:39:49,200
咱们到这个代码这

710
00:39:49,200 --> 00:39:51,480
咱们随便儿找那么一个函数

711
00:39:51,480 --> 00:39:53,520
随便找个函数找个长点的函数

712
00:39:54,640 --> 00:39:57,340
比如说这这个函数

713
00:39:57,370 --> 00:39:59,200
这个函数体在这儿

714
00:39:59,200 --> 00:40:04,660
这个是C语言风格的缩进这个这这是那个

715
00:40:06,040 --> 00:40:06,580
在这儿

716
00:40:06,610 --> 00:40:07,450
然后呢

717
00:40:07,450 --> 00:40:09,460
比如说咱们一行一行的

718
00:40:09,460 --> 00:40:12,130
一行一行的那一行语句

719
00:40:12,160 --> 00:40:18,190
咱们要注意一行语句一条语句就带他就对应着啥呀

720
00:40:18,370 --> 00:40:20,620
他就对应着这上面的一个节点

721
00:40:21,460 --> 00:40:23,470
一条语句就对应一个节点

722
00:40:23,500 --> 00:40:24,100
然后呢

723
00:40:24,100 --> 00:40:25,780
又一条语句又一个节点

724
00:40:25,780 --> 00:40:30,220
又一条语句又一个节点如果说你这里边儿

725
00:40:30,250 --> 00:40:32,230
这语句这语句里边儿

726
00:40:32,260 --> 00:40:35,230
你你是在这儿赋值的负值的

727
00:40:35,230 --> 00:40:37,420
那这个副职

728
00:40:37,420 --> 00:40:39,700
这个变量你就要挂在这个之上

729
00:40:40,800 --> 00:40:42,690
这个变量就要挂在这个之上

730
00:40:42,930 --> 00:40:44,490
你要判断

731
00:40:44,520 --> 00:40:45,540
这是一个节点

732
00:40:45,570 --> 00:40:46,890
然后判断

733
00:40:46,890 --> 00:40:49,320
一个变量你挂在这个之上

734
00:40:49,320 --> 00:40:51,480
另一个变量挂在挂在另外一个之上

735
00:40:51,510 --> 00:40:54,000
然后一个操作挂在一个之上

736
00:40:54,060 --> 00:40:56,430
一条语句它就是其中一个节点

737
00:40:56,640 --> 00:40:59,580
然后语句里的细节就在这儿开始分叉

738
00:40:59,980 --> 00:41:01,030
然后啊

739
00:41:01,060 --> 00:41:03,370
然后如果说你有循环对吧

740
00:41:03,400 --> 00:41:04,060
你有循环

741
00:41:04,210 --> 00:41:05,410
那你有循环的话

742
00:41:05,470 --> 00:41:05,980
那好

743
00:41:06,070 --> 00:41:08,110
那这个节点它就复杂一点

744
00:41:08,110 --> 00:41:09,940
然后这个节点它在分支

745
00:41:09,940 --> 00:41:11,050
他在分好多叉

746
00:41:11,610 --> 00:41:12,990
又分好多叉

747
00:41:13,110 --> 00:41:13,560
但是呢

748
00:41:13,560 --> 00:41:14,370
他不是主干

749
00:41:14,580 --> 00:41:16,740
主干仍然是要回到这儿来

750
00:41:16,830 --> 00:41:19,260
实际上这个这这个循环对吧

751
00:41:19,320 --> 00:41:22,020
这个循环这是一个大循环语句

752
00:41:22,750 --> 00:41:24,010
这是个大循环语句

753
00:41:24,160 --> 00:41:27,820
那么大循环语句里面有好多好多好多赋值语句

754
00:41:27,820 --> 00:41:30,160
还有判断语句那赋值语句

755
00:41:30,460 --> 00:41:34,900
那这个大循环语句在整个的这个在整个的这个主干上

756
00:41:34,900 --> 00:41:38,440
他分出一个大分支来那么这个大分支

757
00:41:38,440 --> 00:41:42,400
然后它里边再分出一个那个稍微小一点儿的大分支

758
00:41:42,400 --> 00:41:45,430
这个对应谁对应对应条件判断a

759
00:41:45,460 --> 00:41:47,980
然后条件判断里边它它又分好多支

760
00:41:48,100 --> 00:41:53,680
然后这个一幅这个for循环这段代码块儿执行完了

761
00:41:53,740 --> 00:41:54,550
他处理完了

762
00:41:54,580 --> 00:41:56,800
然后再回到这个主干上

763
00:41:56,830 --> 00:41:58,210
然后继续往下走

764
00:41:58,590 --> 00:42:00,030
实际上这个数

765
00:42:00,090 --> 00:42:03,810
这个数就是就是为了去把这些代码

766
00:42:04,390 --> 00:42:05,380
给换个形式

767
00:42:06,460 --> 00:42:08,140
把这个东西给换个形式

768
00:42:08,170 --> 00:42:09,310
换个形式

769
00:42:09,340 --> 00:42:10,030
然后呢

770
00:42:10,120 --> 00:42:12,490
让给下一步去处理

771
00:42:12,580 --> 00:42:14,170
你不这样去做

772
00:42:14,170 --> 00:42:14,890
你不这样去做

773
00:42:14,890 --> 00:42:18,160
计算机它是一它它是它是理解不了这种语法的

774
00:42:18,460 --> 00:42:20,350
那他只能与理解什么

775
00:42:20,350 --> 00:42:27,010
只能理解那种汇编那种形式的哈语法要先把这个东西转成

776
00:42:27,010 --> 00:42:29,170
转成那种转乘这个数

777
00:42:29,200 --> 00:42:29,680
然后呢

778
00:42:29,680 --> 00:42:36,340
再由这个数这种这种结构按照规则在在转成汇编那种形式这样一来呢

779
00:42:36,340 --> 00:42:38,260
这样一步一步的去走

780
00:42:38,260 --> 00:42:39,250
一步一步的去走

781
00:42:39,250 --> 00:42:39,910
这这这样

782
00:42:41,140 --> 00:42:44,140
这样咱们这样才行哈那

783
00:42:45,880 --> 00:42:46,270
咳

784
00:42:48,230 --> 00:42:49,190
那接下来

785
00:42:49,280 --> 00:42:50,900
咱们把这个语法抽象数

786
00:42:50,900 --> 00:42:54,410
把他给把他给那个搞清楚了

787
00:42:54,440 --> 00:42:55,820
搞清楚了之后呢

788
00:42:55,940 --> 00:42:57,380
接下来干什么呢

789
00:42:57,500 --> 00:42:59,390
接下来现在

790
00:42:59,390 --> 00:43:01,550
就是现在的那个

791
00:43:02,390 --> 00:43:04,850
就是现在的这个微吧

792
00:43:04,850 --> 00:43:06,260
现在的这个JS引擎

793
00:43:06,650 --> 00:43:08,960
那你把抽象出数弄好了

794
00:43:08,960 --> 00:43:11,870
那就转成字节码转成字节码

795
00:43:11,960 --> 00:43:13,100
你转成字节码

796
00:43:13,100 --> 00:43:15,620
实际上现在V8他就是个虚拟机

797
00:43:16,420 --> 00:43:17,710
V8就是个虚拟机

798
00:43:17,710 --> 00:43:18,730
现在呢

799
00:43:18,760 --> 00:43:20,770
要不然你要字节码干什么

800
00:43:20,950 --> 00:43:21,430
对吧

801
00:43:21,490 --> 00:43:23,530
之前他是没有字字节码的

802
00:43:23,680 --> 00:43:27,040
那些那些那个老引擎它是没有这个字节码的

803
00:43:28,140 --> 00:43:30,360
那实际上字节码是在干啥呀

804
00:43:30,450 --> 00:43:33,090
他是为了隐藏底层特性

805
00:43:33,090 --> 00:43:34,770
为了隐藏底层特性

806
00:43:34,920 --> 00:43:38,670
他就不直接去去掉谁调操作系统的那些API

807
00:43:39,430 --> 00:43:39,880
对吧

808
00:43:39,970 --> 00:43:42,610
它隐藏在那个虚拟机层之下

809
00:43:42,910 --> 00:43:45,490
然后这样他他好划分

810
00:43:45,490 --> 00:43:49,060
字节码就跑在这个虚拟机层然后呢

811
00:43:49,150 --> 00:43:50,740
虚拟机层之上

812
00:43:50,740 --> 00:43:53,860
你你就去去就去做那个那个编译过程

813
00:43:54,340 --> 00:43:54,700
对吧

814
00:43:54,700 --> 00:43:58,660
他的那个内部编译过程然后虚拟机之下呢

815
00:43:58,660 --> 00:44:02,590
你再去你再去分别针对不同的这个操作系统

816
00:44:02,680 --> 00:44:04,930
你在统一封装什么

817
00:44:04,930 --> 00:44:07,060
再统一封装这个调用接口

818
00:44:07,680 --> 00:44:07,950
是吧

819
00:44:08,010 --> 00:44:08,670
这样呢

820
00:44:08,730 --> 00:44:10,140
分层很清晰

821
00:44:10,170 --> 00:44:13,260
而且能把这个能把这个活儿分给不同的

822
00:44:13,260 --> 00:44:18,780
这个分给不同的人去做去这个这样分活儿也好分这这是属于那个软件

823
00:44:19,020 --> 00:44:20,250
这个这个这个

824
00:44:21,040 --> 00:44:24,880
内内叫那个项目管理里边儿的那个那个东西了

825
00:44:25,000 --> 00:44:28,810
然后咱们把那个生成语法抽象树生成字节码

826
00:44:28,810 --> 00:44:40,540
这个字节码就是跑在V8救救它就相当于跑在V8这个虚拟机里的汇编不是会边跑在V8虚拟机里的那个机器指令

827
00:44:41,760 --> 00:44:42,930
虚拟机是什么

828
00:44:42,990 --> 00:44:45,570
跟你虚拟出一个CPU来

829
00:44:45,570 --> 00:44:47,790
这叫虚拟系那字节码

830
00:44:47,820 --> 00:44:55,710
它就相当于跑在这个虚拟出来的这个CPU上的那个机器质量然后然后干什么呢

831
00:44:55,740 --> 00:45:02,460
然后解析器然后解析器V8这个恶微吧

832
00:45:02,460 --> 00:45:06,420
里边儿用这个解析器去他去执行了

833
00:45:07,410 --> 00:45:09,060
在在这儿去执行那个

834
00:45:09,940 --> 00:45:14,590
去去执行你的这个源代码是实际上在这儿呢

835
00:45:14,590 --> 00:45:15,640
这这是解析器

836
00:45:15,850 --> 00:45:18,850
那么在之前只有这个解析器

837
00:45:18,850 --> 00:45:21,490
这是之前是直接这样抽象语法树

838
00:45:21,490 --> 00:45:23,080
然后交给解析器

839
00:45:23,930 --> 00:45:24,650
这是之前

840
00:45:24,890 --> 00:45:25,730
现在呢

841
00:45:25,820 --> 00:45:27,830
交给自己生成字节码

842
00:45:27,830 --> 00:45:28,670
再交给解析器

843
00:45:28,700 --> 00:45:30,860
解析器在在虚拟机里

844
00:45:31,580 --> 00:45:32,810
把它包在虚拟机里去了

845
00:45:33,350 --> 00:45:34,730
这是那个流程

846
00:45:34,880 --> 00:45:36,920
那么这个JS

847
00:45:36,980 --> 00:45:40,370
你在创建新对象的时候吧

848
00:45:40,370 --> 00:45:41,720
创建新对象的时候

849
00:45:41,720 --> 00:45:42,530
那那

850
00:45:43,310 --> 00:45:44,750
那是怎么弄的呢

851
00:45:44,750 --> 00:45:47,060
他那内存它是怎么管理的呢

852
00:45:47,060 --> 00:45:48,860
这个时候是是有什么

853
00:45:48,950 --> 00:45:50,390
有垃圾回收机制

854
00:45:50,450 --> 00:45:53,150
就是那个GCGC在这个地方

855
00:45:53,720 --> 00:45:53,960
是吧

856
00:45:54,260 --> 00:45:57,980
那这个GC它是一个独立的这么一个东西

857
00:45:57,980 --> 00:46:01,100
他不他不搀和这个解析器的工作

858
00:46:01,370 --> 00:46:03,110
当进行GC的时候

859
00:46:03,380 --> 00:46:06,830
那么这个解析器他的工作就要暂停

860
00:46:07,630 --> 00:46:09,490
那他就要暂停

861
00:46:09,490 --> 00:46:11,560
同样是防止内啥

862
00:46:11,590 --> 00:46:14,200
防止那个死锁或者是产生脏数据

863
00:46:15,280 --> 00:46:17,110
然后咱们再看

864
00:46:17,140 --> 00:46:18,670
咱们再看另外一个

865
00:46:18,760 --> 00:46:20,470
再看另外一个分支

866
00:46:20,590 --> 00:46:22,390
现在又加上什么了

867
00:46:22,450 --> 00:46:23,500
又加上几

868
00:46:23,530 --> 00:46:25,210
又加上这个j it了

869
00:46:25,600 --> 00:46:27,190
It是什么意思

870
00:46:27,310 --> 00:46:28,510
Just in time

871
00:46:29,000 --> 00:46:29,450
没有啊

872
00:46:29,450 --> 00:46:31,160
它的全称是Justin time

873
00:46:31,400 --> 00:46:32,960
其实就是即时编译

874
00:46:33,170 --> 00:46:34,700
那这个即时编译是什么

875
00:46:34,790 --> 00:46:37,070
直接把这个东西

876
00:46:37,130 --> 00:46:43,490
直接把这个这个源代码编译成机器的本地代码

877
00:46:43,490 --> 00:46:48,650
我们要注意字节码和本地代码这俩是什么区别

878
00:46:49,870 --> 00:46:51,850
字节码是什么

879
00:46:51,940 --> 00:46:54,850
他是跑在那个虚拟机里的

880
00:46:56,280 --> 00:46:59,250
他是跑在虚拟机里的那个东西

881
00:46:59,250 --> 00:47:00,330
这是字节码

882
00:47:00,630 --> 00:47:02,400
那本地代码呢

883
00:47:02,550 --> 00:47:03,870
他是跑在

884
00:47:05,580 --> 00:47:06,750
CPU上的

885
00:47:07,360 --> 00:47:08,440
这是本地代码

886
00:47:09,540 --> 00:47:09,960
是吧

887
00:47:10,170 --> 00:47:11,430
这个就快多了

888
00:47:11,730 --> 00:47:12,180
对吧

889
00:47:12,210 --> 00:47:15,660
他是直接直接给直接给直接给CPU了

890
00:47:15,810 --> 00:47:17,070
而这个字节码呢

891
00:47:17,070 --> 00:47:19,080
中间还隔着一层的

892
00:47:19,080 --> 00:47:21,450
中间还隔着一层那个虚拟机呢

893
00:47:22,180 --> 00:47:22,660
是吧

894
00:47:22,720 --> 00:47:23,980
本地当然是真实的啦

895
00:47:23,980 --> 00:47:25,360
就是二进制

896
00:47:25,360 --> 00:47:26,590
就是二进制代码

897
00:47:26,680 --> 00:47:28,900
就和你C语言的那个代码

898
00:47:28,960 --> 00:47:31,210
C语言编译出来的那个代码

899
00:47:31,390 --> 00:47:33,580
他他性质是性质相同的

900
00:47:35,130 --> 00:47:35,490
是吧

901
00:47:35,520 --> 00:47:38,220
所以说j it它最快

902
00:47:38,220 --> 00:47:41,010
J it TE他是他是最快的

903
00:47:41,220 --> 00:47:44,250
那现在好多这种脚本语言

904
00:47:44,370 --> 00:47:48,090
好多脚本语言都都用上了这种it技术

905
00:47:49,330 --> 00:47:51,400
比如像像那个JS算一个

906
00:47:51,400 --> 00:47:52,600
还有那个Python

907
00:47:52,600 --> 00:47:56,620
Python他也有这个j it娜扎瓦就更不更不用提了

908
00:47:56,620 --> 00:48:00,100
Java用这个阶梯式是相当是相当相当早的

909
00:48:03,690 --> 00:48:04,230
嗯

910
00:48:10,170 --> 00:48:10,860
嗨

911
00:48:11,750 --> 00:48:12,110
嗯

912
00:48:15,510 --> 00:48:17,280
那么这个j it啊

913
00:48:17,310 --> 00:48:19,380
我们看看一下这个j it

914
00:48:19,500 --> 00:48:20,820
这个j it呢

915
00:48:20,850 --> 00:48:22,500
我们发现了两条路径

916
00:48:23,830 --> 00:48:24,790
我们这儿发现了

917
00:48:24,790 --> 00:48:27,370
你去你去生成这个GT的时候呢

918
00:48:27,490 --> 00:48:28,990
这儿有两条路径呢

919
00:48:29,050 --> 00:48:34,510
一条路径是直接语法抽象数直语法抽象数直接生成了j it

920
00:48:34,840 --> 00:48:35,950
另一条路径呢

921
00:48:36,040 --> 00:48:40,030
是这个解析器解析器生成的这个阶梯

922
00:48:40,480 --> 00:48:42,730
那么在V8引擎里边儿

923
00:48:43,120 --> 00:48:44,620
那在V8引擎里边

924
00:48:44,800 --> 00:48:48,160
它是有两种产生j it的机制

925
00:48:48,640 --> 00:48:50,980
一种一种机制是什么呢

926
00:48:51,600 --> 00:48:55,380
一种机制是简单的产生j it啊

927
00:48:55,380 --> 00:48:56,940
快速生成j it

928
00:48:57,360 --> 00:48:58,800
另外一种机制呢

929
00:48:58,860 --> 00:49:01,320
是优化性地生成j it

930
00:49:02,440 --> 00:49:06,040
那么这个就是快速生成j it快速生成

931
00:49:06,400 --> 00:49:09,400
那快速生成他要先扫描一下你的代码

932
00:49:09,490 --> 00:49:10,450
扫描你的代码

933
00:49:10,450 --> 00:49:12,760
你他会他会发现

934
00:49:12,760 --> 00:49:17,740
他会发现哪一块代码Xu re有可能会被频繁调用

935
00:49:17,950 --> 00:49:21,310
那我就直接那我就直接

936
00:49:22,120 --> 00:49:23,260
那个

937
00:49:23,440 --> 00:49:27,670
那我就直接就就给他j it当然这种呢

938
00:49:27,700 --> 00:49:31,690
这种直接产生j it的它的它的这个性能比较低

939
00:49:31,690 --> 00:49:32,710
性能不太高

940
00:49:33,840 --> 00:49:35,130
那么另外一种呢

941
00:49:35,220 --> 00:49:37,290
就是优化性的j it

942
00:49:37,410 --> 00:49:41,100
优化性的这个机制全都封装在这个微吧里边儿

943
00:49:41,640 --> 00:49:43,200
那么这个微吧

944
00:49:43,470 --> 00:49:45,870
他在执行你代码的过程当中

945
00:49:45,900 --> 00:49:48,120
随着你代码的执行

946
00:49:48,210 --> 00:49:50,760
它会逐渐的嗨

947
00:49:51,000 --> 00:49:53,280
逐渐的意识到

948
00:49:53,280 --> 00:49:57,390
你这段代码是需要进行j it的

949
00:49:58,580 --> 00:49:59,960
需要进行j it的

950
00:50:00,260 --> 00:50:11,090
那这实际实际在静态分析的时候和动态静态分析和动态分析这两种产生的结果是不一样的

951
00:50:11,640 --> 00:50:12,060
对吧

952
00:50:12,420 --> 00:50:13,740
这两种产生的结果不一样

953
00:50:14,040 --> 00:50:14,880
这这个大

954
00:50:14,880 --> 00:50:16,770
这这个大框里边都是V8

955
00:50:17,130 --> 00:50:18,420
这个大框里面都是V8

956
00:50:18,570 --> 00:50:19,740
都是V8在干的事儿

957
00:50:20,430 --> 00:50:20,970
不是吧

958
00:50:21,540 --> 00:50:23,580
当然这个快速生成也是V8了

959
00:50:23,730 --> 00:50:28,110
他就是微吧里边儿两种两种产生GT的机制吗

960
00:50:28,350 --> 00:50:31,860
那么动态产生的这种动态产生的这种

961
00:50:32,100 --> 00:50:35,100
它产生它生成的j it性能更高

962
00:50:36,710 --> 00:50:39,020
这是两种产生j it的方式

963
00:50:39,260 --> 00:50:41,120
那么这个具体的

964
00:50:41,120 --> 00:50:42,710
具体的有一些这个机制呢

965
00:50:42,710 --> 00:50:44,510
在在咱们这个公众号儿里

966
00:50:44,510 --> 00:50:46,700
咱们公众号好像是那个三月份儿

967
00:50:46,700 --> 00:50:49,880
今年三月份我我我那个翻译了一篇文章

968
00:50:49,880 --> 00:50:51,020
就是那个j it

969
00:50:51,080 --> 00:50:52,910
那就是j it

970
00:50:52,910 --> 00:50:58,430
这就是就是这个JTJJJ2种这这这这两种处理方式

971
00:50:58,430 --> 00:50:59,900
大家可以去找一找

972
00:51:00,760 --> 00:51:01,390
在公众号里

973
00:51:01,390 --> 00:51:03,370
你去翻一翻这这两种

974
00:51:04,300 --> 00:51:05,230
那么这个

975
00:51:07,540 --> 00:51:12,490
当然GT最最终的目的就是生成可以直接跑在CPU上的

976
00:51:12,490 --> 00:51:13,930
跑在CPU上的那个代码

977
00:51:14,230 --> 00:51:16,360
那么垃圾自动回收机制呢

978
00:51:16,420 --> 00:51:20,500
它既管你解析器这一块儿的这个内存

979
00:51:20,500 --> 00:51:24,310
也管这个本地代码他所需要的那个内存

980
00:51:24,310 --> 00:51:25,390
这两块儿都要管

981
00:51:25,810 --> 00:51:28,180
那么接下来就有一个问题

982
00:51:28,210 --> 00:51:29,500
接下来就有一个问题

983
00:51:29,650 --> 00:51:32,230
当垃圾回收的时候

984
00:51:32,260 --> 00:51:33,790
当进行GC的时候

985
00:51:33,880 --> 00:51:36,730
为什么这个代码的执行他要暂停

986
00:51:37,920 --> 00:51:39,060
这是下一个问题

987
00:51:39,420 --> 00:51:41,100
那么这个问题

988
00:51:41,100 --> 00:51:46,500
这这这他这个问题怎么解释呢

989
00:51:46,500 --> 00:51:47,220
怎么解释呢

990
00:51:47,340 --> 00:51:48,450
实际上

991
00:51:48,660 --> 00:51:49,710
咱们要

992
00:51:50,260 --> 00:51:51,280
咱们得从

993
00:51:51,840 --> 00:51:52,740
这个微吧

994
00:51:52,740 --> 00:51:55,800
他在实例化的时候说起V8

995
00:51:56,390 --> 00:51:59,270
你比如说你的程序里边儿嵌入了这个微吧

996
00:51:59,300 --> 00:52:00,740
就拿note JS来说

997
00:52:00,860 --> 00:52:02,540
Note JS里面欠了这个微吧

998
00:52:02,810 --> 00:52:03,380
然后

999
00:52:04,090 --> 00:52:05,830
当no de JS执行的时候

1000
00:52:05,950 --> 00:52:09,910
No de JS他要像操作系统

1001
00:52:10,950 --> 00:52:12,630
要一大块内存

1002
00:52:15,940 --> 00:52:17,740
这个no的JS

1003
00:52:19,250 --> 00:52:22,220
他要像操作系统要一大块内存过来

1004
00:52:22,520 --> 00:52:24,410
那么这一大块儿内存

1005
00:52:25,930 --> 00:52:27,610
全都归谁管

1006
00:52:27,820 --> 00:52:30,490
全都归弄得JS管

1007
00:52:31,120 --> 00:52:32,740
那都归他管

1008
00:52:34,250 --> 00:52:35,060
然后呢

1009
00:52:35,090 --> 00:52:36,890
后续的运行

1010
00:52:36,890 --> 00:52:41,540
后续的执行就不再像操作系统要要内存了

1011
00:52:41,780 --> 00:52:45,140
就直接说操作系统你给我1G的内存

1012
00:52:45,950 --> 00:52:47,690
这1G的内存我我干什么

1013
00:52:47,690 --> 00:52:48,500
你就不用管了

1014
00:52:48,650 --> 00:52:50,240
我完全自己管理

1015
00:52:50,240 --> 00:52:51,770
这这这弄的自己管的

1016
00:52:51,950 --> 00:52:54,020
然后1G的内存来了

1017
00:52:54,170 --> 00:52:55,250
然后弄的呢

1018
00:52:55,280 --> 00:52:57,980
他会把其中的一部分

1019
00:52:58,500 --> 00:52:59,250
生成

1020
00:53:00,140 --> 00:53:01,760
把它生成这个堆区

1021
00:53:02,700 --> 00:53:04,530
把其中一部分生成堆区

1022
00:53:04,950 --> 00:53:07,890
然后这个堆区给谁用给V8用

1023
00:53:09,300 --> 00:53:10,710
这个堆区给V8用

1024
00:53:10,710 --> 00:53:12,720
你在创建新对象的时候

1025
00:53:12,840 --> 00:53:18,660
新对象就要就要创建在这个堆堆里边儿那么在这个堆区里边儿

1026
00:53:19,240 --> 00:53:20,620
你在创建

1027
00:53:20,830 --> 00:53:23,560
你在不断的创建这个对象

1028
00:53:23,560 --> 00:53:24,550
不断创建对象

1029
00:53:24,580 --> 00:53:25,930
然后对象越来越多

1030
00:53:26,200 --> 00:53:27,640
对象你不要了

1031
00:53:27,730 --> 00:53:29,350
你就要去删除这些对象

1032
00:53:29,350 --> 00:53:30,040
对吧

1033
00:53:30,130 --> 00:53:31,240
这是一个内存

1034
00:53:31,360 --> 00:53:35,980
内存他是个一维的结构比如说你一开始创建了这么多对象

1035
00:53:36,010 --> 00:53:36,700
然后呢

1036
00:53:36,730 --> 00:53:39,130
中间某些对象不要了

1037
00:53:39,250 --> 00:53:41,230
你按照顺序去创建

1038
00:53:41,440 --> 00:53:42,910
它会从前往后去

1039
00:53:42,970 --> 00:53:45,880
从前往后去去往里边儿补

1040
00:53:46,030 --> 00:53:47,530
但是你但是你去

1041
00:53:47,740 --> 00:53:48,910
但是你不要他了

1042
00:53:49,340 --> 00:53:49,790
对吧

1043
00:53:49,940 --> 00:53:50,990
但是你不要他了

1044
00:53:51,020 --> 00:53:51,830
你不要他

1045
00:53:52,010 --> 00:53:53,750
他里边儿会产生什么

1046
00:53:53,750 --> 00:53:54,470
产生碎片

1047
00:53:56,120 --> 00:53:57,350
它会产生碎片

1048
00:53:57,830 --> 00:54:00,620
你这些对象按顺序创建

1049
00:54:00,770 --> 00:54:02,690
但是你不用它的时候

1050
00:54:02,690 --> 00:54:05,750
它可未必是按顺序不用他

1051
00:54:06,400 --> 00:54:07,630
对吧

1052
00:54:07,660 --> 00:54:10,060
所以你你一些对象

1053
00:54:10,060 --> 00:54:11,710
你你你不需要了

1054
00:54:11,710 --> 00:54:13,075
他他就要把这个

1055
00:54:13,075 --> 00:54:14,680
把这个对象释放掉

1056
00:54:14,680 --> 00:54:15,460
释放掉以后

1057
00:54:15,460 --> 00:54:16,990
内存里面就产生碎片了

1058
00:54:17,470 --> 00:54:20,890
那么GC在回收这些碎片的时候

1059
00:54:20,890 --> 00:54:22,840
也就是说把这些把这些

1060
00:54:23,740 --> 00:54:25,240
不要的这些

1061
00:54:25,240 --> 00:54:27,490
不要的这些对象

1062
00:54:27,490 --> 00:54:29,110
把它给释放掉的时候

1063
00:54:30,130 --> 00:54:34,300
内存里边这一小块儿它是可用的

1064
00:54:34,300 --> 00:54:35,950
这一小块又是可用的

1065
00:54:35,950 --> 00:54:37,300
这一小块儿还是可用的

1066
00:54:37,690 --> 00:54:38,500
但是啊

1067
00:54:39,100 --> 00:54:41,410
他可用空间看得挺多

1068
00:54:41,530 --> 00:54:42,910
但实际上呢

1069
00:54:43,390 --> 00:54:44,740
那但实际上呢

1070
00:54:44,890 --> 00:54:48,790
实际上你你真正能用的空间就少了

1071
00:54:49,320 --> 00:54:50,010
为什么呀

1072
00:54:50,070 --> 00:54:52,230
你想要创建一个大对象

1073
00:54:52,320 --> 00:54:53,970
你看着一个

1074
00:54:53,970 --> 00:54:55,410
你看着空间挺多

1075
00:54:55,470 --> 00:54:57,600
但是这些空间散落在不同的地方

1076
00:54:57,960 --> 00:54:58,680
那你就

1077
00:54:59,240 --> 00:55:00,170
放不进去了

1078
00:55:01,350 --> 00:55:01,830
对吧

1079
00:55:01,920 --> 00:55:03,210
这个东西挺多

1080
00:55:03,300 --> 00:55:05,220
但是你愣是地方挺多

1081
00:55:05,220 --> 00:55:06,360
但是你硬是放不进去

1082
00:55:06,450 --> 00:55:10,020
这时候该怎么办整理就要整理一下

1083
00:55:10,170 --> 00:55:11,490
那整理的时候呢

1084
00:55:11,580 --> 00:55:15,900
就要把这些全都往前移动对吧

1085
00:55:16,050 --> 00:55:18,120
就得往前移动了

1086
00:55:18,330 --> 00:55:21,210
你要把这些碎片全都给消除掉

1087
00:55:22,020 --> 00:55:23,070
你把它消除掉

1088
00:55:23,100 --> 00:55:24,720
后边儿不就有大空间了吗

1089
00:55:24,720 --> 00:55:25,560
大块空间了吗

1090
00:55:25,680 --> 00:55:27,930
有了大块空间你就能放进去了

1091
00:55:28,140 --> 00:55:29,460
那么问题在哪儿呢

1092
00:55:29,790 --> 00:55:31,020
问题就在这儿

1093
00:55:31,230 --> 00:55:33,150
当你这个GC

1094
00:55:33,180 --> 00:55:35,250
当你GC回收之后

1095
00:55:35,250 --> 00:55:36,330
他要进行整理

1096
00:55:36,750 --> 00:55:38,760
整理的时候你

1097
00:55:39,220 --> 00:55:40,630
实际上在干什么

1098
00:55:40,870 --> 00:55:43,630
在移动这个内存里的数据

1099
00:55:43,960 --> 00:55:46,510
换句话说就是把这个数据

1100
00:55:46,600 --> 00:55:48,505
把它复制到这个位置上来

1101
00:55:48,505 --> 00:55:51,490
来这个数据来复制到前面这个位置上来

1102
00:55:51,730 --> 00:55:53,380
再改他们的地址

1103
00:55:55,000 --> 00:55:56,620
是在改他们的地址

1104
00:55:57,040 --> 00:55:59,050
那么再改地址的过程当中

1105
00:55:59,140 --> 00:56:01,870
你V吧正好用到其中一个数据

1106
00:56:02,490 --> 00:56:05,460
然后你然后你下次在用的时候呢

1107
00:56:05,460 --> 00:56:06,390
这个地址变了

1108
00:56:06,720 --> 00:56:09,210
那你肯定要报错的

1109
00:56:09,210 --> 00:56:09,870
对吧

1110
00:56:09,960 --> 00:56:11,760
为了防止这种情况

1111
00:56:11,850 --> 00:56:13,050
为了防止这种情况

1112
00:56:13,050 --> 00:56:14,760
实际上这种情况叫什么叫脏数据

1113
00:56:15,480 --> 00:56:16,260
叫脏数据

1114
00:56:16,350 --> 00:56:19,320
数据数数据被损坏了

1115
00:56:19,590 --> 00:56:21,060
那为了防止这种情况

1116
00:56:21,120 --> 00:56:23,790
那GC在在在进行工作的时候

1117
00:56:23,940 --> 00:56:25,890
那V8引擎他就要暂停

1118
00:56:27,190 --> 00:56:27,760
微微吧

1119
00:56:27,760 --> 00:56:29,170
他就他就不能执行了

1120
00:56:29,200 --> 00:56:30,610
Java也是这种

1121
00:56:30,610 --> 00:56:32,800
Java也是这种东西

1122
00:56:32,920 --> 00:56:35,920
也也是这这一套机制你地址

1123
00:56:36,790 --> 00:56:39,430
他不是他不是代码地址

1124
00:56:39,550 --> 00:56:40,300
他不是代码

1125
00:56:40,300 --> 00:56:41,650
它是数据的地址

1126
00:56:42,670 --> 00:56:45,430
其实你对象你对象都是数据

1127
00:56:45,430 --> 00:56:47,590
你要注意对象是数据

1128
00:56:47,710 --> 00:56:49,180
他在数据空间里

1129
00:56:50,460 --> 00:56:53,940
他不在代码空间里咱们王了吗

1130
00:56:54,000 --> 00:57:00,090
咱们这个程序两大块儿两大块儿的那个程序的内存空间分两大块儿

1131
00:57:00,880 --> 00:57:02,170
那一个是

1132
00:57:03,160 --> 00:57:04,660
一个是代码空间

1133
00:57:04,750 --> 00:57:08,620
一个是一个是那个

1134
00:57:08,620 --> 00:57:18,490
一个是那个这个这个这个这个数据空间老袁讲的新生代老生代那是GC的策略

1135
00:57:18,760 --> 00:57:20,830
那是GC的管理策略

1136
00:57:21,640 --> 00:57:23,530
和我讲的不是一回事儿

1137
00:57:23,860 --> 00:57:25,240
老袁那个新生代

1138
00:57:25,240 --> 00:57:27,910
老生代那是GC的那个管理策略

1139
00:57:28,150 --> 00:57:29,770
我讲的这个是什么

1140
00:57:29,830 --> 00:57:32,620
讲的是GC在工作的时候

1141
00:57:32,710 --> 00:57:35,230
你的虚拟机或还有这个微吧

1142
00:57:35,230 --> 00:57:36,250
他又要停顿

1143
00:57:37,470 --> 00:57:39,150
明白了吧

1144
00:57:41,430 --> 00:57:44,910
新生代老生代试剂C具体怎么去工作

1145
00:57:44,910 --> 00:57:47,940
他具体怎么去管理内存是吧

1146
00:57:48,150 --> 00:57:52,020
实际上实际上这个GGC他在工作的时候

1147
00:57:52,020 --> 00:57:52,860
他这个内存

1148
00:57:52,890 --> 00:57:55,020
它这个内存它它这个堆内存

1149
00:57:55,140 --> 00:57:57,870
不是一一个一个往往后排的

1150
00:57:58,050 --> 00:57:59,040
他是干什么

1151
00:57:59,220 --> 00:58:00,300
往这儿放

1152
00:58:00,450 --> 00:58:01,650
还要往这儿放

1153
00:58:02,720 --> 00:58:04,760
往中间挤的

1154
00:58:04,760 --> 00:58:06,860
他是要往中间挤的

1155
00:58:06,860 --> 00:58:07,970
中间是空的

1156
00:58:08,000 --> 00:58:09,950
两头往两头放数据

1157
00:58:10,070 --> 00:58:11,540
这是真正的那个

1158
00:58:11,540 --> 00:58:14,930
这是真正它的那个操作模式

1159
00:58:15,020 --> 00:58:16,580
我在这儿给你讲

1160
00:58:16,730 --> 00:58:18,590
给你们讲是按照顺序讲

1161
00:58:18,590 --> 00:58:20,870
这是为了说明说明道理

1162
00:58:21,730 --> 00:58:23,710
说明这个道理

1163
00:58:25,330 --> 00:58:25,630
好

1164
00:58:25,630 --> 00:58:26,110
然后呢

1165
00:58:26,110 --> 00:58:29,440
这个这是那个JS引擎

1166
00:58:29,440 --> 00:58:32,320
它内部的这个内部的这个工作机制

1167
00:58:32,500 --> 00:58:34,450
那么这个工作机制

1168
00:58:36,020 --> 00:58:38,270
这个工作机制呢

1169
00:58:38,270 --> 00:58:40,520
全都是在实现的代码里

1170
00:58:41,810 --> 00:58:44,000
之后咱们再再接着看

1171
00:58:44,240 --> 00:58:46,580
再接着看V8和JS号

1172
00:58:46,580 --> 00:58:49,700
他们俩之间的这个他们俩之间的这个区别

1173
00:58:49,910 --> 00:58:52,070
JS Qu ER a它是默认的

1174
00:58:52,100 --> 00:58:53,720
他是web的默认的

1175
00:58:53,930 --> 00:58:56,600
而那个现在现在那个Chrome里边儿

1176
00:58:56,600 --> 00:58:58,790
它不叫它不叫那个web kit啦

1177
00:58:58,790 --> 00:59:00,170
他叫blink啦

1178
00:59:00,470 --> 00:59:04,250
那GS ku他也是他也是那个

1179
00:59:04,250 --> 00:59:07,640
他也是那个恶这这个开源的

1180
00:59:07,670 --> 00:59:08,900
它它也是这个开源的

1181
00:59:09,050 --> 00:59:09,830
然后呢

1182
00:59:11,830 --> 00:59:13,900
一开始它的性能并不好

1183
00:59:14,290 --> 00:59:15,490
那么就是因为

1184
00:59:15,490 --> 00:59:17,530
一开始JS靠的性能不好

1185
00:59:17,530 --> 00:59:20,920
然后Google他才开始开开始打算把它给替换掉

1186
00:59:21,100 --> 00:59:24,700
要不然他就在那个JS号上去去做分支了

1187
00:59:24,700 --> 00:59:25,060
对吧

1188
00:59:25,300 --> 00:59:26,020
那威吧

1189
00:59:26,020 --> 00:59:27,940
他可不是GS ku的分支

1190
00:59:27,940 --> 00:59:30,010
不令格式是web kit的分支

1191
00:59:30,010 --> 00:59:34,450
蛋蛋V8 he和那个外盒这个JS可是完全不一样的

1192
00:59:34,840 --> 00:59:38,200
那么这个玩意儿它它也是有什么

1193
00:59:38,200 --> 00:59:40,390
它里边也是有这个

1194
00:59:40,390 --> 00:59:43,060
这个字节码的这个解释器

1195
00:59:43,060 --> 00:59:46,930
实际上V8和GS号是越来越像了

1196
00:59:47,560 --> 00:59:49,780
这他们的这个实现机制是越来越像了

1197
00:59:49,990 --> 00:59:51,550
这这个技术路线

1198
00:59:51,550 --> 00:59:55,780
走着走着就走到一起去了一开始他们还有差异

1199
00:59:55,780 --> 00:59:58,390
按照自己的思路去走去去实现

1200
00:59:58,540 --> 00:59:59,530
但是实现呢

1201
00:59:59,530 --> 01:00:02,650
实现都都就走到一个走到一条路上来了

1202
01:00:02,650 --> 01:00:04,330
因为他们分别证明了

1203
01:00:04,330 --> 01:00:05,740
那个方向不行

1204
01:00:05,740 --> 01:00:08,860
那个方向走不通能走通的方向

1205
01:00:08,860 --> 01:00:11,590
然后别人然后那个对方就学了去了

1206
01:00:11,590 --> 01:00:13,480
所以这这这这俩东西

1207
01:00:13,480 --> 01:00:14,350
最终啊

1208
01:00:14,350 --> 01:00:18,940
最终这个技术电视就就会那个就会趋同的

1209
01:00:20,350 --> 01:00:24,280
那么那个JS Qu而他这个JS扣呢

1210
01:00:24,370 --> 01:00:25,540
到今天

1211
01:00:25,540 --> 01:00:28,120
它的性能也是也是很不错了

1212
01:00:28,120 --> 01:00:29,140
但是呢

1213
01:00:29,140 --> 01:00:30,730
他他后发

1214
01:00:30,730 --> 01:00:32,830
他他他他没有先发优势了

1215
01:00:32,980 --> 01:00:33,760
那个V8

1216
01:00:33,760 --> 01:00:39,010
他那个那个V8已经那个弄的JS已经用用这个V8了

1217
01:00:39,010 --> 01:00:42,370
还有好多好多东西也已经习惯用V8了

1218
01:00:42,490 --> 01:00:45,190
所以GS靠现在现在比较

1219
01:00:45,190 --> 01:00:46,120
现在性能好了

1220
01:00:46,120 --> 01:00:47,290
但是呢

1221
01:00:47,320 --> 01:00:55,960
很少有有用有趣欠这个JS号的这这个引擎的了所以说他他那个先发优势

1222
01:00:55,960 --> 01:00:57,970
没有然后呢

1223
01:00:57,970 --> 01:01:01,180
这个note JS里面V8NOTE JS里面这个V8呢

1224
01:01:01,180 --> 01:01:02,980
咱们那个上节课给大家

1225
01:01:03,950 --> 01:01:06,410
上节课给大家讲过这个东西了

1226
01:01:06,530 --> 01:01:07,790
No的JS

1227
01:01:07,940 --> 01:01:12,200
他里边儿两个重要的重要的模块儿是啥呀

1228
01:01:12,260 --> 01:01:14,750
一个是V81个是事件循环

1229
01:01:14,990 --> 01:01:15,560
对吧

1230
01:01:15,680 --> 01:01:19,760
这这俩东西都不是弄的JS他自己实现出来的

1231
01:01:20,000 --> 01:01:24,470
No的JS他自己实现的是个啥东西呢

1232
01:01:24,530 --> 01:01:27,080
就是这个弄得buildings

1233
01:01:27,620 --> 01:01:28,010
哈哈

1234
01:01:28,040 --> 01:01:30,740
这这是那个note JS他自己的东西

1235
01:01:30,920 --> 01:01:33,110
那他他就是把这些东西往里插

1236
01:01:33,110 --> 01:01:36,530
这是V8在弄的JS的这这个地位

1237
01:01:36,530 --> 01:01:38,270
这个东西咱们上节课讲过了

1238
01:01:38,270 --> 01:01:39,560
这节课就不多说了

1239
01:01:39,740 --> 01:01:44,720
然后弄得JS这这些东西咱就不多说了之后呢

1240
01:01:44,720 --> 01:01:47,150
咱们就要涉及到这个源码了

1241
01:01:47,240 --> 01:01:48,410
就涉及到这个源码

1242
01:01:48,530 --> 01:01:50,930
那么这个VBA源码

1243
01:01:50,930 --> 01:01:52,550
VBA源码他在

1244
01:01:53,020 --> 01:01:54,310
他在那个

1245
01:01:56,010 --> 01:01:58,230
他在他是那个

1246
01:01:59,960 --> 01:02:03,410
Chromium就是古这个它不叫谷歌浏览器

1247
01:02:03,410 --> 01:02:08,360
他是那个开源版的谷那个谷歌浏览器开源版的谷歌浏览器

1248
01:02:08,360 --> 01:02:10,580
它不叫浏览器叫谷歌浏览器

1249
01:02:10,850 --> 01:02:15,620
那么它是那个开源版的那个谷歌浏览器里边的一个子项目这个微吧

1250
01:02:15,920 --> 01:02:17,600
那咱们要找它的代码

1251
01:02:17,600 --> 01:02:19,250
就是到他的官网上去

1252
01:02:19,370 --> 01:02:21,890
官方网站上去找那但是这个东西呢

1253
01:02:21,890 --> 01:02:26,120
得得得需要一些那个技术手段呢

1254
01:02:26,120 --> 01:02:29,420
你你要想你要想去想去那个

1255
01:02:29,960 --> 01:02:32,540
看他的画得得需要一些技术手段

1256
01:02:32,540 --> 01:02:36,500
这个技术手段咱别别说话别别别别说别说

1257
01:02:36,500 --> 01:02:38,330
你要说你要说了

1258
01:02:38,330 --> 01:02:41,210
那个咱咱容易被封

1259
01:02:41,210 --> 01:02:44,540
咱这课堂被封现在现在管的挺严的

1260
01:02:45,780 --> 01:02:46,080
对

1261
01:02:47,110 --> 01:02:51,220
那么这个在那个Chrome的源码

1262
01:02:51,520 --> 01:02:52,600
Chrome的源码

1263
01:02:52,630 --> 01:02:55,030
还有V8的源码都放在一起了

1264
01:02:55,030 --> 01:02:56,530
但是咱们

1265
01:02:56,530 --> 01:02:58,120
这个Chrome的源码相当大

1266
01:02:59,110 --> 01:03:00,370
科普源码相当大的

1267
01:03:00,550 --> 01:03:01,150
但是呢

1268
01:03:01,150 --> 01:03:02,980
那个V8的这个代码呢

1269
01:03:02,980 --> 01:03:03,970
就就30多兆

1270
01:03:03,970 --> 01:03:11,230
它压缩以后就30多兆然后咱们咱们那个先看一下先那个先不看他源码了

1271
01:03:11,380 --> 01:03:15,670
先看一下它这个V8的这个官网V8的这个官网

1272
01:03:15,670 --> 01:03:19,300
如果说我们要想学他的这个代码的话

1273
01:03:19,300 --> 01:03:24,310
V8官网它这个博客和文档是必不可少的

1274
01:03:25,520 --> 01:03:27,050
那么这个博客

1275
01:03:27,080 --> 01:03:30,050
这个博客你看他这都是release对吧

1276
01:03:30,110 --> 01:03:31,730
各种release各种发版

1277
01:03:31,970 --> 01:03:34,190
但是你不要看他这个各种发版

1278
01:03:34,190 --> 01:03:36,440
各种发版只是告诉你这个新特性

1279
01:03:36,770 --> 01:03:38,210
那他里边儿是什么呢

1280
01:03:38,450 --> 01:03:43,370
它里边儿是有好多这个开发团队他们写的文章

1281
01:03:44,530 --> 01:03:50,830
开发团队写的文章就是说这个V8哪一块儿我做了什么优化了

1282
01:03:50,830 --> 01:03:52,510
这个优化的这个方向

1283
01:03:52,510 --> 01:03:54,700
这个优化的这个实现细节是什么

1284
01:03:54,820 --> 01:03:55,690
原理是什么

1285
01:03:55,690 --> 01:03:56,920
我为什么要这样优化

1286
01:03:58,040 --> 01:04:00,380
比如说像像这个对吧

1287
01:04:00,470 --> 01:04:03,950
一个那个这个正则表达式引擎

1288
01:04:03,980 --> 01:04:05,750
它给它给那个

1289
01:04:07,010 --> 01:04:08,210
他给那个优化了

1290
01:04:09,320 --> 01:04:09,800
对吧

1291
01:04:09,890 --> 01:04:15,290
他那个这叫这叫这这这这叫那个back tracking啊

1292
01:04:15,290 --> 01:04:21,650
这这个non bank transfer这这个模式的那个是正则

1293
01:04:21,650 --> 01:04:24,050
这个模式的政则它它开始支持了

1294
01:04:24,680 --> 01:04:28,550
就是那个回溯那就是这个正则回溯那个玩意儿

1295
01:04:29,870 --> 01:04:33,020
他他这里他的那个实现实现原理

1296
01:04:33,020 --> 01:04:34,250
乱七八糟的

1297
01:04:34,250 --> 01:04:39,050
这这都是这都是人家团队的那个人加团队作者弄的

1298
01:04:39,140 --> 01:04:44,180
然后那个之前给之前那个翻译过一个

1299
01:04:44,210 --> 01:04:48,200
之之前翻译过一个就是那个压缩指针的那个

1300
01:04:48,200 --> 01:04:55,970
他把64位指针压缩拆成那个两个32位指针他他他他进行他他进行那个处理

1301
01:04:56,780 --> 01:04:59,540
原来我翻译过那个在后后边找不到了

1302
01:04:59,630 --> 01:05:04,190
然后还有什么G类似j it类似微吧

1303
01:05:04,190 --> 01:05:05,060
这是这是什么

1304
01:05:05,120 --> 01:05:07,160
不用j it的V8

1305
01:05:07,810 --> 01:05:10,660
去掉JJH的微博所有的机制

1306
01:05:10,660 --> 01:05:11,770
就是所有的那个机制

1307
01:05:11,770 --> 01:05:14,290
还有各种各种各样的测试

1308
01:05:14,290 --> 01:05:17,350
这个这个这个这个这个测试结果

1309
01:05:17,350 --> 01:05:18,100
乱七八糟的

1310
01:05:18,280 --> 01:05:20,350
实际上要想把这个VBA学好

1311
01:05:20,350 --> 01:05:21,670
就就看这个

1312
01:05:21,670 --> 01:05:26,200
就看这个他的这个博客就就是人家那个东西

1313
01:05:26,890 --> 01:05:29,350
就是人家做的这个开发团队弄的

1314
01:05:29,380 --> 01:05:32,950
然后这个还有他的这个他的这个文档

1315
01:05:32,950 --> 01:05:36,460
它的文档就是详细详细说了这个微吧

1316
01:05:36,580 --> 01:05:39,880
你在基于这个VBA进行开发的时候

1317
01:05:41,050 --> 01:05:42,130
这个东西咱们不用

1318
01:05:42,130 --> 01:05:44,920
咱们就没没有什么必要看了

1319
01:05:45,070 --> 01:05:53,440
这个这个文档是你要想把这个V8引擎嵌入到自己的系统里边儿去就就好像是你在做一个漏的对吧

1320
01:05:53,620 --> 01:05:55,480
你你做个单呢

1321
01:05:55,540 --> 01:06:00,250
你去内内内那个作者他做完弄得他他在做呆着

1322
01:06:00,370 --> 01:06:02,980
就是干这种干这种活的

1323
01:06:02,980 --> 01:06:03,940
干这种事儿的人

1324
01:06:04,120 --> 01:06:05,110
他们要看这个

1325
01:06:05,520 --> 01:06:07,410
看那个文档

1326
01:06:07,560 --> 01:06:11,010
你或者说你把它放到那个嵌入式

1327
01:06:15,480 --> 01:06:16,320
这个啊

1328
01:06:16,560 --> 01:06:17,820
这这这个字

1329
01:06:18,360 --> 01:06:19,440
DEMO啊

1330
01:06:19,440 --> 01:06:21,750
就把note给倒过来

1331
01:06:21,960 --> 01:06:23,010
一个作者

1332
01:06:23,010 --> 01:06:25,500
一个作者写的单都是用那个rust写的

1333
01:06:25,860 --> 01:06:26,880
他不用C加加写了

1334
01:06:26,880 --> 01:06:27,930
一开始用go写

1335
01:06:28,350 --> 01:06:31,350
后来发现那个勾的那个勾

1336
01:06:31,350 --> 01:06:36,750
勾的那个GC会和那个会和那个V8

1337
01:06:36,750 --> 01:06:39,930
会会和他这个单独的这个DJ冲突

1338
01:06:39,930 --> 01:06:43,350
它它会产生那个双击C这种问题

1339
01:06:44,010 --> 01:06:45,330
所以他就放弃了勾

1340
01:06:45,360 --> 01:06:49,350
然后直接用那个rust完全完全自己去管理内存了

1341
01:06:49,620 --> 01:06:51,450
他冲先用勾写了

1342
01:06:51,450 --> 01:06:53,040
一写了一半儿发现不对劲儿

1343
01:06:53,040 --> 01:06:54,630
然后就就改成rush了

1344
01:06:54,630 --> 01:06:56,310
这个人真是个大牛

1345
01:06:56,310 --> 01:06:57,210
什么都能干

1346
01:06:57,890 --> 01:06:59,360
什么语言都拿得起来

1347
01:06:59,630 --> 01:07:00,440
说换就换

1348
01:07:01,100 --> 01:07:02,420
架构能力也好

1349
01:07:03,620 --> 01:07:04,310
然后呢

1350
01:07:04,310 --> 01:07:06,470
这这个这这个官网

1351
01:07:06,470 --> 01:07:15,710
不要那个不要忘了去去去那个去看的那个我去那个还没打开

1352
01:07:16,900 --> 01:07:18,070
然后我们看一下

1353
01:07:18,340 --> 01:07:19,330
看一下这个

1354
01:07:19,360 --> 01:07:20,590
看一下那个cur name

1355
01:07:22,960 --> 01:07:24,850
这个V8的这个源代码

1356
01:07:25,000 --> 01:07:31,480
那这个这个chromium chromium这这个地方在在这个地方它是

1357
01:07:32,320 --> 01:07:35,140
他这个就是一个SVN

1358
01:07:35,140 --> 01:07:37,300
它它就相当于一个那个SVN啊

1359
01:07:40,910 --> 01:07:43,010
然后一个web版的那个SVN

1360
01:07:43,010 --> 01:07:44,210
就是一个代码管理器

1361
01:07:44,360 --> 01:07:47,030
像这个这这这这这这个里边呢

1362
01:07:47,030 --> 01:07:50,150
也以所有的代码你都能看得到

1363
01:07:50,150 --> 01:07:51,500
现现在打不开

1364
01:07:51,620 --> 01:07:53,210
打不开就先先不管他了

1365
01:07:53,540 --> 01:07:54,380
那么接下来呢

1366
01:07:54,380 --> 01:07:55,580
咱们得搞清楚

1367
01:07:55,670 --> 01:07:57,050
咱们要学这个微吧

1368
01:07:57,050 --> 01:07:58,100
学的是什么东西

1369
01:07:58,980 --> 01:08:00,780
你并不是为了看代码儿

1370
01:08:00,780 --> 01:08:03,510
看代码咱们要朝这么几个方向去看

1371
01:08:03,780 --> 01:08:06,090
第一个是什么呢

1372
01:08:06,090 --> 01:08:07,050
JSJS的理解

1373
01:08:07,050 --> 01:08:08,790
增加G对JS的理解

1374
01:08:08,970 --> 01:08:11,490
你比如说像他那个object

1375
01:08:12,070 --> 01:08:12,490
对吧

1376
01:08:12,580 --> 01:08:14,050
JS的那个object

1377
01:08:14,050 --> 01:08:16,330
它究竟是怎么回事儿

1378
01:08:16,330 --> 01:08:18,160
他是他他是怎么实现的

1379
01:08:18,250 --> 01:08:19,420
还有那个原型链

1380
01:08:19,420 --> 01:08:24,460
它究竟是怎么回事儿你通过你在代码底层那个代码层面上去理解它

1381
01:08:24,820 --> 01:08:25,720
还有一些呢

1382
01:08:25,720 --> 01:08:27,910
就是它里边有好多各种各样的那个算法

1383
01:08:27,940 --> 01:08:32,350
通过那个东西去去学算法还有就是内存管理

1384
01:08:32,410 --> 01:08:34,060
内存管理还有他那个GC

1385
01:08:34,510 --> 01:08:36,820
还有这个编译原理

1386
01:08:37,000 --> 01:08:38,380
投进代码去

1387
01:08:38,380 --> 01:08:40,150
然后生成生成啥呀

1388
01:08:40,210 --> 01:08:44,170
就是这个东西投进代码去生成抽象语法树

1389
01:08:44,170 --> 01:08:45,340
这个是编译原理的

1390
01:08:45,400 --> 01:08:46,270
然后呢

1391
01:08:46,330 --> 01:08:47,170
还有啥呀

1392
01:08:47,170 --> 01:08:49,720
操作系统方面的知识

1393
01:08:49,720 --> 01:08:51,460
操作系统方面的东西

1394
01:08:52,870 --> 01:08:59,290
这怎么去怎么去那个怎么去向向向外去去传递东西

1395
01:08:59,440 --> 01:09:00,550
对吧

1396
01:09:00,550 --> 01:09:02,830
最最终就是就是面试

1397
01:09:02,950 --> 01:09:04,420
就最终就是面试

1398
01:09:04,420 --> 01:09:06,610
人家要问你看过VBA的代码吗

1399
01:09:06,610 --> 01:09:07,360
你说看过

1400
01:09:08,300 --> 01:09:09,470
你就可以说看过

1401
01:09:09,590 --> 01:09:11,270
人家会问你看过哪部分

1402
01:09:11,300 --> 01:09:14,000
然后你就说你最熟的那一部分是吧

1403
01:09:14,000 --> 01:09:17,090
这一部分是它是怎么实现的她用的什么数据结构

1404
01:09:17,090 --> 01:09:18,260
一个什么样的处理机制

1405
01:09:18,260 --> 01:09:22,160
他先先干什么再干什么然后这个数据结构上有什么东西

1406
01:09:22,160 --> 01:09:23,780
哪个东西是干什么用的

1407
01:09:23,930 --> 01:09:26,900
你你你你就能你就能说出来了

1408
01:09:26,900 --> 01:09:29,420
那那就说这那那你就牛了

1409
01:09:29,570 --> 01:09:30,860
那就工资也就有了

1410
01:09:31,370 --> 01:09:31,790
对吧

1411
01:09:32,060 --> 01:09:33,380
然后那个

1412
01:09:35,140 --> 01:09:36,520
那么那个接接着呢

1413
01:09:36,520 --> 01:09:40,000
就是那个图这个V8引擎

1414
01:09:40,000 --> 01:09:42,580
V8引擎里边咱们需要着重看的

1415
01:09:42,580 --> 01:09:45,010
着重看的比如说像那个数据类型

1416
01:09:45,730 --> 01:09:46,300
对吧

1417
01:09:46,420 --> 01:09:49,870
里边儿实际上这个JS它是它是弱类型语言

1418
01:09:49,930 --> 01:09:53,380
咱们要是要说它没有类型也未免太偏颇了

1419
01:09:53,500 --> 01:09:56,800
还是有一还是有那么几种类型的

1420
01:09:56,800 --> 01:09:58,480
当然他不是真正的类型

1421
01:09:58,480 --> 01:09:59,350
它那个数据

1422
01:09:59,710 --> 01:10:02,710
它那个数据它是它是它那个类型究竟是怎么样的

1423
01:10:02,830 --> 01:10:03,340
对吧

1424
01:10:03,340 --> 01:10:04,600
它是怎么实现出来的

1425
01:10:04,810 --> 01:10:05,230
另外呢

1426
01:10:05,230 --> 01:10:08,710
它里边儿内存还有那个绑定机制

1427
01:10:08,710 --> 01:10:10,930
它还有还有那个JS那个绑定机制

1428
01:10:11,050 --> 01:10:11,530
最后呢

1429
01:10:11,530 --> 01:10:12,460
就是这个字节版

1430
01:10:12,460 --> 01:10:14,320
还有j it它这个处理过程

1431
01:10:14,500 --> 01:10:17,080
就就就主要是看看这些东西

1432
01:10:17,200 --> 01:10:19,870
然后然后又又现在又多了什么呢

1433
01:10:19,870 --> 01:10:21,430
多了一个SM

1434
01:10:22,630 --> 01:10:26,440
WSM现在已经那个正式的支持了

1435
01:10:26,440 --> 01:10:36,130
他他就他比那个它比那个GT比比的更近了一步GT是把你里边的代码片段变成什么

1436
01:10:36,130 --> 01:10:38,860
变成CPU可以执行的那个代码儿

1437
01:10:38,860 --> 01:10:40,540
那个WSM呢

1438
01:10:40,600 --> 01:10:42,580
把你一个模块儿

1439
01:10:42,580 --> 01:10:45,940
把一个模块完全变成CPU可以执行的代码

1440
01:10:45,940 --> 01:10:47,980
这样效率更高了对吧

1441
01:10:48,220 --> 01:10:51,340
那那个更进一步

1442
01:10:51,340 --> 01:10:56,410
后边儿后边的课会给下个星期应该是下个星期给大家讲这个WSM啊

1443
01:10:57,720 --> 01:10:57,960
好

1444
01:10:57,960 --> 01:11:02,220
那然后这个这个PPT这一块儿就就就给大家这个说完了

1445
01:11:02,340 --> 01:11:05,490
然后这节课剩下的部分就全全都是代码

1446
01:11:05,490 --> 01:11:10,350
带着带带着大家的去去看那个去去做这个代码分析

1447
01:11:10,560 --> 01:11:12,330
然后再做代码分析的时候呢

1448
01:11:12,330 --> 01:11:15,630
还也会还会给大家去讲一些那个语法

1449
01:11:15,630 --> 01:11:16,230
C语言

1450
01:11:16,230 --> 01:11:17,670
还有C加加的这个语法

1451
01:11:17,700 --> 01:11:18,960
让让大家能够看懂

1452
01:11:18,960 --> 01:11:21,480
现在的目标是能看懂

1453
01:11:21,480 --> 01:11:24,450
不是不是去写好咱们先休息五分钟

1454
01:11:24,480 --> 01:11:25,680
接下来就是代码部分

1455
01:13:27,590 --> 01:13:29,780
Miss me like I was made for you

1456
01:13:31,760 --> 01:13:43,460
and you re you re you can I stay for me that I would just mi you cannot escape from me that I was just a Li

1457
01:13:48,290 --> 01:13:49,130
阿狸

1458
01:13:50,570 --> 01:13:51,410
阿狸阿狸

1459
01:13:52,880 --> 01:13:53,690
阿狸阿狸

1460
01:13:55,130 --> 01:13:55,400
阿狸

1461
01:14:22,560 --> 01:14:28,410
When I started its next to him and him

1462
01:14:36,420 --> 01:14:37,500
in the

1463
01:14:41,220 --> 01:14:42,510
giving you my long

1464
01:14:44,070 --> 01:14:44,550
beach

1465
01:15:04,320 --> 01:15:07,140
hello hello

1466
01:15:08,250 --> 01:15:09,990
hello

1467
01:18:51,150 --> 01:19:01,140
A group of rock and roll all night and sat down just a little bits of the group and

1468
01:19:33,740 --> 01:19:33,950
好

1469
01:19:33,950 --> 01:19:35,270
咱们开始看代码

1470
01:19:35,990 --> 01:19:37,160
咱开始看代码

1471
01:19:45,390 --> 01:19:46,320
这玩意儿打不开

1472
01:19:46,320 --> 01:19:46,980
我去

1473
01:19:53,410 --> 01:19:54,460
QQ打不开

1474
01:19:54,520 --> 01:19:56,080
嘿嘿嘿

1475
01:19:58,630 --> 01:20:00,190
这抽什么疯了不知道

1476
01:20:08,950 --> 01:20:10,180
那个任务代码呢

1477
01:20:10,180 --> 01:20:11,890
一般那个

1478
01:20:13,100 --> 01:20:13,880
不敢下载

1479
01:20:15,020 --> 01:20:17,330
我这儿下载了这个web kit

1480
01:20:17,330 --> 01:20:19,400
把这个web下载下来发

1481
01:20:19,430 --> 01:20:20,180
后悔了

1482
01:20:20,540 --> 01:20:20,900
呵呵

1483
01:20:21,320 --> 01:20:23,840
Web kit这个包太大了

1484
01:20:24,320 --> 01:20:28,460
而且里边儿那个代码是极其的那个啥恶

1485
01:20:28,640 --> 01:20:30,590
而且我下载下载完了以后呢

1486
01:20:30,590 --> 01:20:31,700
发现下载错了

1487
01:20:32,480 --> 01:20:34,280
下载的是那个工具

1488
01:20:34,520 --> 01:20:36,560
下载试试一套工具

1489
01:20:36,560 --> 01:20:42,230
不是那个源码就下载了这个lab we note

1490
01:20:42,230 --> 01:20:43,310
还有这个V8

1491
01:20:43,310 --> 01:20:45,410
这这三个东西

1492
01:20:45,410 --> 01:20:48,530
先说这个阿赖屋

1493
01:20:48,530 --> 01:20:49,820
这个lab Le

1494
01:20:52,330 --> 01:20:55,090
这个lab we是C语言的库

1495
01:20:55,480 --> 01:20:57,490
那么这个C语这这个裤呢

1496
01:20:58,540 --> 01:21:00,580
它是一个底层互

1497
01:21:00,940 --> 01:21:03,160
那咱们拿到这个C代码的话

1498
01:21:03,160 --> 01:21:04,510
怎么看

1499
01:21:04,510 --> 01:21:05,620
怎么去看

1500
01:21:05,890 --> 01:21:07,090
咱们这个C代码

1501
01:21:07,090 --> 01:21:11,440
先给大家说一下这个C代码你怎么去编译他

1502
01:21:22,740 --> 01:21:26,730
C代码咋编译他C代码呢

1503
01:21:26,730 --> 01:21:28,890
它里边儿这个背的时候

1504
01:21:28,890 --> 01:21:29,880
有这个GCC

1505
01:21:30,910 --> 01:21:32,500
有这个GCC先

1506
01:21:32,620 --> 01:21:33,610
这GCC呢

1507
01:21:33,610 --> 01:21:36,400
属于C语言编译链

1508
01:21:36,400 --> 01:21:37,390
属于它编译链

1509
01:21:37,600 --> 01:21:38,230
它里边呢

1510
01:21:38,230 --> 01:21:42,430
有一有一有一整套的这个工具GC是其中一个

1511
01:21:42,790 --> 01:21:45,490
那么GCC编译完了以后呢

1512
01:21:45,610 --> 01:21:50,320
那GCC然后后边就是你的那个什么什么什么什么点C

1513
01:21:51,220 --> 01:21:51,640
点C

1514
01:21:51,640 --> 01:21:52,540
然后杠o

1515
01:21:52,600 --> 01:21:53,410
杠o呢

1516
01:21:53,410 --> 01:21:54,310
就是

1517
01:21:54,370 --> 01:21:57,400
你要输出到什么文件上

1518
01:21:57,400 --> 01:21:58,540
输出到什么文件上

1519
01:21:58,540 --> 01:22:01,450
比如说a点a

1520
01:22:01,450 --> 01:22:04,240
你输出的这个可执行文件和或者点o

1521
01:22:04,240 --> 01:22:06,190
这只output文件就是输出文件

1522
01:22:06,460 --> 01:22:08,650
这就是CPU可以执行的代码了

1523
01:22:09,040 --> 01:22:09,700
但是呢

1524
01:22:09,820 --> 01:22:15,940
咱们执行咱们是咱们在写这个C代码的时候呢

1525
01:22:16,000 --> 01:22:20,200
这些代码是有好多的一个C一个C代码

1526
01:22:20,230 --> 01:22:22,090
你就得执行一下这个GC

1527
01:22:22,240 --> 01:22:24,610
然后生成一个点o文件

1528
01:22:24,610 --> 01:22:26,050
这样呢

1529
01:22:26,050 --> 01:22:27,580
效率太低了

1530
01:22:27,580 --> 01:22:28,240
对对吧

1531
01:22:28,360 --> 01:22:30,640
你你要执行好多次这个GCC

1532
01:22:30,820 --> 01:22:31,810
那怎么办呢

1533
01:22:31,870 --> 01:22:34,840
就要涉及到这个编译链儿里边儿第二个工具

1534
01:22:34,840 --> 01:22:36,040
第二个工具叫什么呢

1535
01:22:36,220 --> 01:22:37,330
叫makefile

1536
01:22:37,970 --> 01:22:38,720
他叫美卡

1537
01:22:39,590 --> 01:22:41,330
是make文件

1538
01:22:41,390 --> 01:22:42,560
是这个make命令

1539
01:22:42,920 --> 01:22:46,130
Make命令它是一个脚本解释器

1540
01:22:46,250 --> 01:22:48,620
这个脚本解释器干什么用呢

1541
01:22:48,800 --> 01:22:51,770
他去处理那个makefile

1542
01:22:52,070 --> 01:22:53,660
她处理这个文件

1543
01:22:53,780 --> 01:22:57,470
那么这个makefile这当然他不是正规的那个makefile

1544
01:22:57,680 --> 01:23:00,860
正正常的那个过程

1545
01:23:00,860 --> 01:23:04,100
正常的那个边这个编译过程应该是

1546
01:23:04,900 --> 01:23:06,160
应该是啥样呢

1547
01:23:06,310 --> 01:23:08,560
先找一个脚本

1548
01:23:08,590 --> 01:23:11,770
就是config来这个脚本

1549
01:23:11,770 --> 01:23:12,910
先找这个脚本

1550
01:23:13,300 --> 01:23:14,650
这个脚本干什么

1551
01:23:14,830 --> 01:23:17,170
他先去扫描你的操作系统

1552
01:23:17,560 --> 01:23:23,860
那看你的操作系统里边有没有装那个对应它所依赖的那些库

1553
01:23:24,070 --> 01:23:25,180
还干什么呢

1554
01:23:25,180 --> 01:23:26,650
还去看

1555
01:23:26,830 --> 01:23:30,010
还去检查你的操作系统版本

1556
01:23:30,010 --> 01:23:31,600
你的CPU等等

1557
01:23:31,780 --> 01:23:32,620
他去干这个

1558
01:23:32,860 --> 01:23:35,560
然后生成一个makefile文件

1559
01:23:35,560 --> 01:23:36,550
就生成这个东西

1560
01:23:36,790 --> 01:23:38,590
它生成的makefile文件呢

1561
01:23:38,590 --> 01:23:39,580
是不带后缀的

1562
01:23:40,030 --> 01:23:40,810
没有后缀

1563
01:23:40,930 --> 01:23:42,970
就是直接一个makefile

1564
01:23:42,970 --> 01:23:44,230
那个L还是大写

1565
01:23:44,410 --> 01:23:45,340
然后呢

1566
01:23:45,970 --> 01:23:48,610
Makefile里边儿就是编译脚本呢

1567
01:23:48,610 --> 01:23:53,890
它自动的帮着你去写这些GC什么什么杠o什么什么

1568
01:23:53,950 --> 01:23:56,080
而且它还支持通配符之类的

1569
01:23:56,500 --> 01:23:59,800
那我们自己去写这个CC项目的时候呢

1570
01:23:59,800 --> 01:24:04,480
我们也可以自己去去编辑这个makefile文件

1571
01:24:04,480 --> 01:24:06,400
也自己去写这个脚本

1572
01:24:06,430 --> 01:24:06,940
然后呢

1573
01:24:07,060 --> 01:24:09,340
用make直接敲make

1574
01:24:09,850 --> 01:24:15,550
那在当前在在这个makefile当前目录下悄悄这个make

1575
01:24:15,820 --> 01:24:17,410
然后他就帮你去编译

1576
01:24:17,650 --> 01:24:21,040
去编译了来这是这是那个编译过程

1577
01:24:21,040 --> 01:24:23,350
编译出来以后给你放到一个目录里边儿

1578
01:24:23,350 --> 01:24:25,870
就好像是咱们用那个web pack打包一样

1579
01:24:25,990 --> 01:24:31,480
或者说咱们用那个TS的编译器去去进行那个转码一样

1580
01:24:31,480 --> 01:24:34,150
这个这个道理是道理是一样的

1581
01:24:34,180 --> 01:24:38,440
把一种把一种形式的代码转换成另外一种形式的代码

1582
01:24:38,470 --> 01:24:40,000
这个过程就叫编译

1583
01:24:40,590 --> 01:24:42,120
那咱们C语言呢

1584
01:24:42,120 --> 01:24:45,810
是把这个文本代码转化成这个机器代码

1585
01:24:45,960 --> 01:24:47,250
TS编译器呢

1586
01:24:47,400 --> 01:24:50,400
是把TS代码转化成JS

1587
01:24:50,400 --> 01:24:52,590
转化成JS这个编译器

1588
01:24:52,590 --> 01:24:54,150
这JS代码

1589
01:24:54,330 --> 01:24:57,120
这这尽管说目标不一样

1590
01:24:57,120 --> 01:24:58,410
目标代码不一样

1591
01:24:58,440 --> 01:24:58,920
但是呢

1592
01:24:58,920 --> 01:25:01,020
他们做的事儿是一样的

1593
01:25:01,020 --> 01:25:01,470
就是转

1594
01:25:01,620 --> 01:25:03,060
就是转换代码形式

1595
01:25:03,630 --> 01:25:04,560
这是编译链儿

1596
01:25:04,590 --> 01:25:05,520
然后呢

1597
01:25:05,550 --> 01:25:08,100
咱们看看这个C语言

1598
01:25:08,100 --> 01:25:10,380
这个C语言里面这些代码

1599
01:25:11,070 --> 01:25:12,630
咱们再看代码的时候

1600
01:25:12,630 --> 01:25:14,670
主要看两个

1601
01:25:14,700 --> 01:25:16,020
主要找两个目录

1602
01:25:16,140 --> 01:25:17,910
一个目录是include

1603
01:25:17,910 --> 01:25:19,650
一个目录是这个SRC

1604
01:25:20,040 --> 01:25:23,430
先说这个include include里边放的什么点H

1605
01:25:23,730 --> 01:25:25,200
这个点H叫什么呢

1606
01:25:25,570 --> 01:25:26,890
他是头文件

1607
01:25:27,160 --> 01:25:29,050
那C语言的头文件

1608
01:25:29,350 --> 01:25:31,300
那么这个头文件里是什么

1609
01:25:31,630 --> 01:25:35,110
他是告诉这个编译器

1610
01:25:35,110 --> 01:25:40,030
告诉编译器我要编译的那些函数

1611
01:25:40,030 --> 01:25:41,680
都有哪些

1612
01:25:41,680 --> 01:25:43,810
还有一些什么全局变量

1613
01:25:43,810 --> 01:25:44,770
乱七八糟的

1614
01:25:45,010 --> 01:25:47,320
他是干它是用来定义这个的

1615
01:25:48,010 --> 01:25:50,320
那咱们在写代码的时候

1616
01:25:50,350 --> 01:25:53,650
有两实际上是在做两件事儿

1617
01:25:53,860 --> 01:25:59,230
一件事儿是做声明一件事声明一件事实现

1618
01:25:59,760 --> 01:26:01,470
那JS实际上也是这样

1619
01:26:01,650 --> 01:26:02,220
只不过呢

1620
01:26:02,220 --> 01:26:04,440
JS把声明和实现给放在一起了

1621
01:26:04,740 --> 01:26:06,750
而那个C语言

1622
01:26:06,750 --> 01:26:10,170
还有C加加语言声明和实现

1623
01:26:10,730 --> 01:26:12,410
是分开的

1624
01:26:12,410 --> 01:26:14,780
当然你也可以放在一起

1625
01:26:14,780 --> 01:26:15,830
也可以放在一起

1626
01:26:15,950 --> 01:26:17,210
你要分开的话

1627
01:26:17,270 --> 01:26:20,270
声明写在哪写在这个头文件里

1628
01:26:20,600 --> 01:26:22,670
比如说像像这个东西

1629
01:26:22,790 --> 01:26:24,200
这是一个函数

1630
01:26:24,730 --> 01:26:25,240
对吧

1631
01:26:25,420 --> 01:26:26,590
这是一个函数

1632
01:26:26,590 --> 01:26:29,470
但是函数体没有

1633
01:26:29,470 --> 01:26:31,540
这叫声明了一个函数

1634
01:26:32,310 --> 01:26:33,510
这是在声明函数

1635
01:26:33,720 --> 01:26:35,970
那么这个函数的实现在哪儿呢

1636
01:26:36,060 --> 01:26:39,600
在点C文件里把声明和实现给分开

1637
01:26:39,930 --> 01:26:41,550
那他为什么要这样做呢

1638
01:26:41,760 --> 01:26:43,440
这个要取决于

1639
01:26:44,220 --> 01:26:46,470
取决于这个壳

1640
01:26:47,950 --> 01:26:53,620
取决于这个C语言的这个编译形式

1641
01:26:53,710 --> 01:26:55,630
C语言在编译的时候

1642
01:26:55,780 --> 01:26:59,140
不仅仅是编译出那个可执行程序来

1643
01:26:59,470 --> 01:27:01,780
他还要编译出来什么

1644
01:27:01,930 --> 01:27:03,880
编译出库来

1645
01:27:04,710 --> 01:27:06,240
他还要编译出库

1646
01:27:06,480 --> 01:27:08,430
那个酷也是二进制文件

1647
01:27:08,670 --> 01:27:11,010
他和咱们JS的库是不一样的

1648
01:27:11,160 --> 01:27:12,870
JS的库是什么

1649
01:27:12,870 --> 01:27:15,900
他就是代码纯JS代码儿

1650
01:27:15,900 --> 01:27:17,580
这个C语言的库呢

1651
01:27:18,140 --> 01:27:21,140
C语言的库它就是二进制

1652
01:27:21,170 --> 01:27:21,680
然后呢

1653
01:27:21,680 --> 01:27:23,450
二进制配一个头文件

1654
01:27:24,110 --> 01:27:25,130
有头文件

1655
01:27:25,190 --> 01:27:27,740
你就在你在那个连接的时候

1656
01:27:27,740 --> 01:27:29,690
就能把那个库里的代码

1657
01:27:29,840 --> 01:27:30,920
把他给抽出来

1658
01:27:30,980 --> 01:27:35,420
然后然后嵌入到你自己的程序里边儿这是C语言的东西

1659
01:27:35,840 --> 01:27:37,520
那JS那个库呢

1660
01:27:37,520 --> 01:27:38,930
JS库他没有

1661
01:27:39,710 --> 01:27:41,390
他他不去抽

1662
01:27:41,510 --> 01:27:42,500
你默认情况下

1663
01:27:42,500 --> 01:27:45,140
它是不是它是不往外抽这个代码的

1664
01:27:45,410 --> 01:27:47,360
所以JS写的代码很大

1665
01:27:47,390 --> 01:27:47,780
对吧

1666
01:27:47,840 --> 01:27:48,920
你要发布的时候

1667
01:27:49,040 --> 01:27:49,940
那些库

1668
01:27:49,940 --> 01:27:51,830
乱七八糟的是什么东西呢

1669
01:27:52,010 --> 01:27:54,380
他连着一块儿发不

1670
01:27:54,560 --> 01:27:58,400
而那个CC你可以把库里的东西给抽出来

1671
01:27:58,890 --> 01:28:00,000
放到你的程序里边

1672
01:28:00,000 --> 01:28:02,310
你发布的时候只发布那个程序就行了

1673
01:28:02,400 --> 01:28:03,330
不用带那个库

1674
01:28:03,920 --> 01:28:10,580
后来JSAJSJ这这这这这个恶越搞越大

1675
01:28:10,580 --> 01:28:12,380
JS程序会越搞越大

1676
01:28:12,410 --> 01:28:14,660
你这个库的依赖也是非常复杂

1677
01:28:14,660 --> 01:28:18,830
后来出现什么web packweb pack你打包的时候

1678
01:28:18,950 --> 01:28:21,830
他把里边儿的有用的代码给你抽出来

1679
01:28:21,830 --> 01:28:23,420
生成那个新的代码文件

1680
01:28:23,690 --> 01:28:25,610
然后用不到的那些代码

1681
01:28:25,610 --> 01:28:27,920
他就他他他就给你扔掉了

1682
01:28:27,920 --> 01:28:30,290
这是减少那个代码体体积

1683
01:28:30,290 --> 01:28:35,720
这是JS的那个JS那个套路那么这个C语言

1684
01:28:35,720 --> 01:28:38,030
C语言里面这个库分两种

1685
01:28:39,390 --> 01:28:40,950
C语言里的库分两种

1686
01:28:41,070 --> 01:28:42,570
一种是静态库

1687
01:28:42,660 --> 01:28:44,280
静态库什么后缀呢

1688
01:28:44,400 --> 01:28:45,150
点儿

1689
01:28:46,800 --> 01:28:48,000
这是静态库

1690
01:28:48,270 --> 01:28:50,340
第二种库是动态库

1691
01:28:50,550 --> 01:28:51,450
动态库

1692
01:28:51,810 --> 01:28:54,840
那动态库在不同的操作系统下

1693
01:28:54,870 --> 01:28:55,710
它是不一样的

1694
01:28:56,300 --> 01:28:57,410
在Linux下

1695
01:28:57,980 --> 01:29:00,080
动态库试点so

1696
01:29:01,200 --> 01:29:04,890
在Windows下试点DLL

1697
01:29:06,800 --> 01:29:07,580
这是动态库

1698
01:29:07,610 --> 01:29:08,510
Windows下的

1699
01:29:08,630 --> 01:29:12,410
Linux下的静态库和动态库有什么区别呢

1700
01:29:12,560 --> 01:29:15,020
静态库是编译时用

1701
01:29:16,310 --> 01:29:17,960
只在编译时候用

1702
01:29:18,500 --> 01:29:20,330
然后程序运行的时候

1703
01:29:20,510 --> 01:29:22,310
程序运行的时候就不需要了

1704
01:29:22,670 --> 01:29:25,850
因为你把代码从静态库里抽出来了

1705
01:29:26,000 --> 01:29:29,120
放到了你的这个exe里边儿去

1706
01:29:29,120 --> 01:29:31,100
他你需要什么代码

1707
01:29:31,100 --> 01:29:32,660
这个你就抽什么代码

1708
01:29:32,810 --> 01:29:34,820
恶把它打成一个包

1709
01:29:34,820 --> 01:29:35,750
这是静态库

1710
01:29:36,080 --> 01:29:37,520
而这个动态库呢

1711
01:29:37,640 --> 01:29:40,190
动态库是编译的时候要用

1712
01:29:40,970 --> 01:29:43,910
运行的时候也要用na动态库

1713
01:29:43,910 --> 01:29:45,740
他不往外抽代码

1714
01:29:46,370 --> 01:29:49,040
不往外抽代码儿是干什么

1715
01:29:49,100 --> 01:29:52,070
当你的程序在执行的时候

1716
01:29:52,070 --> 01:29:57,110
在运行的时候从现从这个动态库里边儿找代码

1717
01:29:57,320 --> 01:29:59,630
找代码以后去执行这个代码

1718
01:30:00,130 --> 01:30:03,490
那你要是要用到了这个动态库的话

1719
01:30:03,610 --> 01:30:05,920
你的程序在发布的时候

1720
01:30:06,070 --> 01:30:09,550
就要把程序和动态库放在一起打包

1721
01:30:09,940 --> 01:30:12,430
那咱们在用一些Windows程序的时候

1722
01:30:12,430 --> 01:30:15,310
咱们会咱们有时候会会遇到这种问题

1723
01:30:15,340 --> 01:30:15,670
对吧

1724
01:30:15,790 --> 01:30:17,710
有一些那个什么绿色软件

1725
01:30:17,710 --> 01:30:18,910
所谓的绿色软件

1726
01:30:19,090 --> 01:30:22,810
它是把内衣一把一些有用的东西给抽出来

1727
01:30:22,810 --> 01:30:26,830
没用的东西是给去掉有的那个绿色软件他做的不好

1728
01:30:26,830 --> 01:30:28,750
有的动态库他没有打包进来

1729
01:30:28,840 --> 01:30:30,010
他会给你什么提示

1730
01:30:30,130 --> 01:30:33,250
就是那个某某某DLL没找到

1731
01:30:33,970 --> 01:30:35,050
他他就会

1732
01:30:35,680 --> 01:30:39,280
他就会给你提示这个东西这这就是少了一个动态库

1733
01:30:39,430 --> 01:30:41,320
另外还有很很久以前

1734
01:30:41,350 --> 01:30:43,210
用温度在Windows下

1735
01:30:43,210 --> 01:30:45,610
很久以前在在那个Windows下

1736
01:30:45,850 --> 01:30:48,070
那个很久以前的Windows呢

1737
01:30:48,130 --> 01:30:52,300
他有一段时间是有好多用c sharp写的程序

1738
01:30:52,820 --> 01:30:58,310
那所以说你要用c sharp写的程序恶要运行那种程序的时候呢

1739
01:30:58,310 --> 01:31:00,920
你得装那个点net frame works啊

1740
01:31:00,920 --> 01:31:03,470
就当net frame works你要不装那个

1741
01:31:03,470 --> 01:31:06,650
它会提示你缺少什么什么DLL

1742
01:31:06,800 --> 01:31:09,020
这样就就就就就是这个原因

1743
01:31:09,350 --> 01:31:12,050
那么静态库和动态库的这个区

1744
01:31:12,080 --> 01:31:14,630
这个区这个区别在这儿

1745
01:31:14,750 --> 01:31:17,090
那么为什么要有这两种库呢

1746
01:31:17,330 --> 01:31:19,100
那静态库

1747
01:31:19,190 --> 01:31:20,870
静态库适合什么呢

1748
01:31:20,960 --> 01:31:23,840
适合这种小规模的这个代码

1749
01:31:23,840 --> 01:31:26,090
你你用的时候这小规模的

1750
01:31:26,870 --> 01:31:29,720
代码没法复用代码没法服用

1751
01:31:29,720 --> 01:31:30,200
你

1752
01:31:30,200 --> 01:31:32,630
你产生一生成一个点exe

1753
01:31:32,630 --> 01:31:35,930
你就要你就要你就要把这个复制一份代码出来

1754
01:31:36,260 --> 01:31:39,980
而那个动态库是可以复用

1755
01:31:40,800 --> 01:31:42,180
动态库可以服用你

1756
01:31:42,180 --> 01:31:44,280
比如说你把一些公共逻辑

1757
01:31:44,280 --> 01:31:45,990
一些公共的这个业务逻辑

1758
01:31:45,990 --> 01:31:47,640
你把它封装到这个动态库里边

1759
01:31:47,970 --> 01:31:48,540
然后呢

1760
01:31:48,540 --> 01:31:51,090
你整个的这个大系统里边儿

1761
01:31:51,090 --> 01:31:53,340
你有不同的这个点exe

1762
01:31:53,430 --> 01:31:55,470
然后这些点exe都要去掉

1763
01:31:55,470 --> 01:31:56,550
用相同的功能

1764
01:31:56,550 --> 01:31:57,060
这叫什么

1765
01:31:57,060 --> 01:31:58,050
这叫组件化

1766
01:31:58,260 --> 01:32:02,370
实际上这个DLL它里边有一种这种那个动态库

1767
01:32:02,370 --> 01:32:06,300
它里边有一种组件化的这种思想这这是那个软件

1768
01:32:06,330 --> 01:32:08,640
软件设计层面涉及到软件设计层面上来

1769
01:32:09,150 --> 01:32:10,770
那这个问题在哪儿呢

1770
01:32:10,770 --> 01:32:16,890
问题是动态库执行效率要比静态库代码执行效率的

1771
01:32:18,090 --> 01:32:24,600
因为你有好多你你你打开你你去你去一个点XG

1772
01:32:24,780 --> 01:32:26,160
用用这个动态库

1773
01:32:26,220 --> 01:32:31,590
他就要把这个动态库整体的把他给宰入到内存里去

1774
01:32:31,890 --> 01:32:32,490
然后呢

1775
01:32:32,520 --> 01:32:34,860
在内存里面去进行这个内存映射

1776
01:32:36,570 --> 01:32:39,000
在内存里面内存空间做一个映射

1777
01:32:39,030 --> 01:32:41,640
然后你exe需要用的时候

1778
01:32:41,730 --> 01:32:43,770
在这个映射空间里面去找

1779
01:32:43,890 --> 01:32:45,300
实际上这两个内存空间

1780
01:32:45,300 --> 01:32:47,640
Exe的内存空间和DLL内存空间

1781
01:32:47,640 --> 01:32:50,670
他不在一起要通过这个映射关系去找

1782
01:32:50,670 --> 01:32:54,540
这样就性能会性能会给会给脱下来会降下来

1783
01:32:54,720 --> 01:32:55,500
但是呢

1784
01:32:55,560 --> 01:32:56,550
它的好处是什么

1785
01:32:56,550 --> 01:32:58,290
它的好处是复用度很高

1786
01:32:58,890 --> 01:33:01,620
尤其是你做一个比较复杂的这种系统

1787
01:33:01,620 --> 01:33:03,780
里边有好多的这个点exe

1788
01:33:04,050 --> 01:33:06,240
像像有好多那个程序

1789
01:33:06,240 --> 01:33:08,940
有好多程序一启动启动一串对吧

1790
01:33:08,940 --> 01:33:11,310
内内那种东西最适合用这个DLL

1791
01:33:11,490 --> 01:33:13,560
还有Windows里边好多DLL

1792
01:33:13,560 --> 01:33:15,750
都都是用的这种这种思想

1793
01:33:16,410 --> 01:33:16,770
好的

1794
01:33:16,770 --> 01:33:19,140
那这这个是他的那个酷

1795
01:33:19,260 --> 01:33:20,310
这个C语言

1796
01:33:20,640 --> 01:33:26,280
还有C加加做出来的东西都都是这种都是这种类似的这种套路

1797
01:33:27,650 --> 01:33:28,220
后来呢

1798
01:33:28,220 --> 01:33:28,880
微软啊

1799
01:33:28,880 --> 01:33:32,420
后来微软在这个动态库上就大做文章

1800
01:33:32,420 --> 01:33:34,040
他他就他就干什么

1801
01:33:34,040 --> 01:33:35,060
他在这个恶

1802
01:33:35,060 --> 01:33:37,940
因为动态库他就有还有组建思想嘛

1803
01:33:37,940 --> 01:33:42,290
后来他微软他就一直不停的去发展这个组件

1804
01:33:42,290 --> 01:33:44,030
这个组件的这种设计思想

1805
01:33:44,180 --> 01:33:45,590
后来又生成什么

1806
01:33:45,650 --> 01:33:47,810
就有了那个OL技术

1807
01:33:47,810 --> 01:33:50,480
OL技术实际上就是那个容器技术

1808
01:33:50,510 --> 01:33:51,350
然后呢

1809
01:33:51,350 --> 01:33:54,950
LOL技术基础之上又加了好多东西

1810
01:33:55,100 --> 01:33:55,760
也是什么

1811
01:33:55,760 --> 01:33:57,380
就是com技术

1812
01:33:57,470 --> 01:33:58,280
全都是大写

1813
01:33:58,280 --> 01:34:00,860
这个com这这这三个都是都是大写

1814
01:34:00,860 --> 01:34:01,970
就是Windows组件

1815
01:34:02,060 --> 01:34:03,440
Windows的组件系统

1816
01:34:03,470 --> 01:34:04,790
后来又出现什么

1817
01:34:04,910 --> 01:34:06,320
又出现了这个康佳

1818
01:34:07,590 --> 01:34:11,910
然后com加还能你还能当成服务给拉起来

1819
01:34:12,090 --> 01:34:14,430
但这位这这是那个十多年前

1820
01:34:14,490 --> 01:34:15,300
十多年前

1821
01:34:16,380 --> 01:34:18,780
那个微软的那个那个技术套路

1822
01:34:18,960 --> 01:34:19,800
但是现在呢

1823
01:34:19,800 --> 01:34:25,140
现现在现在很现在很少有人用用用这个东西了因为那个桌面的

1824
01:34:25,290 --> 01:34:38,730
像现在跑在Windows上这个J这个在Windows上做服务器的这个市场的事儿是越来越小了可以说这个Windows差不多差不多丢掉了这个服务器的这个市场大不丢掉了

1825
01:34:38,730 --> 01:34:41,520
大部分的服务器市场都跑到这个limit上去了

1826
01:34:42,910 --> 01:34:46,780
这是温这这这是一些那个他背后的一些花絮

1827
01:34:46,840 --> 01:34:49,570
然后咱们再回到这个C语言这儿来

1828
01:34:49,630 --> 01:34:52,270
C语言这儿来注释的注释

1829
01:34:52,270 --> 01:34:53,590
这个规则之类的

1830
01:34:53,650 --> 01:34:55,690
He和咱们那个JS是一样的

1831
01:34:55,840 --> 01:34:57,070
然后咱们看这

1832
01:34:57,070 --> 01:35:01,150
看这这这这个defy衣服恩的饭

1833
01:35:01,150 --> 01:35:02,320
然后的饭

1834
01:35:02,320 --> 01:35:03,490
然后什么恩的衣服

1835
01:35:03,610 --> 01:35:04,060
这是什么

1836
01:35:04,060 --> 01:35:05,200
这是红

1837
01:35:05,200 --> 01:35:05,770
这是红

1838
01:35:05,920 --> 01:35:07,630
那么这个红是这个红

1839
01:35:07,930 --> 01:35:13,720
红就是一组一组指令就就就就红的意思就是一组指令

1840
01:35:15,420 --> 01:35:16,470
红啊

1841
01:35:16,560 --> 01:35:17,340
这个红

1842
01:35:19,200 --> 01:35:20,190
那么这个红呢

1843
01:35:20,220 --> 01:35:23,730
是由编译器是编译器

1844
01:35:23,730 --> 01:35:27,900
他是他是部编不把它编译成代码的咱们要注意

1845
01:35:28,080 --> 01:35:32,070
这个红编译器是不把它转成机器代码的

1846
01:35:32,400 --> 01:35:33,690
他是干什么

1847
01:35:33,870 --> 01:35:37,140
它是用来控制你的编译逻辑的

1848
01:35:37,710 --> 01:35:39,300
那什么叫编译逻辑呢

1849
01:35:39,300 --> 01:35:40,620
比如说我们要跨平台

1850
01:35:41,280 --> 01:35:42,120
哼是吧

1851
01:35:42,300 --> 01:35:43,260
我们要跨平台

1852
01:35:43,380 --> 01:35:44,430
跨平台的时候

1853
01:35:44,460 --> 01:35:47,580
Windows的API和Linux API不一样

1854
01:35:47,580 --> 01:35:48,390
这个时候呢

1855
01:35:48,540 --> 01:35:50,550
就要去检查什么

1856
01:35:50,580 --> 01:35:51,870
检查操作系统平台

1857
01:35:51,870 --> 01:35:53,130
比如说这一块儿

1858
01:35:53,250 --> 01:35:54,480
衣服的饭

1859
01:35:54,510 --> 01:36:02,250
如果说你要你要去给Windows windows32位系统下去去编译这个程序的话

1860
01:36:02,460 --> 01:36:07,020
你就需要在一个头文件里面去定义这个定义这个宏

1861
01:36:07,820 --> 01:36:08,930
要定义一下这个红

1862
01:36:08,930 --> 01:36:10,130
就是下划线WEN32

1863
01:36:10,220 --> 01:36:10,940
然后呢

1864
01:36:10,940 --> 01:36:13,430
编译的过程当中发现你定义了这个红了

1865
01:36:13,580 --> 01:36:16,100
那就走哪儿走这个分值

1866
01:36:16,100 --> 01:36:17,510
就走这个分值

1867
01:36:17,510 --> 01:36:18,710
这是编译逻辑

1868
01:36:18,800 --> 01:36:21,650
然后如果说你如果说你定

1869
01:36:21,650 --> 01:36:28,730
如果说你你你你不是那个没有定义温三儿没有没有定义这个东西那个内怎么办

1870
01:36:28,820 --> 01:36:33,560
那就走尤尼克斯那就走尤尼克斯的那个那个套路

1871
01:36:33,620 --> 01:36:35,270
Unix和Linux的套路

1872
01:36:35,390 --> 01:36:38,180
如果说你要走unix和Linux的套路呢

1873
01:36:38,180 --> 01:36:39,800
这你还要检查什么

1874
01:36:39,950 --> 01:36:42,800
检查这个C编译器

1875
01:36:42,800 --> 01:36:43,670
GOC啊

1876
01:36:43,670 --> 01:36:45,530
看他的版本是不是大于四

1877
01:36:45,530 --> 01:36:47,930
大于四就支持什么东西

1878
01:36:47,930 --> 01:36:53,210
不大于四它它它它它要做什么反应这里是各种各样的定义

1879
01:36:53,210 --> 01:36:57,830
各种各样的红那么大家看到像这些东西的时候就忽略他就行了

1880
01:36:58,320 --> 01:36:59,490
大家看代码的时候

1881
01:36:59,670 --> 01:37:01,200
看到这些东西的时候

1882
01:37:01,290 --> 01:37:04,050
什么if defyf def

1883
01:37:04,050 --> 01:37:05,370
然后什么if

1884
01:37:05,520 --> 01:37:06,990
像看到这一块儿的时候

1885
01:37:07,020 --> 01:37:10,470
你你你你注意他就是他就是检查你的这个环境的

1886
01:37:11,440 --> 01:37:13,300
检查你这个编译环境的

1887
01:37:13,300 --> 01:37:14,590
你你不用去管他

1888
01:37:14,860 --> 01:37:16,300
那么这个东西是干什么

1889
01:37:16,450 --> 01:37:18,790
这个东西你你问这个是吧

1890
01:37:18,910 --> 01:37:23,830
衣服衣服的饭下滑两个下划线c plus plus然后呢

1891
01:37:23,890 --> 01:37:25,840
Ex tens a这是在干什么

1892
01:37:26,140 --> 01:37:27,190
这是

1893
01:37:27,280 --> 01:37:28,330
这不是C代码

1894
01:37:28,330 --> 01:37:29,050
我告诉你

1895
01:37:29,050 --> 01:37:30,940
这不是这不是C加加代码

1896
01:37:30,970 --> 01:37:31,840
这是C代码

1897
01:37:32,110 --> 01:37:32,950
这是C代码

1898
01:37:33,070 --> 01:37:34,090
纯粹的C代码

1899
01:37:35,240 --> 01:37:37,250
纯粹代码他是干什么

1900
01:37:37,550 --> 01:37:38,900
他这个东西

1901
01:37:39,080 --> 01:37:42,170
它是为了做函数入口的导出

1902
01:37:43,810 --> 01:37:45,610
这是给C加加

1903
01:37:46,350 --> 01:37:52,680
这是给C加加编译器去导出C语言库的调用

1904
01:37:52,980 --> 01:37:54,420
这个函数调用

1905
01:37:55,300 --> 01:37:56,590
函数调用入口儿

1906
01:37:56,920 --> 01:38:04,450
因为C和C加加这两个这两个编译器套路是不一样的编译套路是不一样的

1907
01:38:04,720 --> 01:38:08,320
所以你CC加加是可以调C语言库的

1908
01:38:08,680 --> 01:38:09,910
但是怎么让他掉呢

1909
01:38:10,090 --> 01:38:13,030
按照C加加的那个规则

1910
01:38:13,480 --> 01:38:16,420
去做这个函数调用导出

1911
01:38:16,420 --> 01:38:18,430
这个就这他就是干这个用的

1912
01:38:19,760 --> 01:38:20,450
他是干这个

1913
01:38:20,450 --> 01:38:22,130
所以它是C语言代码

1914
01:38:22,310 --> 01:38:25,130
就是告诉CC加加编译器

1915
01:38:25,430 --> 01:38:27,590
这是一个C语言的库

1916
01:38:28,590 --> 01:38:32,250
你你你在你在那个往外抽抽代码的时候

1917
01:38:32,250 --> 01:38:34,920
你要注意它里边没有没有这个类

1918
01:38:34,920 --> 01:38:36,090
没有什么乱七八糟的

1919
01:38:36,090 --> 01:38:38,670
不要按C语言的套路去去做处理

1920
01:38:38,670 --> 01:38:40,500
按C语言的套路去处理这事

1921
01:38:40,500 --> 01:38:42,000
告诉C加加编译器的

1922
01:38:42,240 --> 01:38:45,750
所以他不是C加加不是C加加代码你你这儿别美

1923
01:38:45,750 --> 01:38:50,700
你还哈哈你你你你还你还哈你你还哈你你哈哈什么

1924
01:38:50,700 --> 01:38:52,980
你哈哈哈哈错了

1925
01:38:54,200 --> 01:38:56,270
所以咱们看看这些东西

1926
01:38:56,420 --> 01:38:57,620
另外还有这个

1927
01:38:57,710 --> 01:38:59,450
UT下划线杠H

1928
01:38:59,570 --> 01:39:00,290
这是干什么

1929
01:39:00,290 --> 01:39:02,300
防止头文件被反复引用

1930
01:39:03,530 --> 01:39:04,910
防止被反复引用

1931
01:39:05,090 --> 01:39:06,740
因为这个C加加编译器

1932
01:39:06,890 --> 01:39:11,750
你要是它不像咱们JSJS你你在你在import一个包的时候

1933
01:39:11,840 --> 01:39:14,150
它在它在内存里面是全局唯一的

1934
01:39:14,730 --> 01:39:15,270
对吧

1935
01:39:15,420 --> 01:39:17,370
那么这个C加加他不是这样的

1936
01:39:17,370 --> 01:39:18,180
C加加编译器

1937
01:39:18,180 --> 01:39:22,050
他他他他不做那个什么全局唯一的这个玩意儿

1938
01:39:22,140 --> 01:39:24,180
它这个关联是极其复杂的

1939
01:39:24,210 --> 01:39:27,420
它它并不是放在这个全局这个全局里边儿

1940
01:39:27,660 --> 01:39:30,570
所以为了防止你重复去导入这个头文件

1941
01:39:30,600 --> 01:39:31,440
你导入一份

1942
01:39:31,440 --> 01:39:33,510
你就就要多多号一份内存

1943
01:39:34,110 --> 01:39:34,590
是吧

1944
01:39:34,620 --> 01:39:35,640
然后你在你

1945
01:39:36,360 --> 01:39:39,180
你你你你在那个编辑的过程当中呢

1946
01:39:39,330 --> 01:39:40,830
那性能就低了

1947
01:39:40,830 --> 01:39:42,570
C语言追求的是性能

1948
01:39:42,630 --> 01:39:44,100
防止反复的去导入

1949
01:39:44,100 --> 01:39:48,510
因为一个头文件会在多个点C文件里边儿去include

1950
01:39:48,510 --> 01:39:50,280
包含在多个点C文件里边儿

1951
01:39:50,490 --> 01:39:54,390
所以防止头文件你你被多次导入

1952
01:39:54,480 --> 01:39:59,850
那就用这个宏来控制if if迪犯了这个洗这个

1953
01:40:00,550 --> 01:40:02,140
没有没有底范这个红

1954
01:40:02,140 --> 01:40:04,450
那就底范那个红底犯了这个红

1955
01:40:04,480 --> 01:40:05,290
然后就

1956
01:40:06,070 --> 01:40:10,090
然然后在在哪儿呢

1957
01:40:10,090 --> 01:40:11,080
在在这儿

1958
01:40:11,170 --> 01:40:13,780
他那个最终结果在在文件的后边儿

1959
01:40:13,780 --> 01:40:15,760
在文件后面这个NF啊

1960
01:40:16,540 --> 01:40:18,430
在这儿这是那个大分值

1961
01:40:18,430 --> 01:40:21,730
如果说定义了UT下划线H

1962
01:40:22,690 --> 01:40:24,610
如果定义了UD下方H

1963
01:40:24,730 --> 01:40:27,310
那么这些代码它就不再再次处理了

1964
01:40:27,460 --> 01:40:29,770
如果没有定义这个UT下划线H呢

1965
01:40:29,890 --> 01:40:34,330
它就要处理这这一大堆代码防防止防止被重复处理

1966
01:40:34,840 --> 01:40:37,180
那他他并不像JS

1967
01:40:37,180 --> 01:40:40,180
因为JS他是他是个动态语言

1968
01:40:40,180 --> 01:40:40,630
对吧

1969
01:40:40,720 --> 01:40:41,920
JS动态语言

1970
01:40:42,010 --> 01:40:43,750
边边解释边运行

1971
01:40:43,750 --> 01:40:46,330
边边处理边解释边解释边运行的

1972
01:40:46,540 --> 01:40:47,950
这这个C呢

1973
01:40:48,010 --> 01:40:49,360
是一次处理

1974
01:40:49,360 --> 01:40:50,710
一下子全都处理完

1975
01:40:50,800 --> 01:40:53,290
处理完以后再去再再去运行

1976
01:40:53,680 --> 01:40:55,090
套路不一致

1977
01:40:55,120 --> 01:40:58,120
然后后边儿就接着看后边儿这个东西是什么

1978
01:40:58,120 --> 01:40:59,230
就是去引那个头

1979
01:40:59,230 --> 01:41:00,610
引那个头文件了

1980
01:41:01,120 --> 01:41:02,200
去引入那些头文件

1981
01:41:02,380 --> 01:41:03,850
那些都有哪些函数

1982
01:41:03,850 --> 01:41:07,090
你不去引那些头文件那些函数你没法用但是呢

1983
01:41:07,090 --> 01:41:08,050
我们要注意

1984
01:41:08,200 --> 01:41:09,460
在include的时候呢

1985
01:41:09,550 --> 01:41:11,770
有的头文件是放在双引号里的

1986
01:41:11,770 --> 01:41:13,990
有的头文件是放在尖括号里的

1987
01:41:14,110 --> 01:41:15,250
这有什么区别呢

1988
01:41:15,340 --> 01:41:18,430
那先说这个尖括号放在尖括号里边呢

1989
01:41:18,520 --> 01:41:19,780
这个是系统的库

1990
01:41:20,390 --> 01:41:22,550
就是编译器给你提供的库

1991
01:41:22,550 --> 01:41:24,200
他放在那个系统文件夹里

1992
01:41:24,440 --> 01:41:30,110
那也就是说他的那个语言的那个语言的标准库

1993
01:41:30,110 --> 01:41:31,220
就放在尖括号里

1994
01:41:31,310 --> 01:41:32,690
而这个双括号呢

1995
01:41:32,750 --> 01:41:34,220
双这个双引号呢

1996
01:41:34,310 --> 01:41:38,540
双引号就是你自己写的头文件你自己的头文件找

1997
01:41:38,540 --> 01:41:40,280
这个头文件的位置不一样

1998
01:41:40,370 --> 01:41:44,000
这个在系统在系统的那个目录底下找

1999
01:41:44,150 --> 01:41:44,690
这个呢

2000
01:41:44,690 --> 01:41:46,730
在你项目项目的目录底下找

2001
01:41:48,750 --> 01:41:50,970
这是引那个引那个头文件

2002
01:41:51,210 --> 01:41:52,170
那记住

2003
01:41:52,170 --> 01:41:53,190
我们要注意

2004
01:41:53,280 --> 01:41:54,360
这个头文件

2005
01:41:54,480 --> 01:41:58,110
当我们在这个代码里面去去去分析的时候

2006
01:41:58,110 --> 01:41:59,310
去分析这些代码的时候

2007
01:41:59,370 --> 01:42:01,260
如果说我们看到一个函数

2008
01:42:01,350 --> 01:42:06,000
那么这个函数不知道是她她再想想再跳到那个函数里边

2009
01:42:06,000 --> 01:42:08,130
再再再去看它是怎么实现的

2010
01:42:08,280 --> 01:42:10,710
那你怎么去找那个函数实现在哪儿呢

2011
01:42:11,760 --> 01:42:12,600
看着头文件

2012
01:42:13,330 --> 01:42:14,080
这些头文件

2013
01:42:14,080 --> 01:42:16,240
他这个看文件名儿对吧

2014
01:42:16,330 --> 01:42:17,440
比如说这个是错误

2015
01:42:17,440 --> 01:42:18,490
这是版本

2016
01:42:18,520 --> 01:42:20,290
然后这个是标准库的定义

2017
01:42:20,290 --> 01:42:21,970
这是标准标准库输入输出

2018
01:42:21,970 --> 01:42:24,220
当然我们看代码不会看标准库的代码

2019
01:42:24,400 --> 01:42:27,460
要看这个项目的代码比如说你看到了一个错误

2020
01:42:27,460 --> 01:42:29,650
我要看看这个错误他是怎么定义的

2021
01:42:29,770 --> 01:42:32,680
它它它它它定义的是是什么东西

2022
01:42:32,680 --> 01:42:34,090
定义的那个细节是什么

2023
01:42:34,210 --> 01:42:38,560
那我们就就从这个L的H里面去找那个那个错误定义去

2024
01:42:40,150 --> 01:42:41,740
这是咱们在文件之间

2025
01:42:41,740 --> 01:42:48,700
文件之间来回来回那个跳代码的时候就要用到这个东西了

2026
01:42:48,820 --> 01:42:50,020
然后在后边呢

2027
01:42:50,020 --> 01:42:54,010
我们看这个这个东西又又是个红这又是个红

2028
01:42:54,190 --> 01:42:58,300
咱们反复的看到这些红在C语言里边儿这个红

2029
01:42:58,390 --> 01:43:00,790
它有一个它有一个名字

2030
01:43:00,790 --> 01:43:01,810
有一个专用的名字

2031
01:43:01,840 --> 01:43:02,920
这专用名字叫什么

2032
01:43:02,980 --> 01:43:04,300
教育处理代码

2033
01:43:05,310 --> 01:43:07,050
这个红教育处理代码

2034
01:43:08,080 --> 01:43:09,280
是预处理

2035
01:43:09,790 --> 01:43:11,770
预他预的是谁

2036
01:43:12,220 --> 01:43:13,300
玉是什么意思

2037
01:43:13,330 --> 01:43:16,000
预先处理教育处理

2038
01:43:16,330 --> 01:43:19,390
那么在什么之前他预处理呢

2039
01:43:19,570 --> 01:43:23,770
就是处理真正的这些代码真正的这个C语言代码

2040
01:43:24,040 --> 01:43:26,320
处理真正C语言代码之前

2041
01:43:26,410 --> 01:43:29,110
先去处理那个红那个红叫

2042
01:43:29,380 --> 01:43:30,400
所以他叫什么

2043
01:43:30,460 --> 01:43:32,080
叫预处理代码

2044
01:43:32,620 --> 01:43:32,890
是吧

2045
01:43:33,070 --> 01:43:37,270
那么这个预处理代码他是不会生成那个二进制代码的

2046
01:43:37,360 --> 01:43:43,090
只是告诉编译器你按照一个什么样的逻辑来进行编译这是红的

2047
01:43:43,180 --> 01:43:44,470
这是那个红的意义

2048
01:43:45,960 --> 01:43:47,850
然后咱们再接着往下看

2049
01:43:47,850 --> 01:43:48,720
我们看这儿

2050
01:43:48,870 --> 01:43:50,760
看这儿这个后边儿

2051
01:43:50,760 --> 01:43:53,040
这这些东西都是红都是红

2052
01:43:53,040 --> 01:43:54,360
实际上我这这些东西

2053
01:43:54,360 --> 01:43:56,310
我们把它当成这个脚本

2054
01:43:56,310 --> 01:43:58,020
我们把它当成脚本看就行了

2055
01:43:58,260 --> 01:43:58,560
这是

2056
01:43:59,670 --> 01:44:01,350
这些这些玩意儿

2057
01:44:01,410 --> 01:44:05,250
他他都是在定义一些那个定义一些东西

2058
01:44:05,370 --> 01:44:05,820
对吧

2059
01:44:05,820 --> 01:44:10,110
把这两个做一个映射咱们看名字就看得出来

2060
01:44:10,110 --> 01:44:12,870
Error number map做的是什么

2061
01:44:13,020 --> 01:44:14,010
做的事

2062
01:44:14,100 --> 01:44:19,350
这个是哪一个那个number这是这是一个编号然后这个呢

2063
01:44:19,350 --> 01:44:22,800
就是那个编号所对应的那个文本信息

2064
01:44:22,800 --> 01:44:25,950
这他他在这里定义了好多红

2065
01:44:25,980 --> 01:44:27,780
它把它做一下映射

2066
01:44:27,810 --> 01:44:29,730
然后再往后呢

2067
01:44:29,730 --> 01:44:32,400
再往后这这些东西都都是类似的东西

2068
01:44:32,460 --> 01:44:34,650
都是类似的这个映射过程

2069
01:44:34,710 --> 01:44:35,610
然后呢

2070
01:44:35,610 --> 01:44:37,620
咱们往后看

2071
01:44:37,620 --> 01:44:38,370
看的时候呢

2072
01:44:38,370 --> 01:44:38,970
看到这儿

2073
01:44:38,970 --> 01:44:39,750
有他的肺

2074
01:44:40,460 --> 01:44:42,530
Type def这是tap的饭

2075
01:44:42,890 --> 01:44:46,430
那么C语言里边你是可以定义自己的这个类型的

2076
01:44:46,580 --> 01:44:47,930
那定义自己的类型

2077
01:44:47,930 --> 01:44:50,450
你你你实际上就是这块数据

2078
01:44:50,450 --> 01:44:51,500
它在内存里什么样

2079
01:44:52,160 --> 01:44:54,980
你看它不像咱们JSJS是什么JS

2080
01:44:54,980 --> 01:44:56,630
你你去弄那个object

2081
01:44:56,750 --> 01:45:02,330
它实际上都是挂在挂在那个那个object object那个类上的

2082
01:45:02,330 --> 01:45:06,200
不断的往那个object那个对象上往上加东西

2083
01:45:07,190 --> 01:45:07,670
是吧

2084
01:45:07,700 --> 01:45:08,900
那那呢

2085
01:45:08,900 --> 01:45:11,630
那是那个咱们JS的那个那个累

2086
01:45:12,170 --> 01:45:13,910
那所以JS那个累

2087
01:45:13,910 --> 01:45:15,140
他不是一个真正的类型

2088
01:45:15,320 --> 01:45:20,210
你没有办法真正的去确定他她它在内存里面什么样

2089
01:45:20,210 --> 01:45:21,890
全都归那个object呢

2090
01:45:21,890 --> 01:45:22,550
他去管

2091
01:45:22,550 --> 01:45:23,990
基于原型链儿是吧

2092
01:45:24,080 --> 01:45:27,260
在那个原型链它实际上就是个数结构

2093
01:45:27,380 --> 01:45:30,080
那个树结构就完全归那个JS自己去管了

2094
01:45:30,080 --> 01:45:32,690
你没有办法去控制他的那个真正的结构

2095
01:45:33,110 --> 01:45:35,930
那么C语言你可以去控制它的这个结构

2096
01:45:35,990 --> 01:45:37,010
比如说这是一个什么

2097
01:45:37,010 --> 01:45:38,180
这是一个枚举类型

2098
01:45:38,720 --> 01:45:39,620
一个枚举类型

2099
01:45:39,830 --> 01:45:40,610
那枚举类型

2100
01:45:40,610 --> 01:45:47,150
那我们这这儿就给他给去太不敌范一个新的枚举类型这个新的枚举类型它是什么名字

2101
01:45:47,240 --> 01:45:47,960
是这个名字

2102
01:45:48,140 --> 01:45:49,430
那type DeFined

2103
01:45:49,610 --> 01:45:54,680
然后在这个差不的饭type DeFined后边呢

2104
01:45:54,680 --> 01:45:56,570
就是这个类型的这个结构

2105
01:45:56,570 --> 01:45:57,740
他究竟是什么样的

2106
01:45:57,860 --> 01:45:58,670
然后最后呢

2107
01:45:58,670 --> 01:46:00,110
就是定义出来这个类型

2108
01:46:00,110 --> 01:46:03,050
他他叫什么名字按照按照这个套路

2109
01:46:03,080 --> 01:46:04,790
后边儿我们也可以看到好多

2110
01:46:04,790 --> 01:46:06,050
比如说type DeFined

2111
01:46:06,050 --> 01:46:07,040
这是个结构体

2112
01:46:07,400 --> 01:46:10,070
这这是这咱们自自己定义的这个结构体

2113
01:46:10,220 --> 01:46:11,960
这个结构体有点儿像累

2114
01:46:11,960 --> 01:46:16,400
但是它里边儿没有没有没有那个没有没有韩束

2115
01:46:16,400 --> 01:46:18,230
没有没有那个方法

2116
01:46:20,630 --> 01:46:23,450
那么这个tempe饭structure

2117
01:46:23,480 --> 01:46:24,830
这个struck是谁

2118
01:46:24,860 --> 01:46:25,430
是这个

2119
01:46:26,540 --> 01:46:28,700
这这这是一个结构体

2120
01:46:28,700 --> 01:46:29,570
这是个结构体

2121
01:46:29,600 --> 01:46:34,310
然后把这个结构体把它定义成把它给定义成这个类型

2122
01:46:34,310 --> 01:46:36,440
这是你去定义自己的类型的

2123
01:46:36,680 --> 01:46:38,600
实际上这个结构体在干什么

2124
01:46:38,690 --> 01:46:46,370
就是在就是在定义你的这个数据在内存里面什么样的然后咱们后边去找一个那个结构体

2125
01:46:46,370 --> 01:46:49,040
这就是一个结构体这就是一个结构体

2126
01:46:49,470 --> 01:46:50,730
这个结构体是什么

2127
01:46:50,760 --> 01:46:55,680
里边儿64位整型放这个又一个64位整型

2128
01:46:55,710 --> 01:46:56,910
若干个64位整型

2129
01:46:56,910 --> 01:46:57,390
然后呢

2130
01:46:57,510 --> 01:47:00,690
这是另外一个类型UV time SPY杠T

2131
01:47:00,780 --> 01:47:01,920
实际上它是什么

2132
01:47:01,920 --> 01:47:03,810
它是一个重新定义的类型

2133
01:47:03,810 --> 01:47:05,520
它的它的那个

2134
01:47:06,040 --> 01:47:12,460
他的那个最根本的类型也是也是一个那个他的根本的类型是一个32位的整型

2135
01:47:13,190 --> 01:47:16,430
这这这里边好都都是钉钉一一堆整数

2136
01:47:16,460 --> 01:47:18,860
然后这个结构体在内存里面是什么样的

2137
01:47:19,190 --> 01:47:21,560
这个结构体在内存里边

2138
01:47:21,560 --> 01:47:23,330
他要站一块连续内存

2139
01:47:23,860 --> 01:47:25,540
然后这块儿连接内存a

2140
01:47:25,570 --> 01:47:26,740
按照顺序

2141
01:47:26,830 --> 01:47:28,150
这是第一个

2142
01:47:28,360 --> 01:47:29,770
这是第一个ID

2143
01:47:29,770 --> 01:47:32,830
第一个那个结构体的那个成员然后呢

2144
01:47:32,890 --> 01:47:34,810
第二个结构体的成员

2145
01:47:34,810 --> 01:47:36,850
按照顺序一个一个放放下来

2146
01:47:36,880 --> 01:47:41,140
然后这一整块内存苗就是这个结构体

2147
01:47:41,660 --> 01:47:44,660
那结构体结构体放在内存里边儿什么样儿

2148
01:47:45,410 --> 01:47:46,940
这一整就是这一整块的一层

2149
01:47:47,090 --> 01:47:50,570
他们是挨在一起的在内存里面是挨在一起的

2150
01:47:50,900 --> 01:47:53,120
当然这个这个这个结构体

2151
01:47:53,180 --> 01:47:55,700
前面还有个前缀这个前缀呢

2152
01:47:56,500 --> 01:47:57,340
这个前缀呢

2153
01:47:57,490 --> 01:48:03,340
它是不计入这个结构体的整个大小的不记不记住结构体整体大小

2154
01:48:03,550 --> 01:48:05,590
结构体的整体大小

2155
01:48:05,620 --> 01:48:09,130
实际上就是把这些东西把这些东西加起来

2156
01:48:10,070 --> 01:48:12,860
把这些把这些数据

2157
01:48:12,980 --> 01:48:14,540
它们所占的内存

2158
01:48:15,200 --> 01:48:17,090
内存大小把它给加在一起

2159
01:48:17,510 --> 01:48:20,690
那这就就就就加在一起

2160
01:48:20,690 --> 01:48:21,800
就是结构体的大小

2161
01:48:21,950 --> 01:48:24,920
但是结构体它在内存里边儿有一个前缀

2162
01:48:25,010 --> 01:48:26,270
一个前缀数据

2163
01:48:26,630 --> 01:48:28,250
那么这个前缀数据

2164
01:48:30,290 --> 01:48:35,810
这个前缀数据加上前缀数据是结构体真正的内内存占用

2165
01:48:35,810 --> 01:48:36,770
在很久以前

2166
01:48:36,950 --> 01:48:38,630
在很久以前去面试的时候

2167
01:48:38,630 --> 01:48:42,440
就就就有人问这个问题有人问过这个问题

2168
01:48:42,440 --> 01:48:46,670
就就就就就考我你你你你懂不懂这个这个内存

2169
01:48:46,700 --> 01:48:48,530
然后我是怎么答的呢

2170
01:48:48,530 --> 01:48:50,900
比如说他问的是一个结构体

2171
01:48:50,900 --> 01:48:54,620
我定义了一个整型定义的一个字符型的

2172
01:48:54,770 --> 01:49:01,580
还还地还里面还有一个那个单精度浮点型问这个结构体实际占用内存是多大是吧

2173
01:49:01,610 --> 01:49:02,960
然后我是怎么答的呢

2174
01:49:03,050 --> 01:49:04,790
我是我我这么说

2175
01:49:05,330 --> 01:49:18,260
看上去看上看上去这个结构体是整形四个字节再加一个字符型一个字节再加单精度浮点型四个字节看上去是九个字节但实际上呢

2176
01:49:18,260 --> 01:49:20,270
它还有一个前缀前缀数据

2177
01:49:20,780 --> 01:49:22,610
前置数据再加一个字节

2178
01:49:22,970 --> 01:49:25,130
那么实际它占的内存

2179
01:49:25,160 --> 01:49:30,020
也不是这也不是这这这这十个字节

2180
01:49:30,020 --> 01:49:42,290
因为在在这个操作在在这个计算在操作系统里边儿还有一个内存对齐机制内存对齐机制它必须得是它必须得是二的二的N次方

2181
01:49:43,130 --> 01:49:45,050
你占用的这个内存块

2182
01:49:45,050 --> 01:49:46,280
必须得是二的N次方

2183
01:49:46,310 --> 01:49:50,000
所以他实际在内存里边儿是16个字节

2184
01:49:50,240 --> 01:49:52,160
所以这样才这样才代表

2185
01:49:52,190 --> 01:49:53,780
你是真正的明白这个东西

2186
01:49:55,580 --> 01:50:00,680
所以说那个去去去这么答去你面试的时候

2187
01:50:00,680 --> 01:50:03,500
你也按照这种套路去答满分儿对吧

2188
01:50:03,500 --> 01:50:04,460
说明你都知道

2189
01:50:04,670 --> 01:50:05,120
而且呢

2190
01:50:05,120 --> 01:50:08,000
你一步一步的给他往网往深入里边儿去

2191
01:50:08,210 --> 01:50:11,810
往深入里面去进行探讨这怎么叫卷王呢

2192
01:50:11,990 --> 01:50:15,050
这不叫卷王这不叫这不叫卷

2193
01:50:15,050 --> 01:50:15,830
这叫什么

2194
01:50:16,220 --> 01:50:19,250
这这不叫内存对齐内存对齐

2195
01:50:19,280 --> 01:50:20,960
因为你在寻址的过程当中

2196
01:50:20,960 --> 01:50:22,700
二的整数倍它是最好算的

2197
01:50:23,500 --> 01:50:23,920
对吧

2198
01:50:23,950 --> 01:50:25,090
他是最好算的

2199
01:50:25,240 --> 01:50:27,460
二的整数整数倍是最好算的

2200
01:50:27,550 --> 01:50:30,160
所以他在他在那个使用内存的时候

2201
01:50:30,430 --> 01:50:35,470
他必须得他他放到二的整数倍的那个那个空间

2202
01:50:35,470 --> 01:50:36,280
那个位置上

2203
01:50:36,700 --> 01:50:38,740
他在寻址的时候是最快的

2204
01:50:39,100 --> 01:50:41,140
这是这是一种那个系统优化

2205
01:50:41,140 --> 01:50:42,790
所以他是他16

2206
01:50:42,970 --> 01:50:43,870
这这叫内存

2207
01:50:43,990 --> 01:50:47,230
这叫内存的那个内存对齐机制

2208
01:50:47,850 --> 01:50:49,410
这这这非常底层了

2209
01:50:50,170 --> 01:50:52,150
那他要不够16个字节

2210
01:50:52,150 --> 01:50:56,170
他要凑够16个字节明白了吧

2211
01:51:01,360 --> 01:51:01,870
还有啊

2212
01:51:01,870 --> 01:51:04,630
大家大家别以为这样就是卷

2213
01:51:05,540 --> 01:51:06,680
这不叫卷

2214
01:51:07,010 --> 01:51:08,660
那这叫这叫什么

2215
01:51:08,750 --> 01:51:10,760
这叫这叫竞争手段

2216
01:51:11,490 --> 01:51:13,290
这叫这叫有效竞争手段

2217
01:51:13,440 --> 01:51:15,570
那怎么叫什么叫什么叫卷

2218
01:51:15,600 --> 01:51:16,350
大家知道吗

2219
01:51:16,960 --> 01:51:18,310
卷的定义是什么

2220
01:51:18,550 --> 01:51:20,980
就是毫无意义的竞争

2221
01:51:21,890 --> 01:51:23,120
毫无意义的竞争

2222
01:51:23,240 --> 01:51:26,360
这个池子就这么大对吧

2223
01:51:26,510 --> 01:51:30,260
这个公司他的工资预算就是100万

2224
01:51:30,710 --> 01:51:31,970
然后十个人分

2225
01:51:32,640 --> 01:51:33,840
一个人分多少

2226
01:51:33,990 --> 01:51:36,990
正常情况下一个人分10万对吧

2227
01:51:37,020 --> 01:51:38,370
然后这个老板说了

2228
01:51:38,400 --> 01:51:40,590
老板说大家努力一下

2229
01:51:40,620 --> 01:51:41,490
大家努力一下

2230
01:51:41,490 --> 01:51:41,970
然后呢

2231
01:51:42,030 --> 01:51:42,660
努力一下儿

2232
01:51:42,660 --> 01:51:43,590
我给大家多分点儿

2233
01:51:43,800 --> 01:51:45,090
然后你努力了

2234
01:51:45,240 --> 01:51:46,410
你得到20万

2235
01:51:46,980 --> 01:51:47,400
对吧

2236
01:51:47,430 --> 01:51:48,390
你得到了20万

2237
01:51:48,450 --> 01:51:49,830
其他人不努力呢

2238
01:51:50,010 --> 01:51:51,060
把这个钱

2239
01:51:51,120 --> 01:51:52,140
给他减了5万

2240
01:51:52,170 --> 01:51:55,590
两个人少了5万来给你凑齐你这个20万

2241
01:51:55,590 --> 01:51:57,780
实际上他的支出是没变的

2242
01:51:57,780 --> 01:52:00,030
甚至可能会更少是吧

2243
01:52:00,060 --> 01:52:01,590
如果说有三个人不努力呢

2244
01:52:01,800 --> 01:52:04,290
那剪了撒捡了仨5万呢

2245
01:52:04,290 --> 01:52:06,900
实际上它是它实际支出是95万

2246
01:52:07,080 --> 01:52:07,800
这叫什么

2247
01:52:07,800 --> 01:52:11,100
这叫内卷前前提是资源

2248
01:52:11,130 --> 01:52:12,150
资源是有限的

2249
01:52:12,150 --> 01:52:12,570
而且呢

2250
01:52:12,570 --> 01:52:14,790
你你这种竞争在整体来看

2251
01:52:14,790 --> 01:52:15,840
它是毫无意义的

2252
01:52:16,520 --> 01:52:16,970
对吧

2253
01:52:17,000 --> 01:52:18,020
这叫卷

2254
01:52:18,200 --> 01:52:20,840
那这这你去把这个东西搞深入了

2255
01:52:20,990 --> 01:52:22,940
搞深入了以后意味着什么呢

2256
01:52:23,090 --> 01:52:24,140
这儿有一个职位

2257
01:52:24,850 --> 01:52:25,810
这儿有一个职位

2258
01:52:26,230 --> 01:52:27,280
这个职位

2259
01:52:27,890 --> 01:52:29,150
这个职位是什么

2260
01:52:29,330 --> 01:52:31,250
你够格你才做

2261
01:52:31,280 --> 01:52:33,170
你不够格你都摸不着

2262
01:52:33,260 --> 01:52:33,950
这叫什么

2263
01:52:33,980 --> 01:52:34,880
这叫竞争

2264
01:52:35,630 --> 01:52:36,860
这叫真正的竞争

2265
01:52:37,310 --> 01:52:38,750
你能做才让你做

2266
01:52:38,750 --> 01:52:43,340
你不能做就门儿也没有这个职位他就年薪100万

2267
01:52:44,700 --> 01:52:45,390
那对吧

2268
01:52:45,420 --> 01:52:46,200
你能不能做

2269
01:52:46,230 --> 01:52:47,460
能做给你100万

2270
01:52:48,060 --> 01:52:48,420
是吧

2271
01:52:49,200 --> 01:52:49,890
不能做

2272
01:52:49,890 --> 01:52:50,910
你你摸不着

2273
01:52:51,150 --> 01:52:54,780
你你去摸那个下级那个次一点的职位

2274
01:52:54,780 --> 01:52:55,380
去那个五

2275
01:52:55,380 --> 01:52:56,580
你去摸那个50万的

2276
01:52:56,580 --> 01:52:57,720
50万你摸不着

2277
01:52:57,720 --> 01:52:59,670
你去摸那个20万的

2278
01:52:59,670 --> 01:53:00,060
对吧

2279
01:53:00,240 --> 01:53:03,480
这这这这就不叫这这这玩意儿不叫卷

2280
01:53:03,840 --> 01:53:05,910
另外什么内卷外卷

2281
01:53:05,910 --> 01:53:09,570
这这叫是什么乱七八糟的这新名词越来越多了

2282
01:53:10,180 --> 01:53:10,990
这个东西

2283
01:53:10,990 --> 01:53:12,370
你不要不要那个啥

2284
01:53:12,370 --> 01:53:15,430
不要不要总是那个

2285
01:53:15,430 --> 01:53:15,940
那个

2286
01:53:18,300 --> 01:53:19,650
不要总是那个啥

2287
01:53:19,650 --> 01:53:23,790
不要总是总总是那个看那些乱七八糟的东西

2288
01:53:23,820 --> 01:53:24,990
实际上这叫什么

2289
01:53:25,110 --> 01:53:26,340
这叫应

2290
01:53:26,370 --> 01:53:27,690
要么你就是啥

2291
01:53:27,720 --> 01:53:29,040
要么就是吃存量

2292
01:53:29,070 --> 01:53:30,270
要么就是吃增量

2293
01:53:31,790 --> 01:53:33,230
吃存量这叫卷

2294
01:53:33,920 --> 01:53:34,640
明白了吧

2295
01:53:34,820 --> 01:53:37,280
吃存量较卷吃增量

2296
01:53:37,280 --> 01:53:38,840
这不叫卷

2297
01:53:38,840 --> 01:53:39,800
所以说什么

2298
01:53:40,010 --> 01:53:43,190
封闭系统是最容易卷的

2299
01:53:43,490 --> 01:53:45,260
呵呵

2300
01:53:45,290 --> 01:53:47,120
那那那那你要那啥

2301
01:53:47,120 --> 01:53:48,680
你要吃增量吃增量

2302
01:53:48,680 --> 01:53:52,070
那那无非就是就就是那个

2303
01:53:52,760 --> 01:53:54,140
你要吃增量的话呢

2304
01:53:54,260 --> 01:53:55,310
那那就呢

2305
01:53:55,310 --> 01:53:58,070
那就那个

2306
01:53:59,210 --> 01:54:02,780
两个两个方式对呢

2307
01:54:02,780 --> 01:54:04,400
你要吃增量怎么增量

2308
01:54:04,400 --> 01:54:06,200
要么你就抢别人的

2309
01:54:06,200 --> 01:54:06,800
要么呢

2310
01:54:06,800 --> 01:54:10,100
你去你去那个把这个蛋糕做大

2311
01:54:10,860 --> 01:54:11,310
是吧

2312
01:54:11,550 --> 01:54:13,650
你这个封闭系统资源不够了

2313
01:54:13,650 --> 01:54:16,140
你去你去抢那个系统外的东西

2314
01:54:16,140 --> 01:54:17,250
你去把那个抢过来

2315
01:54:17,250 --> 01:54:18,570
这是帝国主义

2316
01:54:19,080 --> 01:54:20,370
这叫外卷

2317
01:54:20,370 --> 01:54:22,140
你把这个蛋糕做大

2318
01:54:22,230 --> 01:54:23,340
把这个市场做大

2319
01:54:23,340 --> 01:54:25,140
或者把这个职位做多

2320
01:54:25,140 --> 01:54:26,730
这这就不叫卷了

2321
01:54:26,730 --> 01:54:28,470
这叫丰富多彩是吧

2322
01:54:28,620 --> 01:54:32,940
这叫扩张把这个千万不要看到一个卷

2323
01:54:32,970 --> 01:54:35,160
然后大家就就说卷卷卷

2324
01:54:35,160 --> 01:54:36,300
怎么我我不想卷

2325
01:54:36,300 --> 01:54:38,070
我想去躺平等等等等等

2326
01:54:38,370 --> 01:54:40,440
实际上咱不应该这样

2327
01:54:41,330 --> 01:54:41,630
对

2328
01:54:41,630 --> 01:54:42,350
开疆扩土

2329
01:54:42,350 --> 01:54:43,460
这叫帝国主义

2330
01:54:44,970 --> 01:54:45,690
应该什么

2331
01:54:45,690 --> 01:54:46,920
应该应该

2332
01:54:46,920 --> 01:54:49,920
那个应该是星辰大海

2333
01:54:50,100 --> 01:54:51,150
应该星辰大海

2334
01:54:51,150 --> 01:54:51,630
不应该

2335
01:54:51,810 --> 01:54:53,040
不应该开疆扩土

2336
01:54:53,520 --> 01:54:54,180
开疆扩土

2337
01:54:54,180 --> 01:54:56,010
那那是那个西方列强

2338
01:54:56,040 --> 01:54:56,280
对吧

2339
01:54:56,280 --> 01:54:57,750
他给你去弄殖民地

2340
01:54:58,380 --> 01:54:59,760
让你殖民地去卷

2341
01:54:59,760 --> 01:55:01,440
然后他去抢你的东西

2342
01:55:01,740 --> 01:55:02,640
那个不行

2343
01:55:02,910 --> 01:55:03,360
你

2344
01:55:03,360 --> 01:55:05,040
你要那个星辰大海

2345
01:55:05,220 --> 01:55:06,330
星辰大海怎么样

2346
01:55:06,540 --> 01:55:07,860
把眼光离开地球

2347
01:55:07,860 --> 01:55:09,330
地球就这么大是吧

2348
01:55:09,480 --> 01:55:10,470
你去火星吧

2349
01:55:10,800 --> 01:55:11,430
哈哈

2350
01:55:11,880 --> 01:55:13,380
以前是leader

2351
01:55:13,380 --> 01:55:14,430
当然是leader了

2352
01:55:18,930 --> 01:55:19,890
带过团队

2353
01:55:20,550 --> 01:55:23,850
带个团队做个大项目

2354
01:55:24,360 --> 01:55:25,200
那是过去了

2355
01:55:34,030 --> 01:55:35,560
这个东西在于积累

2356
01:55:35,590 --> 01:55:36,820
这这玩意儿在于积累

2357
01:55:36,820 --> 01:55:38,920
并并不是说那个

2358
01:55:38,920 --> 01:55:41,800
这都是平时点点滴滴点点滴滴的积累

2359
01:55:41,860 --> 01:55:42,910
你你遇到什么事儿

2360
01:55:42,910 --> 01:55:43,450
你要去

2361
01:55:43,600 --> 01:55:44,710
你要去思考

2362
01:55:44,710 --> 01:55:45,520
要要去反省

2363
01:55:45,730 --> 01:55:49,030
然后咱们接着看下一个下一个下一个点

2364
01:55:49,090 --> 01:55:50,710
下一个点是这个

2365
01:55:50,770 --> 01:55:51,760
下一个点是这个

2366
01:55:51,760 --> 01:55:53,260
我我很有钱

2367
01:55:53,260 --> 01:55:55,600
我我很有我我偷偷的告诉你们

2368
01:55:55,600 --> 01:55:56,380
我要很有钱

2369
01:55:56,380 --> 01:55:58,120
我就不跟着老袁干啦

2370
01:56:00,490 --> 01:56:03,040
我就我我就多买几套房子

2371
01:56:03,040 --> 01:56:04,150
我就收租去啦

2372
01:56:04,840 --> 01:56:05,920
我就不讲课了

2373
01:56:08,560 --> 01:56:09,340
哎呀

2374
01:56:09,370 --> 01:56:10,510
咱都是穷人

2375
01:56:11,140 --> 01:56:13,840
咱都是穷人

2376
01:56:13,840 --> 01:56:14,020
对

2377
01:56:14,020 --> 01:56:16,420
老袁比我有钱

2378
01:56:16,420 --> 01:56:17,170
不说这个了

2379
01:56:17,170 --> 01:56:17,590
时间

2380
01:56:17,650 --> 01:56:18,490
时间不够了

2381
01:56:18,490 --> 01:56:19,600
时间不多了

2382
01:56:20,880 --> 01:56:21,630
都快十点了

2383
01:56:21,630 --> 01:56:22,260
不说笑话了

2384
01:56:22,320 --> 01:56:23,730
然后看那个看那个

2385
01:56:24,000 --> 01:56:24,960
这个是什么呢

2386
01:56:25,050 --> 01:56:25,950
这个是

2387
01:56:26,690 --> 01:56:29,000
咱们不看前面的captain了

2388
01:56:29,000 --> 01:56:30,710
看就看那个这是什么

2389
01:56:30,710 --> 01:56:31,820
函数指针

2390
01:56:33,440 --> 01:56:35,060
这个东西是函数指针

2391
01:56:35,390 --> 01:56:38,720
那么这个函数指针它是指向代码的指针

2392
01:56:39,110 --> 01:56:43,940
咱们咱们前面那节课给大家讲的是那个指向数据的指针

2393
01:56:44,750 --> 01:56:45,290
对吧

2394
01:56:45,410 --> 01:56:46,880
指向数据的指针

2395
01:56:46,880 --> 01:56:48,080
数据也好

2396
01:56:48,110 --> 01:56:48,860
代码也好

2397
01:56:48,860 --> 01:56:49,940
它都在内存里边儿

2398
01:56:50,390 --> 01:56:51,860
那你都在内存里边儿

2399
01:56:51,950 --> 01:56:53,990
那都可以找到它的地址

2400
01:56:54,020 --> 01:56:57,020
能找到他的地址就可以用指针来

2401
01:56:57,020 --> 01:57:00,350
就可以用指针来只那么这个东西

2402
01:57:00,410 --> 01:57:03,740
这个东西就是指向代码的指针

2403
01:57:03,800 --> 01:57:05,360
咱们写的那个函数

2404
01:57:05,450 --> 01:57:07,100
他就是个他就是代码

2405
01:57:07,530 --> 01:57:10,050
实际上咱们写的那个C语言函数

2406
01:57:10,110 --> 01:57:11,610
C语言函数的那个实现

2407
01:57:12,280 --> 01:57:13,570
咱们再打开一个文件

2408
01:57:17,290 --> 01:57:18,550
再打开一个

2409
01:57:18,550 --> 01:57:19,810
比如说像这个

2410
01:57:19,840 --> 01:57:20,650
打开这个timer

2411
01:57:20,710 --> 01:57:23,920
这个timer的这个代码少一点

2412
01:57:23,980 --> 01:57:25,540
这是一个静态函数

2413
01:57:25,540 --> 01:57:26,410
不管他什么静态

2414
01:57:26,410 --> 01:57:28,030
不含静态不静态了

2415
01:57:29,290 --> 01:57:32,590
这是一个C语言函数的实现呢

2416
01:57:32,650 --> 01:57:33,880
C语言函数的实现

2417
01:57:33,880 --> 01:57:35,560
它也有函数名来

2418
01:57:35,590 --> 01:57:36,970
然后有这个

2419
01:57:37,420 --> 01:57:38,140
行程表儿

2420
01:57:39,240 --> 01:57:39,960
有形参表

2421
01:57:39,960 --> 01:57:45,390
这是形式参数表简称形参这然后后边儿这个东西是实现

2422
01:57:45,570 --> 01:57:49,590
实际上这个玩意儿函数名告诉你们一个秘密

2423
01:57:49,830 --> 01:57:53,670
C语言里面函数名本身就是一个函数指针

2424
01:57:54,580 --> 01:57:56,590
它本身就能当函数用

2425
01:57:56,590 --> 01:57:58,120
当本身就能当指针用

2426
01:57:58,150 --> 01:58:01,060
然后咱们再回到这个函数指针这儿来

2427
01:58:01,420 --> 01:58:02,980
再回到这个函数指针这儿来

2428
01:58:03,190 --> 01:58:05,950
这个函数指针实际上它就是一种声明

2429
01:58:07,330 --> 01:58:09,280
声明了什么函数的原型

2430
01:58:09,340 --> 01:58:10,360
什么叫函数原型

2431
01:58:10,360 --> 01:58:14,560
这个函数长得什么样咱们JS里边儿很少提这个概念

2432
01:58:14,560 --> 01:58:16,630
咱们JS里边儿也有函数原型这个东西

2433
01:58:16,900 --> 01:58:20,320
但是咱们咱们在JS里面根本就不提这个东西

2434
01:58:20,350 --> 01:58:22,060
根本不提这个概念

2435
01:58:22,120 --> 01:58:26,410
因为这个函数的声明和和和实现都都在一起啦

2436
01:58:26,410 --> 01:58:29,200
甚至有匿名函数对吧

2437
01:58:29,260 --> 01:58:32,440
所以就匿名函数就跟根本就没没声明了

2438
01:58:32,440 --> 01:58:33,700
就直接代码块儿了

2439
01:58:33,700 --> 01:58:40,270
就没有这个这个这个这个函数名那这个是啥意思这个

2440
01:58:40,700 --> 01:58:44,510
这是函数指针这是函数指针

2441
01:58:45,140 --> 01:58:49,610
那么函数函数名可以当函数指针去用

2442
01:58:49,640 --> 01:58:50,780
反过来也行

2443
01:58:50,840 --> 01:58:51,920
反过来也一样

2444
01:58:52,190 --> 01:58:56,240
函数指针你把它指向那个代码以后

2445
01:58:56,510 --> 01:58:59,690
函数指针就可以当成函数去用

2446
01:59:00,320 --> 01:59:01,370
当初函数去掉

2447
01:59:01,980 --> 01:59:05,610
实际上这就是CC语言的那个灵活性在这儿

2448
01:59:06,730 --> 01:59:07,570
咳

2449
01:59:07,900 --> 01:59:08,920
那么在这儿

2450
01:59:09,670 --> 01:59:11,830
为什么要声明这个函数指针呢

2451
01:59:12,400 --> 01:59:15,340
因为C语言里边儿是没有多肽的

2452
01:59:16,450 --> 01:59:16,990
对吧

2453
01:59:17,230 --> 01:59:19,360
C语言里边没有多肽

2454
01:59:19,360 --> 01:59:21,460
C语言它它不是面向对象语言

2455
01:59:21,670 --> 01:59:22,690
什么叫多肽

2456
01:59:23,140 --> 01:59:24,760
一个函数

2457
01:59:24,760 --> 01:59:28,480
一个函数它有多种实现实现形式这叫多肽

2458
01:59:29,160 --> 01:59:29,670
对吧

2459
01:59:29,940 --> 01:59:31,020
在面向对象里面

2460
01:59:31,140 --> 01:59:32,580
面向对象的语言里面

2461
01:59:32,580 --> 01:59:34,440
这种这种东西是司空见惯的

2462
01:59:34,650 --> 01:59:36,060
函数长得一模一样

2463
01:59:36,150 --> 01:59:40,680
但是它是但是它里边的这个代码是是完全不一样的

2464
01:59:41,460 --> 01:59:42,210
这是多肽

2465
01:59:42,420 --> 01:59:44,010
但是C语言里面没有这个东西

2466
01:59:44,250 --> 01:59:48,030
那那怎么去解决这个问题用函数指针

2467
01:59:48,060 --> 01:59:52,620
函数指针他只要是这个函数的原型是一样的

2468
01:59:53,040 --> 01:59:54,600
函数的原型是一样的

2469
01:59:54,600 --> 01:59:55,980
就可以让函数指针去只

2470
01:59:57,280 --> 02:00:00,610
那你只上去以后它就变成函数了

2471
02:00:00,820 --> 02:00:02,770
这个这个指针名就变成函数了

2472
02:00:03,100 --> 02:00:04,720
那直接当成函数去用

2473
02:00:05,340 --> 02:00:05,730
是吧

2474
02:00:05,940 --> 02:00:09,690
那么前面这个前面这个是海是指真名儿

2475
02:00:09,840 --> 02:00:10,770
然后这个呢

2476
02:00:10,770 --> 02:00:13,830
是声明指针的方式声明函数指针的方式

2477
02:00:13,950 --> 02:00:14,820
后边儿呢

2478
02:00:14,910 --> 02:00:18,600
是你这个函数指针要指向的那个函数

2479
02:00:18,600 --> 02:00:21,150
它的它的那个形参

2480
02:00:21,150 --> 02:00:22,260
它的形参是什么样儿

2481
02:00:22,410 --> 02:00:24,330
前边儿别忘了有返回值

2482
02:00:24,510 --> 02:00:27,720
咱们JS里面是没有返回恶

2483
02:00:27,750 --> 02:00:30,180
那个没有声明这个返回值的

2484
02:00:30,180 --> 02:00:33,030
这这这这这个这个概念的

2485
02:00:33,510 --> 02:00:34,020
对吧

2486
02:00:34,080 --> 02:00:39,090
C语言里边儿你要声明这个函数参数表函数名

2487
02:00:39,150 --> 02:00:41,040
再加上返回值都得写出来

2488
02:00:42,600 --> 02:00:44,220
这个JS里面的JS

2489
02:00:44,220 --> 02:00:45,600
他返回的就是个对象

2490
02:00:46,370 --> 02:00:46,820
是吧

2491
02:00:46,940 --> 02:00:48,440
JS就是返回就是个对象

2492
02:00:48,440 --> 02:00:49,610
你你能带啥呀

2493
02:00:49,670 --> 02:00:53,990
你你你你这个返回值你能有啥类型对吧

2494
02:00:54,260 --> 02:00:55,460
函数指针是这个

2495
02:00:56,440 --> 02:00:58,600
函数指针是是这一块儿

2496
02:00:58,600 --> 02:01:00,130
不带前面那个型号儿

2497
02:01:00,310 --> 02:01:02,440
但是咱们看到这个形式的时候

2498
02:01:02,530 --> 02:01:05,050
咱们要知道它是生命的一个函数指针

2499
02:01:05,290 --> 02:01:07,600
那函数指针是这个东西

2500
02:01:08,280 --> 02:01:10,380
那那么前面加一个星号

2501
02:01:10,380 --> 02:01:11,250
加小括号

2502
02:01:11,370 --> 02:01:16,230
这是它的语法规则声明函数指针时候的语法规则

2503
02:01:16,260 --> 02:01:18,510
用的时候是不能加这个星号的

2504
02:01:18,630 --> 02:01:20,790
用的时候直接拿这个拿这个

2505
02:01:21,790 --> 02:01:23,230
直接用这个就行

2506
02:01:23,230 --> 02:01:24,070
这是函数指针

2507
02:01:25,580 --> 02:01:26,330
然后呢

2508
02:01:26,330 --> 02:01:27,200
咱们接着

2509
02:01:30,670 --> 02:01:32,950
这个结构体说过了

2510
02:01:33,250 --> 02:01:37,300
当然这个C语言里边还有一个比较奇特的这个结构

2511
02:01:37,330 --> 02:01:41,590
还有一个奇特的这个类型叫叫联合叫联合

2512
02:01:41,770 --> 02:01:42,880
那么这个联合

2513
02:01:42,880 --> 02:01:45,610
和那个TS里面联合有点类似

2514
02:01:46,560 --> 02:01:51,630
只不过那个联合你是规定不了内存里边儿长什么样儿

2515
02:01:51,630 --> 02:01:53,160
C语言里边这个联合呢

2516
02:01:53,310 --> 02:01:58,140
他他就是复用复用这块儿同一块内存的这是联合

2517
02:01:58,140 --> 02:01:58,950
那个联合呢

2518
02:01:58,950 --> 02:02:01,980
你你大家去看那个回头把那个手册

2519
02:02:03,270 --> 02:02:07,260
或者是去看那个上次给你们的那个网站

2520
02:02:07,260 --> 02:02:08,340
去看一下那个联合

2521
02:02:08,340 --> 02:02:09,930
那个联合是是挺有意思的

2522
02:02:10,110 --> 02:02:14,760
那就是就是你在同样一个一块大一块内存里边

2523
02:02:14,760 --> 02:02:18,480
你可以你可以保存不同不同类型的这个数据

2524
02:02:20,230 --> 02:02:23,260
一个内存里边保存不同类型的数据

2525
02:02:23,500 --> 02:02:24,130
你可以保

2526
02:02:24,280 --> 02:02:27,070
比如说一个八个字节的内存

2527
02:02:27,070 --> 02:02:29,200
你可以放放一个整形

2528
02:02:29,590 --> 02:02:31,390
那可以当成一个整形去用

2529
02:02:31,510 --> 02:02:33,790
也可以当成一个a字符型去用

2530
02:02:33,850 --> 02:02:36,700
也可以当成一个双精度浮点型去用

2531
02:02:37,600 --> 02:02:39,760
那就是去服用这个内存的

2532
02:02:41,470 --> 02:02:42,700
随意操作内存

2533
02:02:42,730 --> 02:02:43,720
非常非常灵活

2534
02:02:43,870 --> 02:02:47,290
然后这这就是那个一些基本的这个语法

2535
02:02:47,290 --> 02:02:49,390
这个C语言的这个这个语法

2536
02:02:49,450 --> 02:02:52,390
然后咱们看这个代码这哈在看到这个代码

2537
02:02:52,540 --> 02:02:58,120
那么这个C代码这前边儿要药引这个头文件不引头文件

2538
02:02:58,150 --> 02:03:01,210
你在代码里边去去调用相对应的那个函数

2539
02:03:01,210 --> 02:03:02,020
你是调不了的

2540
02:03:02,050 --> 02:03:03,520
编译器会给你报错

2541
02:03:03,520 --> 02:03:09,040
就相当于咱们去在JS里面去import一样一个道理的之后呢

2542
02:03:09,370 --> 02:03:10,450
这个东西是什么呢

2543
02:03:10,780 --> 02:03:11,680
这个玩意是什么呢

2544
02:03:11,800 --> 02:03:13,300
这是变量

2545
02:03:13,300 --> 02:03:14,650
这个变量它是个指针

2546
02:03:15,040 --> 02:03:18,910
通过指针去找这个结构体里的

2547
02:03:19,910 --> 02:03:20,570
属性

2548
02:03:21,770 --> 02:03:27,020
通过通过指向结构体的指针去找结构体里的属性

2549
02:03:27,050 --> 02:03:27,830
就是这个东西

2550
02:03:27,860 --> 02:03:28,580
这个小箭头

2551
02:03:29,650 --> 02:03:30,610
是吧

2552
02:03:31,880 --> 02:03:33,080
咳咳

2553
02:03:33,930 --> 02:03:36,990
A是指向结构体的指针

2554
02:03:36,990 --> 02:03:39,120
通过指针找结构体里的

2555
02:03:39,720 --> 02:03:43,290
成员就用就用箭头儿相当于什么

2556
02:03:43,290 --> 02:03:45,510
相当于咱们JS里面那个点儿

2557
02:03:46,270 --> 02:03:46,750
对吧

2558
02:03:46,930 --> 02:03:49,600
你要找object里边那个属性

2559
02:03:49,750 --> 02:03:52,750
那你得把它点出来你在C语言里边儿

2560
02:03:52,930 --> 02:03:54,580
你用的是指针

2561
02:03:54,580 --> 02:03:55,540
就用小箭头儿

2562
02:03:55,780 --> 02:03:58,900
如果是一个结构体的变量呢

2563
02:03:58,900 --> 02:04:00,610
她不是她不是指针

2564
02:04:00,610 --> 02:04:02,170
它不是结构体的指针

2565
02:04:02,170 --> 02:04:05,020
它是它就是这个结构体变量本身

2566
02:04:05,020 --> 02:04:07,120
在这种情况下才用那个点儿

2567
02:04:08,200 --> 02:04:14,650
这这是那个区别这是区别P2P也是箭头是吧

2568
02:04:14,650 --> 02:04:16,030
P2P他那不是指针

2569
02:04:16,150 --> 02:04:18,640
批十批不是指针内内不是指针

2570
02:04:18,640 --> 02:04:20,200
它它都是引用

2571
02:04:20,530 --> 02:04:23,440
别别别那个啥别那个整错了

2572
02:04:38,560 --> 02:04:39,580
咳

2573
02:04:42,380 --> 02:04:42,680
嗯

2574
02:04:48,200 --> 02:04:48,440
好

2575
02:04:48,440 --> 02:04:50,480
这是那个C的

2576
02:04:50,480 --> 02:04:53,060
这是C的一些那个前面没有讲到的那个语法

2577
02:04:53,300 --> 02:04:54,020
然后呢

2578
02:04:54,020 --> 02:04:55,910
咱们再回到这个

2579
02:04:56,540 --> 02:04:57,650
这个鼠标怎么不动了

2580
02:04:59,150 --> 02:05:00,080
再回到这个源码

2581
02:05:00,080 --> 02:05:02,390
这那么咱们再看这个源码的时候

2582
02:05:02,930 --> 02:05:04,070
望文生义

2583
02:05:05,110 --> 02:05:06,070
望文生义

2584
02:05:06,100 --> 02:05:09,220
什么叫望文生义这个代码这个文件是干什么用的

2585
02:05:10,040 --> 02:05:10,550
对吧

2586
02:05:10,820 --> 02:05:11,870
文件干什么用的

2587
02:05:12,350 --> 02:05:13,850
看它的文件名

2588
02:05:14,210 --> 02:05:15,170
这是个啥呀

2589
02:05:15,350 --> 02:05:16,130
这是个队列

2590
02:05:17,230 --> 02:05:17,770
对吧

2591
02:05:17,980 --> 02:05:19,150
这是个队列

2592
02:05:19,180 --> 02:05:21,340
实际上它是声明了一个什么

2593
02:05:21,370 --> 02:05:22,630
声明了一个队列

2594
02:05:23,570 --> 02:05:27,980
生了一个队列的这个数据结构这这这就是队列

2595
02:05:27,980 --> 02:05:30,950
只不过他这个队列是用红血的用用红血的

2596
02:05:31,190 --> 02:05:35,300
他他那个编译出来的那个去用红处理

2597
02:05:35,330 --> 02:05:36,530
处理之后

2598
02:05:36,530 --> 02:05:40,160
他他生成的那个代码更加紧凑一些

2599
02:05:40,880 --> 02:05:43,070
但是这个红容易造成混乱

2600
02:05:43,100 --> 02:05:44,060
能不用还是不用

2601
02:05:44,240 --> 02:05:46,700
那么这个呢

2602
02:05:46,700 --> 02:05:47,570
STRCCPY是什么

2603
02:05:47,570 --> 02:05:48,740
字符串拷贝

2604
02:05:48,740 --> 02:05:52,130
他他他实现的就是去去拷贝字符串

2605
02:05:53,320 --> 02:05:55,480
他他就是一拷贝字符串的功能

2606
02:05:55,600 --> 02:05:56,740
望文生义

2607
02:05:56,770 --> 02:05:58,720
看到这个名字咱就知道他干什么

2608
02:05:58,870 --> 02:06:00,010
另外还有这个东西

2609
02:06:00,070 --> 02:06:01,120
Keep对吧

2610
02:06:01,180 --> 02:06:01,930
Keep是什么

2611
02:06:01,960 --> 02:06:07,180
堆堆恶食这个堆怎么去实现呢

2612
02:06:07,180 --> 02:06:08,800
实实现那个堆的那个定义

2613
02:06:09,010 --> 02:06:09,700
然后呢

2614
02:06:09,700 --> 02:06:10,540
C代码

2615
02:06:10,570 --> 02:06:12,190
C代码也是这样

2616
02:06:12,190 --> 02:06:13,120
C代码也是这样

2617
02:06:13,330 --> 02:06:19,450
他他这里封装的封装的各各种各样的那个C

2618
02:06:19,480 --> 02:06:22,750
你可以看到它的那个根据名字知道他是干什么

2619
02:06:22,750 --> 02:06:24,160
比如说这个call是什么

2620
02:06:24,250 --> 02:06:25,630
就是它的核心

2621
02:06:25,630 --> 02:06:26,560
它的核心代码

2622
02:06:27,640 --> 02:06:28,720
根据这个去看

2623
02:06:28,780 --> 02:06:29,590
然后呢

2624
02:06:29,590 --> 02:06:31,150
咱们再看一下note

2625
02:06:31,180 --> 02:06:33,490
看一下note的那个带note JS的代码

2626
02:06:33,490 --> 02:06:37,510
V8的咱就V8V8弄的实际上差不多

2627
02:06:37,510 --> 02:06:38,320
都是C加加的

2628
02:06:42,380 --> 02:06:42,710
算了

2629
02:06:42,710 --> 02:06:44,210
还是看V88上节课

2630
02:06:44,480 --> 02:06:46,760
上节课那个看了一眼

2631
02:06:46,760 --> 02:06:48,260
看了一眼那个弄的

2632
02:06:48,500 --> 02:06:50,750
看V8 v8也是

2633
02:06:50,780 --> 02:06:52,400
看到看先看什么

2634
02:06:52,400 --> 02:06:53,360
先看include

2635
02:06:53,630 --> 02:06:58,520
还有s r c INC Lu的决定了你这里边有什么东西

2636
02:06:58,520 --> 02:07:00,110
你的代码有什么东西

2637
02:07:00,110 --> 02:07:02,270
SRC是实现它这个微吧

2638
02:07:02,300 --> 02:07:03,500
东西挺多的

2639
02:07:03,500 --> 02:07:06,710
按照模块儿分成了不同的这个目录

2640
02:07:06,740 --> 02:07:08,570
比如说他对外提供的API

2641
02:07:08,750 --> 02:07:10,580
你要把它给嵌到这里边

2642
02:07:10,700 --> 02:07:13,670
你要把这个VV8000到你自己的那个程序里边儿

2643
02:07:13,880 --> 02:07:17,210
那你你你对这块儿的代码感兴趣

2644
02:07:17,210 --> 02:07:18,230
就看它

2645
02:07:18,230 --> 02:07:20,360
它是对外提供的那个接口

2646
02:07:21,000 --> 02:07:22,200
八对外提供的接口

2647
02:07:22,230 --> 02:07:23,010
然后呢

2648
02:07:23,010 --> 02:07:24,690
咱们看ADUI是吧

2649
02:07:24,690 --> 02:07:27,450
实际上咱们最感兴趣的就是内存管理

2650
02:07:27,450 --> 02:07:30,210
还有他的那个类型等等类型的这个实现

2651
02:07:30,390 --> 02:07:34,590
如果说你对他的那个这个堆内存来感兴趣

2652
02:07:34,710 --> 02:07:36,720
那就转到这个堆这儿来

2653
02:07:36,780 --> 02:07:37,830
然后看什么

2654
02:07:37,920 --> 02:07:40,350
看它里边的这个相关的东西

2655
02:07:40,440 --> 02:07:42,060
那他从哪开始看

2656
02:07:42,120 --> 02:07:44,130
直接看这个heap

2657
02:07:44,130 --> 02:07:45,420
直接找这个heap

2658
02:07:45,600 --> 02:07:47,400
然后找到这个hip以后呢

2659
02:07:47,520 --> 02:07:48,270
再看

2660
02:07:49,680 --> 02:07:50,790
这个C代码

2661
02:07:52,180 --> 02:07:56,890
它实现的是这个堆的哪一部分这个这个命名

2662
02:07:56,890 --> 02:07:59,860
这个命名命名规则是命名规则是很重要的

2663
02:08:00,070 --> 02:08:01,150
那么它的这个堆

2664
02:08:01,150 --> 02:08:05,710
比如说我们看一下这个heap.cc这是对这是那个堆的实现呢

2665
02:08:05,920 --> 02:08:07,690
那么这个堆的实现

2666
02:08:07,810 --> 02:08:09,490
在在在在哪儿呢

2667
02:08:09,490 --> 02:08:11,860
在在这儿初始化这个堆是吧

2668
02:08:11,890 --> 02:08:13,390
这这是堆的堆

2669
02:08:13,390 --> 02:08:15,130
这是那个hip那个累

2670
02:08:15,130 --> 02:08:16,240
这是hip类

2671
02:08:17,000 --> 02:08:19,670
类类的结构定义在头文件里

2672
02:08:19,880 --> 02:08:21,950
那那么累的那个实现呢

2673
02:08:22,130 --> 02:08:22,610
是这个

2674
02:08:22,760 --> 02:08:27,440
这是实现的时候累的名字双冒号后边是

2675
02:08:28,070 --> 02:08:29,690
类方法的名字

2676
02:08:29,690 --> 02:08:31,550
这是里边那个里边那个实现

2677
02:08:31,850 --> 02:08:37,220
那这这这这一块儿都是都是这个堆都是堆的那个实现代码了

2678
02:08:37,220 --> 02:08:38,510
咱们要感兴趣的话

2679
02:08:38,510 --> 02:08:39,890
就就就看这一块儿

2680
02:08:40,160 --> 02:08:44,090
那如果说咱们看这一块儿想一一直往下看

2681
02:08:44,090 --> 02:08:46,160
比如说这个hip hip的构造函数

2682
02:08:46,850 --> 02:08:47,420
对吧

2683
02:08:47,720 --> 02:08:49,670
你要看一个累的话

2684
02:08:49,790 --> 02:08:51,230
先看它的构造函数

2685
02:08:51,230 --> 02:08:52,790
看他做了哪些初始化

2686
02:08:53,880 --> 02:08:55,140
看他做哪些初始化

2687
02:08:55,350 --> 02:08:57,330
这个是什么的

2688
02:08:57,330 --> 02:08:58,830
Tek EQ啊

2689
02:08:58,830 --> 02:08:59,700
他在干什么呢

2690
02:08:59,820 --> 02:09:02,460
去检查他去检查一个东西

2691
02:09:02,610 --> 02:09:03,570
这个东西是啥呀

2692
02:09:03,570 --> 02:09:05,040
EQ实际上就是这个队列

2693
02:09:06,170 --> 02:09:08,510
相当于恶劣检查一个队列

2694
02:09:08,510 --> 02:09:10,910
他他在这儿去做那个初始化

2695
02:09:10,970 --> 02:09:13,610
初始化了好多个结构

2696
02:09:13,850 --> 02:09:14,660
两个list

2697
02:09:14,930 --> 02:09:16,160
然后这个是什么

2698
02:09:16,310 --> 02:09:16,940
这个是

2699
02:09:17,740 --> 02:09:21,010
这个是那个映射页面

2700
02:09:21,010 --> 02:09:23,860
内存的那个页面映射映射规则

2701
02:09:24,890 --> 02:09:31,340
这是什么map I map的配置就是没有印社的那些页面

2702
02:09:31,340 --> 02:09:33,980
这是内存管理的一个一个算法

2703
02:09:33,980 --> 02:09:37,400
就是那个内存你要你要给人家分配内存的话

2704
02:09:37,460 --> 02:09:39,200
内存内内存分配算法

2705
02:09:39,440 --> 02:09:41,720
你不能一块儿一块儿给

2706
02:09:41,780 --> 02:09:43,580
你不能恶那个

2707
02:09:44,170 --> 02:09:45,760
内存里边儿切一块儿就给他

2708
02:09:45,760 --> 02:09:46,450
你不能这样

2709
02:09:46,630 --> 02:09:49,900
你先得把内存分成若干个小单元

2710
02:09:49,900 --> 02:09:51,220
这若干个小单元叫什么

2711
02:09:51,220 --> 02:09:54,070
就叫页面就是内存页面是吧

2712
02:09:54,280 --> 02:09:56,080
你他要多少内存

2713
02:09:56,230 --> 02:10:00,190
你你比如说你一个一个内存页面儿是是那个4K

2714
02:10:00,830 --> 02:10:01,280
对吧

2715
02:10:01,370 --> 02:10:02,990
他要想要7K

2716
02:10:03,320 --> 02:10:04,940
他要想要7K的内存

2717
02:10:05,000 --> 02:10:07,040
你就得你就得给他分两个页面

2718
02:10:07,700 --> 02:10:08,000
是吧

2719
02:10:08,000 --> 02:10:09,800
这这这么一个东西

2720
02:10:09,800 --> 02:10:11,180
这么一个套路

2721
02:10:12,230 --> 02:10:15,080
那这个在CC语言里边

2722
02:10:15,080 --> 02:10:17,300
在C加加语言在C加加里边呢

2723
02:10:17,420 --> 02:10:22,670
实际上它里边这个看这个C加加的话

2724
02:10:22,760 --> 02:10:24,110
先看累

2725
02:10:24,110 --> 02:10:25,880
先看先找到这个对应的类

2726
02:10:25,910 --> 02:10:26,450
然后呢

2727
02:10:26,450 --> 02:10:28,160
再再找这个类

2728
02:10:28,700 --> 02:10:32,030
类方法类方法搞清楚他是干什么的

2729
02:10:32,030 --> 02:10:39,110
再去分析他那个类方法的实验比如说要找那个hip类B类C类都在这儿呢

2730
02:10:39,440 --> 02:10:42,470
在这儿声明了这么多这么多累对吧

2731
02:10:42,710 --> 02:10:43,820
这是命名空间

2732
02:10:43,910 --> 02:10:46,790
就相当于咱们那个JS里面那个包名儿

2733
02:10:47,150 --> 02:10:50,060
这这个包里边有这么两个有有这么两个类

2734
02:10:50,210 --> 02:10:58,130
然后这个这这还有一个这个B类这这这是那个在这个heap包底下有一个hip类

2735
02:10:58,630 --> 02:11:00,820
就就是咱们JS里面那个包路径

2736
02:11:00,820 --> 02:11:01,930
相当于那个东西

2737
02:11:03,480 --> 02:11:04,440
之后在后边呢

2738
02:11:04,440 --> 02:11:06,480
这是这是累的定义

2739
02:11:06,600 --> 02:11:11,640
类里边儿有多少个成员属性有多少个都有什么那个方法

2740
02:11:11,640 --> 02:11:13,650
类方法先看类定义

2741
02:11:13,680 --> 02:11:14,250
然后呢

2742
02:11:14,370 --> 02:11:19,320
再看类方法里边儿那个实现就就就是按照这种顺序

2743
02:11:19,440 --> 02:11:25,590
然后这个这个C加加里边儿有一个东西是啥

2744
02:11:25,590 --> 02:11:26,280
就是这个东西

2745
02:11:26,920 --> 02:11:28,390
这是最后最后一点

2746
02:11:28,390 --> 02:11:30,190
大家要注意这个东西是什么呢

2747
02:11:30,190 --> 02:11:31,450
是饭行

2748
02:11:31,450 --> 02:11:32,410
这叫梵行

2749
02:11:32,530 --> 02:11:33,580
就是模板类

2750
02:11:33,580 --> 02:11:35,470
咱们TS里边儿好像也有犯行

2751
02:11:35,500 --> 02:11:36,340
对吧

2752
02:11:36,580 --> 02:11:39,580
JS这个Java里边也有饭行JS没有

2753
02:11:39,790 --> 02:11:41,080
那么这个模板类

2754
02:11:41,110 --> 02:11:42,520
它就是这个代码模板

2755
02:11:42,580 --> 02:11:43,660
相当于代码模板

2756
02:11:44,600 --> 02:11:47,630
那么这个泛型它也是一种预处理代码

2757
02:11:47,630 --> 02:11:48,860
但他不是红蛋

2758
02:11:48,860 --> 02:11:51,980
它归入那个预处理代码里面去呢

2759
02:11:52,730 --> 02:11:53,510
这种东西呢

2760
02:11:53,510 --> 02:11:54,350
就是啊

2761
02:11:54,350 --> 02:11:56,060
就是更加紧凑了

2762
02:11:56,060 --> 02:11:59,810
他他不是那个对象实际上这个这个模板

2763
02:11:59,810 --> 02:12:04,070
模板看上去和那个和那个对象是挺像的呢

2764
02:12:04,070 --> 02:12:04,880
对吧

2765
02:12:04,880 --> 02:12:06,350
和那个对对象挺像

2766
02:12:06,350 --> 02:12:07,580
但实际上不是

2767
02:12:07,790 --> 02:12:09,890
不是他他就是给你搭一个架子

2768
02:12:10,100 --> 02:12:13,490
然后然后把你这个架子里边儿给你做好了

2769
02:12:13,490 --> 02:12:18,260
各种各样的那个各种各样的那个处理机制

2770
02:12:18,320 --> 02:12:19,370
然后把你要

2771
02:12:19,920 --> 02:12:21,240
把你要那个

2772
02:12:22,190 --> 02:12:26,960
把你要放入这个处理机制里边儿那个数据

2773
02:12:26,960 --> 02:12:27,950
给他传进去

2774
02:12:28,310 --> 02:12:29,870
到时候直接编译成代码

2775
02:12:29,900 --> 02:12:32,780
就可以少写好多代码

2776
02:12:33,020 --> 02:12:35,510
比如说有那个list

2777
02:12:35,510 --> 02:12:36,980
比如说有那个list泛型

2778
02:12:37,130 --> 02:12:39,470
泛型那边有list list泛型类

2779
02:12:39,740 --> 02:12:42,110
那你要想用这个list这个结构

2780
02:12:42,260 --> 02:12:45,920
但是呢a list里边儿那个放的那个元素

2781
02:12:45,950 --> 02:12:47,990
元素类型你是各种各样的

2782
02:12:48,140 --> 02:12:51,470
你可以把元素类型传给那个类似的类似的模板

2783
02:12:51,620 --> 02:12:57,440
然后就专编辑代码的时候生成的就是专门针对你那个数据类型的那个list

2784
02:12:57,900 --> 02:13:02,250
那这这个东西就属于属于代码代码复用的好

2785
02:13:02,250 --> 02:13:03,480
那么这个

2786
02:13:04,540 --> 02:13:05,800
C语言代码呢

2787
02:13:05,920 --> 02:13:07,420
其他的东西

2788
02:13:07,420 --> 02:13:13,930
其他的东西没有什么没有什么这个太多好说的那个因为在这个在这种代码里边

2789
02:13:14,020 --> 02:13:15,880
像什么有缘之类的

2790
02:13:15,880 --> 02:13:18,760
这这些特性一般是比较少用的

2791
02:13:18,910 --> 02:13:21,130
还有什么操作符承载之类的

2792
02:13:21,250 --> 02:13:24,040
在这种引擎里边也不多见

2793
02:13:24,040 --> 02:13:26,020
更别说那个多继承呢

2794
02:13:26,020 --> 02:13:33,970
那个多继承一般都是尽可能的那个去尽可能的去那个避免去使用的好今天呢

2795
02:13:33,970 --> 02:13:35,140
这个课

2796
02:13:35,140 --> 02:13:39,100
就先给大家讲到就先给大家讲到这儿了

2797
02:13:39,250 --> 02:13:41,650
实际上这个因为这个时间关系

2798
02:13:41,710 --> 02:13:43,090
像这个C语言

2799
02:13:43,090 --> 02:13:47,140
还有这个C加加语言这方面的这些这些东西

2800
02:13:48,790 --> 02:13:53,260
这这些这些东西是是挺多的

2801
02:13:53,260 --> 02:13:55,270
咱们就分步骤走

2802
02:13:55,300 --> 02:13:57,760
如果说你对这个C语言或者C加加感兴趣

2803
02:13:57,760 --> 02:13:59,620
第一步就是先能看懂代码

2804
02:14:00,160 --> 02:14:00,520
是吧

2805
02:14:00,640 --> 02:14:01,240
然后呢

2806
02:14:01,240 --> 02:14:04,750
再去写一些简单的东西这是按按分步骤走

2807
02:14:05,050 --> 02:14:07,420
那如果说你你不想学这个C语言

2808
02:14:07,420 --> 02:14:10,360
以后也不打算用这个C和或者是C加加写代码

2809
02:14:10,480 --> 02:14:12,190
但是它的语法也得搞清楚

2810
02:14:13,280 --> 02:14:16,970
你搞清楚你你就能看看懂它底层的那些机智了

2811
02:14:16,970 --> 02:14:21,680
这这是有很大好处的实际上多这个多学一点东西

2812
02:14:21,680 --> 02:14:23,390
他也没什么坏处的

2813
02:14:23,660 --> 02:14:26,720
像那些你你咱们做JS的

2814
02:14:26,720 --> 02:14:27,890
你要会C

2815
02:14:27,890 --> 02:14:28,490
你要会C

2816
02:14:28,490 --> 02:14:30,470
你这个系你要走技术路线的话

2817
02:14:30,620 --> 02:14:32,660
你是相当占便宜的

2818
02:14:32,990 --> 02:14:34,580
就好像是做Java的一样

2819
02:14:34,670 --> 02:14:36,080
做Java的他要会C

2820
02:14:36,080 --> 02:14:36,950
加加他的

2821
02:14:37,130 --> 02:14:38,570
他是很很占便宜的

2822
02:14:39,390 --> 02:14:41,820
为什么做Java的会C加加很占便宜

2823
02:14:41,820 --> 02:14:43,050
他可以写那个

2824
02:14:43,410 --> 02:14:46,830
他可以写那个JNA层那个JN是什么

2825
02:14:46,830 --> 02:14:48,600
就是就等于用C加加给他

2826
02:14:48,600 --> 02:14:53,850
用C加加给他给给他写扩展你你要想给note写扩展

2827
02:14:53,850 --> 02:14:55,320
那就是C加加吗

2828
02:14:55,320 --> 02:14:57,030
你你是很占便宜的

2829
02:14:57,030 --> 02:15:02,040
看了又好像什么都没看这个这个你需要时间去磨

2830
02:15:02,220 --> 02:15:03,570
这个你需要去时间去磨

2831
02:15:03,570 --> 02:15:06,570
你要先把语法搞懂

2832
02:15:06,840 --> 02:15:12,330
然后才能去看懂他这个代码不是看不是为看代码看代码

2833
02:15:12,330 --> 02:15:14,340
而是看他那个机制看流程

2834
02:15:14,760 --> 02:15:17,280
那你怎么去看人家JS代码

2835
02:15:17,280 --> 02:15:19,560
你就你就怎么去看C代码

2836
02:15:19,830 --> 02:15:21,600
但是但是呢

2837
02:15:21,600 --> 02:15:24,270
前提前提千万别忘了

2838
02:15:26,640 --> 02:15:26,880
好了

2839
02:15:26,880 --> 02:15:27,360
今天呢

2840
02:15:27,360 --> 02:15:28,740
就先给大家讲到这儿了

2841
02:15:28,770 --> 02:15:30,840
然后那个下周

2842
02:15:30,840 --> 02:15:38,430
下周给大家讲那个WSM之类的WSM也也咱就用C去写

2843
02:15:39,560 --> 02:15:43,280
WSM咱们用C去实现那个DEMO

2844
02:15:43,400 --> 02:15:44,120
用C实现的

2845
02:15:44,120 --> 02:15:45,410
这C你是躲不掉的

2846
02:15:45,830 --> 02:15:47,870
你要你要做这个性能优化

2847
02:15:48,140 --> 02:15:49,850
你你你优化到极致

2848
02:15:49,850 --> 02:15:51,950
你可不是得写WSM吗

2849
02:15:52,570 --> 02:15:53,140
对吧

2850
02:15:53,290 --> 02:15:56,500
那你不会塞也不会C加加你怎么写

2851
02:15:56,740 --> 02:15:57,580
你没法写

2852
02:15:57,610 --> 02:15:58,930
这个活你就干不了

2853
02:15:58,960 --> 02:16:00,070
那你就去卷吧

2854
02:16:00,430 --> 02:16:00,910
是吧

2855
02:16:01,060 --> 02:16:01,780
哈哈

2856
02:16:02,050 --> 02:16:05,920
这这这就真正的给这就真的给见到那个卷里边儿去了

2857
02:16:07,830 --> 02:16:08,070
好

2858
02:16:08,070 --> 02:16:09,150
今天就先到这儿

2859
02:16:09,150 --> 02:16:10,650
咱们那个下周再见

