1
00:00:39,300 --> 00:00:39,660
嗯

2
00:01:25,370 --> 00:01:26,960
这一路上

3
00:01:26,960 --> 00:01:28,520
走走停停

4
00:01:28,520 --> 00:01:31,070
顺着少年漂流的痕迹

5
00:01:31,640 --> 00:01:34,670
迈出车站的前一刻

6
00:01:34,670 --> 00:01:36,650
竟有些犹豫

7
00:01:38,270 --> 00:01:39,350
不禁笑着

8
00:01:39,350 --> 00:01:42,740
近乡情怯仍无法避免

9
00:01:43,250 --> 00:01:45,980
而长野的天依旧那么暖

10
00:01:45,980 --> 00:01:47,780
风吹起了从前

11
00:01:48,620 --> 00:01:52,940
从前初识这世间万般流连

12
00:01:53,270 --> 00:01:56,030
看着天边似在眼前

13
00:01:56,030 --> 00:02:00,320
也甘愿赴汤蹈火去走它一遍

14
00:02:01,220 --> 00:02:03,770
如今走过这世间

15
00:02:04,160 --> 00:02:05,360
万般流连

16
00:02:05,420 --> 00:02:09,800
翻过岁月不同侧脸措不及防

17
00:02:09,830 --> 00:02:12,170
闯入你的笑颜

18
00:02:14,210 --> 00:02:17,870
我曾难自拔于世界之大

19
00:02:18,110 --> 00:02:20,060
也成了一个汽车

20
00:02:20,230 --> 00:02:22,540
梦话不得真假

21
00:02:22,540 --> 00:02:23,650
不做挣扎

22
00:02:23,950 --> 00:02:26,320
不惧笑话

23
00:02:26,620 --> 00:02:30,070
我曾将青春翻涌成她

24
00:02:30,310 --> 00:02:32,920
曾指尖弹出盛夏

25
00:02:32,950 --> 00:02:34,540
心之所动

26
00:02:34,540 --> 00:02:37,450
且就随缘去发

27
00:02:39,010 --> 00:02:39,430
着

28
00:02:41,320 --> 00:02:45,190
风吹雨打咯

29
00:02:56,020 --> 00:02:56,740
短路

30
00:02:56,740 --> 00:02:58,210
走走停停

31
00:02:58,930 --> 00:03:00,880
有na几分的距离

32
00:03:01,450 --> 00:03:06,340
不知抚摸的是故事还是段心情

33
00:03:07,690 --> 00:03:12,130
也许期待的不过是时间问题

34
00:03:13,030 --> 00:03:14,140
再次见到你

35
00:03:14,590 --> 00:03:17,710
为了晨光里笑得很甜蜜

36
00:03:18,370 --> 00:03:19,780
从前初识

37
00:03:20,180 --> 00:03:22,850
这世间万般流连

38
00:03:23,090 --> 00:03:25,820
看着天边死在眼前

39
00:03:25,820 --> 00:03:30,020
也甘愿赴汤蹈火去走它一遍

40
00:03:30,860 --> 00:03:35,240
如今走过这世间万般流连

41
00:03:35,270 --> 00:03:38,210
翻过岁月不同侧脸

42
00:03:38,210 --> 00:03:42,470
措不及防闯入你的笑颜

43
00:03:44,030 --> 00:03:50,990
我曾难自拔于世界之大也沉溺的心中梦话

44
00:03:50,990 --> 00:03:51,590
不做

45
00:03:51,590 --> 00:03:52,370
真假

46
00:03:52,370 --> 00:03:53,480
不做挣扎

47
00:03:53,780 --> 00:03:56,180
不惧笑话

48
00:03:56,420 --> 00:04:02,750
我曾将青春翻涌成她也从指尖弹出盛夏

49
00:04:02,750 --> 00:04:04,340
心之所动

50
00:04:04,490 --> 00:04:08,030
且就随缘去吧

51
00:04:33,580 --> 00:04:37,330
晚风吹起遮白发

52
00:04:37,660 --> 00:04:40,000
我凭回忆留下的

53
00:04:40,000 --> 00:04:43,120
把你的眼中明暗交杂

54
00:04:43,300 --> 00:04:45,730
一笑生花

55
00:04:45,970 --> 00:04:49,660
暮色遮住你蹒跚的步伐

56
00:04:49,810 --> 00:04:52,840
走进床头藏起的画

57
00:04:52,840 --> 00:04:56,440
画中的你低着头说话

58
00:04:58,360 --> 00:05:01,450
我让感叹于世界之大

59
00:05:02,020 --> 00:05:04,360
也沉醉别的世界

60
00:05:04,360 --> 00:05:06,280
话不想挣扎

61
00:05:06,520 --> 00:05:07,810
不做挣扎

62
00:05:08,020 --> 00:05:10,480
无悔笑话

63
00:05:10,750 --> 00:05:14,260
我终将青春还给了他

64
00:05:14,590 --> 00:05:17,620
从指尖弹出的盛夏

65
00:05:17,620 --> 00:05:20,140
心之所动就随风

66
00:05:20,220 --> 00:05:23,415
去爱你

67
00:05:23,415 --> 00:05:24,900
爱着你

68
00:05:25,110 --> 00:05:28,050
你还愿意吗

69
00:06:14,710 --> 00:06:15,850
我们还是

70
00:06:16,030 --> 00:06:19,150
我们还是08:05开始同学们

71
00:06:19,150 --> 00:06:19,840
不对

72
00:06:19,840 --> 00:06:21,010
02:05说错了

73
00:06:22,800 --> 00:06:25,410
为啥子川菜中的钵钵鸡本来是串串

74
00:06:25,410 --> 00:06:27,480
里面没有肌肉还叫钵钵鸡

75
00:06:28,600 --> 00:06:28,900
对呀

76
00:06:28,900 --> 00:06:30,130
所以不叫串串吗

77
00:06:31,210 --> 00:06:31,510
不

78
00:06:31,540 --> 00:06:32,230
他不一样

79
00:06:32,230 --> 00:06:32,830
串串

80
00:06:33,670 --> 00:06:35,920
你看你吃吃的是什么串串

81
00:06:35,920 --> 00:06:38,140
有有那种冷锅串串

82
00:06:38,790 --> 00:06:40,080
用冷锅串串

83
00:06:40,900 --> 00:06:42,760
一般就叫做钵钵鸡

84
00:06:42,880 --> 00:06:44,500
或者是有的串串

85
00:06:44,500 --> 00:06:46,210
它是那个煮火锅煮的

86
00:06:47,210 --> 00:06:48,320
拿那种就比较热

87
00:06:48,350 --> 00:06:50,150
然后冷锅串串的话

88
00:06:51,090 --> 00:06:51,600
饿死

89
00:06:52,380 --> 00:06:53,490
里面没有肌肉

90
00:06:53,490 --> 00:06:54,420
还叫钵钵鸡

91
00:06:55,660 --> 00:06:56,440
你说这话

92
00:06:56,530 --> 00:06:59,620
你觉得这个有点儿

93
00:07:01,470 --> 00:07:02,280
好像是

94
00:07:03,340 --> 00:07:06,070
可能是他们早期里面主要是肌肉

95
00:07:06,220 --> 00:07:07,840
主要早期里面主要吃鸡肉吧

96
00:07:07,990 --> 00:07:08,860
而且这个

97
00:07:09,480 --> 00:07:10,980
而且这个一开始的话

98
00:07:11,100 --> 00:07:15,630
他是走乐山乐山乐山那边的钵钵鸡特别有名

99
00:07:16,170 --> 00:07:22,260
乐山的那个豆腐脑儿和乐山的钵钵鸡又便宜又便宜又好吃

100
00:07:22,950 --> 00:07:24,420
应该从那边传过来的

101
00:07:24,450 --> 00:07:25,680
就是船到成都的

102
00:07:26,410 --> 00:07:29,350
因为成都的那个钵钵鸡本身没有乐山的那边好吃

103
00:07:29,500 --> 00:07:32,320
一般打钵钵鸡的招牌都打的是乐山的钵钵鸡

104
00:07:32,970 --> 00:07:33,540
要吃的话

105
00:07:33,540 --> 00:07:34,770
那边就特别便宜

106
00:07:34,770 --> 00:07:35,700
而且特别好吃

107
00:07:36,620 --> 00:07:37,760
那边就有机子了

108
00:07:39,990 --> 00:07:41,490
那边肌肉就比较多了

109
00:07:42,920 --> 00:07:43,610
你可以可以

110
00:07:43,610 --> 00:07:45,980
如果要去那个峨眉山

111
00:07:45,980 --> 00:07:46,850
或者说是

112
00:07:47,550 --> 00:07:49,140
乐山大佛那块儿

113
00:07:49,230 --> 00:07:50,040
然后就可以

114
00:07:50,910 --> 00:07:53,130
吃里面的饽饽鸡就比较好吃一些

115
00:08:02,380 --> 00:08:02,620
对

116
00:08:03,160 --> 00:08:05,380
但是其实如果要去峨眉山

117
00:08:05,860 --> 00:08:06,490
请注意

118
00:08:06,490 --> 00:08:08,260
一定要小心当地的猴子

119
00:08:10,120 --> 00:08:11,950
峨眉山的猴子特别的凶残

120
00:08:12,910 --> 00:08:13,480
就是你

121
00:08:13,510 --> 00:08:15,700
你有什么东西都可能被猴子给抢了

122
00:08:15,880 --> 00:08:17,500
那边的猴子太厉害了

123
00:08:18,700 --> 00:08:22,270
一东西一塞

124
00:08:23,620 --> 00:08:24,700
歌

125
00:08:26,680 --> 00:08:29,170
歌词这歌

126
00:08:35,260 --> 00:08:35,800
这

127
00:08:36,070 --> 00:08:38,020
这个叫大山和日本的

128
00:08:39,730 --> 00:08:40,540
猴子会打人

129
00:08:40,900 --> 00:08:41,080
不

130
00:08:41,140 --> 00:08:43,660
猴子一般情况下只会抢东西

131
00:08:45,190 --> 00:08:46,060
一般情况下

132
00:08:46,060 --> 00:08:46,390
他

133
00:08:46,570 --> 00:08:47,860
比如你买点儿什么

134
00:08:48,400 --> 00:08:49,540
他可能会抢你的包

135
00:08:49,750 --> 00:08:51,280
如果你买点儿什么排骨钱

136
00:08:51,280 --> 00:08:52,660
你问他们为他们的话

137
00:08:53,080 --> 00:08:56,230
他可能直接就从你的手中抢走

138
00:09:00,010 --> 00:09:00,850
如果要

139
00:09:01,210 --> 00:09:02,680
如果你带孩子去乐山

140
00:09:02,680 --> 00:09:03,730
就一定要小心

141
00:09:04,120 --> 00:09:06,310
因为之前有一个新闻

142
00:09:06,640 --> 00:09:07,810
一个新闻是啥

143
00:09:08,290 --> 00:09:11,110
楼上有一个猴子打一个小孩

144
00:09:11,110 --> 00:09:11,980
一个小男孩

145
00:09:12,190 --> 00:09:13,000
那个小男孩

146
00:09:13,090 --> 00:09:16,870
那个小男孩是躺在那个婴儿车上的

147
00:09:17,530 --> 00:09:21,220
然后我被他的猴子把那个小儿的蛋给偷了

148
00:09:22,030 --> 00:09:22,990
特别凶残

149
00:09:23,290 --> 00:09:24,310
一定要小心

150
00:09:30,670 --> 00:09:31,045
对

151
00:09:31,045 --> 00:09:32,290
我去过一次

152
00:09:32,320 --> 00:09:33,130
真真的

153
00:09:33,130 --> 00:09:36,160
特别是看小女小女生一个人

154
00:09:36,160 --> 00:09:38,920
小女生猴子根本就不怕

155
00:09:42,880 --> 00:09:43,600
就算

156
00:09:45,550 --> 00:09:46,240
and

157
00:09:48,550 --> 00:09:49,510
nano

158
00:09:54,370 --> 00:09:55,780
不知道有没有把他自己了

159
00:09:56,050 --> 00:09:56,590
反正

160
00:09:57,010 --> 00:09:58,120
反正你们要去了

161
00:09:58,450 --> 00:09:59,830
要去那个峨眉山的话

162
00:10:00,640 --> 00:10:01,660
小心地

163
00:10:01,960 --> 00:10:03,940
他们在那儿的猴子是最凶残

164
00:10:05,140 --> 00:10:05,440
的

165
00:10:09,820 --> 00:10:10,150
对

166
00:10:10,300 --> 00:10:10,720
是的

167
00:10:11,230 --> 00:10:13,240
就是因为有峨眉山的保护吗

168
00:10:13,240 --> 00:10:15,970
保护区特别肆无忌惮

169
00:10:18,100 --> 00:10:22,630
也在所拔的都拔孤单女生

170
00:10:31,210 --> 00:10:32,590
身上有啥好地方玩儿的

171
00:10:33,640 --> 00:10:34,330
挺多的

172
00:10:34,390 --> 00:10:35,170
去九寨沟

173
00:10:35,230 --> 00:10:35,890
你可以去一下

174
00:10:35,890 --> 00:10:36,430
九寨沟

175
00:10:37,780 --> 00:10:38,890
的风景非常美

176
00:10:39,520 --> 00:10:41,410
还有像

177
00:10:41,410 --> 00:10:42,040
康定

178
00:10:42,160 --> 00:10:43,630
康定那边也挺漂亮的

179
00:10:44,410 --> 00:10:46,600
还有一些像单就是四川

180
00:10:46,720 --> 00:10:48,880
还有一些少数民族聚集的地方

181
00:10:48,880 --> 00:10:50,620
就是贪婪

182
00:10:51,100 --> 00:10:53,620
贪婪部分的话可以去

183
00:10:53,620 --> 00:10:58,150
就是我刚说的康定有个叫做康定那边有海螺沟

184
00:10:58,220 --> 00:10:59,420
然后还有毕棚沟

185
00:10:59,420 --> 00:11:00,650
然后这些都特别漂亮

186
00:11:01,220 --> 00:11:02,600
还有500

187
00:11:02,630 --> 00:11:04,100
就是五千米以上的雪山

188
00:11:04,100 --> 00:11:05,060
四川也有几座

189
00:11:08,900 --> 00:11:09,470
牙齿

190
00:11:12,140 --> 00:11:12,770
咋被坑了

191
00:11:13,160 --> 00:11:14,120
收了多少钱

192
00:11:14,960 --> 00:11:17,360
四川川南的赞助还是挺多的

193
00:11:19,520 --> 00:11:21,620
因为苍南有一条街赞助的通道嘛

194
00:11:22,100 --> 00:11:22,340
对吧

195
00:11:22,430 --> 00:11:24,080
那你们大渡河也在那边

196
00:11:33,680 --> 00:11:34,670
我还没遇到过呢

197
00:11:35,990 --> 00:11:36,680
我还没遇到

198
00:11:38,420 --> 00:11:38,870
一条鱼

199
00:11:38,870 --> 00:11:39,320
800

200
00:11:39,320 --> 00:11:40,130
这有点坑

201
00:11:47,510 --> 00:11:50,240
不过四川重点推荐的话

202
00:11:50,240 --> 00:11:51,020
可以去

203
00:11:51,470 --> 00:11:53,570
可以去一下那个什么九寨沟

204
00:11:53,780 --> 00:11:55,280
九寨沟还是真的特别漂亮

205
00:11:55,460 --> 00:11:57,350
这一生至少要去约去了

206
00:11:58,240 --> 00:11:58,900
九寨沟

207
00:12:01,690 --> 00:12:03,580
而且很有名

208
00:12:05,620 --> 00:12:06,310
时间到了

209
00:12:15,460 --> 00:12:16,450
为什么不能使用

210
00:12:23,240 --> 00:12:24,230
呆着强吧

211
00:12:25,070 --> 00:12:26,420
明天明天讲那个

212
00:12:32,460 --> 00:12:33,660
他不能够直接使用

213
00:12:35,100 --> 00:12:36,390
明天讲顾客好

214
00:12:36,540 --> 00:12:37,560
时间差不多到了

215
00:12:38,320 --> 00:12:40,810
我们今天接着昨天的

216
00:12:42,150 --> 00:12:43,530
今天接着昨天的讲

217
00:12:43,800 --> 00:12:44,700
昨天啊

218
00:12:44,700 --> 00:12:45,630
不是前天讲

219
00:12:45,720 --> 00:12:48,060
前天我们对是我

220
00:12:51,530 --> 00:12:52,340
同学们大家好

221
00:12:52,340 --> 00:12:54,380
今天我们就时间到了

222
00:12:54,380 --> 00:12:56,750
我们就先不等了

223
00:12:56,780 --> 00:12:57,260
先不等了

224
00:12:57,260 --> 00:12:59,360
同学们来的也有27个了

225
00:12:59,360 --> 00:13:00,770
我们就先讲着走

226
00:13:00,800 --> 00:13:04,070
其他同学的话没来的可能后面就直接看回放

227
00:13:04,100 --> 00:13:06,260
前面的可以看回放

228
00:13:06,710 --> 00:13:08,030
之前那一节课我们讲了

229
00:13:08,030 --> 00:13:10,520
就是react时期的三个大部分中的一个

230
00:13:10,520 --> 00:13:11,390
就是调度器

231
00:13:11,750 --> 00:13:12,920
它可以控制是什么

232
00:13:12,920 --> 00:13:13,820
它控制的是

233
00:13:14,280 --> 00:13:15,630
哪一个

234
00:13:15,660 --> 00:13:17,670
更新的就是哪一次更新

235
00:13:17,760 --> 00:13:21,450
哪一次开始的更新可以优先进入到接下来的流程

236
00:13:21,510 --> 00:13:26,790
接下来的流程指的就是会在进行一项创建fiber

237
00:13:26,970 --> 00:13:27,720
创建fiber

238
00:13:27,750 --> 00:13:28,620
然后dif

239
00:13:28,620 --> 00:13:30,000
最后把它渲染到页面上

240
00:13:30,810 --> 00:13:31,830
然后今天的话

241
00:13:31,830 --> 00:13:35,520
我们就主要就讲这三大部分的另外两块儿

242
00:13:35,520 --> 00:13:38,010
一个就是它的名字叫做re consider

243
00:13:38,100 --> 00:13:40,350
也可以称为中文可以称为协调器

244
00:13:40,680 --> 00:13:43,410
另外部分可以称为他叫做render阶段或者

245
00:13:43,410 --> 00:13:44,640
com的阶段都可以

246
00:13:45,000 --> 00:13:46,500
这都都都可以这么叫

247
00:13:46,530 --> 00:13:49,080
但是它并不是我们函数

248
00:13:49,170 --> 00:13:51,330
我们那个class函数的那个render函数

249
00:13:51,360 --> 00:13:51,900
并不是

250
00:13:52,290 --> 00:13:56,520
并不是你可以理解为它的作用就是把他电话组建渲染到页面上

251
00:13:56,520 --> 00:13:58,050
就是真正的渲染到DOM上了

252
00:13:58,760 --> 00:13:59,960
这个只是它的一个称呼

253
00:13:59,960 --> 00:14:01,910
有人称他render阶段

254
00:14:01,910 --> 00:14:03,020
也能称为commit阶段

255
00:14:03,020 --> 00:14:03,620
都可以

256
00:14:03,980 --> 00:14:04,400
都可以

257
00:14:04,400 --> 00:14:05,360
因为它既包含

258
00:14:05,390 --> 00:14:06,740
它主要包含两个部分

259
00:14:06,740 --> 00:14:07,790
一个叫做render root

260
00:14:07,880 --> 00:14:09,140
一个叫做commit root

261
00:14:09,320 --> 00:14:11,750
所以所以有的就这么称呼她

262
00:14:11,780 --> 00:14:13,610
反正大概就是这样

263
00:14:14,450 --> 00:14:17,240
今天我们就介绍协调器re consider

264
00:14:17,540 --> 00:14:18,470
它的主要作用

265
00:14:18,740 --> 00:14:21,800
我们还是用一句话就可以先说明它的主要作用是什么

266
00:14:22,220 --> 00:14:24,470
他负责构建February

267
00:14:24,680 --> 00:14:26,900
就是前面我们讲了一节课

268
00:14:26,930 --> 00:14:27,500
其实啊

269
00:14:27,500 --> 00:14:31,370
他还根本还没有走到构建Patrick的这么一个阶段儿

270
00:14:31,370 --> 00:14:32,630
我之前已经讲过

271
00:14:32,630 --> 00:14:35,360
就是在RA clip它是有一个

272
00:14:35,360 --> 00:14:36,560
相当于是有一个虚拟

273
00:14:36,620 --> 00:14:37,310
虚拟数的

274
00:14:37,310 --> 00:14:40,070
就是我们所通俗说的

275
00:14:40,070 --> 00:14:41,120
像那种微催账

276
00:14:41,150 --> 00:14:41,390
对吧

277
00:14:41,390 --> 00:14:43,040
VV当就是虚拟数

278
00:14:43,220 --> 00:14:44,630
就是虚拟down

279
00:14:45,020 --> 00:14:48,200
那么在record里

280
00:14:48,200 --> 00:14:52,910
F16之后的微创就指的就是February February了

281
00:14:53,240 --> 00:14:54,860
那么他在这个阶段

282
00:14:54,860 --> 00:14:55,340
Re consider

283
00:14:55,340 --> 00:14:56,810
他就负责构建fever tree

284
00:14:57,050 --> 00:14:57,560
然后呢

285
00:14:57,590 --> 00:14:59,390
把变化的组件给找出来

286
00:14:59,660 --> 00:15:02,510
然后把组件是什么变化给标记上

287
00:15:02,930 --> 00:15:03,950
这句话什么意思呢

288
00:15:04,280 --> 00:15:06,110
比如说比如我下面这个图

289
00:15:06,110 --> 00:15:07,580
我只有刺探变了

290
00:15:07,820 --> 00:15:08,060
对吧

291
00:15:08,060 --> 00:15:08,720
我们会有

292
00:15:09,020 --> 00:15:12,800
我在X这个阶段不仅要把这个数给构建好

293
00:15:12,800 --> 00:15:14,210
而且还要找到

294
00:15:14,560 --> 00:15:16,540
具体是哪个元素

295
00:15:16,870 --> 00:15:19,180
具体哪个组件哪个节点发生了变化

296
00:15:19,300 --> 00:15:19,990
然后呢

297
00:15:20,050 --> 00:15:21,400
他可能是被删掉它

298
00:15:21,400 --> 00:15:24,220
也可能是改了属性它也可能是增加了子节点

299
00:15:24,490 --> 00:15:27,550
那么这三种就分别是不同的处理逻辑

300
00:15:27,940 --> 00:15:28,720
那么在这里

301
00:15:28,840 --> 00:15:31,960
但是这三种处理逻辑都适合当操作有关的

302
00:15:32,260 --> 00:15:34,960
而不所以而在re consider这个阶段的话

303
00:15:35,020 --> 00:15:35,800
他还

304
00:15:36,260 --> 00:15:37,040
不会操作大

305
00:15:37,220 --> 00:15:40,100
因此他只能先给他打上一个标记

306
00:15:40,830 --> 00:15:43,710
标记他比如说标记假如他是个删除

307
00:15:43,740 --> 00:15:44,670
把这个数量给删了

308
00:15:44,820 --> 00:15:47,460
那么我就把他的一个叫做flex的字段

309
00:15:47,730 --> 00:15:50,640
把它设为删除设为删除

310
00:15:50,670 --> 00:15:53,550
然后到最后render阶段的时候

311
00:15:54,100 --> 00:15:54,730
在这个阶段

312
00:15:54,730 --> 00:15:56,020
我们只需要遍历

313
00:15:56,530 --> 00:15:59,050
所有的遍历所有更改的

314
00:15:59,770 --> 00:16:01,270
所以更改的翻版note了

315
00:16:02,050 --> 00:16:04,870
更改的word找到它的那个flex

316
00:16:05,050 --> 00:16:05,890
然后啊

317
00:16:05,890 --> 00:16:06,910
比如说flex删除

318
00:16:06,910 --> 00:16:08,800
那我们就直接执行删除的逻辑

319
00:16:08,830 --> 00:16:10,120
而不用再判断一次

320
00:16:10,630 --> 00:16:15,310
因此相当于不需现在在re consider这里面做的事情就很多

321
00:16:15,960 --> 00:16:16,320
就很多

322
00:16:16,320 --> 00:16:17,220
他之所以多的话

323
00:16:17,220 --> 00:16:24,390
实际实际上是本来把把正常流程后面render就是render阶段要干的事情先提前干干好了

324
00:16:24,600 --> 00:16:25,590
但干好了之后

325
00:16:25,770 --> 00:16:27,450
他只是先把他存在那儿

326
00:16:27,660 --> 00:16:28,410
后面在用

327
00:16:28,860 --> 00:16:30,450
所以他re consider这个阶段

328
00:16:30,600 --> 00:16:31,950
他要干的事情比较多

329
00:16:32,510 --> 00:16:33,320
要更新比较多

330
00:16:33,320 --> 00:16:34,790
我们可以

331
00:16:34,790 --> 00:16:36,800
因此它主要来说他就

332
00:16:37,500 --> 00:16:41,400
他就可以用一句话来解释复购件发票去找变化的组件

333
00:16:41,400 --> 00:16:42,390
标记组件的变化

334
00:16:42,840 --> 00:16:43,860
在这个阶段的话

335
00:16:45,240 --> 00:16:46,170
在这个阶段的话

336
00:16:46,200 --> 00:16:47,910
我们的

337
00:16:48,680 --> 00:16:49,130
我们的

338
00:16:49,250 --> 00:16:51,050
我们的那个生命周期

339
00:16:51,050 --> 00:16:52,010
是会执行一部分的

340
00:16:52,010 --> 00:16:53,690
会执行一部分的生命周期

341
00:16:53,870 --> 00:16:55,460
具体来说是执行render

342
00:16:55,460 --> 00:16:58,250
即render之前就render生命周期

343
00:16:58,250 --> 00:17:00,410
以及render之前的生命周期都会执行

344
00:17:00,770 --> 00:17:01,490
都会执行到

345
00:17:01,670 --> 00:17:03,740
而这个consider这个阶段

346
00:17:03,740 --> 00:17:04,280
由于

347
00:17:04,640 --> 00:17:05,120
由于他

348
00:17:05,120 --> 00:17:08,360
因为由于我们之前讲过react

349
00:17:08,820 --> 00:17:10,170
优先级高的会打洞

350
00:17:10,170 --> 00:17:10,860
优先级低的

351
00:17:10,890 --> 00:17:13,740
所以这个re cons or也会可能会反复执行

352
00:17:14,010 --> 00:17:15,060
可能会反复执行

353
00:17:15,570 --> 00:17:18,540
所以react它里边有一些生命周期

354
00:17:18,900 --> 00:17:21,330
被他给标上了一个UN safe

355
00:17:21,720 --> 00:17:26,520
就是因为可能他这个生命周期执行的次数会比以前更多

356
00:17:26,850 --> 00:17:27,510
会比以前更多

357
00:17:27,510 --> 00:17:28,650
所以加了个UN safe

358
00:17:29,130 --> 00:17:32,430
而像render之后的生命周期就没有S了

359
00:17:32,430 --> 00:17:37,020
因为后面就不会再就不会再那个反复的被打断了

360
00:17:37,290 --> 00:17:38,160
原因很简单

361
00:17:38,400 --> 00:17:41,730
因为render render过程其实最主要的是干什么

362
00:17:41,730 --> 00:17:42,630
最主要的是

363
00:17:43,600 --> 00:17:46,270
把那个变化的组件给渲染到页面上了

364
00:17:46,270 --> 00:17:47,650
这个时候要操作down了

365
00:17:47,950 --> 00:17:49,570
ER down是很昂贵的

366
00:17:49,750 --> 00:17:53,350
如果我在我本来已经要开始操作DOM的时候

367
00:17:53,530 --> 00:17:54,970
然后你还能把我给打断了

368
00:17:55,000 --> 00:17:56,560
就是优先机构还能把我打断了

369
00:17:56,710 --> 00:17:58,300
这其实是得不偿失的

370
00:17:58,540 --> 00:18:01,450
因为本来我只需要一次操作档

371
00:18:01,540 --> 00:18:03,940
然后就把它全部给渲染到页面上

372
00:18:04,240 --> 00:18:06,820
但是由于由于我这个优化

373
00:18:07,480 --> 00:18:09,610
如果我的优化就是这个高优先级达成的

374
00:18:09,610 --> 00:18:11,620
优先级的这个优化反而让

375
00:18:12,570 --> 00:18:15,030
让那个操作当也变成多次的话

376
00:18:15,300 --> 00:18:17,490
那么我们的一次操作就变成了多次

377
00:18:17,490 --> 00:18:19,260
操作上而操作但又非常的昂贵

378
00:18:19,770 --> 00:18:23,370
所以昂贵的意思就是他耗时比较耗时比较久嘛

379
00:18:23,400 --> 00:18:24,390
我们一个DOM节点

380
00:18:24,600 --> 00:18:25,170
大家可以看

381
00:18:25,170 --> 00:18:26,220
比如一个div节点

382
00:18:26,220 --> 00:18:27,420
它有N多的属性

383
00:18:27,510 --> 00:18:28,470
属性超级多

384
00:18:28,830 --> 00:18:29,700
属性超级多

385
00:18:30,060 --> 00:18:31,080
这么多的属性

386
00:18:31,530 --> 00:18:32,370
如果您

387
00:18:32,850 --> 00:18:34,920
还多次的进行调动

388
00:18:34,920 --> 00:18:35,730
调动的话

389
00:18:36,810 --> 00:18:38,070
很多次进行调研的话

390
00:18:38,580 --> 00:18:41,640
那么它的性能肯定会比以前更差

391
00:18:41,670 --> 00:18:43,080
就变成了一个负向的优化

392
00:18:43,790 --> 00:18:45,320
所以他的逻辑

393
00:18:45,350 --> 00:18:48,200
那么他就只能允许你的re consider就是自然

394
00:18:49,340 --> 00:18:51,290
坐着这一件事情的过程当中

395
00:18:51,290 --> 00:18:51,980
允许被搭讪

396
00:18:52,010 --> 00:18:53,180
后面的就不允许了

397
00:18:53,630 --> 00:18:54,260
就不允许

398
00:18:55,640 --> 00:18:59,660
我们来看一下它的就是大概他是这么

399
00:19:00,240 --> 00:19:01,170
做这样一件事情

400
00:19:01,230 --> 00:19:05,070
但是具体做了他其实做了蛮多事情的

401
00:19:05,070 --> 00:19:06,450
我们可以一起来看一下

402
00:19:06,840 --> 00:19:08,160
首先我们来看一下

403
00:19:08,160 --> 00:19:13,950
我们直接来看一下一个已经构建好的一个faculty长的样子还是之前那副图

404
00:19:15,120 --> 00:19:17,130
还是之前那个做咱们这样

405
00:19:17,880 --> 00:19:20,760
每一次rag发生一次更新的时候

406
00:19:20,880 --> 00:19:21,960
比如像write down

407
00:19:22,590 --> 00:19:22,800
典

408
00:19:22,800 --> 00:19:24,210
Render或者sit EST

409
00:19:24,570 --> 00:19:25,320
它都会从

410
00:19:25,990 --> 00:19:28,210
February开始从上往下便利

411
00:19:28,240 --> 00:19:30,010
就是一开始他只只有一个节点

412
00:19:30,370 --> 00:19:31,390
从上往下遍历

413
00:19:31,390 --> 00:19:32,800
逐一找到变化的节点

414
00:19:33,220 --> 00:19:35,950
然后构成一个完整的entry

415
00:19:35,950 --> 00:19:36,340
如果

416
00:19:36,340 --> 00:19:37,720
如果之前没有

417
00:19:37,780 --> 00:19:39,250
如果没有变

418
00:19:39,310 --> 00:19:40,930
就是如果之前从来没有生成过

419
00:19:40,930 --> 00:19:42,550
那他就逐一生成节点

420
00:19:43,000 --> 00:19:43,420
然后呢

421
00:19:43,420 --> 00:19:44,650
构成一个完整的发票退

422
00:19:45,010 --> 00:19:46,570
而在rock的内部

423
00:19:46,810 --> 00:19:49,180
他有可能会同时存在两个发票

424
00:19:49,720 --> 00:19:51,130
同时存在两颗发布会

425
00:19:52,230 --> 00:19:56,400
这就是要用到我们上节课所讲到的那个范儿

426
00:19:56,400 --> 00:19:57,540
Note的一个属性

427
00:19:57,720 --> 00:19:59,550
我们可以回顾一下

428
00:19:59,550 --> 00:20:02,940
回顾一下这个就是反而我们的每一个filed

429
00:20:03,360 --> 00:20:04,560
每一个filed我们讲了

430
00:20:04,560 --> 00:20:08,190
他也retired child spring这些节点来构成February

431
00:20:08,340 --> 00:20:10,380
但他实际上和发包

432
00:20:10,970 --> 00:20:12,620
连接有关的还有另外一个属性

433
00:20:12,620 --> 00:20:13,610
叫做outlet

434
00:20:14,030 --> 00:20:17,840
这个outlet它是指向上一次构建的镜像

435
00:20:18,290 --> 00:20:19,070
三四个渐渐

436
00:20:19,070 --> 00:20:19,640
什么意思呢

437
00:20:19,910 --> 00:20:20,360
我们来

438
00:20:21,630 --> 00:20:23,970
我们来看一下上一次构建镜像

439
00:20:24,150 --> 00:20:24,660
比如说

440
00:20:25,870 --> 00:20:27,460
第一次就是我从来没有的

441
00:20:27,460 --> 00:20:29,230
从来没有过见过FAB的时候

442
00:20:29,230 --> 00:20:33,040
那么它有一个feb ru na的这个就是FAB root吗

443
00:20:33,100 --> 00:20:34,150
FAB的一个节点

444
00:20:34,510 --> 00:20:35,830
然后他一个current

445
00:20:36,340 --> 00:20:38,140
指向的是我们的root

446
00:20:38,140 --> 00:20:39,970
然后APP0

447
00:20:39,970 --> 00:20:41,080
这就是一开始

448
00:20:41,500 --> 00:20:43,030
但我们只是write down

449
00:20:43,600 --> 00:20:44,950
Crack down的时候

450
00:20:46,440 --> 00:20:47,670
我画一个图

451
00:20:47,670 --> 00:20:48,660
画一个草图

452
00:20:54,560 --> 00:20:56,900
就是一开始热点render的时候

453
00:20:58,630 --> 00:21:01,180
那么在整个内存当中

454
00:21:01,450 --> 00:21:03,190
它所存在的数就是这样的一个

455
00:21:03,760 --> 00:21:04,660
就是这样的一个数

456
00:21:07,180 --> 00:21:07,630
嗯

457
00:21:11,430 --> 00:21:12,510
就这样一个假如

458
00:21:12,630 --> 00:21:13,170
假如啊

459
00:21:13,200 --> 00:21:14,610
整个内存当中这个是root

460
00:21:15,060 --> 00:21:16,800
这个root not那么

461
00:21:17,550 --> 00:21:18,990
他一个carry的数

462
00:21:19,020 --> 00:21:19,950
一个CAD的字段

463
00:21:19,950 --> 00:21:20,640
它就直线了

464
00:21:20,820 --> 00:21:21,330
这样一个

465
00:21:21,600 --> 00:21:23,820
当这个税构成构建完成了之后

466
00:21:24,800 --> 00:21:27,260
那么我们的页面也就终于渲染出东西了

467
00:21:27,930 --> 00:21:28,170
对吧

468
00:21:28,170 --> 00:21:31,230
因为它我们的这个内部的REC的内部的

469
00:21:31,380 --> 00:21:33,000
因为它是数据驱动视图吗

470
00:21:33,300 --> 00:21:35,430
我们的内部的是什么样子

471
00:21:35,670 --> 00:21:38,910
他最后映射到页面上就会是一个什么样子

472
00:21:39,500 --> 00:21:41,630
当这个QQ的完全建立好之后

473
00:21:42,570 --> 00:21:43,920
然后再把它下载到页面上

474
00:21:43,920 --> 00:21:45,240
那么我们的页面就有东西了

475
00:21:45,570 --> 00:21:46,620
那么第二次进行C的

476
00:21:46,620 --> 00:21:47,310
C的之后

477
00:21:47,550 --> 00:21:51,570
同学们第二次进CF之后

478
00:21:51,570 --> 00:21:53,160
他这现在这个情况

479
00:21:53,160 --> 00:21:54,480
他们的每一个的outlet

480
00:21:54,690 --> 00:21:56,040
因为没有上一次的镜像吗

481
00:21:56,040 --> 00:21:58,560
没有他的每一个节点的outlet

482
00:21:58,560 --> 00:21:59,460
它都是什么呢

483
00:21:59,460 --> 00:22:00,840
都是那肯定都是那

484
00:22:01,340 --> 00:22:06,920
因为这里头它的学名就是她的意思就是指向上一次的相同的那个节点

485
00:22:07,650 --> 00:22:08,910
先就是我第一次

486
00:22:08,970 --> 00:22:10,200
那么他肯定是就是

487
00:22:10,200 --> 00:22:11,820
那假如第二次构建的时候

488
00:22:11,820 --> 00:22:12,330
什么是构建

489
00:22:12,330 --> 00:22:14,040
比如选C的CTE

490
00:22:14,550 --> 00:22:16,680
则C的他又会从头开始

491
00:22:17,130 --> 00:22:17,910
就从头开始

492
00:22:17,910 --> 00:22:19,230
比如这里有一个root

493
00:22:19,620 --> 00:22:21,720
但是他的outlet属性它就有

494
00:22:21,720 --> 00:22:22,860
它就会直线上一次的

495
00:22:23,580 --> 00:22:24,510
就这样一次的

496
00:22:25,180 --> 00:22:25,720
然后呢

497
00:22:26,020 --> 00:22:27,100
他的每一个

498
00:22:27,890 --> 00:22:30,740
每一个结点它都会有一个out的属性

499
00:22:30,860 --> 00:22:33,830
而每一个out的属性它都会对应上一次

500
00:22:34,700 --> 00:22:38,150
上一次相同位置的那样的一个节点

501
00:22:38,150 --> 00:22:39,590
它都是属于对应的关系

502
00:22:40,160 --> 00:22:43,400
因此就就如同这幅图所示

503
00:22:44,280 --> 00:22:45,420
在第二次的时候

504
00:22:45,780 --> 00:22:46,500
这是第一次

505
00:22:46,980 --> 00:22:48,450
第一次构建好了就构建好

506
00:22:48,450 --> 00:22:50,640
这个比较简单然后呢

507
00:22:51,220 --> 00:22:53,200
第二次有的时候那么

508
00:22:54,520 --> 00:22:58,390
那么他的重新重新生成了一个新的发票退

509
00:22:59,020 --> 00:23:04,450
那么在内部就把它称之为叫做working progress working progress tree

510
00:23:04,570 --> 00:23:07,930
而这个working progress tree字面意思怎么样呢

511
00:23:07,930 --> 00:23:11,230
字面意思就是我要先新建一个新的APP

512
00:23:11,230 --> 00:23:11,590
对不对

513
00:23:11,650 --> 00:23:12,670
新建一个新的Patrick

514
00:23:12,880 --> 00:23:13,990
而现在页面上

515
00:23:14,860 --> 00:23:16,390
由于我们的这个

516
00:23:16,390 --> 00:23:17,170
在这幅图中

517
00:23:17,200 --> 00:23:18,580
由于我们的filed

518
00:23:18,730 --> 00:23:20,590
他的carry还指向先前那一个

519
00:23:20,800 --> 00:23:24,040
所以我们页面上现在还没有做任何的改变

520
00:23:24,550 --> 00:23:25,660
还没有做任何的改变

521
00:23:25,810 --> 00:23:27,070
那什么时候会改变呢

522
00:23:27,280 --> 00:23:28,180
就是当他这个

523
00:23:28,820 --> 00:23:31,970
当你的心的发票去完全构建成功之后呢

524
00:23:31,970 --> 00:23:35,780
它的它就会把这个care这个字段指向新的Patrick

525
00:23:35,780 --> 00:23:37,850
就是指向新的working progress tree

526
00:23:38,090 --> 00:23:41,810
就相当于一个什么备胎转正的一个感觉

527
00:23:42,230 --> 00:23:43,700
我构建了一个新的

528
00:23:44,400 --> 00:23:45,300
新了之后

529
00:23:45,300 --> 00:23:45,570
他

530
00:23:45,660 --> 00:23:47,040
他叫working progress tree

531
00:23:47,280 --> 00:23:50,100
然后我就把我的feb ru Donald

532
00:23:50,780 --> 00:23:53,570
The current字段指向了新的working progress tree

533
00:23:54,680 --> 00:24:01,010
然后我的新的work in progress是不是就变成了他就变成了carry了耳

534
00:24:01,010 --> 00:24:03,230
旧的这个相当于就不要了

535
00:24:03,440 --> 00:24:04,280
自动就不要了

536
00:24:04,580 --> 00:24:05,690
而如果也有新的

537
00:24:06,110 --> 00:24:06,620
假如

538
00:24:06,620 --> 00:24:07,460
假如在这里

539
00:24:13,200 --> 00:24:15,090
假如这假如有了的

540
00:24:15,300 --> 00:24:17,100
我又发现了另一次新的更新

541
00:24:17,100 --> 00:24:17,430
对吧

542
00:24:17,760 --> 00:24:19,290
假如发起一次更新的更新

543
00:24:19,530 --> 00:24:21,060
那么对他来说

544
00:24:21,830 --> 00:24:24,350
他的上一次的character就是他

545
00:24:24,530 --> 00:24:25,940
而他又是一个新的

546
00:24:26,880 --> 00:24:30,210
又是一个新的working progress tree组件的又构建

547
00:24:30,270 --> 00:24:31,440
等他构建好了之后

548
00:24:32,250 --> 00:24:33,030
构建好了之后

549
00:24:33,630 --> 00:24:34,170
然后呢

550
00:24:34,470 --> 00:24:35,850
他的carry a又在直线打

551
00:24:36,360 --> 00:24:37,050
在之前打

552
00:24:37,200 --> 00:24:37,770
让他老了

553
00:24:37,770 --> 00:24:38,910
然后又给丢弃了

554
00:24:39,650 --> 00:24:40,280
又给丢弃了

555
00:24:40,610 --> 00:24:41,570
是这么一个过程

556
00:24:41,930 --> 00:24:44,420
而他的奥特利的属性是之前上一个

557
00:24:45,640 --> 00:24:46,570
可以直接上一个

558
00:24:48,230 --> 00:24:49,010
上一个吧

559
00:24:50,100 --> 00:24:51,360
相互只只只只

560
00:24:52,260 --> 00:24:53,520
这样有个什么好处呢

561
00:24:53,790 --> 00:24:55,590
这样一个最大的一个好处是

562
00:24:56,430 --> 00:24:56,640
对

563
00:24:56,670 --> 00:24:57,000
是的

564
00:24:57,270 --> 00:25:00,090
始终保持的是上一次的forever nod

565
00:25:03,310 --> 00:25:05,530
他虽然他是一个working book ST

566
00:25:05,530 --> 00:25:08,230
但是它实际上节点与节点之间是相互指的

567
00:25:08,620 --> 00:25:09,610
相互的并不是

568
00:25:09,910 --> 00:25:11,440
并不是说只有在跟

569
00:25:11,620 --> 00:25:12,310
就是范儿

570
00:25:12,310 --> 00:25:13,990
Roots roots favor

571
00:25:13,990 --> 00:25:15,850
这一个节点指向他的outlet

572
00:25:15,850 --> 00:25:17,050
指向上一上一个

573
00:25:17,290 --> 00:25:18,220
这样的好处

574
00:25:18,400 --> 00:25:19,510
好处是显而易见的

575
00:25:20,020 --> 00:25:22,480
就是非常的方便对比

576
00:25:22,600 --> 00:25:25,600
比如说我我我一个非常就是深的一个节点

577
00:25:25,750 --> 00:25:26,080
对吧

578
00:25:26,440 --> 00:25:27,550
非常深的一个节点

579
00:25:28,320 --> 00:25:29,160
我这个节点

580
00:25:29,870 --> 00:25:30,410
就是他吧

581
00:25:30,500 --> 00:25:31,490
非常深的一个节点

582
00:25:31,490 --> 00:25:32,060
他很深

583
00:25:32,480 --> 00:25:33,650
那么啊

584
00:25:33,710 --> 00:25:35,690
他只需要他的一个out的属性

585
00:25:36,520 --> 00:25:37,060
就可以

586
00:25:37,210 --> 00:25:38,380
只要通过他奥特的属性

587
00:25:38,380 --> 00:25:42,430
就可以立刻拿到他上一他上一次的那个老的节点

588
00:25:43,490 --> 00:25:44,600
上次那个老师几点

589
00:25:45,280 --> 00:25:46,090
就可以立刻拿到它

590
00:25:46,860 --> 00:25:48,300
对于新的来说

591
00:25:48,420 --> 00:25:50,070
大家看这里是相互指的

592
00:25:50,280 --> 00:25:52,290
新的那就是旧的

593
00:25:52,320 --> 00:25:53,640
他的out是指向新的

594
00:25:53,640 --> 00:25:55,020
新的out是之前旧的

595
00:25:55,020 --> 00:25:56,280
它有一个复制的过程

596
00:25:56,520 --> 00:25:57,540
为什么这样做呢

597
00:25:57,690 --> 00:25:58,440
因为有的时候

598
00:25:58,440 --> 00:26:00,150
因为在那个当dif的时候

599
00:26:00,360 --> 00:26:01,650
他有的时候

600
00:26:01,650 --> 00:26:04,440
他要用旧的来做主题来比较

601
00:26:04,440 --> 00:26:06,690
有的会用旧的来做主题进行比较

602
00:26:06,690 --> 00:26:08,730
有的时候会用新的主题来进行比较

603
00:26:08,880 --> 00:26:10,230
所以他两个

604
00:26:10,320 --> 00:26:12,330
所以他在进行纸箱的时候

605
00:26:12,420 --> 00:26:14,610
他干脆给他进行一个相互的指

606
00:26:14,640 --> 00:26:15,420
他们都可以

607
00:26:16,030 --> 00:26:18,100
拿到对方如果没有的话

608
00:26:18,100 --> 00:26:18,640
那就没有

609
00:26:19,460 --> 00:26:19,970
是这样

610
00:26:22,460 --> 00:26:24,050
那为什么是双缓存结构呢

611
00:26:24,050 --> 00:26:27,080
这就是内部REC的内部的一个双缓存结构

612
00:26:27,350 --> 00:26:29,570
所以双缓存结构就是有有两个数

613
00:26:29,660 --> 00:26:30,950
大家记住有两个队

614
00:26:31,400 --> 00:26:32,990
两个队一个叫做current

615
00:26:33,320 --> 00:26:37,880
这个current她永远永远和咱们屏幕上显示的内容是对应的

616
00:26:38,120 --> 00:26:40,820
它是咱屏幕上显示的内容的一次真正的映射

617
00:26:41,090 --> 00:26:41,600
比如我

618
00:26:41,960 --> 00:26:43,610
比如我就算发起了一次CS的

619
00:26:43,910 --> 00:26:46,220
那么在屏幕变化之前

620
00:26:46,220 --> 00:26:47,870
那么他的carry就还是老

621
00:26:47,930 --> 00:26:48,920
还是老的那一个

622
00:26:50,910 --> 00:26:53,550
而working progress that re work in progress the

623
00:26:53,550 --> 00:26:54,120
它就是

624
00:26:54,980 --> 00:26:59,120
要创建一个就是我们我们要更新的新的一个February

625
00:26:59,850 --> 00:27:00,720
新的一个开发区

626
00:27:01,080 --> 00:27:02,910
他们都是通过Outlook的属性连接

627
00:27:03,120 --> 00:27:05,820
而他的优点就是可以

628
00:27:06,440 --> 00:27:10,310
可以快速的拿到之前的节点进行对比进行复用

629
00:27:10,310 --> 00:27:11,510
甚至直接可以进行服用

630
00:27:11,540 --> 00:27:13,400
如果那个节点他对比了一下

631
00:27:13,400 --> 00:27:14,000
发现

632
00:27:14,360 --> 00:27:15,320
我没有任何的变化

633
00:27:15,620 --> 00:27:17,510
那么我就直接复用了这个

634
00:27:18,080 --> 00:27:21,140
所以这个是为了一个是为了找起来快

635
00:27:21,200 --> 00:27:22,220
第二个是为了服用

636
00:27:22,610 --> 00:27:26,630
第二个是为了服用对于性能的提升还是非常有帮助的

637
00:27:27,140 --> 00:27:29,450
而类似这种在函数里边儿

638
00:27:30,570 --> 00:27:31,710
在介词里面

639
00:27:32,300 --> 00:27:34,100
类似这种刷卡的结构还有很多

640
00:27:34,280 --> 00:27:34,820
还有很多

641
00:27:34,850 --> 00:27:35,600
如果大家

642
00:27:36,260 --> 00:27:38,720
有看过那个careless careless

643
00:27:40,460 --> 00:27:43,220
careless就是canvas里面一个非常重要的一个优化

644
00:27:43,220 --> 00:27:44,630
叫做礼品凯尔斯

645
00:27:44,990 --> 00:27:46,010
这是礼品

646
00:27:47,120 --> 00:27:47,750
凯尔斯

647
00:27:48,740 --> 00:27:50,840
我一看到这个working progress的时候

648
00:27:50,840 --> 00:27:52,430
就立刻想到了这个礼品卡

649
00:27:52,970 --> 00:27:54,020
它就是差不多

650
00:27:54,620 --> 00:27:55,910
他其实差不多就是在

651
00:27:56,840 --> 00:28:00,200
礼品开发商渲染相似的图形和重复的图像

652
00:28:00,820 --> 00:28:01,330
如果

653
00:28:01,940 --> 00:28:04,460
自己在动画帧的重复一些相同的会操作

654
00:28:04,700 --> 00:28:06,440
可以把它放在礼品卡时尚

655
00:28:08,170 --> 00:28:08,710
大家下来

656
00:28:08,710 --> 00:28:11,020
如果以后有那个喝canvas相关的

657
00:28:11,020 --> 00:28:12,400
这个我就不多讲了

658
00:28:12,850 --> 00:28:15,010
如果和callous有关的觉得很慢

659
00:28:15,250 --> 00:28:17,500
你可以考虑用一下礼品careless

660
00:28:17,830 --> 00:28:20,290
它有一个叫做off screen

661
00:28:20,350 --> 00:28:22,000
以前是直接相当于用一个

662
00:28:22,790 --> 00:28:24,950
最早的时候叫做礼品careless

663
00:28:24,950 --> 00:28:27,710
是你是创建一个看不见的careless

664
00:28:27,950 --> 00:28:29,030
然后呢把它来做

665
00:28:29,060 --> 00:28:34,940
那现在其实就直接就有一个叫做off off screen canvas这么一个方法可以拿来用

666
00:28:35,420 --> 00:28:39,290
这也是对于carry来说一个非常重要的一个优化点

667
00:28:40,320 --> 00:28:44,100
ER RA tic实际上它内部相当于就实现了一个礼品的

668
00:28:44,810 --> 00:28:45,800
你另外一个数

669
00:28:45,830 --> 00:28:46,400
所以叫做

670
00:28:46,490 --> 00:28:47,990
这就是它的上层结构

671
00:28:48,700 --> 00:28:51,940
是非常就是是整个

672
00:28:52,810 --> 00:28:53,470
嗯

673
00:28:54,270 --> 00:28:55,320
整个就是开发使上

674
00:28:55,320 --> 00:28:56,940
反正是一个比较重要的一个优化

675
00:28:56,940 --> 00:28:57,900
一个优化的东西

676
00:28:58,560 --> 00:28:59,790
它这个还是挺有作用的

677
00:28:59,850 --> 00:29:00,540
挺重要的

678
00:29:00,810 --> 00:29:01,980
这块能听明白吗

679
00:29:02,310 --> 00:29:03,840
能听明白的可以各一

680
00:29:04,480 --> 00:29:06,010
不能拼爹听明白的扣个呢

681
00:29:16,100 --> 00:29:17,360
好滴行

682
00:29:17,390 --> 00:29:18,530
为什么双方的结构

683
00:29:18,530 --> 00:29:19,670
这个也给大家讲到了

684
00:29:19,670 --> 00:29:21,680
就是可以很快的找到

685
00:29:21,770 --> 00:29:22,130
对吧

686
00:29:22,550 --> 00:29:23,540
可以直接服用

687
00:29:23,900 --> 00:29:25,610
然后更新完成之后

688
00:29:25,610 --> 00:29:28,760
我们的current会指向working progress root完成federal trade

689
00:29:28,760 --> 00:29:31,160
这个平行OB就变成新的February

690
00:29:31,490 --> 00:29:34,700
这个我们到时候看那个代码分析的时候

691
00:29:34,700 --> 00:29:37,670
我会给大家讲到它这个更新完毕

692
00:29:37,730 --> 00:29:42,650
它实际上是在那个component的mount那个差不多那个阶段的时候

693
00:29:42,680 --> 00:29:43,520
他才会重新制

694
00:29:44,610 --> 00:29:46,890
每次C都会从底部重新开始遍历吗

695
00:29:46,890 --> 00:29:47,250
是的

696
00:29:47,700 --> 00:29:49,920
这就是react

697
00:29:50,130 --> 00:29:52,230
我个人觉得他其实没有那么智能

698
00:29:52,410 --> 00:29:53,070
他没那么智能

699
00:29:53,070 --> 00:29:57,300
他每他每一次他都要从根组件开始重新建立

700
00:29:57,900 --> 00:29:58,560
重新便利

701
00:29:59,010 --> 00:30:00,630
而不像那个VIVO

702
00:30:00,630 --> 00:30:03,480
它是它的那个依赖收集

703
00:30:03,780 --> 00:30:05,790
其实可以做到效率更高

704
00:30:06,530 --> 00:30:07,880
VIVO的那个依赖设计

705
00:30:07,880 --> 00:30:09,470
其实效率会比这个更高

706
00:30:09,620 --> 00:30:11,480
但是他们的发展方向不太一样

707
00:30:11,960 --> 00:30:12,770
发展方向不太一样

708
00:30:12,980 --> 00:30:14,900
所以react他后面他的

709
00:30:15,500 --> 00:30:18,920
更新迭代你就会发现它全部都点到哪里去了

710
00:30:19,370 --> 00:30:24,110
他的逻辑全部都把它的优化方向主要是进行运行时的进行

711
00:30:24,770 --> 00:30:26,870
主要是进行运行时的优化

712
00:30:27,520 --> 00:30:29,380
就是运行的过程当中进行优化

713
00:30:30,470 --> 00:30:34,520
React因为react他也他也有运气这句话

714
00:30:34,580 --> 00:30:35,750
然后它有一部分呢

715
00:30:35,750 --> 00:30:36,680
是放在编译前

716
00:30:36,680 --> 00:30:38,690
就是因为它它的那个MP的

717
00:30:39,790 --> 00:30:40,660
V1的MP的

718
00:30:40,900 --> 00:30:42,760
他有的是静态的

719
00:30:43,300 --> 00:30:43,780
那么

720
00:30:44,480 --> 00:30:47,660
她在编译阶段就会做一些编译方面的优化

721
00:30:48,590 --> 00:30:52,220
所以react和Vue他们现在其实从内部的代码角度上来讲

722
00:30:52,430 --> 00:30:54,560
他们的发展方向的话已经不太一样

723
00:30:54,770 --> 00:30:55,310
不太一样

724
00:30:56,050 --> 00:30:57,880
React现在就是运行

725
00:30:57,880 --> 00:30:59,140
是运行时的巅峰

726
00:30:59,170 --> 00:31:00,820
比如说像什么双缓冲结构

727
00:31:00,820 --> 00:31:01,390
之前还有

728
00:31:01,750 --> 00:31:03,880
之前还有那个

729
00:31:04,180 --> 00:31:07,180
之前还有那个request idle call back等等

730
00:31:07,450 --> 00:31:09,220
他们主要是在运行的过程当中

731
00:31:09,220 --> 00:31:10,450
他想办法让你更快

732
00:31:10,900 --> 00:31:11,380
可以更快

733
00:31:11,410 --> 00:31:13,120
但是由于它设计上的

734
00:31:13,180 --> 00:31:14,230
你可以说设计上的

735
00:31:14,230 --> 00:31:15,700
他每次都从底部重新开始

736
00:31:16,860 --> 00:31:18,720
那么这个其实就保证不了

737
00:31:18,720 --> 00:31:20,910
他可能就真的没有没有那么快

738
00:31:21,330 --> 00:31:23,070
但是她也有自己的优势

739
00:31:23,400 --> 00:31:24,360
就是在运行时

740
00:31:24,660 --> 00:31:26,010
他就是他就是非常快的

741
00:31:26,730 --> 00:31:27,420
他就非常快

742
00:31:29,300 --> 00:31:29,690
对

743
00:31:29,840 --> 00:31:30,410
那么

744
00:31:31,700 --> 00:31:32,240
Correct

745
00:31:34,200 --> 00:31:34,830
那就这样

746
00:31:34,830 --> 00:31:39,690
所以所以他的这这这点我其实之前也不太能理解

747
00:31:39,690 --> 00:31:40,440
也不太能理解

748
00:31:40,740 --> 00:31:41,250
但是呢

749
00:31:41,730 --> 00:31:43,110
但是他确实很有用

750
00:31:43,170 --> 00:31:45,180
后面我会讲到它这个re consider啊

751
00:31:46,030 --> 00:31:50,500
他这个re consider其实不光不光react可以使用它

752
00:31:50,500 --> 00:31:51,550
可以把它单拎出来

753
00:31:51,850 --> 00:31:53,440
然后你在其他地方也可以用

754
00:31:53,770 --> 00:31:54,370
也可以用

755
00:31:54,730 --> 00:31:55,780
比如说像什么呢

756
00:31:55,810 --> 00:31:57,490
比如像什么Tara

757
00:31:57,490 --> 00:31:58,240
大家听过吧

758
00:31:58,240 --> 00:31:58,690
Tara

759
00:31:59,690 --> 00:32:02,270
就是用rap来写小程序

760
00:32:02,390 --> 00:32:03,650
用right来写小程序

761
00:32:05,480 --> 00:32:06,980
Tara用rap的一些小程序

762
00:32:07,100 --> 00:32:08,690
它里边其实

763
00:32:09,380 --> 00:32:12,680
它里边其实就是把这个re consider单独剥离出来

764
00:32:12,710 --> 00:32:14,390
单独剥离出来直接就拿来用了

765
00:32:15,020 --> 00:32:15,530
不然呢

766
00:32:16,070 --> 00:32:17,840
然后这里边所做的所有的优化

767
00:32:17,840 --> 00:32:19,370
它都可以移植到他的框架里

768
00:32:20,290 --> 00:32:22,090
他都可以移植到他的框架里

769
00:32:22,510 --> 00:32:23,650
那么相当于

770
00:32:24,260 --> 00:32:25,070
Rap的部分

771
00:32:25,070 --> 00:32:26,780
这一部分运行时优化的能力

772
00:32:26,810 --> 00:32:29,210
他就直接他就直接使用上了

773
00:32:29,300 --> 00:32:32,000
呆会儿接下来我给大家给大家提一嘴

774
00:32:32,030 --> 00:32:34,730
给大家提一嘴这块儿就是他的优势

775
00:32:35,530 --> 00:32:37,120
它的优势来看

776
00:32:37,120 --> 00:32:38,710
那接下来我们来看一下那个

777
00:32:39,360 --> 00:32:41,820
构建fair trade这么一个整个过程了

778
00:32:42,630 --> 00:32:43,170
比如说

779
00:32:43,820 --> 00:32:45,920
比如说我这里render的时候

780
00:32:45,920 --> 00:32:47,120
我弄了一个简单的

781
00:32:47,120 --> 00:32:48,200
就这个的

782
00:32:48,200 --> 00:32:49,250
我们一般都这么写吗

783
00:32:49,250 --> 00:32:49,610
对不对

784
00:32:49,790 --> 00:32:51,530
但是你也可以写的很复杂的字

785
00:32:51,530 --> 00:32:52,340
弄的比较简单

786
00:32:52,990 --> 00:32:55,480
那么在构建发票催的时候

787
00:32:55,780 --> 00:32:56,530
他会从

788
00:32:57,220 --> 00:32:58,120
Render road sync

789
00:32:58,120 --> 00:33:00,310
大致是从render think还是开始

790
00:33:00,980 --> 00:33:02,870
从优先级最高的root开始的贵

791
00:33:04,460 --> 00:33:07,760
优先级最高的三个肉的开始地位就是从头开始往下走

792
00:33:08,000 --> 00:33:08,930
从头开始往下走

793
00:33:09,410 --> 00:33:12,560
那么这我们可以就这种代码我是重点分析的

794
00:33:12,800 --> 00:33:16,070
大家先看我打了黄色标记的这几行代码

795
00:33:16,620 --> 00:33:18,030
先给我打了黄色标记的讲

796
00:33:18,030 --> 00:33:18,570
这讲代码

797
00:33:19,080 --> 00:33:21,240
第一个首先是一个函数

798
00:33:21,630 --> 00:33:23,550
这个函数里是一个递归

799
00:33:23,580 --> 00:33:23,910
对不对

800
00:33:23,910 --> 00:33:24,420
是一个递归

801
00:33:24,420 --> 00:33:27,540
这个while while里有一个字段叫做working progress

802
00:33:27,690 --> 00:33:28,980
这个先给大家

803
00:33:30,840 --> 00:33:32,670
这个working progress节点

804
00:33:32,670 --> 00:33:34,140
我们刚才给大家已经说过了

805
00:33:34,140 --> 00:33:35,700
什么事working progress节点

806
00:33:36,060 --> 00:33:43,590
这个working progress or working progress working progress fiber刚给大家介绍这个呢

807
00:33:43,680 --> 00:33:45,570
它指的是working progress节点

808
00:33:47,440 --> 00:33:48,280
他指的是

809
00:33:52,830 --> 00:33:54,000
Working progress

810
00:33:56,490 --> 00:33:57,090
几点

811
00:33:58,610 --> 00:33:58,940
姐姐

812
00:33:58,940 --> 00:34:00,590
她什么意思呢

813
00:34:02,600 --> 00:34:03,440
他表示

814
00:34:05,550 --> 00:34:06,990
当前正在

815
00:34:08,010 --> 00:34:09,690
构建的哪一个

816
00:34:13,570 --> 00:34:15,910
Favor他只是当前正在构建的ever

817
00:34:15,910 --> 00:34:16,690
它是会变的

818
00:34:17,050 --> 00:34:17,800
它是会变的

819
00:34:18,880 --> 00:34:20,500
因此这儿有一个这个Y

820
00:34:20,500 --> 00:34:23,770
这它它不是只属于这个函数类的

821
00:34:23,800 --> 00:34:25,840
所以它相对于这个函数来讲

822
00:34:26,230 --> 00:34:26,920
它是全区的

823
00:34:27,310 --> 00:34:27,880
它是全局的

824
00:34:27,880 --> 00:34:30,400
几个他几个那个函数可以共用

825
00:34:30,400 --> 00:34:32,470
他实际上是在那个文件里的一个B包

826
00:34:33,020 --> 00:34:33,440
因此

827
00:34:34,250 --> 00:34:36,680
当这段话的意思就很简单了

828
00:34:36,680 --> 00:34:38,480
当working process不等于浪的时候

829
00:34:38,750 --> 00:34:40,880
那么就一直掉problem上teamwork

830
00:34:42,220 --> 00:34:44,230
而在performance until work里

831
00:34:44,260 --> 00:34:45,490
我们的working progress

832
00:34:45,490 --> 00:34:46,990
它的指向会发生变化

833
00:34:47,110 --> 00:34:48,610
这个我们下来马上会讲到

834
00:34:49,090 --> 00:34:51,580
这个performance until work就在这里

835
00:34:52,180 --> 00:34:53,200
然后这里对吧

836
00:34:53,260 --> 00:34:54,370
我们用到了outlet

837
00:34:54,850 --> 00:34:57,850
因为这个until work它实际上就指的是working progress吗

838
00:34:58,180 --> 00:35:03,490
Check out let是不是指向我们的current current current就是当前页面上

839
00:35:03,520 --> 00:35:09,310
就是当前页面上页面所对应的那个LV的其中的一个节点

840
00:35:09,790 --> 00:35:10,600
就是那个节点

841
00:35:10,840 --> 00:35:11,590
凯特找到了

842
00:35:11,590 --> 00:35:12,550
他可能会用到它

843
00:35:13,790 --> 00:35:14,540
可能会用到它

844
00:35:14,870 --> 00:35:17,120
然后在这里它会做什么呢

845
00:35:17,420 --> 00:35:18,770
首先掉了两方法

846
00:35:18,770 --> 00:35:20,150
其实它主要就是调了两个方法

847
00:35:20,570 --> 00:35:21,740
一个叫做begin work

848
00:35:22,070 --> 00:35:25,820
另外一个叫做completed on tear of work这两个方法

849
00:35:26,790 --> 00:35:29,130
而在我先他这里面做了很多事情

850
00:35:29,130 --> 00:35:29,580
我先

851
00:35:30,330 --> 00:35:31,350
大致的告诉大家

852
00:35:31,650 --> 00:35:35,190
他这实际上返回的这个next指向的是她的俏的

853
00:35:35,860 --> 00:35:37,720
待会我们会详细的详细的讲

854
00:35:37,780 --> 00:35:38,440
不用着急

855
00:35:38,470 --> 00:35:38,920
不用着急

856
00:35:38,920 --> 00:35:41,230
我们你可以先按照老师的思路来走

857
00:35:41,970 --> 00:35:43,320
他调这个begin work里

858
00:35:43,680 --> 00:35:44,940
它会返回的是什么呢

859
00:35:45,150 --> 00:35:48,210
返回的是until work下面的child

860
00:35:48,860 --> 00:35:49,250
然后呢

861
00:35:49,250 --> 00:35:50,180
发我一个next

862
00:35:50,860 --> 00:35:53,590
而这个next如果为那个next

863
00:35:53,590 --> 00:35:54,520
如果为none

864
00:35:54,970 --> 00:35:56,800
那么就执行complete after work

865
00:35:56,950 --> 00:35:58,660
如果这个next不为浪

866
00:35:59,020 --> 00:36:02,770
那么就把这个next复制给working progress啊

867
00:36:02,770 --> 00:36:04,630
那么这样我大概就懂他的意思了

868
00:36:04,930 --> 00:36:05,860
他的意思是这样的

869
00:36:06,430 --> 00:36:07,390
大家看它的意思是这样的

870
00:36:07,390 --> 00:36:08,590
我这样一个pap a tree

871
00:36:10,290 --> 00:36:11,670
我这样一个happy我

872
00:36:18,680 --> 00:36:19,400
我这样一个ipad

873
00:36:19,400 --> 00:36:20,750
因为我有个循环吗

874
00:36:20,750 --> 00:36:23,900
我首先我有个working working progress的字段

875
00:36:24,290 --> 00:36:26,480
我第一次肯定是指向他的发了root

876
00:36:27,280 --> 00:36:27,670
对不对

877
00:36:27,910 --> 00:36:28,330
然后呢

878
00:36:28,330 --> 00:36:32,740
我当我进入到这个performance until work里执行了begin work

879
00:36:33,040 --> 00:36:33,940
那么由于

880
00:36:34,630 --> 00:36:37,930
由于begin work会返回我们这个节

881
00:36:37,930 --> 00:36:40,000
Working process这个节点的纸

882
00:36:40,730 --> 00:36:42,350
子节点对吧

883
00:36:42,500 --> 00:36:43,730
有人返回它的子节点

884
00:36:43,760 --> 00:36:44,630
就是他翘的嘛

885
00:36:44,630 --> 00:36:47,480
他有三个属性是child submit return

886
00:36:47,510 --> 00:36:49,580
构成federal trade这三个重要的节点

887
00:36:50,300 --> 00:36:53,090
这构成发布这个节点重要的三个属性

888
00:36:53,780 --> 00:36:57,320
就是这三个ER child就指它的子节点

889
00:36:57,860 --> 00:36:59,630
那么working progress

890
00:36:59,630 --> 00:37:02,630
当第一轮轮询就是第一轮

891
00:37:02,720 --> 00:37:04,280
就是第一轮那个循环

892
00:37:04,860 --> 00:37:06,120
那么之后

893
00:37:07,600 --> 00:37:08,290
就到了这里

894
00:37:08,380 --> 00:37:10,090
那如果那个存在就是存在

895
00:37:10,090 --> 00:37:11,440
直接点就是跳的存在

896
00:37:12,040 --> 00:37:12,430
那么

897
00:37:13,100 --> 00:37:15,140
Work in progress就等于他的直接点

898
00:37:15,650 --> 00:37:17,450
那么第三轮循环之后

899
00:37:17,690 --> 00:37:19,190
它就会指向他的新的节点

900
00:37:19,970 --> 00:37:21,080
一直执行

901
00:37:21,080 --> 00:37:21,650
一直执行

902
00:37:21,950 --> 00:37:24,050
一第四轮就指向心里直点

903
00:37:24,080 --> 00:37:24,830
直到什么呢

904
00:37:24,890 --> 00:37:27,170
直到他没有任何的直接点了

905
00:37:27,680 --> 00:37:29,060
直到没有任何的直接点了

906
00:37:29,090 --> 00:37:29,810
它才会执行

907
00:37:29,810 --> 00:37:31,730
这个叫做complete down to our work的

908
00:37:32,150 --> 00:37:34,520
也就是说假如我们是这样的一个结构

909
00:37:34,700 --> 00:37:38,030
那么再把内轮循环执行完毕之后

910
00:37:38,580 --> 00:37:40,470
大概走到这个地方为止

911
00:37:40,860 --> 00:37:43,350
当她走到这个逻辑分支的时候

912
00:37:43,800 --> 00:37:44,250
我们

913
00:37:45,390 --> 00:37:46,050
这个节点

914
00:37:46,170 --> 00:37:46,770
这个节点

915
00:37:46,950 --> 00:37:48,420
这个节点的这个节点

916
00:37:48,540 --> 00:37:50,430
这四个发展节点都已经创建好了

917
00:37:51,100 --> 00:37:52,540
都已经商量好了

918
00:37:52,540 --> 00:37:54,070
这个时候有同学可能就发生疑问了

919
00:37:55,040 --> 00:37:56,420
老师

920
00:37:56,450 --> 00:37:58,010
发不出一两个就建好了吗

921
00:37:58,310 --> 00:37:59,900
我们现在我们现在只

922
00:38:00,500 --> 00:38:03,080
只看到他的第一个子节点市场就好了

923
00:38:03,080 --> 00:38:04,430
但是他不是还有设备吗

924
00:38:04,640 --> 00:38:05,810
他不是还有我们一个

925
00:38:06,110 --> 00:38:07,700
我们一个含税

926
00:38:07,700 --> 00:38:09,230
可能会经常出现并列的

927
00:38:09,620 --> 00:38:09,950
对吧

928
00:38:09,980 --> 00:38:12,380
他还有他还有他的兄弟节点

929
00:38:12,650 --> 00:38:14,480
而这些兄弟节点却通通没有处理

930
00:38:15,550 --> 00:38:16,690
接下来不要着急

931
00:38:16,960 --> 00:38:17,950
他的兄弟节点呢

932
00:38:17,950 --> 00:38:20,620
其实就在这个complete until work里

933
00:38:20,950 --> 00:38:25,150
我们接下来先直接看complete until work谈

934
00:38:25,680 --> 00:38:28,830
他和February构建主要的部分的逻辑是什么

935
00:38:30,510 --> 00:38:31,740
Complained on their work

936
00:38:32,500 --> 00:38:33,970
我们看在这个地方

937
00:38:33,970 --> 00:38:35,860
大家看他又来了一个新的循环

938
00:38:36,190 --> 00:38:38,710
大家看到了一个豆一个

939
00:38:41,140 --> 00:38:41,770
一个well

940
00:38:41,980 --> 00:38:46,510
不过这一次他外的是叫做complete walk to complete work是什么呢

941
00:38:46,750 --> 00:38:47,680
这个complete work

942
00:38:48,900 --> 00:38:50,040
A complete work

943
00:38:50,700 --> 00:38:51,360
就是当

944
00:38:52,140 --> 00:38:54,420
当我们找到我们找到最下面的时候

945
00:38:54,450 --> 00:38:57,660
是不是这个child就是working progress就等于烂了

946
00:38:58,080 --> 00:38:59,100
等于烂了之后

947
00:38:59,740 --> 00:39:00,640
他就把这个

948
00:39:02,130 --> 00:39:05,700
这个节点付了一个新的新的变量

949
00:39:05,700 --> 00:39:06,930
叫做complete work

950
00:39:07,780 --> 00:39:09,280
就这个最底下的这个点

951
00:39:09,310 --> 00:39:10,180
附了一个新的变量

952
00:39:10,180 --> 00:39:11,320
叫做computer work

953
00:39:12,300 --> 00:39:14,700
然后大家看这是比较重要的

954
00:39:15,360 --> 00:39:17,640
然后他找到了complete works点

955
00:39:17,640 --> 00:39:20,040
说不定现在开始处理他的兄弟节点了

956
00:39:20,460 --> 00:39:21,750
兄弟节点有

957
00:39:22,230 --> 00:39:23,040
如果有

958
00:39:23,370 --> 00:39:23,760
大家看

959
00:39:23,760 --> 00:39:25,740
如果有兄弟节点他干了一件什么事情

960
00:39:26,040 --> 00:39:28,620
他又把兄弟节点付给了working progress

961
00:39:29,160 --> 00:39:30,420
She work in progress

962
00:39:31,240 --> 00:39:32,320
现在只想他了

963
00:39:33,190 --> 00:39:33,910
只见他

964
00:39:34,060 --> 00:39:35,440
假如他还有直接点

965
00:39:36,340 --> 00:39:40,270
那么还是按照上面的那一层行o king progress又会继续

966
00:39:40,880 --> 00:39:43,070
网址节点下面去指他这个return呢

967
00:39:43,070 --> 00:39:46,490
实际上是把这个这一轮这一轮循环给return掉了

968
00:39:49,020 --> 00:39:51,000
如果他的说不定还有直接点

969
00:39:51,000 --> 00:39:53,460
那么就继续还是按上面的那个流程

970
00:39:53,520 --> 00:39:55,380
一级一级的撬的撬掉

971
00:39:55,380 --> 00:39:56,640
撬点撬点

972
00:39:56,640 --> 00:39:57,780
撬的一直往下找

973
00:39:58,020 --> 00:39:59,820
直到又找到没有了

974
00:40:00,060 --> 00:40:01,440
那么他又看他有没有

975
00:40:01,680 --> 00:40:04,080
他又会进入到这个complete a work

976
00:40:04,200 --> 00:40:05,280
又看他有没有split

977
00:40:06,070 --> 00:40:07,420
如果没有了

978
00:40:07,900 --> 00:40:09,550
我们刚刚讲的是有的情况对不对

979
00:40:09,580 --> 00:40:10,420
如果没有了

980
00:40:10,840 --> 00:40:12,820
好他的逻辑是返回父节点

981
00:40:13,300 --> 00:40:15,520
返回节点我们还是回到刚刚这个

982
00:40:15,550 --> 00:40:16,540
假如他没有直接点

983
00:40:16,870 --> 00:40:18,130
那么它就返回父节点

984
00:40:19,010 --> 00:40:20,090
返回了父节点

985
00:40:21,460 --> 00:40:23,500
那么他就直会执行这一层循环

986
00:40:23,950 --> 00:40:25,180
那么它又会长

987
00:40:25,850 --> 00:40:27,740
这个complete work就等于他了

988
00:40:28,070 --> 00:40:30,650
那么他就找这个complete work有没有

989
00:40:30,830 --> 00:40:32,090
有没有兄弟节点

990
00:40:33,160 --> 00:40:34,030
如果没有兄弟几点

991
00:40:34,030 --> 00:40:34,900
她就找她

992
00:40:35,050 --> 00:40:36,100
她有没有兄弟节点

993
00:40:36,430 --> 00:40:38,470
那么我我重新给大家发一复数

994
00:40:38,470 --> 00:40:40,600
所以这个节点甚至顺序是怎样的呢

995
00:40:41,240 --> 00:40:44,210
这个节点生成的顺序就是他是第一个

996
00:40:44,880 --> 00:40:45,915
对不对

997
00:40:45,915 --> 00:40:47,430
他第一个他是第二个

998
00:40:48,410 --> 00:40:49,220
他是第三个

999
00:40:49,910 --> 00:40:50,810
他是第四个

1000
00:40:51,990 --> 00:40:53,730
注意看我这两个兄弟节点

1001
00:40:54,060 --> 00:40:57,360
我这上面这两个节点它都是有设定的

1002
00:40:57,840 --> 00:40:58,800
然后这是第五个

1003
00:40:59,470 --> 00:40:59,980
然后呢

1004
00:40:59,980 --> 00:41:00,640
第六个

1005
00:41:01,260 --> 00:41:01,710
是

1006
00:41:02,520 --> 00:41:03,330
他的spring

1007
00:41:04,360 --> 00:41:07,000
然后他说不定大家看他是怎么循环

1008
00:41:07,000 --> 00:41:08,710
是他是怎么构建web的

1009
00:41:09,010 --> 00:41:10,930
他首先是从上往下

1010
00:41:11,440 --> 00:41:13,210
立刻从上往下找了一轮

1011
00:41:13,890 --> 00:41:14,220
对不对

1012
00:41:14,220 --> 00:41:15,360
从上往下找了一轮

1013
00:41:15,750 --> 00:41:18,450
然后等找到最底层的时候

1014
00:41:18,750 --> 00:41:20,010
等找到最底层的时候

1015
00:41:20,130 --> 00:41:22,140
他然后他再由下往上

1016
00:41:22,530 --> 00:41:23,010
然后

1017
00:41:24,680 --> 00:41:25,370
再来一次

1018
00:41:25,820 --> 00:41:30,170
这两次合并构成了一个完整的family tree

1019
00:41:31,150 --> 00:41:32,320
这样大家能理解吗

1020
00:41:32,350 --> 00:41:33,040
能理解的话

1021
00:41:33,040 --> 00:41:33,640
扣个一

1022
00:41:34,060 --> 00:41:35,200
不能里解扣一个零

1023
00:41:45,220 --> 00:41:47,800
这其实其实是一个深度优先遍历

1024
00:41:48,070 --> 00:41:49,210
是一个深度优先遍历

1025
00:41:49,540 --> 00:41:51,220
关键代码其实就在那里

1026
00:41:51,220 --> 00:41:52,540
就在我

1027
00:41:53,530 --> 00:41:55,180
我打上标记的

1028
00:41:55,180 --> 00:41:56,290
这我打上

1029
00:41:57,430 --> 00:41:58,420
标记了这几行

1030
00:41:58,900 --> 00:42:00,430
我打上标记的就是构建发票

1031
00:42:00,430 --> 00:42:01,930
这一次打那个最强

1032
00:42:02,290 --> 00:42:03,850
那有同学可能非常有疑问

1033
00:42:03,850 --> 00:42:07,750
就是那为什么要从上网就要来一次从上往下

1034
00:42:08,490 --> 00:42:11,010
再来一次从下往上的这样的两个查找

1035
00:42:11,430 --> 00:42:12,810
后面我给大家解释

1036
00:42:12,990 --> 00:42:14,760
解释他这样的做的好处

1037
00:42:15,680 --> 00:42:16,700
这个好处是什么

1038
00:42:17,480 --> 00:42:17,840
总之

1039
00:42:17,840 --> 00:42:19,940
我们的faculty实际上就通过

1040
00:42:20,610 --> 00:42:24,420
我们的发票就通过这样的以上一下一上

1041
00:42:25,050 --> 00:42:26,130
这样的两次构建

1042
00:42:26,370 --> 00:42:28,650
我们的family tree就构建完毕了

1043
00:42:28,920 --> 00:42:33,030
但是我们可不仅仅只是构建web翠这么简单的

1044
00:42:33,300 --> 00:42:35,460
就在在这个re cons ter这个阶段

1045
00:42:35,460 --> 00:42:37,890
可不仅仅是构建web这个这么简单

1046
00:42:38,520 --> 00:42:41,460
接下来我们要来看他这两大函数

1047
00:42:42,460 --> 00:42:44,560
他这他这两大函数我刚刚讲了

1048
00:42:44,560 --> 00:42:47,050
这个在performance until work里有两大函数

1049
00:42:47,380 --> 00:42:48,430
第二个叫做begin work

1050
00:42:48,670 --> 00:42:50,260
第二个是complete on till work

1051
00:42:50,590 --> 00:42:53,290
这两个所做的事情可不是那么简单的

1052
00:42:53,920 --> 00:42:59,230
我们接下来就要来详细的讲一讲这个begin work里其实在REC的

1053
00:42:59,850 --> 00:43:03,270
这个re consider里面它是一个非常关键的一个点

1054
00:43:03,480 --> 00:43:04,530
非常关键的一个点

1055
00:43:04,980 --> 00:43:05,940
因为他在里面会

1056
00:43:06,390 --> 00:43:07,860
因为创建favor TE

1057
00:43:08,040 --> 00:43:10,560
就相当于是通过begin work创建

1058
00:43:11,510 --> 00:43:12,560
不管是哪一个节点

1059
00:43:12,560 --> 00:43:13,970
它都是通过beginner创建

1060
00:43:14,360 --> 00:43:16,940
所以他做的事情有这么几件

1061
00:43:16,970 --> 00:43:17,990
大概有这么几件

1062
00:43:19,200 --> 00:43:19,440
第一

1063
00:43:19,440 --> 00:43:23,490
那肯定就是创建和付付或者复用fiber节点写错了

1064
00:43:28,430 --> 00:43:28,850
第一

1065
00:43:28,850 --> 00:43:31,010
肯定就是创建或者复用fer ti Li

1066
00:43:31,980 --> 00:43:36,480
第二点它就是对比节点是否需要更新

1067
00:43:37,170 --> 00:43:38,790
看一下节点是不是需要更新

1068
00:43:39,180 --> 00:43:41,250
如果节点需要更新的话

1069
00:43:41,520 --> 00:43:43,470
那么就会给他打上一个标记

1070
00:43:43,530 --> 00:43:44,550
这个刚刚也讲到了

1071
00:43:44,550 --> 00:43:45,900
为什么需要给他打成标记

1072
00:43:45,900 --> 00:43:47,760
而不是直接就执行的原因

1073
00:43:48,060 --> 00:43:49,740
因为我们节点这个内部

1074
00:43:50,160 --> 00:43:52,080
它内部的这个微大事

1075
00:43:52,660 --> 00:43:54,220
维持节点就是虚拟节点

1076
00:43:54,610 --> 00:43:56,890
因为是在是在begin work里创建的吗

1077
00:43:57,160 --> 00:43:58,030
这个也跟大家讲了

1078
00:43:58,180 --> 00:43:59,530
为什么只打上一个标记

1079
00:43:59,710 --> 00:44:01,960
而不是立即立即更新档的原因

1080
00:44:02,320 --> 00:44:02,770
然后呢

1081
00:44:02,770 --> 00:44:03,520
返回直接点

1082
00:44:04,090 --> 00:44:06,430
返回返回直接点就是就是这一行

1083
00:44:06,430 --> 00:44:07,330
就是这行代码

1084
00:44:08,080 --> 00:44:11,770
就这是为了构建fever tree所必不可少的

1085
00:44:12,190 --> 00:44:14,170
根据IP这个大逻辑必不可少的

1086
00:44:14,970 --> 00:44:15,330
最后

1087
00:44:15,330 --> 00:44:16,890
在begin work里

1088
00:44:16,890 --> 00:44:19,800
它会执行扔到生命周期之前的所有生命周期

1089
00:44:20,520 --> 00:44:22,230
加上人的身份证七

1090
00:44:24,760 --> 00:44:26,050
这其实有一个

1091
00:44:26,080 --> 00:44:27,790
有一个比较关键的面试题

1092
00:44:28,720 --> 00:44:29,530
这是一个面试题

1093
00:44:29,530 --> 00:44:31,030
如果说

1094
00:44:31,030 --> 00:44:31,480
我们

1095
00:44:32,130 --> 00:44:35,400
就是比较right的节点

1096
00:44:35,400 --> 00:44:37,590
它的它的那个生命周期的执行

1097
00:44:38,040 --> 00:44:39,060
生命周期的执行

1098
00:44:39,750 --> 00:44:40,800
经常有这样的情况

1099
00:44:40,800 --> 00:44:44,250
比如说人走之前生命周期的执行

1100
00:44:45,500 --> 00:44:47,690
如果给你一个具体的具体的例子

1101
00:44:47,990 --> 00:44:49,760
那么你可能需要结合这张图

1102
00:44:49,760 --> 00:44:51,410
如果你想

1103
00:44:51,710 --> 00:44:52,760
比较完美的回答

1104
00:44:53,450 --> 00:44:56,870
有可能你需要结合这张图才能够完成的完整的把它回答出来

1105
00:44:57,230 --> 00:44:58,400
因为为啥呢

1106
00:44:58,520 --> 00:44:58,940
因为

1107
00:44:59,590 --> 00:45:03,430
因为有个比较关键的点是它的这个父节点

1108
00:45:03,430 --> 00:45:06,370
就是子节点和子节点下一个spring节点

1109
00:45:06,850 --> 00:45:09,460
他们的这个执行顺序是不一样的

1110
00:45:09,550 --> 00:45:09,910
对不对

1111
00:45:09,940 --> 00:45:10,570
是不一样的

1112
00:45:10,810 --> 00:45:11,860
复线执行

1113
00:45:12,910 --> 00:45:14,800
直接点接着执行

1114
00:45:15,280 --> 00:45:16,600
然后又会执行直接点

1115
00:45:16,600 --> 00:45:17,050
直接点

1116
00:45:17,470 --> 00:45:19,930
最后才会执行兄弟节点

1117
00:45:20,900 --> 00:45:22,760
兄弟节点他执行的时候

1118
00:45:22,790 --> 00:45:24,410
那么当然他才会构建法治

1119
00:45:24,800 --> 00:45:28,130
所以如果说比如这四个节点中对这四个节点中

1120
00:45:28,160 --> 00:45:33,410
他并不如果说让你让你回答render之前的生命周期

1121
00:45:33,560 --> 00:45:34,370
比如就是render

1122
00:45:34,400 --> 00:45:35,570
哪个render现执行

1123
00:45:36,120 --> 00:45:36,840
两分钟后执行

1124
00:45:36,840 --> 00:45:39,390
那就是12341234

1125
00:45:39,390 --> 00:45:43,230
但是我们平常可能就是感觉上

1126
00:45:43,900 --> 00:45:47,290
可能会感觉成1243对不对

1127
00:45:47,350 --> 00:45:49,360
可能会这么这么感觉

1128
00:45:49,360 --> 00:45:50,920
就是先把这一层全执行完了

1129
00:45:50,950 --> 00:45:51,760
再执行下一个

1130
00:45:51,940 --> 00:45:52,660
实际上不是

1131
00:45:53,260 --> 00:45:54,730
现在不是要小心

1132
00:45:54,730 --> 00:45:56,095
你得你得想

1133
00:45:56,095 --> 00:45:58,000
你得你得在想象中

1134
00:45:58,000 --> 00:45:59,290
或者在那个纸上

1135
00:45:59,680 --> 00:46:00,400
你可以把

1136
00:46:01,280 --> 00:46:05,090
那个例子就是面试官给你的那道题

1137
00:46:05,300 --> 00:46:06,770
具体是哪几个发表

1138
00:46:06,770 --> 00:46:09,470
你可以把它大概的发表所画一画

1139
00:46:09,950 --> 00:46:10,520
然后呢

1140
00:46:11,390 --> 00:46:13,580
按照老师刚刚讲的顺序这样子

1141
00:46:14,620 --> 00:46:15,190
这样子

1142
00:46:15,580 --> 00:46:16,600
假如他还有的话

1143
00:46:16,630 --> 00:46:17,590
那就是这样子

1144
00:46:18,920 --> 00:46:19,340
嗯

1145
00:46:20,010 --> 00:46:20,670
这样子

1146
00:46:21,320 --> 00:46:21,800
这样子

1147
00:46:25,560 --> 00:46:29,550
这个顺序的话有一点就是还是有一点那个迷惑性的

1148
00:46:31,930 --> 00:46:33,010
附逐渐带动

1149
00:46:33,750 --> 00:46:35,460
紫竹院刷新的顺序

1150
00:46:36,240 --> 00:46:39,660
也是1234值带动植组建沙县的顺序

1151
00:46:39,660 --> 00:46:41,250
其实就是render的顺序吗

1152
00:46:41,520 --> 00:46:41,850
对吧

1153
00:46:42,480 --> 00:46:43,440
接着点顺序

1154
00:46:48,300 --> 00:46:49,380
She不定有直接点

1155
00:46:49,740 --> 00:46:50,640
说不定有直接点

1156
00:46:50,640 --> 00:46:51,540
刚刚讲到了

1157
00:46:51,660 --> 00:46:52,950
说不定有子节点的话

1158
00:46:53,370 --> 00:46:53,940
那么他

1159
00:46:55,300 --> 00:46:56,290
那么在

1160
00:46:56,290 --> 00:46:57,010
在这里

1161
00:47:00,460 --> 00:47:02,050
萨林有自己店

1162
00:47:03,090 --> 00:47:04,710
但是一般也不会出的这么难

1163
00:47:04,890 --> 00:47:05,760
如果是不令

1164
00:47:06,960 --> 00:47:07,710
有sub令

1165
00:47:07,860 --> 00:47:10,470
那么就把sub另付给了working progress对不对

1166
00:47:10,680 --> 00:47:13,140
那么他就继续走walk in progress的逻辑了

1167
00:47:13,410 --> 00:47:14,430
Seven有子节点

1168
00:47:14,610 --> 00:47:16,560
那么现在working progress就只抢了他

1169
00:47:17,460 --> 00:47:17,910
那么

1170
00:47:18,720 --> 00:47:19,740
如果Sabrina直接点

1171
00:47:19,740 --> 00:47:22,500
那个working process就指向继续指向Sabrina直接点

1172
00:47:23,200 --> 00:47:23,830
如果没有了

1173
00:47:23,830 --> 00:47:24,760
他才会反馈回来

1174
00:47:24,760 --> 00:47:25,720
然后再往上走

1175
00:47:26,170 --> 00:47:26,770
能理解吗

1176
00:47:30,800 --> 00:47:31,340
也就是说

1177
00:47:31,370 --> 00:47:33,140
如果说这儿说不定一个直接点

1178
00:47:33,140 --> 00:47:34,370
那就是一

1179
00:47:35,120 --> 00:47:37,340
这是123

1180
00:47:39,530 --> 00:47:40,130
四

1181
00:47:40,740 --> 00:47:41,250
五

1182
00:47:42,550 --> 00:47:43,000
六

1183
00:47:43,640 --> 00:47:44,420
这就变成六了

1184
00:47:44,510 --> 00:47:46,370
他四接下来就是五

1185
00:47:46,460 --> 00:47:48,260
如果他还有一个直接点

1186
00:47:48,260 --> 00:47:50,060
那还是我们刚刚一样

1187
00:47:50,680 --> 00:47:51,520
我们刚说的一样

1188
00:47:51,520 --> 00:47:55,510
就是12123

1189
00:47:56,200 --> 00:48:00,640
4567能明白这个意思吗

1190
00:48:08,910 --> 00:48:09,210
对

1191
00:48:09,210 --> 00:48:10,590
如果submarine有子节点的话

1192
00:48:10,590 --> 00:48:14,550
那么他肯定就又进入了working progress的就是先找纸的

1193
00:48:14,940 --> 00:48:16,380
再找先找纸

1194
00:48:16,380 --> 00:48:18,540
当纸的没有的情况下再找纱布的

1195
00:48:18,540 --> 00:48:19,680
然后在网上地位

1196
00:48:20,200 --> 00:48:22,540
这就是为啥说一个往下一个往上呢

1197
00:48:23,180 --> 00:48:25,040
要活跃活跃活跃活跃

1198
00:48:28,590 --> 00:48:29,790
如果再往下

1199
00:48:29,790 --> 00:48:31,140
然后他就是这样的嘛

1200
00:48:31,560 --> 00:48:31,920
对吧

1201
00:48:36,640 --> 00:48:37,000
嗯

1202
00:48:39,410 --> 00:48:39,770
OK

1203
00:48:39,770 --> 00:48:40,280
好

1204
00:48:40,310 --> 00:48:41,360
那我们接下来

1205
00:48:42,880 --> 00:48:43,840
来看看

1206
00:48:45,660 --> 00:48:48,510
这个begin work大致先讲一下begin work的

1207
00:48:48,690 --> 00:48:51,420
刚刚我们讲了大致begin work做的事情

1208
00:48:51,810 --> 00:48:53,580
然后接下来讲这个begin work了

1209
00:48:55,540 --> 00:48:57,130
第一他做什么事情

1210
00:48:57,130 --> 00:48:57,940
第一判断节点

1211
00:48:58,690 --> 00:48:59,560
是否可以服用

1212
00:49:00,040 --> 00:49:02,830
根据不同的tag生成不同的FAB节点

1213
00:49:03,940 --> 00:49:04,570
然后呢

1214
00:49:04,630 --> 00:49:07,600
给存在更新的版本节点打上一个标记

1215
00:49:08,410 --> 00:49:08,770
然后呢

1216
00:49:08,770 --> 00:49:10,120
返回OK book翘的

1217
00:49:10,120 --> 00:49:12,760
我们来看一下

1218
00:49:12,760 --> 00:49:14,830
她常建了两三个两个节点

1219
00:49:14,830 --> 00:49:17,470
一个scare and一个working progress thick ness

1220
00:49:18,660 --> 00:49:20,460
如果current不等于

1221
00:49:20,460 --> 00:49:21,780
那那就说明什么

1222
00:49:21,990 --> 00:49:23,430
那就说明之前已经构建过了

1223
00:49:24,430 --> 00:49:25,810
之前已经构建过一次了

1224
00:49:25,810 --> 00:49:27,130
至少说明构建过一次

1225
00:49:27,160 --> 00:49:30,430
就是它肯定不是ROM的那次对不对

1226
00:49:30,790 --> 00:49:34,690
那么这个时候你就比较它是不是可以服用

1227
00:49:35,080 --> 00:49:36,490
是不是可以复用

1228
00:49:36,490 --> 00:49:37,450
是不是需要更新

1229
00:49:37,450 --> 00:49:39,310
这是这比较大是是不是需要更新

1230
00:49:39,340 --> 00:49:40,600
如果是有

1231
00:49:41,550 --> 00:49:43,140
就是你的props如果变了

1232
00:49:43,320 --> 00:49:44,610
大家想如果plus变了

1233
00:49:44,610 --> 00:49:45,600
是不是肯定要更新

1234
00:49:46,300 --> 00:49:49,240
你的你的你的组件的props变化了

1235
00:49:49,270 --> 00:49:50,170
是不是肯定要更新

1236
00:49:50,470 --> 00:49:51,400
那一定会更新的

1237
00:49:51,730 --> 00:49:53,290
所以如果说props变了

1238
00:49:53,800 --> 00:49:55,750
或者说你的context改变了

1239
00:49:56,600 --> 00:49:56,960
这些

1240
00:49:56,960 --> 00:49:58,610
这实际上就是指的是context

1241
00:49:58,610 --> 00:50:01,160
我们regularly有context概念对不对

1242
00:50:01,310 --> 00:50:03,020
Context概念这个应该都懂

1243
00:50:03,020 --> 00:50:04,190
都懂吗

1244
00:50:05,120 --> 00:50:05,930
CONTEXT12点

1245
00:50:07,630 --> 00:50:08,470
Create a

1246
00:50:09,790 --> 00:50:10,600
context

1247
00:50:13,300 --> 00:50:18,100
他可以跨级context可以跨层级渠道属性渠道属性

1248
00:50:19,530 --> 00:50:22,440
这样子避免的是我如果你的组件比较多

1249
00:50:22,770 --> 00:50:25,320
那么我不需要一级一级打props

1250
00:50:25,320 --> 00:50:26,550
一级一级的往下传

1251
00:50:27,060 --> 00:50:28,320
我直接通过context

1252
00:50:29,060 --> 00:50:32,300
那么可以取到很高层级的属性

1253
00:50:32,360 --> 00:50:34,820
很高层级的主主线节点的那个属性

1254
00:50:35,180 --> 00:50:35,600
所以

1255
00:50:36,330 --> 00:50:37,440
Contacts这个变化啦

1256
00:50:37,440 --> 00:50:38,670
那么他也要

1257
00:50:39,890 --> 00:50:40,970
也也要更新

1258
00:50:40,970 --> 00:50:42,560
就是它也是需要及时更新的

1259
00:50:43,100 --> 00:50:44,060
也是需要及时更新的

1260
00:50:44,600 --> 00:50:48,980
然后这里大家看这边有一个注意一个东西叫做班out

1261
00:50:49,730 --> 00:50:51,200
Buy out by out

1262
00:50:51,200 --> 00:50:55,220
在REC的内部就有很多这种八二的开头的方法

1263
00:50:55,640 --> 00:50:56,600
这其实意味着啥

1264
00:50:56,600 --> 00:50:59,630
意思是说你的这个东西直接就可以服用

1265
00:50:59,810 --> 00:51:02,240
直接可以服用他这么一这么个意思

1266
00:51:03,090 --> 00:51:03,630
这个意思

1267
00:51:03,930 --> 00:51:04,500
那么这

1268
00:51:05,620 --> 00:51:07,600
所以他把直接把它标记为了是吗

1269
00:51:07,720 --> 00:51:09,100
Reserve它就不用更新了

1270
00:51:09,130 --> 00:51:10,540
更新了就用这个就行了

1271
00:51:10,990 --> 00:51:11,710
就这个就行了

1272
00:51:12,220 --> 00:51:14,050
这个第一件事情

1273
00:51:14,380 --> 00:51:15,130
他判断

1274
00:51:15,640 --> 00:51:17,530
他判断这个节点需不需要更新

1275
00:51:17,890 --> 00:51:19,840
当然他不光是这里判断

1276
00:51:20,140 --> 00:51:20,590
大家想

1277
00:51:20,590 --> 00:51:23,320
因为可能有同学还在还在想老师

1278
00:51:24,120 --> 00:51:28,020
判断更新是不是还有一个东西叫做should component update对不对

1279
00:51:28,470 --> 00:51:30,360
还有a component update的判断更新

1280
00:51:30,630 --> 00:51:31,890
这只是第一次判断

1281
00:51:32,590 --> 00:51:33,580
这是第一次判断

1282
00:51:33,790 --> 00:51:37,000
后面他还会根据是component update那些

1283
00:51:37,240 --> 00:51:39,430
然后来改这个值

1284
00:51:39,700 --> 00:51:40,540
来改这个值

1285
00:51:40,630 --> 00:51:41,560
所以不需要着急

1286
00:51:42,160 --> 00:51:44,050
这是通过props context

1287
00:51:44,110 --> 00:51:46,690
我们可以首先判断他是第一次更新

1288
00:51:47,230 --> 00:51:48,670
就是需要更新

1289
00:51:48,670 --> 00:51:49,930
因为如果你这个改变了

1290
00:51:50,050 --> 00:51:51,040
那你肯定要更新吗

1291
00:51:52,940 --> 00:51:54,740
第二个working progress烂

1292
00:51:55,100 --> 00:51:58,700
我们来看workingprogress.tag根据这就是第二件事情

1293
00:51:59,030 --> 00:52:00,290
根据它的不同

1294
00:52:00,440 --> 00:52:01,610
大家看它的不同

1295
00:52:02,400 --> 00:52:05,370
它里面其实处理了非常非常多的类型

1296
00:52:05,640 --> 00:52:06,360
非常非常类型

1297
00:52:06,360 --> 00:52:07,260
我这儿没写完

1298
00:52:07,830 --> 00:52:08,550
我这没有写完

1299
00:52:08,550 --> 00:52:10,860
因为我要是把它全部粘过来的话

1300
00:52:11,040 --> 00:52:12,900
我这一我这一瓶都摆不下

1301
00:52:12,960 --> 00:52:13,830
我这一瓶都摆不下

1302
00:52:14,510 --> 00:52:16,340
它里面的这个类型非常多的

1303
00:52:16,580 --> 00:52:20,990
比如说比如说我们之前我们可能认为他不算是一个

1304
00:52:21,760 --> 00:52:23,110
特殊的类型的

1305
00:52:23,820 --> 00:52:25,740
在这都是有不同的逻辑的

1306
00:52:26,100 --> 00:52:26,880
比如lazy

1307
00:52:27,890 --> 00:52:30,620
Function这个这个function肯定和class不一样

1308
00:52:30,830 --> 00:52:31,070
对吧

1309
00:52:31,070 --> 00:52:32,420
这个我们肯定都都知道

1310
00:52:33,130 --> 00:52:33,880
我们都知道

1311
00:52:33,880 --> 00:52:37,270
比如这个后手机是在render的时候第一次喝

1312
00:52:37,540 --> 00:52:39,970
第一次的时候他会执行host

1313
00:52:40,930 --> 00:52:42,145
Black down的对

1314
00:52:42,145 --> 00:52:43,150
他自己host

1315
00:52:43,760 --> 00:52:44,510
Host root

1316
00:52:44,750 --> 00:52:45,440
还有其他的

1317
00:52:45,440 --> 00:52:46,670
比如像portal

1318
00:52:47,030 --> 00:52:48,470
比如我们有个party的概念

1319
00:52:48,470 --> 00:52:50,150
在record里有portal

1320
00:52:50,600 --> 00:52:51,560
有fragment

1321
00:52:51,590 --> 00:52:51,980
对不对

1322
00:52:52,400 --> 00:52:55,550
Fragment都是不同的功能

1323
00:52:55,550 --> 00:52:57,170
不同的内内部不同的功能

1324
00:52:57,650 --> 00:52:59,690
那么它根据这个tag的不同

1325
00:53:00,880 --> 00:53:02,260
他就执行不同的case

1326
00:53:03,190 --> 00:53:06,190
而这个case里其实大部分

1327
00:53:06,540 --> 00:53:09,450
创建favor的这个逻辑是创建一个web的逻辑

1328
00:53:09,930 --> 00:53:10,830
其实是一样的

1329
00:53:10,950 --> 00:53:11,760
其实是一样的

1330
00:53:12,060 --> 00:53:12,450
但是呢

1331
00:53:12,450 --> 00:53:14,250
他们有自己的差异的

1332
00:53:14,460 --> 00:53:15,480
差异化的部分

1333
00:53:15,810 --> 00:53:18,690
比如function和class的差异部分上

1334
00:53:18,900 --> 00:53:19,440
比如说class

1335
00:53:19,440 --> 00:53:20,940
它可以执行生命周期

1336
00:53:21,360 --> 00:53:22,080
方形呢

1337
00:53:22,200 --> 00:53:23,340
他可能会有hooks

1338
00:53:23,930 --> 00:53:25,760
那么在class component里

1339
00:53:26,560 --> 00:53:28,660
Class complain的这么个分支里

1340
00:53:29,110 --> 00:53:30,400
他对他执行

1341
00:53:30,400 --> 00:53:32,110
这里边儿就是执行生命之妻

1342
00:53:32,560 --> 00:53:35,410
而function component这个分支里

1343
00:53:35,650 --> 00:53:36,400
它这里呢

1344
00:53:36,640 --> 00:53:37,930
他就会去初始化

1345
00:53:38,580 --> 00:53:40,530
Cook猪肉hooks

1346
00:53:40,530 --> 00:53:43,020
上下文就是有一些不一样

1347
00:53:43,260 --> 00:53:43,890
但是呢

1348
00:53:44,490 --> 00:53:44,910
但是呢

1349
00:53:44,910 --> 00:53:46,200
有一些又是相同的

1350
00:53:46,440 --> 00:53:47,400
相同的就在这个

1351
00:53:47,400 --> 00:53:52,080
Re consider children there是来做构建FAB节点的

1352
00:53:52,110 --> 00:53:55,020
因为他们始终要创建一个节点

1353
00:53:55,110 --> 00:53:57,750
除非像fragment它不需要创建节点

1354
00:53:58,520 --> 00:53:59,300
那么就不需要

1355
00:53:59,690 --> 00:54:01,400
如果说只要你要创建节点

1356
00:54:01,910 --> 00:54:04,010
不管你是走哪个逻辑分支下来

1357
00:54:04,100 --> 00:54:07,310
那么你肯定都要走到这个re consider dian children里面去

1358
00:54:08,060 --> 00:54:08,510
对

1359
00:54:08,570 --> 00:54:10,310
所以我就直接把它单拎出来了

1360
00:54:10,730 --> 00:54:12,830
像这个host roots也是一样

1361
00:54:13,460 --> 00:54:13,970
也是一样

1362
00:54:13,970 --> 00:54:15,620
它会走到这个cos的确诊了

1363
00:54:16,850 --> 00:54:21,320
好走到这个走到这个re cons脸children之后

1364
00:54:21,410 --> 00:54:22,850
我们可以看到它区分

1365
00:54:23,240 --> 00:54:24,470
区分了两种情况

1366
00:54:25,040 --> 00:54:27,110
第一种是can a等于浪

1367
00:54:28,250 --> 00:54:28,550
等于

1368
00:54:28,550 --> 00:54:29,450
那意味着什么

1369
00:54:29,480 --> 00:54:30,650
页面上什么也没有

1370
00:54:31,480 --> 00:54:32,350
我们可以理解为

1371
00:54:33,200 --> 00:54:34,520
页面上并没有结

1372
00:54:34,520 --> 00:54:35,570
并没有这个节点

1373
00:54:36,080 --> 00:54:38,390
那么要创建对不对

1374
00:54:38,390 --> 00:54:38,960
叫创建

1375
00:54:39,260 --> 00:54:40,340
如果页面上有了

1376
00:54:40,760 --> 00:54:43,370
那么我们来看一下是否可以服用

1377
00:54:43,580 --> 00:54:44,090
如果

1378
00:54:44,830 --> 00:54:45,550
不能服用的话

1379
00:54:45,550 --> 00:54:46,840
看一下该怎么更新

1380
00:54:47,080 --> 00:54:48,340
所以分为两步

1381
00:54:48,340 --> 00:54:49,780
如果页面上没有节点的话

1382
00:54:50,050 --> 00:54:50,860
如果是mount阶段

1383
00:54:50,860 --> 00:54:51,940
就创建fiber节点

1384
00:54:52,180 --> 00:54:53,950
如果是update阶段

1385
00:54:54,190 --> 00:54:56,290
那么我们就更新fiber节点

1386
00:54:57,030 --> 00:54:58,650
更新快点儿

1387
00:54:58,650 --> 00:55:01,350
这儿大家看创建的这个节点

1388
00:55:01,650 --> 00:55:03,810
是直接赋值给了他的翘的

1389
00:55:03,840 --> 00:55:04,230
对不对

1390
00:55:04,320 --> 00:55:06,210
是直接复制了给了他的翘的

1391
00:55:08,910 --> 00:55:10,200
能能看清楚

1392
00:55:10,470 --> 00:55:14,190
复制给他翘的后面这里又会把翘的返回去

1393
00:55:15,120 --> 00:55:16,350
一会儿把翘的返回去

1394
00:55:16,410 --> 00:55:17,820
你看上面吧

1395
00:55:17,820 --> 00:55:18,330
对

1396
00:55:18,330 --> 00:55:18,840
对

1397
00:55:19,410 --> 00:55:21,120
Retire working prison terms

1398
00:55:21,940 --> 00:55:24,610
是不是因为比如像这个这个分支

1399
00:55:25,320 --> 00:55:27,690
他最后也会调到re consider返回一个

1400
00:55:28,300 --> 00:55:30,010
得到一个working progress and child

1401
00:55:30,520 --> 00:55:31,030
而这

1402
00:55:31,480 --> 00:55:32,470
他就说

1403
00:55:33,620 --> 00:55:35,060
这里return的时候

1404
00:55:35,420 --> 00:55:38,540
里边儿他就直接把working progress and child给ritter回去了

1405
00:55:39,500 --> 00:55:40,250
睿册回去了

1406
00:55:40,910 --> 00:55:41,930
这就是它的逻辑

1407
00:55:42,560 --> 00:55:44,210
因此这这一步我们也讲到了

1408
00:55:44,720 --> 00:55:45,770
他创建了PI节点

1409
00:55:45,800 --> 00:55:47,540
复制给了子节点

1410
00:55:48,080 --> 00:55:48,620
创建好了

1411
00:55:48,620 --> 00:55:50,690
同时也给它指向working progress

1412
00:55:50,990 --> 00:55:53,150
指向working progress点抢

1413
00:55:54,360 --> 00:55:58,140
然后再根据我们刚刚所讲到的那个创建翡翠的那个流程

1414
00:55:58,680 --> 00:56:03,960
那么他把working progress紧俏的是不是也复制给了work in progress就一层一层的往下推动了

1415
00:56:04,230 --> 00:56:04,620
推动了

1416
00:56:04,620 --> 00:56:04,950
走了

1417
00:56:07,820 --> 00:56:08,450
这

1418
00:56:09,080 --> 00:56:10,190
这不止这一个

1419
00:56:10,490 --> 00:56:10,880
同学们

1420
00:56:10,880 --> 00:56:11,660
这不止这一个

1421
00:56:11,870 --> 00:56:12,950
这个方法是什么意思

1422
00:56:13,220 --> 00:56:14,630
这个方法是指的是

1423
00:56:16,150 --> 00:56:17,170
Police mun替换

1424
00:56:17,820 --> 00:56:20,850
Please就是placement single child

1425
00:56:20,940 --> 00:56:22,590
这是只是替换节点

1426
00:56:22,860 --> 00:56:23,460
替换节点

1427
00:56:23,490 --> 00:56:26,010
但是这是直接打上flex

1428
00:56:26,010 --> 00:56:27,210
大家看到了

1429
00:56:27,330 --> 00:56:29,250
直接打上了flex替换节点

1430
00:56:29,980 --> 00:56:30,610
不止这一个

1431
00:56:30,610 --> 00:56:31,330
如果是的

1432
00:56:31,330 --> 00:56:32,860
他有个方法叫做delete

1433
00:56:32,860 --> 00:56:34,840
吓得我这就没有写出来了

1434
00:56:35,440 --> 00:56:36,550
我这就没有写出来了

1435
00:56:38,270 --> 00:56:40,610
它里面不只有那肯定

1436
00:56:40,610 --> 00:56:42,830
因为他不止有新增替换

1437
00:56:43,500 --> 00:56:44,280
还有删除

1438
00:56:44,520 --> 00:56:47,490
那么等等这种这些类型可能还有更新吗

1439
00:56:47,520 --> 00:56:49,140
更新更新的话

1440
00:56:49,140 --> 00:56:51,900
那就是比如说你的数属性值更新了什么的

1441
00:56:52,320 --> 00:56:54,300
那么他会给你标记一个属性叫做

1442
00:56:54,980 --> 00:56:55,850
更新属性值

1443
00:56:55,910 --> 00:56:59,390
而他后面处理处理这个副作用的时候

1444
00:56:59,630 --> 00:57:02,060
这种会在right里面称为一个副作用

1445
00:57:02,450 --> 00:57:05,690
就是一次每一个节点你发生了一次变化

1446
00:57:06,110 --> 00:57:08,270
那么他把这个节点叫做一个副作用

1447
00:57:08,750 --> 00:57:09,590
本来这个flex

1448
00:57:09,590 --> 00:57:11,300
他原本叫做CD effects

1449
00:57:11,360 --> 00:57:12,560
他现在改成flex

1450
00:57:12,830 --> 00:57:13,940
他认为是一个副作用

1451
00:57:14,240 --> 00:57:16,400
如果这个副作用有这个副作用

1452
00:57:16,400 --> 00:57:17,780
他最后会遍历这个副作用

1453
00:57:17,780 --> 00:57:19,070
然后再批量的做处理

1454
00:57:19,680 --> 00:57:24,300
而那么他就不需要在在那个render就是render阶段

1455
00:57:24,300 --> 00:57:25,320
他不需要再

1456
00:57:26,370 --> 00:57:27,270
循环一遍

1457
00:57:27,570 --> 00:57:28,710
然后来判断一遍了

1458
00:57:28,740 --> 00:57:29,880
他就可以直接处理了

1459
00:57:30,180 --> 00:57:31,560
相当于他这一次的循环

1460
00:57:31,560 --> 00:57:32,970
他利用了非常的充分

1461
00:57:33,390 --> 00:57:35,640
在recovery的这一次循环

1462
00:57:35,850 --> 00:57:37,560
它实际上是利用的比较充分的

1463
00:57:38,200 --> 00:57:41,020
接下来我们看到它不仅不仅会打上fax

1464
00:57:41,260 --> 00:57:42,430
它打的东西可多了

1465
00:57:43,270 --> 00:57:44,230
做的东西可多了

1466
00:57:47,660 --> 00:57:49,280
的算法

1467
00:57:51,530 --> 00:57:54,050
的算法我们暂时先不讲

1468
00:57:54,140 --> 00:57:58,820
等待会把整个这两个begin work和complete work都讲完了之后

1469
00:57:58,820 --> 00:58:00,380
我们再讲dif

1470
00:58:00,470 --> 00:58:02,630
它可能会把我们的流程拉远了

1471
00:58:03,730 --> 00:58:06,790
newfiber.outlet指向的是working progress

1472
00:58:07,520 --> 00:58:08,600
A new fiber

1473
00:58:11,960 --> 00:58:12,470
不是的

1474
00:58:12,470 --> 00:58:12,890
不是的

1475
00:58:13,070 --> 00:58:15,620
这个new fiber他是不是新的fiber

1476
00:58:15,650 --> 00:58:16,490
新的fiber的话

1477
00:58:16,490 --> 00:58:18,170
它其实指向它

1478
00:58:18,170 --> 00:58:20,300
其实它本身就是working progress however

1479
00:58:20,780 --> 00:58:23,060
它的outlet就是指的是老节点

1480
00:58:24,160 --> 00:58:28,300
他的a的值是现现在页面他只是current理解

1481
00:58:28,970 --> 00:58:31,160
因为live fiber他的名字吗

1482
00:58:32,010 --> 00:58:34,560
什么是new working progress才是new face啊

1483
00:58:38,080 --> 00:58:39,160
Working progress number

1484
00:58:39,160 --> 00:58:41,350
所以他的所以他的outlet

1485
00:58:41,350 --> 00:58:42,670
它指向的是current

1486
00:58:42,670 --> 00:58:46,360
就是也就是页面上现在正有页面上现在

1487
00:58:48,480 --> 00:58:50,130
这有到那个节点

1488
00:58:50,340 --> 00:58:53,310
而如果他carrot不存在的情况下

1489
00:58:54,720 --> 00:58:55,200
Please

1490
00:58:55,500 --> 00:58:56,880
他就给他打上一个这个节点

1491
00:59:02,030 --> 00:59:04,700
其实他的这个语义化做得还是不错的

1492
00:59:04,850 --> 00:59:06,470
同学们与计划做的还是不错的

1493
00:59:06,650 --> 00:59:09,560
Current你就理解为就很好理解嘛

1494
00:59:09,560 --> 00:59:12,260
就是叶荷叶面反正是对应的那个current当前那个

1495
00:59:13,660 --> 00:59:13,930
对吧

1496
00:59:13,930 --> 00:59:15,490
这个new favor那肯定是一个

1497
00:59:15,730 --> 00:59:17,230
这一次要创建一个新的

1498
00:59:19,980 --> 00:59:21,720
他就其实是working progress

1499
00:59:23,380 --> 00:59:23,530
好

1500
00:59:23,530 --> 00:59:23,980
Begin work

1501
00:59:23,980 --> 00:59:26,050
我们来总结一下

1502
00:59:26,920 --> 00:59:29,140
他这是你第一判断节点是否可以服用

1503
00:59:29,500 --> 00:59:32,380
第二根据不同的是否需要更新

1504
00:59:35,720 --> 00:59:37,820
因为如果不需要更新

1505
00:59:41,190 --> 00:59:42,270
不需要跟你是不是就是

1506
00:59:43,440 --> 00:59:44,850
是不是就是直接可以复用

1507
00:59:54,890 --> 00:59:56,390
不需要给你是不是直接就可以服用

1508
00:59:56,980 --> 00:59:59,410
而根据不同的第二个第二个件事情

1509
00:59:59,410 --> 01:00:01,480
根据不同的tag生成不同的favor节点

1510
01:00:01,900 --> 01:00:02,440
一个是MT

1511
01:00:02,440 --> 01:00:04,510
一个是update MT就创建

1512
01:00:04,540 --> 01:00:05,530
Update就更新

1513
01:00:05,710 --> 01:00:07,300
然后在这个阶段他会做diff

1514
01:00:07,930 --> 01:00:08,680
回头differ

1515
01:00:08,680 --> 01:00:09,460
这两个地方的话

1516
01:00:09,460 --> 01:00:11,080
我暂时还没给大家讲到

1517
01:00:11,080 --> 01:00:12,940
待会会讲到第三

1518
01:00:13,540 --> 01:00:14,710
我们知道它变

1519
01:00:14,740 --> 01:00:15,790
它具体的变更了

1520
01:00:16,440 --> 01:00:17,640
那么就给他打上标记

1521
01:00:18,060 --> 01:00:18,780
打上标记

1522
01:00:19,690 --> 01:00:21,550
Replacement update a delicious

1523
01:00:21,550 --> 01:00:22,240
还有其他的

1524
01:00:22,810 --> 01:00:23,260
第四

1525
01:00:23,350 --> 01:00:24,250
创建web节点

1526
01:00:24,250 --> 01:00:26,650
复制给working prison child返回

1527
01:00:27,250 --> 01:00:27,850
还有第五

1528
01:00:27,850 --> 01:00:28,720
他会执行

1529
01:00:29,770 --> 01:00:30,880
执行对应的

1530
01:00:31,000 --> 01:00:32,170
执行不同的

1531
01:00:34,130 --> 01:00:35,000
不同的类型

1532
01:00:35,450 --> 01:00:37,910
不同类型的节点

1533
01:00:39,960 --> 01:00:41,520
不同类型的favor几点

1534
01:00:44,580 --> 01:00:47,130
会执行

1535
01:00:47,940 --> 01:00:49,260
除了构建petri

1536
01:00:49,290 --> 01:00:52,470
会执行就是相应的特殊逻辑

1537
01:00:57,980 --> 01:00:59,510
比如说如果是class

1538
01:00:59,570 --> 01:01:00,290
那就会执行

1539
01:01:00,290 --> 01:01:00,890
生殖器

1540
01:01:03,950 --> 01:01:05,180
会掉生命值减函数

1541
01:01:06,650 --> 01:01:07,640
如果是方形

1542
01:01:09,350 --> 01:01:09,920
它没有生命

1543
01:01:09,920 --> 01:01:10,760
之间还是可以调

1544
01:01:10,790 --> 01:01:11,780
那么会注入

1545
01:01:14,900 --> 01:01:15,170
对

1546
01:01:15,170 --> 01:01:16,160
是的是的

1547
01:01:18,690 --> 01:01:19,020
Cooks

1548
01:01:19,020 --> 01:01:19,650
上下文

1549
01:01:21,030 --> 01:01:21,480
是的

1550
01:01:21,690 --> 01:01:22,830
其实它就指的是

1551
01:01:24,930 --> 01:01:26,430
这指的就是方向

1552
01:01:26,430 --> 01:01:32,250
Comment就指的是我们一个我们写的那个function component函数组件

1553
01:01:32,580 --> 01:01:34,920
这些只是我们写的那个class函数组件

1554
01:01:35,570 --> 01:01:37,070
如果是function还是组建

1555
01:01:37,760 --> 01:01:41,300
那么它在这个它会掉这个update的function component

1556
01:01:41,600 --> 01:01:45,230
它里面会调用一个方法叫做render with hooks

1557
01:01:45,530 --> 01:01:48,140
这个方法会注入hook上下文之心

1558
01:01:48,500 --> 01:01:49,160
芳心

1559
01:01:49,880 --> 01:01:50,510
直接发个信

1560
01:01:50,510 --> 01:01:51,020
函数题

1561
01:01:53,400 --> 01:01:53,850
大家注意

1562
01:01:53,850 --> 01:01:55,440
在hooks里大家可能都写过

1563
01:01:55,440 --> 01:01:57,270
就是如果你在class里调hooks

1564
01:01:57,270 --> 01:01:58,020
实际上调不通

1565
01:01:58,050 --> 01:01:59,220
对不对是用不了的

1566
01:01:59,250 --> 01:02:00,120
他会给你报错

1567
01:02:00,510 --> 01:02:05,370
原因就是因为它只有因为在class里hooks上下文并不存在

1568
01:02:05,370 --> 01:02:07,200
它是实时给你副词的

1569
01:02:07,930 --> 01:02:09,280
他是时势赋的值

1570
01:02:10,580 --> 01:02:11,060
明白吗

1571
01:02:11,060 --> 01:02:12,050
实时赋的值

1572
01:02:12,350 --> 01:02:14,960
所以说class里永远掉不了

1573
01:02:15,910 --> 01:02:16,780
护色

1574
01:02:17,690 --> 01:02:18,830
就是后续的东西

1575
01:02:19,540 --> 01:02:22,420
护士的东西只有在放弃里面才能调实时复制

1576
01:02:22,660 --> 01:02:22,990
第二

1577
01:02:23,830 --> 01:02:25,060
判断节点是否服用

1578
01:02:25,180 --> 01:02:26,860
能服用者巴拉的获取方法

1579
01:02:26,860 --> 01:02:27,490
服用节点

1580
01:02:28,390 --> 01:02:30,010
就主要是这个不太一样

1581
01:02:30,460 --> 01:02:33,220
在class里面的话就直接扔的就是生命

1582
01:02:33,550 --> 01:02:35,050
Render之前的生命周期

1583
01:02:35,380 --> 01:02:37,330
我们可以从代码里面看一看

1584
01:02:38,230 --> 01:02:40,900
现在rock实际源码在这里的目的是

1585
01:02:42,890 --> 01:02:43,460
什么意思

1586
01:02:45,140 --> 01:02:45,500
是啊

1587
01:02:45,500 --> 01:02:45,920
肯定啊

1588
01:02:45,950 --> 01:02:49,040
内组建类组件并不会被废弃的

1589
01:02:49,040 --> 01:02:49,490
同学们

1590
01:02:50,510 --> 01:02:51,200
方形组建

1591
01:02:51,200 --> 01:02:53,840
虽然现在说有很大的方形组件

1592
01:02:53,840 --> 01:02:55,370
现在虽然说有很大的那个

1593
01:02:56,880 --> 01:02:58,230
就是它的份额比以前更大

1594
01:02:58,230 --> 01:03:00,000
但是内组建并不会被放弃的

1595
01:03:01,300 --> 01:03:04,690
他也同样是react里面还是一个非常重要的一个功能

1596
01:03:04,690 --> 01:03:05,920
不会不会

1597
01:03:06,580 --> 01:03:08,980
只是说内组件它不能调用hooks

1598
01:03:08,980 --> 01:03:09,730
这肯定是

1599
01:03:09,850 --> 01:03:10,990
这肯定是一定的

1600
01:03:11,560 --> 01:03:13,270
但是它原本的那些生命周期

1601
01:03:13,390 --> 01:03:14,140
那些都是还在

1602
01:03:14,140 --> 01:03:15,640
并不会放弃掉

1603
01:03:16,270 --> 01:03:17,020
而方见

1604
01:03:17,440 --> 01:03:19,510
因为他以前还没有这个逻辑

1605
01:03:19,510 --> 01:03:20,170
现在有了

1606
01:03:20,170 --> 01:03:20,710
有护士了

1607
01:03:20,710 --> 01:03:21,760
所以他也会掉

1608
01:03:22,420 --> 01:03:23,560
我们可以来看一下

1609
01:03:24,220 --> 01:03:26,740
可以看一下从代码里面瞅一瞅

1610
01:03:26,800 --> 01:03:27,040
第二

1611
01:03:27,040 --> 01:03:30,190
我们因为我们了解了大部分大概他

1612
01:03:30,830 --> 01:03:31,640
做了什么事情

1613
01:03:31,640 --> 01:03:33,830
我们就可以来跳一跳代码了

1614
01:03:34,900 --> 01:03:35,500
跳到代码

1615
01:03:35,500 --> 01:03:36,460
如果直接跳的话

1616
01:03:36,460 --> 01:03:37,450
可能大家都会

1617
01:03:38,160 --> 01:03:39,090
被他绕晕了

1618
01:03:40,180 --> 01:03:42,190
在react时期的时候

1619
01:03:42,190 --> 01:03:44,590
大家看它的函数里有两个

1620
01:03:44,830 --> 01:03:46,120
比如有一个叫做点六

1621
01:03:46,270 --> 01:03:47,230
也就是点二的

1622
01:03:48,980 --> 01:03:51,050
刚开始他是直接复制了一份出来

1623
01:03:51,470 --> 01:03:52,610
直接复制一份出来

1624
01:03:52,940 --> 01:03:53,960
因为她不想影响

1625
01:03:54,170 --> 01:03:55,850
她在开发新功能的时候

1626
01:03:56,270 --> 01:03:57,740
他不想影响老的东西

1627
01:03:58,130 --> 01:03:59,750
所以他就这么区分一下就是

1628
01:04:00,320 --> 01:04:01,640
用了一个点o的点六

1629
01:04:02,120 --> 01:04:05,720
然后如果说他觉得时机成熟了

1630
01:04:05,720 --> 01:04:07,820
那么就把所有的纸箱都变成六

1631
01:04:10,750 --> 01:04:12,460
否则之前的话就还是用o的

1632
01:04:12,460 --> 01:04:13,780
这样的话他

1633
01:04:14,510 --> 01:04:17,060
让内部不是说要做那个渐进式的升级吗

1634
01:04:17,120 --> 01:04:20,300
渐进式升级不会说我这次开发了新的功能

1635
01:04:20,300 --> 01:04:24,350
你老子就直接就像像那个什么安哥拉

1636
01:04:24,710 --> 01:04:25,790
安哥拉之前一样

1637
01:04:25,790 --> 01:04:27,410
然后做断崖式升级

1638
01:04:27,440 --> 01:04:28,970
没有做这种断崖式升级

1639
01:04:29,240 --> 01:04:30,320
想做间接升级

1640
01:04:30,320 --> 01:04:31,520
所以他想了这么个办法

1641
01:04:32,060 --> 01:04:34,070
这个办法我们现在看六就行了

1642
01:04:34,130 --> 01:04:34,730
看就行了

1643
01:04:35,150 --> 01:04:38,060
我们看一下它这个APP的function convenient

1644
01:04:39,460 --> 01:04:44,350
的我们不看Di v它其实DV里面可能有很多调试的逻辑

1645
01:04:45,800 --> 01:04:47,270
DV都给他切掉

1646
01:04:49,930 --> 01:04:50,500
让我们

1647
01:04:51,500 --> 01:04:54,230
Up de function component里面

1648
01:04:54,230 --> 01:04:55,010
我们看到了没

1649
01:04:55,800 --> 01:04:57,750
Render with hooks对不对

1650
01:04:57,780 --> 01:04:58,710
Render with hooks

1651
01:04:58,980 --> 01:05:02,160
这里面render with hooks就是注入我们的hook上下文了

1652
01:05:03,620 --> 01:05:04,760
我们的hook上下文

1653
01:05:05,630 --> 01:05:06,200
就是这个

1654
01:05:06,500 --> 01:05:09,200
比如说我们当前的要处理的fiber

1655
01:05:09,290 --> 01:05:12,110
他就把它复制给叫做currently rendering fiber

1656
01:05:12,850 --> 01:05:14,770
然后这个难nice

1657
01:05:15,360 --> 01:05:16,650
有了这个之后

1658
01:05:16,860 --> 01:05:18,840
Hooks才能掉得了

1659
01:05:19,540 --> 01:05:21,640
如果没有这个hooks是根本调不动的

1660
01:05:21,970 --> 01:05:22,810
还有就是这款

1661
01:05:23,440 --> 01:05:24,310
大家大家注意

1662
01:05:24,460 --> 01:05:30,370
如果你是在react源码里搜这个react current dispatch action current

1663
01:05:30,880 --> 01:05:31,600
她会是什么

1664
01:05:31,720 --> 01:05:32,320
它会是浪

1665
01:05:32,350 --> 01:05:33,670
源码你直接掉

1666
01:05:33,700 --> 01:05:35,560
你直接去找这个东西

1667
01:05:36,100 --> 01:05:36,910
它会是个浪

1668
01:05:38,360 --> 01:05:41,600
他是个那但是你只有在注入

1669
01:05:42,600 --> 01:05:44,460
Render with hooks so

1670
01:05:45,460 --> 01:05:49,060
他会实时给你复制就给你复制

1671
01:05:49,210 --> 01:05:52,450
而当你的这个节点运行完了之后

1672
01:05:54,100 --> 01:05:56,230
他又把这个值又重新给设备让了

1673
01:05:56,500 --> 01:05:57,550
又重新给设备上了

1674
01:05:57,790 --> 01:05:58,630
这就保证什么

1675
01:05:59,530 --> 01:06:02,170
这就保证了你只能够在函数组件里调

1676
01:06:02,350 --> 01:06:03,610
你在其他组件里

1677
01:06:03,850 --> 01:06:05,050
比如在内组件里掉

1678
01:06:05,050 --> 01:06:05,890
你是掉不了的

1679
01:06:06,510 --> 01:06:07,980
因为他在用户时

1680
01:06:07,980 --> 01:06:09,030
他就会去找这个

1681
01:06:10,060 --> 01:06:10,750
复试的时候

1682
01:06:10,990 --> 01:06:12,370
我们后面会看原版

1683
01:06:12,370 --> 01:06:14,020
你就可以看到他直接就找这个

1684
01:06:15,070 --> 01:06:16,660
如果这个为让他就什么也不管

1685
01:06:16,660 --> 01:06:17,800
就直接报错就行了

1686
01:06:18,450 --> 01:06:19,260
直接报就行了

1687
01:06:19,500 --> 01:06:23,820
而这个柱子的逻辑就是在我们这次讲到了这个地方

1688
01:06:26,070 --> 01:06:26,520
这

1689
01:06:28,500 --> 01:06:30,960
Ren der with hooks and or with hooks

1690
01:06:31,570 --> 01:06:32,170
这个地方

1691
01:06:32,820 --> 01:06:34,770
然后这也是设了一个working books

1692
01:06:34,770 --> 01:06:38,790
然后再调了我们刚刚所调的那个所说的那个re considered children

1693
01:06:39,480 --> 01:06:40,290
他其实就是

1694
01:06:41,130 --> 01:06:42,240
我开始调整对不对

1695
01:06:42,240 --> 01:06:44,700
跟我们说看到那个代码一样

1696
01:06:45,760 --> 01:06:46,840
如果等于零的时候

1697
01:06:47,200 --> 01:06:48,640
就MT一个新的

1698
01:06:48,910 --> 01:06:50,230
如果不等于

1699
01:06:50,970 --> 01:06:52,530
Current存在的情况下

1700
01:06:52,530 --> 01:06:54,510
那么他是要进行一个对比的

1701
01:06:55,460 --> 01:06:56,390
再进行一个对比

1702
01:06:56,750 --> 01:06:57,590
再就是

1703
01:06:58,990 --> 01:07:01,090
Function component function

1704
01:07:01,480 --> 01:07:01,990
做事情

1705
01:07:02,730 --> 01:07:03,900
我们再来看一下class

1706
01:07:05,130 --> 01:07:06,600
我们刚刚说的生命周期

1707
01:07:06,930 --> 01:07:08,460
我们来看一下生命周期

1708
01:07:10,110 --> 01:07:13,470
有没有如老师所讲的那样被调用呢

1709
01:07:14,970 --> 01:07:16,650
还是第一位不看

1710
01:07:17,160 --> 01:07:20,010
第一步看他里面写了

1711
01:07:20,810 --> 01:07:21,980
很多的

1712
01:07:24,150 --> 01:07:25,110
ADV

1713
01:07:29,870 --> 01:07:32,660
这这这就有点烦人那天

1714
01:07:35,790 --> 01:07:36,630
这行不行

1715
01:07:39,000 --> 01:07:39,660
高的吧

1716
01:07:42,420 --> 01:07:45,030
那个新的可能我可能我

1717
01:07:46,180 --> 01:07:47,200
烧的那个可好

1718
01:07:47,290 --> 01:07:49,270
有的时候听到

1719
01:07:51,280 --> 01:07:52,300
Class对吧

1720
01:07:52,330 --> 01:07:53,560
他就给了一个社

1721
01:07:54,040 --> 01:07:56,530
是否有context是否context

1722
01:07:57,210 --> 01:07:57,690
然后

1723
01:07:59,310 --> 01:08:00,510
是否youth did not

1724
01:08:01,160 --> 01:08:02,300
如果是stayed not等于

1725
01:08:02,300 --> 01:08:04,460
那那就说明是第一次执行

1726
01:08:04,580 --> 01:08:06,140
因为还是和canon一样

1727
01:08:06,680 --> 01:08:07,610
那个斯诺的

1728
01:08:07,970 --> 01:08:08,870
我先提一嘴

1729
01:08:08,870 --> 01:08:10,520
它储存的是真的大美元素

1730
01:08:11,140 --> 01:08:12,820
就是你那个范儿节点

1731
01:08:13,270 --> 01:08:14,290
他当元素

1732
01:08:14,560 --> 01:08:19,600
它会在它会在我们后面会讲到的complete until work里给他生成好

1733
01:08:20,350 --> 01:08:21,760
而如果是下一次更新

1734
01:08:22,060 --> 01:08:23,890
那么你的这个节点有没有

1735
01:08:24,750 --> 01:08:26,100
有没有这个氮元素

1736
01:08:26,550 --> 01:08:28,050
那么它可以来做一些判断

1737
01:08:29,340 --> 01:08:30,000
这个还好

1738
01:08:30,000 --> 01:08:31,170
这个其实就是一个属性

1739
01:08:31,200 --> 01:08:32,550
放放它的一个属性

1740
01:08:33,060 --> 01:08:34,560
第一次执行走这个

1741
01:08:36,020 --> 01:08:38,840
第二次执行就是如果不是第一次执行

1742
01:08:39,230 --> 01:08:41,000
那么这里会执行

1743
01:08:41,700 --> 01:08:46,380
这个方法你会执行well I MT should component update等等

1744
01:08:46,380 --> 01:08:48,180
生命周期就会执行这个

1745
01:08:48,930 --> 01:08:51,030
而下面这个会自信

1746
01:08:51,810 --> 01:08:54,060
Computer will receive props

1747
01:08:54,850 --> 01:08:59,020
Complete did catch up date the flag

1748
01:08:59,230 --> 01:09:00,280
这大家注意

1749
01:09:00,280 --> 01:09:01,690
这里只是会打上一个flag

1750
01:09:01,840 --> 01:09:05,200
因为他认为的update也好的MT也好

1751
01:09:06,160 --> 01:09:07,840
他也是低的update

1752
01:09:07,840 --> 01:09:09,190
不是慢的dock的

1753
01:09:09,490 --> 01:09:11,080
就说明你的属性更新了吗

1754
01:09:11,290 --> 01:09:12,730
他认为这也是一个副作用

1755
01:09:12,790 --> 01:09:14,140
所以要达成一个标记

1756
01:09:14,870 --> 01:09:16,490
然后执行这个执行他执行他

1757
01:09:16,490 --> 01:09:17,600
我们他比较全

1758
01:09:17,600 --> 01:09:18,320
我们看一下他

1759
01:09:20,230 --> 01:09:21,160
After class

1760
01:09:21,220 --> 01:09:21,910
我们看一下

1761
01:09:23,170 --> 01:09:23,920
这里啊

1762
01:09:23,950 --> 01:09:25,630
很多的这种props对比

1763
01:09:25,630 --> 01:09:26,230
对吧

1764
01:09:26,620 --> 01:09:27,580
我们不用细看

1765
01:09:27,610 --> 01:09:29,470
我们只看他掉没掉

1766
01:09:29,470 --> 01:09:31,660
我们所想要看

1767
01:09:31,690 --> 01:09:33,250
所关心的几个方法

1768
01:09:33,400 --> 01:09:33,880
第一个

1769
01:09:34,150 --> 01:09:35,980
Get drivers seat from props

1770
01:09:36,420 --> 01:09:36,540
好

1771
01:09:36,540 --> 01:09:38,160
我们看到了这个生命周期

1772
01:09:38,370 --> 01:09:39,330
如果它等于function

1773
01:09:39,570 --> 01:09:40,650
他是直接执行呢

1774
01:09:41,350 --> 01:09:42,250
是否会直接执行

1775
01:09:43,680 --> 01:09:45,390
Good drive state from props

1776
01:09:45,510 --> 01:09:47,130
我看一下他在哪咨询

1777
01:09:49,710 --> 01:09:49,980
看

1778
01:09:49,980 --> 01:09:51,480
如果它等于放行

1779
01:09:52,160 --> 01:09:53,720
他会执行他这个

1780
01:09:53,720 --> 01:09:55,490
这个的意思是会执行一个生命

1781
01:09:55,490 --> 01:09:56,720
会执行生命周期

1782
01:09:56,990 --> 01:09:57,980
它会执行这个方法

1783
01:09:58,160 --> 01:10:01,370
但是会给他附上附上首要的职责

1784
01:10:02,320 --> 01:10:03,220
附上谁的字

1785
01:10:03,760 --> 01:10:07,390
然后这下面的这还是上面的一个

1786
01:10:09,620 --> 01:10:12,890
会执行component will receive props就在这里执行的

1787
01:10:14,430 --> 01:10:15,600
他的对比很简单

1788
01:10:15,600 --> 01:10:16,830
就是props不一致

1789
01:10:17,340 --> 01:10:20,280
就执行这个component will receive props

1790
01:10:20,310 --> 01:10:22,980
但现在已经给他标上了UN safe的一个标记了

1791
01:10:24,550 --> 01:10:25,570
On set的一个标记了

1792
01:10:26,050 --> 01:10:28,300
然后下面是滴的update

1793
01:10:28,300 --> 01:10:31,210
大家看的到update之前有同学就很疑惑

1794
01:10:31,210 --> 01:10:32,200
说的的update呢

1795
01:10:32,200 --> 01:10:33,400
不是在认的

1796
01:10:33,400 --> 01:10:37,390
就是和那个component did mount的时机一致的

1797
01:10:37,630 --> 01:10:38,500
差不多一致的吗

1798
01:10:38,500 --> 01:10:39,670
为什么会在这里用

1799
01:10:40,260 --> 01:10:42,240
这实际上只是给他打了一个flex

1800
01:10:42,990 --> 01:10:44,700
就说明有东西更新了

1801
01:10:44,820 --> 01:10:46,680
她也是认为它也它是一个副作用

1802
01:10:47,430 --> 01:10:48,930
给snapshot before update

1803
01:10:50,450 --> 01:10:54,620
这个同样也是这个含这个生命周期同样也是在什么呢

1804
01:10:54,620 --> 01:10:55,310
也是在

1805
01:10:56,040 --> 01:10:57,660
那也是在康复的阶段

1806
01:10:57,660 --> 01:10:59,010
就是那个阶段执行的

1807
01:10:59,960 --> 01:11:01,670
所以也是打上一个标记

1808
01:11:01,700 --> 01:11:02,990
就这两个打上了标记

1809
01:11:03,780 --> 01:11:04,350
这个是

1810
01:11:05,460 --> 01:11:07,590
给drive that said from props自信了

1811
01:11:08,200 --> 01:11:08,920
这一次行了

1812
01:11:09,830 --> 01:11:12,800
Get the should component update执行了

1813
01:11:12,890 --> 01:11:13,910
如果这个为醋

1814
01:11:14,930 --> 01:11:17,270
那么就认为值逐渐会更新

1815
01:11:18,580 --> 01:11:19,330
如果说come

1816
01:11:19,390 --> 01:11:21,310
如果说the update啊

1817
01:11:21,310 --> 01:11:22,630
这这不对

1818
01:11:22,630 --> 01:11:22,900
同学

1819
01:11:22,900 --> 01:11:23,560
我说错了

1820
01:11:24,040 --> 01:11:26,080
这只是判断她是否需要update

1821
01:11:26,260 --> 01:11:28,720
如果需要update它才会执行

1822
01:11:30,470 --> 01:11:32,120
Compared with up的生命周期

1823
01:11:33,360 --> 01:11:35,400
这里complete will update

1824
01:11:36,280 --> 01:11:36,940
会自信

1825
01:11:38,200 --> 01:11:38,770
你好

1826
01:11:39,640 --> 01:11:40,930
这也是打上标记

1827
01:11:42,420 --> 01:11:43,590
好差不多了

1828
01:11:43,740 --> 01:11:45,090
差不多就到这里

1829
01:11:45,570 --> 01:11:46,470
差不多就到这里

1830
01:11:46,620 --> 01:11:48,630
而他的函数体的执行

1831
01:11:50,380 --> 01:11:52,510
我们刚这讲的是

1832
01:11:54,060 --> 01:11:54,870
他的点润

1833
01:11:55,020 --> 01:11:56,640
它的函数体的执行

1834
01:11:56,790 --> 01:11:59,400
就是构建发那个执行肯定是执行典render

1835
01:11:59,430 --> 01:11:59,760
对不对

1836
01:11:59,910 --> 01:12:00,660
执行点render

1837
01:12:00,960 --> 01:12:03,690
我们可以看一下它的典render

1838
01:12:04,660 --> 01:12:06,070
执行了这么多生命周期

1839
01:12:06,940 --> 01:12:07,150
对

1840
01:12:07,180 --> 01:12:10,750
前面这个这个地方执行的是render

1841
01:12:10,750 --> 01:12:13,060
之前的所有的生命周期基本上都执行了

1842
01:12:13,570 --> 01:12:14,410
接下来

1843
01:12:15,160 --> 01:12:16,030
他会执行

1844
01:12:16,790 --> 01:12:17,900
生命值的

1845
01:12:18,200 --> 01:12:21,530
也就是如果是方向的肯定就执行函数体

1846
01:12:21,890 --> 01:12:22,850
这就执行end

1847
01:12:22,850 --> 01:12:23,330
我们看

1848
01:12:24,960 --> 01:12:26,220
我看一下关键的

1849
01:12:32,700 --> 01:12:33,780
大家看

1850
01:12:33,780 --> 01:12:35,820
Instance典render执行了

1851
01:12:35,820 --> 01:12:37,230
得到了新的东西

1852
01:12:37,960 --> 01:12:38,980
得到了子节点

1853
01:12:40,250 --> 01:12:41,240
他可能不止一个嘛

1854
01:12:41,240 --> 01:12:41,600
对吧

1855
01:12:41,690 --> 01:12:44,000
得了得到了节点

1856
01:12:44,000 --> 01:12:45,320
然后后面再做处理

1857
01:12:45,960 --> 01:12:47,250
这就是生命周期的执行

1858
01:12:47,670 --> 01:12:49,260
这块能明白吗同学们

1859
01:12:50,060 --> 01:12:51,290
给大家看了一下

1860
01:12:53,510 --> 01:12:56,660
我们的begin work做的事情大概就是这么几件了

1861
01:12:57,510 --> 01:12:58,680
能能明白嘛

1862
01:12:58,680 --> 01:13:00,270
有不懂有不明白的地方吗

1863
01:13:02,600 --> 01:13:04,160
如果明白的话扣个一

1864
01:13:04,790 --> 01:13:05,840
不明白扣个零

1865
01:13:12,120 --> 01:13:14,010
我在大概捋一遍大概捋一遍

1866
01:13:16,060 --> 01:13:17,080
行行

1867
01:13:17,870 --> 01:13:21,110
然后dif的话就下半节课继续讲

1868
01:13:21,110 --> 01:13:22,970
下半节课就是呆会儿会继续讲

1869
01:13:22,970 --> 01:13:25,010
因为complete until work还没讲完呢

1870
01:13:25,640 --> 01:13:27,410
现在时间已经过了一个小时了

1871
01:13:27,410 --> 01:13:28,610
大家可以休息五分钟

1872
01:13:29,120 --> 01:13:30,170
去喝点水

1873
01:13:30,560 --> 01:13:31,580
然后上个厕所

1874
01:13:32,300 --> 01:13:34,880
我们03:10的时候继续

1875
01:13:46,600 --> 01:13:48,220
刚刚我们跳代码跳的快不快

1876
01:13:48,610 --> 01:13:49,930
大家能跟得上吗

1877
01:13:50,500 --> 01:13:53,890
因为以前的时候直接就没有这个文档

1878
01:13:54,130 --> 01:13:55,180
就直接挑代码

1879
01:13:55,570 --> 01:13:58,000
然后大家反应就是经常被绕晕

1880
01:13:58,760 --> 01:14:00,260
因为因为函数太多了

1881
01:14:13,860 --> 01:14:15,030
还是太猛了

1882
01:14:24,280 --> 01:14:26,980
所以那那你看我这里看我这里就行

1883
01:14:27,900 --> 01:14:29,070
看到这边这个地方吗

1884
01:14:30,030 --> 01:14:32,190
就是在class com那里

1885
01:14:33,220 --> 01:14:36,520
北京这个大家下下来把那个代码发给大家

1886
01:14:36,520 --> 01:14:39,130
大家自己去跳来大家自己去跳吧

1887
01:14:39,960 --> 01:14:44,280
反正可以看到就是它其实也就是要紧的那几个函数

1888
01:14:45,240 --> 01:14:46,080
要剪就开始

1889
01:14:46,110 --> 01:14:48,720
这可能生命周期因为比较多嘛

1890
01:14:49,110 --> 01:14:49,320
对吧

1891
01:14:49,320 --> 01:14:50,220
生命周期比较多

1892
01:14:51,080 --> 01:14:51,890
可能跳得比较

1893
01:14:52,670 --> 01:14:53,540
跳得比较厉害

1894
01:14:55,500 --> 01:14:56,310
大家申请吧

1895
01:14:56,310 --> 01:14:56,790
申请

1896
01:14:57,620 --> 01:14:58,400
我给大家

1897
01:15:02,460 --> 01:15:02,850
没有钱

1898
01:15:02,850 --> 01:15:04,830
现在申请给他加这个后面会发的

1899
01:15:05,310 --> 01:15:07,140
因为现在可能会有一些补充

1900
01:15:07,140 --> 01:15:09,570
所以不适合一开始就发

1901
01:16:17,410 --> 01:16:19,000
手机上就别打开了

1902
01:16:19,150 --> 01:16:19,960
用电脑吧

1903
01:16:20,170 --> 01:16:22,360
手机上他不一定支持

1904
01:16:22,750 --> 01:16:24,100
我也不知道它支不支持手机

1905
01:16:33,850 --> 01:16:36,670
后面会把这个给大家弄成一个PDF

1906
01:16:36,880 --> 01:16:37,300
然后

1907
01:16:37,920 --> 01:16:38,520
然后呢

1908
01:16:39,250 --> 01:16:40,270
链接分享给大家

1909
01:16:40,270 --> 01:16:41,140
大家可以申请

1910
01:16:43,080 --> 01:16:44,250
然后在PC上看

1911
01:16:44,550 --> 01:16:45,390
如果有PDF

1912
01:16:45,390 --> 01:16:46,620
后面有PDF了

1913
01:16:47,570 --> 01:16:48,710
后面有PDF了

1914
01:16:48,710 --> 01:16:49,220
大家

1915
01:16:49,970 --> 01:16:51,830
就就可以在手机上查看

1916
01:16:53,080 --> 01:16:55,270
现在他可能不支持吧

1917
01:16:55,660 --> 01:16:56,590
好久没弄这个

1918
01:16:57,400 --> 01:16:58,690
好久好久

1919
01:16:59,980 --> 01:17:01,210
好久没有打开过了

1920
01:17:01,210 --> 01:17:02,110
已经不太清楚

1921
01:17:24,340 --> 01:17:25,180
时间嘛

1922
01:17:25,330 --> 01:17:26,350
时间后面有

1923
01:17:29,880 --> 01:17:30,210
好

1924
01:17:31,140 --> 01:17:32,430
时间到了

1925
01:17:32,940 --> 01:17:33,990
我们就接着讲吧

1926
01:17:34,620 --> 01:17:37,410
同学们回来了没

1927
01:17:43,440 --> 01:17:45,480
就是也感觉有bug

1928
01:17:52,240 --> 01:17:53,350
是感觉bug吧

1929
01:17:53,560 --> 01:17:55,030
这里好几个百米与乐趣

1930
01:18:10,450 --> 01:18:10,690
好吧

1931
01:18:10,690 --> 01:18:11,350
这也不重要

1932
01:18:11,860 --> 01:18:12,670
不重要继续吧

1933
01:18:14,170 --> 01:18:17,140
接下来是complete complete until work

1934
01:18:18,370 --> 01:18:19,000
这个东西

1935
01:18:21,380 --> 01:18:23,600
上面我们讲了begin work的事情

1936
01:18:23,630 --> 01:18:24,980
现在completely UN work

1937
01:18:25,650 --> 01:18:28,830
他首先他要做的第一件事情就是向上递归

1938
01:18:29,100 --> 01:18:29,370
对吧

1939
01:18:29,430 --> 01:18:31,170
向上的compete complete work

1940
01:18:31,170 --> 01:18:32,130
这个大家讲到了

1941
01:18:32,280 --> 01:18:34,770
他是构建faculty的一个非常重要的一个过程

1942
01:18:35,370 --> 01:18:37,920
他做的做的第二件事情就是创建DOM节点

1943
01:18:38,160 --> 01:18:39,570
更新或者更新DOM节点

1944
01:18:40,260 --> 01:18:40,770
然后呢

1945
01:18:40,770 --> 01:18:42,990
把DOM节点赋值给state not

1946
01:18:43,950 --> 01:18:44,430
第三

1947
01:18:45,060 --> 01:18:47,100
他是把子节点叫做city fact

1948
01:18:47,130 --> 01:18:48,330
什么city fact呢

1949
01:18:49,070 --> 01:18:49,970
City fact

1950
01:18:50,300 --> 01:18:51,440
这里的sit in fact

1951
01:18:52,720 --> 01:18:53,710
这里的CD pack

1952
01:18:53,710 --> 01:18:54,790
它是指的是

1953
01:18:55,480 --> 01:18:57,430
一个链条也也是一个链表

1954
01:18:57,490 --> 01:19:00,310
但这个链表是只是有更新的

1955
01:19:00,370 --> 01:19:03,640
比如有根就是需要有更新的节点的

1956
01:19:04,350 --> 01:19:05,940
FAB有更新的FAB节点

1957
01:19:06,120 --> 01:19:09,030
他会通通的放到这个c de fec链条上去

1958
01:19:10,060 --> 01:19:15,910
然后子节点的CDC的链条又会附加到父节点的CF链条之上

1959
01:19:16,630 --> 01:19:18,760
这个也是在康蜜的阶段备用的

1960
01:19:19,580 --> 01:19:21,590
我们的这个单节点复制给斯诺的属性

1961
01:19:21,590 --> 01:19:22,280
它也是在

1962
01:19:22,280 --> 01:19:24,830
com的阶段备用的

1963
01:19:24,830 --> 01:19:25,220
第四

1964
01:19:25,220 --> 01:19:26,210
存在兄弟节点

1965
01:19:26,210 --> 01:19:27,950
将working progress指向新的节点

1966
01:19:28,560 --> 01:19:29,460
执行兄弟节点呢

1967
01:19:29,460 --> 01:19:30,510
Begin work的过程

1968
01:19:30,630 --> 01:19:35,760
这个也是之前讲到的整个federal trade构建过程的一个很重要的部分

1969
01:19:36,830 --> 01:19:37,550
同样也是

1970
01:19:37,550 --> 01:19:38,240
这个也讲过了

1971
01:19:38,240 --> 01:19:39,470
就不多说了

1972
01:19:40,630 --> 01:19:44,710
然后这在complete work里我们看到这个循环

1973
01:19:44,710 --> 01:19:44,980
对吧

1974
01:19:45,100 --> 01:19:48,940
也就是说如果是整个构件设备处于一个双重循环

1975
01:19:49,520 --> 01:19:50,360
除以三种循环

1976
01:19:50,780 --> 01:19:53,270
第一个循环就是上面那个大外耳

1977
01:19:53,420 --> 01:19:58,250
大外那个那个第一层刑事处理working progress就是指节点

1978
01:19:58,310 --> 01:19:59,240
一直处理节点

1979
01:20:00,330 --> 01:20:02,670
Complete a walk的这个小循环

1980
01:20:03,330 --> 01:20:04,560
它处理的是什么

1981
01:20:04,950 --> 01:20:06,990
他处理的是生理节点

1982
01:20:07,020 --> 01:20:08,250
以及返回的父节点

1983
01:20:08,610 --> 01:20:09,360
返回节点

1984
01:20:09,750 --> 01:20:11,880
那么这可以回答之前呢

1985
01:20:11,880 --> 01:20:14,220
把这几个代码讲完了之后

1986
01:20:14,220 --> 01:20:16,800
就可以回答一个非常重要的问题就是

1987
01:20:17,630 --> 01:20:21,770
为什么他一定是从下从上到下

1988
01:20:22,130 --> 01:20:23,630
他为什么选择从上到下

1989
01:20:23,810 --> 01:20:25,460
就然后再从下

1990
01:20:25,460 --> 01:20:27,560
然后一级一级的返回的这种形式

1991
01:20:28,160 --> 01:20:28,880
原因是什么呢

1992
01:20:29,270 --> 01:20:30,620
我们来看一下他做的事情

1993
01:20:31,010 --> 01:20:33,620
比如他执行的一个complete work的方法

1994
01:20:34,280 --> 01:20:35,390
这个complete work

1995
01:20:36,130 --> 01:20:39,220
它主要的逻辑是在MT的阶段创建DOM节点

1996
01:20:39,550 --> 01:20:43,420
并且将子孙DOM节点插入到刚生成的DOM节点中

1997
01:20:44,020 --> 01:20:45,550
赋值给c note保存备用

1998
01:20:45,550 --> 01:20:46,030
一句话

1999
01:20:46,240 --> 01:20:46,990
创建节点

2000
01:20:48,040 --> 01:20:48,820
更新的时候

2001
01:20:49,150 --> 01:20:50,230
由于当前创建过

2002
01:20:50,230 --> 01:20:51,850
于是更新一些属性就可以

2003
01:20:52,970 --> 01:20:54,080
这是第一件事情

2004
01:20:54,260 --> 01:20:59,570
第二件事情把子弟CD fac的附加在附近的CD fac电视上

2005
01:20:59,600 --> 01:21:03,290
大家看这实际上是一个链表的一个链表的一个拼接

2006
01:21:03,890 --> 01:21:04,580
Richer发表

2007
01:21:04,580 --> 01:21:07,070
我们讲了瑞特fiber是他的父节点

2008
01:21:07,750 --> 01:21:08,260
绿茶婊

2009
01:21:08,260 --> 01:21:09,880
父节点看也看得明白对不对

2010
01:21:10,420 --> 01:21:11,260
父节点呢

2011
01:21:12,520 --> 01:21:15,490
那个副作用链条不等于那等于浪的话

2012
01:21:15,760 --> 01:21:17,110
那么就把直接点了

2013
01:21:17,800 --> 01:21:18,820
这个是我们直接点

2014
01:21:18,880 --> 01:21:20,260
这是我们当前的这个直接点

2015
01:21:20,710 --> 01:21:22,720
直接点的链条复制给他

2016
01:21:23,170 --> 01:21:23,710
如果

2017
01:21:24,990 --> 01:21:29,610
父节点的那个链条不等于不等于浪就是有

2018
01:21:29,880 --> 01:21:33,090
那么就把他的这个first effect它复制给

2019
01:21:33,880 --> 01:21:37,690
他的lasteffect.next effect意思是什么

2020
01:21:37,690 --> 01:21:42,670
意思就是夹在父节点的那个副作用链条的最后一位

2021
01:21:42,910 --> 01:21:43,300
对不对

2022
01:21:43,330 --> 01:21:45,670
那是不是就给他相当于给他拼接到付几点呢

2023
01:21:45,880 --> 01:21:47,650
City fact链条之上了

2024
01:21:47,950 --> 01:21:50,890
而这个city effect我讲到了这个CD fec

2025
01:21:50,890 --> 01:21:53,860
他指的就是有更新的发展节点

2026
01:21:54,160 --> 01:21:55,540
有任何更新的发展节点

2027
01:21:57,930 --> 01:21:59,310
而她找的这个发布节点

2028
01:22:00,710 --> 01:22:02,780
通过我们这种方式

2029
01:22:04,690 --> 01:22:05,560
通过我们的

2030
01:22:05,740 --> 01:22:07,870
我们再把画一幅刚刚画的那个图

2031
01:22:08,710 --> 01:22:10,330
大家看从上到下

2032
01:22:10,330 --> 01:22:11,380
假如现在走到这儿了

2033
01:22:11,890 --> 01:22:12,880
我们走到最下面了

2034
01:22:12,880 --> 01:22:13,390
对不对

2035
01:22:13,390 --> 01:22:14,920
到最下边了现在

2036
01:22:15,600 --> 01:22:17,730
假如他我已经产生了一个effect

2037
01:22:17,880 --> 01:22:19,200
我已经产生了一个副作用

2038
01:22:19,230 --> 01:22:23,730
比如我们有一个有一个单元素发生属性的变化

2039
01:22:26,070 --> 01:22:27,840
有个大圆杀生的属性的变化

2040
01:22:27,870 --> 01:22:29,550
那么我拥有了一个effect

2041
01:22:30,370 --> 01:22:30,910
然后呢

2042
01:22:31,180 --> 01:22:32,140
当他回去的时候

2043
01:22:32,140 --> 01:22:34,210
他就把这个发给富也富集了

2044
01:22:34,720 --> 01:22:35,500
而负极呢

2045
01:22:35,800 --> 01:22:37,330
他同样有自己的effect

2046
01:22:37,960 --> 01:22:38,500
然后呢

2047
01:22:38,830 --> 01:22:39,730
复制的effect

2048
01:22:39,730 --> 01:22:41,020
再加上直接点effect

2049
01:22:41,020 --> 01:22:42,040
他又复制一个负极

2050
01:22:42,460 --> 01:22:44,260
这副又反馈给负极

2051
01:22:44,560 --> 01:22:45,670
然后负极又有了

2052
01:22:46,320 --> 01:22:47,280
好几个effect

2053
01:22:47,460 --> 01:22:48,870
那么又把所有的加上

2054
01:22:49,410 --> 01:22:50,340
然后一直是法人

2055
01:22:50,340 --> 01:22:50,790
一直返回

2056
01:22:50,790 --> 01:22:52,530
直到返回根节点

2057
01:22:53,010 --> 01:22:56,100
但返回根节点大家发现一件事情就是

2058
01:22:56,100 --> 01:23:00,660
我更节点的这个IP的链条就包含了下面所有的effect

2059
01:23:01,210 --> 01:23:03,220
也就是说他汇总

2060
01:23:03,220 --> 01:23:05,890
他把所有的要更新的节点的这个一份量

2061
01:23:06,640 --> 01:23:08,890
已经全部汇总到我们的根节点了

2062
01:23:08,920 --> 01:23:11,530
那么下一次如果在咖啡的节点

2063
01:23:11,920 --> 01:23:12,760
com的阶段

2064
01:23:12,760 --> 01:23:14,380
我想要获取哪些

2065
01:23:14,530 --> 01:23:16,720
我想要对已经更新的节点做处理

2066
01:23:17,140 --> 01:23:18,400
那么就是不是很方便

2067
01:23:18,790 --> 01:23:19,420
不是很方便

2068
01:23:19,420 --> 01:23:25,150
因为我只需要找到这个working process fiber的那个root

2069
01:23:25,300 --> 01:23:26,110
就是根结点

2070
01:23:26,260 --> 01:23:27,580
Working process的根节点

2071
01:23:27,940 --> 01:23:29,320
然后拿到它的链条

2072
01:23:29,440 --> 01:23:31,000
拿到它的这个F链

2073
01:23:31,000 --> 01:23:33,010
就瞬间就知道了所有的

2074
01:23:34,470 --> 01:23:36,180
更新的要需要更新的版本

2075
01:23:36,180 --> 01:23:38,430
需要处理更新的版本节点全部拿到了

2076
01:23:39,100 --> 01:23:40,120
同时什么呢

2077
01:23:40,300 --> 01:23:41,560
由于我们的

2078
01:23:42,200 --> 01:23:43,490
由于我们的这个

2079
01:23:44,180 --> 01:23:45,800
同时也已经创建了

2080
01:23:46,790 --> 01:23:47,690
当当元素

2081
01:23:47,690 --> 01:23:49,490
我们的氮元素同样也是这样

2082
01:23:50,030 --> 01:23:53,960
一级一级的会把它插入插入DOS de note里

2083
01:23:54,410 --> 01:23:55,850
因为它有两个属性

2084
01:23:55,850 --> 01:23:56,750
一个struts

2085
01:23:57,940 --> 01:24:01,120
External的另外一个working progress啊

2086
01:24:01,330 --> 01:24:03,910
就是那个F链条这两个属性

2087
01:24:04,710 --> 01:24:08,640
都是都是下面子节点全部汇总上来的

2088
01:24:08,970 --> 01:24:10,110
那么他处理起来的话

2089
01:24:10,530 --> 01:24:13,350
那么在在computer阶段处理起来的话

2090
01:24:13,350 --> 01:24:14,610
就不需要再遍历一次了

2091
01:24:14,640 --> 01:24:16,230
就只需要取来用就行了

2092
01:24:17,010 --> 01:24:17,910
这就决定了

2093
01:24:17,910 --> 01:24:20,190
这就是为什么从下到上

2094
01:24:21,090 --> 01:24:27,480
他做的事情做得非常的就是就是使用这一次循环使用的非常的充分

2095
01:24:27,840 --> 01:24:28,200
对不对

2096
01:24:28,440 --> 01:24:30,840
就不需要后面我们用不用再

2097
01:24:31,540 --> 01:24:34,030
在这样子整整体的再来一遍了嘛

2098
01:24:34,030 --> 01:24:34,330
对吧

2099
01:24:36,310 --> 01:24:37,870
Complete work我们刚刚讲了

2100
01:24:38,800 --> 01:24:40,120
他是创建的节点

2101
01:24:40,240 --> 01:24:42,220
在这里创建的节点

2102
01:24:43,240 --> 01:24:44,020
这48

2103
01:24:44,640 --> 01:24:46,890
子孙的大节点插入到刚生成的大门

2104
01:24:46,890 --> 01:24:47,430
几点钟

2105
01:24:48,080 --> 01:24:49,190
其实也就是给父级嘛

2106
01:24:49,190 --> 01:24:49,430
对吧

2107
01:24:49,430 --> 01:24:50,690
把尺寸的叉给我

2108
01:24:51,140 --> 01:24:52,880
我再给父级

2109
01:24:52,910 --> 01:24:54,350
然后一直一直给他更几点

2110
01:24:54,800 --> 01:24:59,150
最后把这个创建好的到极点复制给了斯塔诺的属性

2111
01:24:59,870 --> 01:25:01,010
复制给山东数据

2112
01:25:01,760 --> 01:25:06,170
这就是complete a walk complete until work做这个事情

2113
01:25:06,820 --> 01:25:09,610
我们接下来来一个总的汇总

2114
01:25:09,670 --> 01:25:11,620
一个总的汇总做了什么事情

2115
01:25:12,370 --> 01:25:14,590
一个总整整体的汇总就出现了

2116
01:25:16,200 --> 01:25:18,570
整体的汇总出现了

2117
01:25:18,870 --> 01:25:22,140
从句构建February开始构建February

2118
01:25:22,380 --> 01:25:23,490
从他

2119
01:25:24,780 --> 01:25:27,120
跟分别是一个非常重要的一个字段

2120
01:25:27,120 --> 01:25:28,590
叫做working progress对吧

2121
01:25:28,620 --> 01:25:31,440
他就是从根结点一直往下创建

2122
01:25:31,440 --> 01:25:32,310
一直往下创建

2123
01:25:33,950 --> 01:25:35,000
这图还是亮起来

2124
01:25:37,330 --> 01:25:38,050
我

2125
01:25:39,800 --> 01:25:40,490
做二个吧

2126
01:25:41,520 --> 01:25:42,090
别乱

2127
01:25:46,580 --> 01:25:47,540
这是根节点

2128
01:25:47,660 --> 01:25:48,200
好

2129
01:25:57,620 --> 01:25:58,670
我以class举例

2130
01:25:58,820 --> 01:25:59,930
假设全是class组件

2131
01:26:00,410 --> 01:26:04,940
那么我听我在创建粉碎首先从上往下

2132
01:26:04,970 --> 01:26:06,410
从上到下的流程

2133
01:26:08,550 --> 01:26:09,510
从上到下的流程

2134
01:26:09,510 --> 01:26:12,660
那么他肯定是走这样的一个县的

2135
01:26:12,690 --> 01:26:13,980
就是走这样的一个县

2136
01:26:15,040 --> 01:26:15,550
然后呢

2137
01:26:16,150 --> 01:26:19,360
我们的working proxy一点就一级级往下至儿在

2138
01:26:20,510 --> 01:26:23,360
每次都会创建一个子节点

2139
01:26:24,610 --> 01:26:26,020
每次都会创建一个子节点

2140
01:26:26,170 --> 01:26:26,950
创建子节点

2141
01:26:27,190 --> 01:26:27,580
然后呢

2142
01:26:27,580 --> 01:26:29,290
又把它复制给working progress

2143
01:26:29,740 --> 01:26:31,210
复制给working progress

2144
01:26:32,640 --> 01:26:34,140
负责给working progress

2145
01:26:35,720 --> 01:26:37,400
而创建这个节点过程

2146
01:26:37,760 --> 01:26:38,990
创建子节点的过程

2147
01:26:38,990 --> 01:26:41,270
毫无疑问他肯定是要执行生命周期的

2148
01:26:41,900 --> 01:26:42,260
因为

2149
01:26:42,350 --> 01:26:43,700
因为你的直接点在哪里

2150
01:26:43,700 --> 01:26:46,190
在你的render函数中的函数中

2151
01:26:46,310 --> 01:26:49,190
所以每执行一个begin work

2152
01:26:49,490 --> 01:26:53,690
那么你的render以及render之前生命周期就已经被执行了

2153
01:26:54,080 --> 01:26:54,920
已经被执行了

2154
01:26:55,310 --> 01:26:56,120
然后呢

2155
01:26:56,120 --> 01:26:57,020
再从下到上

2156
01:26:57,560 --> 01:26:58,700
从下到上的时候

2157
01:26:58,880 --> 01:26:59,450
那么他

2158
01:27:00,310 --> 01:27:00,730
同样

2159
01:27:00,730 --> 01:27:01,180
他会

2160
01:27:01,940 --> 01:27:02,960
得到你的这个

2161
01:27:03,050 --> 01:27:05,180
它首先会有city fact

2162
01:27:05,970 --> 01:27:06,570
键桥

2163
01:27:08,180 --> 01:27:08,990
菲菲链条

2164
01:27:09,230 --> 01:27:10,880
然后往上

2165
01:27:12,390 --> 01:27:14,190
把这个city fac复制给他

2166
01:27:14,370 --> 01:27:14,730
然后呢

2167
01:27:14,730 --> 01:27:15,540
Send log

2168
01:27:16,420 --> 01:27:18,070
也复制给他的那个

2169
01:27:18,340 --> 01:27:19,840
插入到他的CF里

2170
01:27:20,460 --> 01:27:20,940
然后呢

2171
01:27:21,660 --> 01:27:22,230
在这里

2172
01:27:22,500 --> 01:27:23,310
同样也是

2173
01:27:24,000 --> 01:27:25,950
把c de fines垫片往上浮

2174
01:27:26,650 --> 01:27:27,250
嗯

2175
01:27:28,120 --> 01:27:29,920
赛得诺的同样也差了

2176
01:27:29,920 --> 01:27:32,200
他决定就一直往上差

2177
01:27:32,230 --> 01:27:36,400
最后最后回到最上层的这个root的时候

2178
01:27:36,820 --> 01:27:37,210
那么

2179
01:27:37,990 --> 01:27:38,740
同首先

2180
01:27:38,740 --> 01:27:40,240
February构建完成了

2181
01:27:40,240 --> 01:27:42,220
在February构建完成的这一瞬间

2182
01:27:42,850 --> 01:27:46,540
他同样他得到了所有的有副作用的CD fact链条

2183
01:27:47,120 --> 01:27:47,750
得到了

2184
01:27:48,880 --> 01:27:50,830
得到了一个整体的一个said nod

2185
01:27:51,310 --> 01:27:53,860
得到一个整总体的总体的一个signal

2186
01:27:54,830 --> 01:27:56,900
都在这个跟根节点上

2187
01:27:57,260 --> 01:27:59,480
那么后面要处理的时候就很方便了

2188
01:27:59,930 --> 01:28:00,440
关于这点

2189
01:28:00,440 --> 01:28:02,870
大家能明白的扣一个一

2190
01:28:02,900 --> 01:28:04,100
不能明白的扣一个零

2191
01:28:06,240 --> 01:28:07,050
可以明白吗

2192
01:28:15,030 --> 01:28:15,840
其他同学呢

2193
01:28:24,640 --> 01:28:25,150
可以呀

2194
01:28:25,210 --> 01:28:27,040
兄弟节点同样也是一样的

2195
01:28:27,070 --> 01:28:29,140
兄弟节点他写的CD fac

2196
01:28:29,140 --> 01:28:30,820
他同样会返回给父节点

2197
01:28:31,150 --> 01:28:34,000
再返回复检的那一刻就复制给父节点

2198
01:28:36,470 --> 01:28:36,710
对吧

2199
01:28:36,710 --> 01:28:37,610
插上去就行了

2200
01:28:39,290 --> 01:28:42,560
没明白链条从底下往上走的时候的连接顺序

2201
01:28:47,280 --> 01:28:49,680
那就是那就是一开始这个February

2202
01:28:51,670 --> 01:28:53,470
发射出的逻辑还没明白

2203
01:28:56,340 --> 01:28:56,940
挑战嘛

2204
01:28:56,940 --> 01:28:57,300
对吧

2205
01:29:01,530 --> 01:29:02,400
这里是不是一

2206
01:29:03,170 --> 01:29:03,680
二

2207
01:29:04,590 --> 01:29:05,280
三

2208
01:29:06,070 --> 01:29:06,670
是啊

2209
01:29:07,740 --> 01:29:08,310
然后呢

2210
01:29:08,400 --> 01:29:09,150
走到这儿

2211
01:29:10,230 --> 01:29:11,850
他的next就等于空了

2212
01:29:11,880 --> 01:29:14,130
就是begin work里的next就已经是烂了

2213
01:29:14,130 --> 01:29:15,120
因为他没有直接点了

2214
01:29:15,540 --> 01:29:18,390
然后他就进到complete until work里

2215
01:29:19,440 --> 01:29:20,220
在这里边儿

2216
01:29:20,800 --> 01:29:22,240
他会复制它会

2217
01:29:23,320 --> 01:29:24,700
去判断他有没有病

2218
01:29:25,030 --> 01:29:26,140
如果有病的话

2219
01:29:26,140 --> 01:29:28,270
就把sub Lin复制给了working progress

2220
01:29:28,480 --> 01:29:30,310
所以这里是第五个节点

2221
01:29:30,430 --> 01:29:31,780
这点能能明白吗

2222
01:29:31,810 --> 01:29:32,620
能明白吗

2223
01:29:32,980 --> 01:29:34,030
所以这里是第五个节点

2224
01:29:34,030 --> 01:29:34,630
能明白吗

2225
01:29:35,140 --> 01:29:38,830
然后因为他又复制给了working progress working progress又有了

2226
01:29:39,130 --> 01:29:40,840
他又执行working progress

2227
01:29:40,840 --> 01:29:41,620
只要不等于那

2228
01:29:41,890 --> 01:29:44,530
那么他就会找他的翘的

2229
01:29:44,980 --> 01:29:46,120
又会找她的翘的

2230
01:29:46,510 --> 01:29:47,740
它翘的又存在

2231
01:29:47,770 --> 01:29:48,130
对不对

2232
01:29:48,130 --> 01:29:49,120
这是存在的

2233
01:29:49,390 --> 01:29:50,560
所以它是第六个节点

2234
01:29:53,060 --> 01:29:55,040
然后现在翘的没有了

2235
01:29:55,400 --> 01:29:57,170
那么next又被控了

2236
01:29:59,140 --> 01:30:01,660
她又进入到了work in progress until work里

2237
01:30:01,900 --> 01:30:02,380
现在

2238
01:30:02,860 --> 01:30:05,560
但是进入到了complete until work early

2239
01:30:05,560 --> 01:30:06,040
它的

2240
01:30:07,530 --> 01:30:08,820
他的兄弟姐妹也没有

2241
01:30:09,440 --> 01:30:10,730
兄弟没有会干什么

2242
01:30:14,010 --> 01:30:15,120
兄弟几点会干

2243
01:30:15,150 --> 01:30:16,560
兄弟节点没有的时候

2244
01:30:19,750 --> 01:30:20,980
看没有兄弟节点的时候

2245
01:30:21,600 --> 01:30:24,060
他的return the favor等于work in progress

2246
01:30:26,370 --> 01:30:27,450
等于complete work

2247
01:30:27,480 --> 01:30:28,380
等于complete work

2248
01:30:28,830 --> 01:30:31,860
于是她是不是她就指向了他

2249
01:30:32,040 --> 01:30:33,510
是不是就指向他的父节点了

2250
01:30:34,620 --> 01:30:35,070
对不对

2251
01:30:35,720 --> 01:30:36,740
直接他的父节点了

2252
01:30:37,010 --> 01:30:38,810
然后现在这副节点

2253
01:30:38,900 --> 01:30:40,340
我们这个节点有没有设备

2254
01:30:40,850 --> 01:30:41,720
没有设备呢

2255
01:30:42,950 --> 01:30:44,600
他是不是又回到这个副节点了

2256
01:30:44,720 --> 01:30:46,010
他他上一个父节点

2257
01:30:47,170 --> 01:30:48,160
回到这个父节点

2258
01:30:48,670 --> 01:30:52,270
这个父节点有没有什么练弹跳的设备吗

2259
01:30:52,940 --> 01:30:53,660
尤瑟不定

2260
01:30:54,660 --> 01:30:55,410
那么是不是

2261
01:30:56,560 --> 01:30:57,670
一个spring的情况下

2262
01:30:57,730 --> 01:31:00,220
那么它的split就成了第六个点

2263
01:31:00,220 --> 01:31:02,260
因为它又复制给working progress

2264
01:31:02,680 --> 01:31:04,570
然后他又有了

2265
01:31:05,220 --> 01:31:05,730
直接点

2266
01:31:07,680 --> 01:31:08,430
到了七

2267
01:31:10,130 --> 01:31:10,580
然后呢

2268
01:31:10,580 --> 01:31:11,270
如果没有的话

2269
01:31:11,270 --> 01:31:12,260
它又会返回三

2270
01:31:14,620 --> 01:31:15,190
然后就

2271
01:31:17,320 --> 01:31:17,740
二

2272
01:31:19,700 --> 01:31:20,120
他

2273
01:31:20,740 --> 01:31:22,660
返回到这个这一层的时候

2274
01:31:22,810 --> 01:31:23,800
他也有兄弟节点

2275
01:31:24,660 --> 01:31:25,110
对不对

2276
01:31:25,200 --> 01:31:25,920
这就是吧

2277
01:31:26,730 --> 01:31:27,270
然后呢

2278
01:31:27,360 --> 01:31:28,110
如果什么

2279
01:31:28,110 --> 01:31:29,070
这又什么也没有了

2280
01:31:29,490 --> 01:31:30,150
烧回来了

2281
01:31:37,670 --> 01:31:37,835
对

2282
01:31:37,835 --> 01:31:38,720
你理解是对的

2283
01:31:38,870 --> 01:31:39,200
兄弟

2284
01:31:39,200 --> 01:31:40,430
今天没围绕的时候

2285
01:31:40,430 --> 01:31:41,330
并且没有主见

2286
01:31:41,330 --> 01:31:42,500
思想递归没错

2287
01:31:43,170 --> 01:31:43,590
没错

2288
01:31:43,890 --> 01:31:45,120
它是其实是先判断地

2289
01:31:45,120 --> 01:31:45,780
没有直接点

2290
01:31:46,610 --> 01:31:47,090
千盼

2291
01:31:47,090 --> 01:31:47,690
没有直接点

2292
01:31:47,690 --> 01:31:49,580
因为没有直接点在上层

2293
01:31:49,910 --> 01:31:51,680
上层讲的那层循环里

2294
01:31:52,370 --> 01:31:53,120
没有节点

2295
01:31:53,150 --> 01:31:54,380
同时兄弟节点也没有

2296
01:31:55,040 --> 01:31:55,730
也没有了

2297
01:31:56,090 --> 01:31:57,620
那么他就返回父节点了

2298
01:31:59,950 --> 01:32:01,600
列表结构的是下边的六个

2299
01:32:02,540 --> 01:32:02,840
嗯

2300
01:32:05,340 --> 01:32:05,760
Sorry

2301
01:32:06,300 --> 01:32:08,730
五六这里应该是七

2302
01:32:10,600 --> 01:32:11,710
七码吧

2303
01:32:12,610 --> 01:32:13,120
九

2304
01:32:13,820 --> 01:32:16,220
另外几个字下面滴溜的下一个元素

2305
01:32:19,360 --> 01:32:20,680
我为啥不去死

2306
01:32:21,840 --> 01:32:23,130
五为啥不去死

2307
01:32:24,590 --> 01:32:25,370
耳机删了

2308
01:32:28,570 --> 01:32:29,980
找的是父节点同学

2309
01:32:30,130 --> 01:32:34,390
父节点六的父节点是五的父节点是三

2310
01:32:38,920 --> 01:32:40,180
我的父节点是三

2311
01:32:41,210 --> 01:32:46,430
这期的父节点是二大家看445的445的兄弟节点

2312
01:32:46,460 --> 01:32:47,630
你根据这行代码

2313
01:32:47,870 --> 01:32:49,880
它并不会回到他的兄弟节点

2314
01:33:12,600 --> 01:33:12,930
喂

2315
01:33:12,930 --> 01:33:13,290
好

2316
01:33:20,780 --> 01:33:22,670
我看一下每个节点咋带上

2317
01:33:23,640 --> 01:33:26,130
Effects seen flex吗

2318
01:33:28,140 --> 01:33:28,770
有flex

2319
01:33:28,770 --> 01:33:30,660
有flex的时候他是不是

2320
01:33:31,570 --> 01:33:32,530
就是有副作用吗

2321
01:33:32,530 --> 01:33:32,740
对吧

2322
01:33:32,740 --> 01:33:35,170
有flex就说明是需要做处理的

2323
01:33:36,250 --> 01:33:36,670
然后呢

2324
01:33:36,670 --> 01:33:38,230
他通过这种代码其实

2325
01:33:38,900 --> 01:33:39,980
这一整段都是

2326
01:33:40,280 --> 01:33:42,320
但是我标黄的这这几行

2327
01:33:43,200 --> 01:33:44,310
就是把它连起来的

2328
01:33:44,310 --> 01:33:45,750
这个逻辑是把它连起来

2329
01:33:45,780 --> 01:33:47,430
它实际上要紧的是什么

2330
01:33:47,430 --> 01:33:48,000
要紧的事

2331
01:33:48,060 --> 01:33:49,260
这个副作用链条

2332
01:33:50,650 --> 01:33:51,700
如果没有的情况下

2333
01:33:51,700 --> 01:33:54,520
那么就直接如果父节点并没有负作用点

2334
01:33:55,530 --> 01:33:59,130
那么就直接等于他如果有就把它放在它的最后

2335
01:33:59,130 --> 01:34:01,770
这其实就把它放在最后的下一个对不对

2336
01:34:02,470 --> 01:34:03,490
最后的下一个

2337
01:34:04,760 --> 01:34:06,260
给了父节点呢

2338
01:34:06,260 --> 01:34:08,390
因为它是递归的那副节点的父节点

2339
01:34:08,390 --> 01:34:09,590
那肯定也是同样的逻辑

2340
01:34:10,130 --> 01:34:11,690
一直到根节点

2341
01:34:12,450 --> 01:34:14,340
那是不是他就有了所有的副作用裂掉了

2342
01:34:16,440 --> 01:34:16,920
明白了吗

2343
01:34:16,920 --> 01:34:18,360
这点儿同学们

2344
01:34:19,210 --> 01:34:20,050
明天扣一个一

2345
01:34:27,530 --> 01:34:27,920
OK

2346
01:34:27,950 --> 01:34:28,400
好的

2347
01:34:29,110 --> 01:34:29,470
好的

2348
01:34:29,530 --> 01:34:31,540
所以我们所以他这个从下到上

2349
01:34:31,540 --> 01:34:33,880
再从下在从上到下

2350
01:34:33,910 --> 01:34:35,410
再从下从下到上

2351
01:34:36,660 --> 01:34:38,220
当sub tree构建完成之后

2352
01:34:38,220 --> 01:34:39,570
你看它就多了好多东西了

2353
01:34:39,570 --> 01:34:40,065
对不对

2354
01:34:40,065 --> 01:34:41,160
他做了好多事情

2355
01:34:41,640 --> 01:34:44,520
把后面的相当于一部分优化都给做了

2356
01:34:44,700 --> 01:34:46,020
但你说不做能不能行

2357
01:34:46,020 --> 01:34:46,320
行

2358
01:34:46,710 --> 01:34:48,630
但是他做的这个实际上是为了优化

2359
01:34:49,050 --> 01:34:49,770
是为了优化

2360
01:34:49,920 --> 01:34:52,140
原因是他不想在扔的过程

2361
01:34:52,140 --> 01:34:54,360
他想要尽可能减少人的过程的时间

2362
01:34:54,510 --> 01:34:56,370
因为这段时间是不可以被打断的

2363
01:34:57,540 --> 01:34:58,830
这段时间是不可以被答案的

2364
01:35:00,720 --> 01:35:01,170
对不对

2365
01:35:01,470 --> 01:35:01,650
好

2366
01:35:01,650 --> 01:35:02,670
现在我们来看一下

2367
01:35:05,060 --> 01:35:05,570
的算法

2368
01:35:05,570 --> 01:35:07,250
我刚刚没有讲的算法对不对

2369
01:35:07,370 --> 01:35:08,150
没有讲的算法

2370
01:35:08,180 --> 01:35:11,510
因为它我刚刚如果讲的话

2371
01:35:11,510 --> 01:35:12,350
把这个讲完了

2372
01:35:12,350 --> 01:35:15,020
我们再来讲complete on their work的逻辑

2373
01:35:15,080 --> 01:35:16,670
实际上就有点费劲了

2374
01:35:16,700 --> 01:35:18,140
因为就绕远了

2375
01:35:18,620 --> 01:35:19,400
就绕远了

2376
01:35:19,400 --> 01:35:21,860
我们现在先把这整个相当于大框架

2377
01:35:22,550 --> 01:35:23,720
给大家捋明白了

2378
01:35:24,260 --> 01:35:24,680
明白了

2379
01:35:24,680 --> 01:35:26,270
接下来我们再看具体的详情

2380
01:35:26,270 --> 01:35:27,980
详细的大家很关注的这一块儿

2381
01:35:28,620 --> 01:35:29,760
的算法是怎么回事儿

2382
01:35:30,000 --> 01:35:31,410
因为有可能面试的时候

2383
01:35:33,980 --> 01:35:36,980
因为有可能面试的时候他还是会问到这块儿的

2384
01:35:42,160 --> 01:35:43,270
这真的做这个bug

2385
01:35:47,000 --> 01:35:52,640
Dip的瓶颈以及wrecked down的应对就是的算法实际上是有一定的瓶颈的

2386
01:35:53,990 --> 01:35:57,530
首先当地扶他会预测几个规则的

2387
01:35:57,530 --> 01:35:59,510
只对同级进行比较

2388
01:36:00,020 --> 01:36:01,400
对同级节点进行比较

2389
01:36:01,400 --> 01:36:02,810
比如我们刚刚那个图

2390
01:36:03,140 --> 01:36:05,600
你的父节点你就不要和

2391
01:36:05,870 --> 01:36:07,220
子节点不要和

2392
01:36:07,250 --> 01:36:11,510
就是你的current feb的父节点就不要和

2393
01:36:12,110 --> 01:36:13,760
翻倍的子节点进行比较了

2394
01:36:13,970 --> 01:36:14,600
没有意义

2395
01:36:14,660 --> 01:36:14,990
对不对

2396
01:36:15,020 --> 01:36:15,530
没有意义

2397
01:36:16,280 --> 01:36:18,050
第二他认为这个没有意义

2398
01:36:18,050 --> 01:36:19,760
是rock认为这个没有意义

2399
01:36:19,790 --> 01:36:22,490
因为你如果是可以跨成绩比较的话

2400
01:36:23,150 --> 01:36:24,620
那么对于rocker来说

2401
01:36:24,950 --> 01:36:26,840
对rock来说一个是它的开销

2402
01:36:26,960 --> 01:36:29,150
他的那个计算开销性能会特别大

2403
01:36:29,580 --> 01:36:29,880
第二

2404
01:36:29,880 --> 01:36:31,500
这种场景却非常的少

2405
01:36:31,830 --> 01:36:32,910
其实这个就是一个

2406
01:36:33,360 --> 01:36:35,160
其实这就是一个rar的对比嘛

2407
01:36:35,160 --> 01:36:36,690
一个IR不够高

2408
01:36:37,320 --> 01:36:38,310
阿拉伯告我的

2409
01:36:38,520 --> 01:36:41,700
我要消耗的资源又非常的大

2410
01:36:41,940 --> 01:36:42,510
但是呢

2411
01:36:42,750 --> 01:36:45,150
这种场景又并不多并不多

2412
01:36:45,150 --> 01:36:48,660
所以他干脆就不满足你这个需求

2413
01:36:48,840 --> 01:36:50,430
我只对同级节点进行比较

2414
01:36:51,460 --> 01:36:54,070
第二节点变化的话就直接删除

2415
01:36:54,070 --> 01:36:54,760
然后重建

2416
01:36:55,970 --> 01:36:56,450
第三

2417
01:36:57,150 --> 01:36:59,040
存在K值对比节点的K值

2418
01:36:59,430 --> 01:37:00,810
所以K值是非常重要的

2419
01:37:01,230 --> 01:37:02,340
K值是非常重要的

2420
01:37:02,340 --> 01:37:03,150
不能够乱写的

2421
01:37:03,860 --> 01:37:04,880
向record里

2422
01:37:07,080 --> 01:37:10,260
一般在循环对case一般的话

2423
01:37:11,500 --> 01:37:12,100
嗯

2424
01:37:13,480 --> 01:37:14,140
一般的话

2425
01:37:14,140 --> 01:37:15,400
你如果不是在

2426
01:37:16,040 --> 01:37:17,150
不在循环里

2427
01:37:17,740 --> 01:37:17,830
对

2428
01:37:17,830 --> 01:37:19,060
你如果不在循环里

2429
01:37:19,120 --> 01:37:22,000
他就是那个比如佛一起

2430
01:37:22,000 --> 01:37:22,360
不不是

2431
01:37:22,360 --> 01:37:23,890
不是说是map

2432
01:37:23,950 --> 01:37:27,700
如果不是那种用map的形式是一般是可以补血的

2433
01:37:28,290 --> 01:37:29,160
一般是可以不写

2434
01:37:29,160 --> 01:37:29,880
他会默认

2435
01:37:30,210 --> 01:37:32,100
但是有的情况下是需要写的

2436
01:37:32,280 --> 01:37:33,210
在什么情况下

2437
01:37:33,270 --> 01:37:35,130
有没有的情况下是

2438
01:37:35,400 --> 01:37:39,030
比如你发现你的原你的那个REC的组件

2439
01:37:39,480 --> 01:37:41,880
它的更新起来就是有一些不更新

2440
01:37:43,220 --> 01:37:45,500
我就我之前遇到过这种场景

2441
01:37:45,650 --> 01:37:46,640
就是当你知道kiss

2442
01:37:46,640 --> 01:37:47,450
真正的罗

2443
01:37:47,600 --> 01:37:49,160
知道kiss的逻辑之后

2444
01:37:49,730 --> 01:37:50,900
你可以用他做事情

2445
01:37:51,480 --> 01:37:52,800
比如我之前有一个场景是

2446
01:37:53,100 --> 01:37:54,390
比如我是在那个

2447
01:37:55,230 --> 01:37:55,980
这是我们的

2448
01:37:56,280 --> 01:37:59,610
这是我们的一个electronic APP对吧

2449
01:37:59,610 --> 01:38:01,110
我点击了一个元素a

2450
01:38:01,860 --> 01:38:02,370
点击这个a

2451
01:38:02,730 --> 01:38:04,200
然后我出现了一个新的窗口

2452
01:38:04,710 --> 01:38:05,850
我调了一个新的窗口

2453
01:38:06,180 --> 01:38:07,890
这个窗口就是新的

2454
01:38:07,980 --> 01:38:09,060
就是新的页面嘛

2455
01:38:09,150 --> 01:38:09,360
对吧

2456
01:38:09,360 --> 01:38:10,710
新的页面儿

2457
01:38:10,710 --> 01:38:11,940
我这个点击a的时候

2458
01:38:11,940 --> 01:38:15,090
它实际上会传入一些社会传入一些

2459
01:38:16,190 --> 01:38:17,390
阐述进来了

2460
01:38:17,420 --> 01:38:18,680
只要传阐述进来了

2461
01:38:20,340 --> 01:38:22,980
我看之前他们写的逻辑就有个bug

2462
01:38:22,980 --> 01:38:24,480
就是我点了这个

2463
01:38:25,410 --> 01:38:26,400
点了这个之后

2464
01:38:26,580 --> 01:38:27,510
第一次没问题

2465
01:38:27,690 --> 01:38:29,790
然后当我在这个窗口不消失的情况下

2466
01:38:29,790 --> 01:38:32,190
我再点一次就会发现就会发

2467
01:38:32,340 --> 01:38:37,230
再点一次另外的一个属性不一样的进来

2468
01:38:37,590 --> 01:38:40,890
就会发现我们这个窗口并不会及时的更新

2469
01:38:42,640 --> 01:38:44,230
这个方法就不会及时的更新

2470
01:38:44,440 --> 01:38:46,720
可能是有有其他的逻辑上的一些问题

2471
01:38:47,080 --> 01:38:49,030
最简单粗暴的解决方法方式呢

2472
01:38:49,030 --> 01:38:49,900
大家知道是什么吗

2473
01:38:50,500 --> 01:38:51,970
我当时要优化这个问题

2474
01:38:52,980 --> 01:38:56,130
然后一共响了不到一共享了不到三分钟

2475
01:38:57,190 --> 01:39:00,190
最简单的语法问题就是把K给他改了

2476
01:39:00,520 --> 01:39:02,770
他绝对会墙根墙根一次

2477
01:39:04,350 --> 01:39:04,650
对

2478
01:39:04,950 --> 01:39:07,380
如果说你要是因为是老逻辑嘛

2479
01:39:07,380 --> 01:39:08,190
我懒得去看

2480
01:39:08,190 --> 01:39:10,020
我懒得去看后面的话再优化

2481
01:39:10,230 --> 01:39:11,490
而当时项目又紧

2482
01:39:11,490 --> 01:39:13,860
那么就把K改这个问题bug解了

2483
01:39:20,400 --> 01:39:22,740
我们会我们会详细看的会详细看的

2484
01:39:23,010 --> 01:39:25,560
对这几个规则会一直会一直存在

2485
01:39:25,770 --> 01:39:26,400
我们会看

2486
01:39:27,400 --> 01:39:29,140
他的有单节点的对比

2487
01:39:29,170 --> 01:39:31,090
就得单节点的地方和多节点的地方

2488
01:39:31,750 --> 01:39:32,950
循环也能加K码

2489
01:39:32,980 --> 01:39:33,370
不对

2490
01:39:33,370 --> 01:39:33,850
可以的

2491
01:39:34,150 --> 01:39:35,710
不是循环可以加K

2492
01:39:39,380 --> 01:39:39,980
可以嫁给

2493
01:39:40,690 --> 01:39:44,350
你只要保证你的那个用法是在你的掌握之内

2494
01:39:45,280 --> 01:39:47,200
就比如我刚刚说的那个场景

2495
01:39:47,260 --> 01:39:48,250
我刚刚说的那个场景

2496
01:39:48,250 --> 01:39:51,550
那就是我只要我只要进了plus不一样

2497
01:39:51,550 --> 01:39:53,560
我那么我的K值每次都会重新变

2498
01:39:53,950 --> 01:39:57,310
我会我会想办法让他变化

2499
01:40:00,480 --> 01:40:00,810
没有啊

2500
01:40:00,810 --> 01:40:01,830
就直接一个开字

2501
01:40:03,330 --> 01:40:04,440
就放就行了

2502
01:40:12,440 --> 01:40:14,210
你就这三个开

2503
01:40:14,390 --> 01:40:14,780
对吧

2504
01:40:15,770 --> 01:40:16,310
组建嘛

2505
01:40:16,310 --> 01:40:17,600
就是个K就完事儿了

2506
01:40:18,880 --> 01:40:20,740
即使它不是循环

2507
01:40:20,800 --> 01:40:21,460
你还可以加

2508
01:40:21,490 --> 01:40:22,270
同样可以加

2509
01:40:26,250 --> 01:40:27,360
很简单这个

2510
01:40:27,660 --> 01:40:28,110
但是呢

2511
01:40:28,110 --> 01:40:29,130
逻辑并不简单

2512
01:40:29,400 --> 01:40:32,970
就是改起来就觉得就是你如果懂这块儿

2513
01:40:33,270 --> 01:40:34,080
改起来就快

2514
01:40:35,030 --> 01:40:36,410
而且改起来也很简单

2515
01:40:36,650 --> 01:40:37,460
你不懂这块儿

2516
01:40:37,490 --> 01:40:38,270
你就想不到它

2517
01:40:38,300 --> 01:40:39,410
其实主要是你想不到的

2518
01:40:40,740 --> 01:40:42,000
这个case还是很重要的

2519
01:40:42,210 --> 01:40:44,850
不能够瞎写在wrecked在

2520
01:40:44,850 --> 01:40:46,170
特别在放一起的时候

2521
01:40:46,860 --> 01:40:48,690
大家千万不要根据这个

2522
01:40:49,460 --> 01:40:51,230
不要根据他的index来写

2523
01:40:51,470 --> 01:40:56,210
比如说什么一二三点佛一起办法

2524
01:40:59,840 --> 01:41:00,290
对吧

2525
01:41:00,320 --> 01:41:00,830
这就

2526
01:41:01,600 --> 01:41:02,440
Index

2527
01:41:03,460 --> 01:41:04,600
一般不是这么高吗

2528
01:41:11,240 --> 01:41:12,020
艾特了

2529
01:41:12,020 --> 01:41:13,040
假如怎么写

2530
01:41:18,260 --> 01:41:18,620
嗯

2531
01:41:21,850 --> 01:41:24,610
这样子写的话是负向优化

2532
01:41:25,090 --> 01:41:26,560
就如果在克瑞微的话

2533
01:41:26,560 --> 01:41:28,030
这种想法是会被嘲笑的

2534
01:41:28,760 --> 01:41:29,120
同学们

2535
01:41:29,990 --> 01:41:31,700
这种写法是负向优化

2536
01:41:34,420 --> 01:41:39,520
就是你反而你本来加K只是为了优化它的那个当地的

2537
01:41:40,090 --> 01:41:41,590
结果你搞成什么了

2538
01:41:42,350 --> 01:41:42,770
结果呢

2539
01:41:42,770 --> 01:41:44,000
搞成了优越

2540
01:41:44,000 --> 01:41:45,320
优化效果越差

2541
01:41:46,560 --> 01:41:48,600
那么他这就是典型的一个例子

2542
01:41:49,360 --> 01:41:50,680
越优化效果越差

2543
01:41:52,420 --> 01:41:53,860
就不能直接这么用

2544
01:41:53,860 --> 01:41:54,730
不能直接这么用

2545
01:41:55,090 --> 01:41:57,010
你可以用这个APP里面的属性

2546
01:41:57,830 --> 01:41:59,450
可以用这个APP里面唯一的属性

2547
01:41:59,450 --> 01:42:02,240
比如说像什么FBI的对吧

2548
01:42:02,980 --> 01:42:04,000
I TE dian ID啊

2549
01:42:04,600 --> 01:42:05,650
或者什么其他东西

2550
01:42:05,710 --> 01:42:07,930
如果这个艾特实在是没有啥可用的

2551
01:42:08,600 --> 01:42:10,610
而且他是有这些中文你不想用

2552
01:42:10,940 --> 01:42:12,200
那么你至少可以这样写

2553
01:42:14,050 --> 01:42:15,970
那么你那么你至少可以这样写

2554
01:42:15,970 --> 01:42:17,710
比如说

2555
01:42:19,360 --> 01:42:21,670
什么testa对吧

2556
01:42:21,730 --> 01:42:22,900
每一个都不一样

2557
01:42:22,960 --> 01:42:23,950
你知道可以这样写

2558
01:42:25,460 --> 01:42:27,380
就不会和其他地方的壮起来

2559
01:42:32,250 --> 01:42:36,420
记住这一点很代码对应的性能提升

2560
01:42:37,020 --> 01:42:39,510
可能你说我还是要想办法做个优化

2561
01:42:39,540 --> 01:42:40,860
结果越做优化越差

2562
01:42:42,810 --> 01:42:44,280
可能就是这个原因导致的

2563
01:42:44,400 --> 01:42:46,230
下来检查一下这种

2564
01:42:46,560 --> 01:42:48,450
这种是明令禁止的

2565
01:42:48,570 --> 01:42:49,440
不可以这么写

2566
01:42:49,830 --> 01:42:53,070
那个yes里面也有类似的

2567
01:42:53,070 --> 01:42:54,840
这也有类似的规则

2568
01:42:55,140 --> 01:42:56,370
就是不让你这么写

2569
01:42:56,460 --> 01:42:57,600
你这么写他就给你报错

2570
01:42:58,340 --> 01:42:59,630
Good about yesterday的错误

2571
01:43:01,180 --> 01:43:02,440
好点儿了

2572
01:43:02,620 --> 01:43:03,520
发的有点多了

2573
01:43:03,730 --> 01:43:03,940
好

2574
01:43:03,940 --> 01:43:06,220
接下来看一下它的的

2575
01:43:06,280 --> 01:43:08,500
首先这其实区分了一下

2576
01:43:08,650 --> 01:43:11,800
这代码在react翘的fiber

2577
01:43:11,800 --> 01:43:13,870
点六下的re consider the child fiber

2578
01:43:14,530 --> 01:43:16,210
首先看一下它是不是react组件

2579
01:43:16,810 --> 01:43:18,970
是不是react组件X组件

2580
01:43:19,330 --> 01:43:23,230
那么他一定是一个object X单独的软件是一个object

2581
01:43:24,220 --> 01:43:27,010
Rock之间里有个叨叨的type of的这个

2582
01:43:28,260 --> 01:43:30,540
是标志你比如你到底是react点

2583
01:43:31,210 --> 01:43:33,460
就是点create element创建的呢

2584
01:43:33,460 --> 01:43:34,690
还是什么其他的东西

2585
01:43:35,260 --> 01:43:36,130
还有什么其他东西

2586
01:43:36,860 --> 01:43:38,930
根据这里对不对

2587
01:43:39,200 --> 01:43:39,830
如果是

2588
01:43:41,350 --> 01:43:42,250
有不同的节点

2589
01:43:42,250 --> 01:43:43,330
那么还是喝

2590
01:43:43,330 --> 01:43:44,500
刚刚上面的逻辑一样

2591
01:43:44,980 --> 01:43:48,910
不同的代码就是不同的type处理不同的逻辑

2592
01:43:49,030 --> 01:43:50,590
这其实是给她家她的事

2593
01:43:50,590 --> 01:43:51,940
给他加flex的

2594
01:43:52,900 --> 01:43:53,710
那如果是

2595
01:43:54,420 --> 01:43:54,840
Error

2596
01:43:54,900 --> 01:43:55,650
如果是个error

2597
01:43:55,650 --> 01:43:58,140
就是我们所常用的这种多节点的速度

2598
01:43:58,350 --> 01:44:00,960
这其实就是判断了一下单节点速度

2599
01:44:01,230 --> 01:44:03,750
就是单节点的符合多节点的父

2600
01:44:04,700 --> 01:44:06,050
分别的逻辑是什么

2601
01:44:06,320 --> 01:44:08,090
我们先看一下单节点

2602
01:44:08,240 --> 01:44:09,470
单节点就非常简单

2603
01:44:10,220 --> 01:44:12,680
判断存在对应的节点case是否相同

2604
01:44:13,160 --> 01:44:14,630
如果case也相同

2605
01:44:14,630 --> 01:44:15,710
节点类型也相同

2606
01:44:15,710 --> 01:44:16,220
就服用

2607
01:44:16,760 --> 01:44:18,530
如果存在对应节点cases

2608
01:44:19,920 --> 01:44:21,720
是否判断K是否相同

2609
01:44:21,720 --> 01:44:23,400
节点类型是否一致

2610
01:44:23,610 --> 01:44:25,650
如果不一致的话就标记一个delete

2611
01:44:27,170 --> 01:44:28,430
如果存在对应节点

2612
01:44:28,670 --> 01:44:30,110
Case不同标记删除

2613
01:44:30,110 --> 01:44:30,740
重新创建

2614
01:44:31,440 --> 01:44:32,520
不存在这些节点

2615
01:44:32,730 --> 01:44:33,570
创建新节点

2616
01:44:35,400 --> 01:44:36,060
这就是罗

2617
01:44:36,060 --> 01:44:36,840
这就是单节点

2618
01:44:36,840 --> 01:44:37,710
我们可以看一下

2619
01:44:38,040 --> 01:44:38,610
首先是

2620
01:44:39,300 --> 01:44:40,020
翘

2621
01:44:40,590 --> 01:44:42,450
如果撬不等于

2622
01:44:43,060 --> 01:44:43,780
就存在吗

2623
01:44:43,810 --> 01:44:45,550
然后就对比K值是否相同

2624
01:44:46,090 --> 01:44:47,770
K相同同时什么呢

2625
01:44:47,980 --> 01:44:49,630
大家看它的APP一样

2626
01:44:49,960 --> 01:44:52,030
比如说你从丢你的K算一样

2627
01:44:52,030 --> 01:44:54,430
但是你把它从div改成了一个屁

2628
01:44:55,340 --> 01:44:56,450
那么他同样是要

2629
01:44:56,540 --> 01:44:58,220
那么他同样是要把它给

2630
01:45:00,050 --> 01:45:00,770
处理掉了

2631
01:45:01,580 --> 01:45:02,750
同样是给它处理掉了

2632
01:45:02,810 --> 01:45:05,990
这里就是指case相同元素类型也一致

2633
01:45:06,530 --> 01:45:08,180
那么这里就可以服用了

2634
01:45:08,690 --> 01:45:09,140
这是服用

2635
01:45:09,140 --> 01:45:11,090
但是服用并不是什么属性都不改

2636
01:45:11,090 --> 01:45:12,800
同学们并不是什么属性都不改

2637
01:45:13,070 --> 01:45:15,500
这个之前有同学真的被面试问到

2638
01:45:15,500 --> 01:45:17,360
就是说费用是怎么个服用法

2639
01:45:18,170 --> 01:45:19,070
他就说不上来了

2640
01:45:19,070 --> 01:45:20,840
其实这个就是要举一反三

2641
01:45:21,540 --> 01:45:22,440
要举一反三

2642
01:45:22,440 --> 01:45:24,810
不可能什么都讲到同学们下来要想一想

2643
01:45:25,560 --> 01:45:27,870
这其实就是只复印的逻辑

2644
01:45:28,890 --> 01:45:31,020
这个exist existing就是存在

2645
01:45:31,290 --> 01:45:32,730
但是你有的有的结

2646
01:45:32,730 --> 01:45:34,320
有的点要改的

2647
01:45:34,560 --> 01:45:36,690
比如像那个riff的return

2648
01:45:36,840 --> 01:45:40,110
因为因为你之前的可能return he

2649
01:45:40,110 --> 01:45:42,000
现在return万一不一样了怎么办呢

2650
01:45:42,390 --> 01:45:44,850
所以它这里是要改这两个节点的

2651
01:45:45,840 --> 01:45:47,400
这两个点先把它改掉了

2652
01:45:47,940 --> 01:45:48,600
然后就服用

2653
01:45:50,060 --> 01:45:51,590
如果这个LC就是

2654
01:45:52,670 --> 01:45:54,470
Else就是element type不一样

2655
01:45:56,680 --> 01:45:57,520
这是标志

2656
01:45:58,280 --> 01:45:59,210
节点类型不一致

2657
01:45:59,210 --> 01:46:00,410
标记为删除

2658
01:46:00,560 --> 01:46:03,950
标记为删除下面下面这个是K值都不一样

2659
01:46:04,190 --> 01:46:05,570
同样是把它标记为删除

2660
01:46:06,110 --> 01:46:07,310
这两个区别是

2661
01:46:08,210 --> 01:46:10,910
这两个区别是它的仔鲢子节点会一起上

2662
01:46:11,770 --> 01:46:12,940
他是不删自己点的

2663
01:46:13,910 --> 01:46:15,380
这个是不是点直接点一起删

2664
01:46:15,380 --> 01:46:15,920
因为她的

2665
01:46:16,730 --> 01:46:17,390
这就意味着

2666
01:46:17,390 --> 01:46:18,680
它的节点不一样了

2667
01:46:20,140 --> 01:46:20,500
嗯

2668
01:46:21,350 --> 01:46:21,920
然后呢

2669
01:46:22,250 --> 01:46:23,690
如果不存在对应的节点

2670
01:46:25,330 --> 01:46:27,850
创建同样也是要复制这个属性

2671
01:46:28,740 --> 01:46:29,880
这就是丹姐的地府

2672
01:46:30,210 --> 01:46:31,050
就这么多东西

2673
01:46:31,200 --> 01:46:33,180
是很简单很简单

2674
01:46:33,210 --> 01:46:34,920
其实但是你要理解他的话

2675
01:46:35,820 --> 01:46:36,300
你就要

2676
01:46:36,300 --> 01:46:40,230
你就要把这个咱们的玉氏的这两个规则放一起看

2677
01:46:40,840 --> 01:46:41,620
现在看明白

2678
01:46:42,430 --> 01:46:43,420
就是你才能理解他

2679
01:46:43,870 --> 01:46:44,770
才能理解他

2680
01:46:44,830 --> 01:46:49,420
因为他只能对同济来同济的来做单集的例子就是这么简单

2681
01:46:51,780 --> 01:46:52,230
嗯

2682
01:46:54,280 --> 01:46:55,720
对单击点确实是

2683
01:46:56,800 --> 01:46:57,550
比较简单

2684
01:46:57,970 --> 01:46:59,350
好这个能理解是吗

2685
01:46:59,560 --> 01:47:00,700
能理解扣一个一

2686
01:47:02,740 --> 01:47:03,820
分离接客呢

2687
01:47:10,480 --> 01:47:14,920
是否全复印那个科目的问题就是复印我们是不是服用了赛尔节点

2688
01:47:16,130 --> 01:47:16,490
对不对

2689
01:47:16,490 --> 01:47:19,160
是不是复印了FAB节点的节点

2690
01:47:19,250 --> 01:47:21,800
每个节点是不是有N多个属性同学

2691
01:47:22,710 --> 01:47:24,450
看不见你的属性是很多

2692
01:47:26,520 --> 01:47:27,930
所以全部的意思是说

2693
01:47:28,290 --> 01:47:32,490
他是不是直接把整个的那个对象给复印过来

2694
01:47:32,490 --> 01:47:33,270
啥也不改呢

2695
01:47:34,880 --> 01:47:35,210
对不对

2696
01:47:35,210 --> 01:47:36,200
他这实际上不是

2697
01:47:36,200 --> 01:47:37,880
他实际上是先把它找到

2698
01:47:38,580 --> 01:47:39,600
找到这个存在了

2699
01:47:39,840 --> 01:47:41,880
然后他的瑞福瑞特要重新赋值

2700
01:47:42,210 --> 01:47:43,110
其实就这么个

2701
01:47:43,140 --> 01:47:44,130
其实就这么个变化

2702
01:47:46,240 --> 01:47:47,050
因为原因是啥

2703
01:47:47,050 --> 01:47:49,030
你的riff可能变

2704
01:47:49,030 --> 01:47:50,890
你的riff每次都会变的

2705
01:47:50,890 --> 01:47:52,450
Return他有可能会变

2706
01:48:02,410 --> 01:48:03,970
好那就是多节点了

2707
01:48:06,570 --> 01:48:07,530
多点对比

2708
01:48:07,530 --> 01:48:10,500
单节点的要稍微难一点点

2709
01:48:10,740 --> 01:48:11,670
要稍微难一点点

2710
01:48:13,650 --> 01:48:14,460
他做了这么远

2711
01:48:14,460 --> 01:48:16,920
谁看我写的东西都比较比较多嘛

2712
01:48:16,920 --> 01:48:17,250
对吧

2713
01:48:17,790 --> 01:48:18,240
多简单

2714
01:48:18,240 --> 01:48:18,990
要难一点点

2715
01:48:19,020 --> 01:48:21,750
他他要判断新的场景就是

2716
01:48:22,340 --> 01:48:23,810
我我单几点

2717
01:48:23,900 --> 01:48:25,850
就看他自己多几点的情况下

2718
01:48:27,060 --> 01:48:28,260
他要考虑的是

2719
01:48:28,800 --> 01:48:30,330
比如它的顺序打乱了

2720
01:48:30,540 --> 01:48:30,990
对不对

2721
01:48:31,350 --> 01:48:32,340
顺序打乱了

2722
01:48:33,200 --> 01:48:36,350
我能否把它给服用出来

2723
01:48:37,330 --> 01:48:38,470
顺序打乱的情况下

2724
01:48:38,500 --> 01:48:41,140
这个时候其实就依赖于我们的K值了

2725
01:48:41,500 --> 01:48:42,700
K值他就会去找

2726
01:48:42,700 --> 01:48:46,600
他就会去找在reactor里面多挤点地方

2727
01:48:46,840 --> 01:48:47,410
我们来看

2728
01:48:47,800 --> 01:48:49,570
实际上有两次循环

2729
01:48:49,570 --> 01:48:50,710
不是双重循环

2730
01:48:50,710 --> 01:48:53,050
同学两次循环双重的话

2731
01:48:53,050 --> 01:48:54,940
我们一般认为它是一层套一层

2732
01:48:55,430 --> 01:48:55,910
两次

2733
01:48:55,910 --> 01:48:57,380
就是先来一次

2734
01:48:57,500 --> 01:48:58,100
再来一次

2735
01:48:59,240 --> 01:49:01,340
这个很成为两次第一次

2736
01:49:02,810 --> 01:49:03,920
我们先看一下

2737
01:49:04,580 --> 01:49:05,750
他做了哪几件事情

2738
01:49:07,550 --> 01:49:07,880
第一

2739
01:49:07,880 --> 01:49:08,450
对比性

2740
01:49:08,450 --> 01:49:11,330
就因为因为既然是数组

2741
01:49:11,330 --> 01:49:13,190
那肯定就是两个数组的对比

2742
01:49:13,780 --> 01:49:14,140
对不对

2743
01:49:14,200 --> 01:49:15,130
两个数组的对比

2744
01:49:15,130 --> 01:49:18,940
对比新旧数组中的相同index对象的K是否相等

2745
01:49:18,940 --> 01:49:20,140
如果是返回该对象

2746
01:49:20,410 --> 01:49:21,250
如果不是返回

2747
01:49:21,250 --> 01:49:21,520
那

2748
01:49:22,420 --> 01:49:25,570
就是对比相同index的对象就是

2749
01:49:29,180 --> 01:49:29,660
二码

2750
01:49:29,660 --> 01:49:30,020
对

2751
01:49:31,220 --> 01:49:31,760
嗯

2752
01:49:34,580 --> 01:49:35,300
这是

2753
01:49:37,070 --> 01:49:37,640
老大

2754
01:49:38,380 --> 01:49:41,440
老子也是个数组行好点拳迷

2755
01:49:43,000 --> 01:49:44,470
在家家去

2756
01:49:46,640 --> 01:49:46,850
嗯

2757
01:49:49,290 --> 01:49:50,100
放大不了吗

2758
01:49:50,310 --> 01:49:50,730
稍等

2759
01:49:57,860 --> 01:49:59,150
我这文档太大了

2760
01:50:00,440 --> 01:50:02,030
这文档写的太大了

2761
01:50:02,450 --> 01:50:03,320
操作起来

2762
01:50:04,010 --> 01:50:06,950
操作起来都有点卡顿

2763
01:50:07,340 --> 01:50:08,180
现在可以吗

2764
01:50:12,220 --> 01:50:12,910
还要吗

2765
01:50:13,590 --> 01:50:14,490
还在大点儿吗

2766
01:50:15,720 --> 01:50:16,230
行

2767
01:50:19,420 --> 01:50:20,980
这是对比相同index的

2768
01:50:21,460 --> 01:50:22,480
相同index的

2769
01:50:23,050 --> 01:50:23,950
接着我这一个

2770
01:50:25,280 --> 01:50:27,410
下面一个我们相同

2771
01:50:27,410 --> 01:50:29,390
Index的K是否一样

2772
01:50:30,480 --> 01:50:30,720
对吧

2773
01:50:30,720 --> 01:50:34,710
我们先看一下有没有第一轮时间就找的是香

2774
01:50:34,710 --> 01:50:36,090
第一轮循环其实

2775
01:50:36,990 --> 01:50:38,040
就是找的是

2776
01:50:39,090 --> 01:50:41,580
第一次循环找的就是比如相同的

2777
01:50:42,060 --> 01:50:44,370
至少说我们这个节点一个一个对应过来

2778
01:50:44,370 --> 01:50:45,360
我们是不是一样的

2779
01:50:47,360 --> 01:50:48,350
这个是一个一个的

2780
01:50:48,980 --> 01:50:52,280
然后第二次判断节点是否存在移动

2781
01:50:52,880 --> 01:50:54,110
存在着反卫星的位置

2782
01:50:57,060 --> 01:51:00,210
如果其实他他这是有逻辑的

2783
01:51:00,480 --> 01:51:02,880
如果说存在新的速度

2784
01:51:02,880 --> 01:51:05,130
其实小于老速度的情况下

2785
01:51:05,520 --> 01:51:07,500
大家看如果是有新的数组

2786
01:51:08,820 --> 01:51:09,990
如果是一个新的数组

2787
01:51:10,290 --> 01:51:12,630
比如我这我小娱乐的数字

2788
01:51:16,330 --> 01:51:19,600
即意味着它肯定有东西是需要被删除的

2789
01:51:19,600 --> 01:51:20,020
对不对

2790
01:51:20,500 --> 01:51:21,490
需要被删除的

2791
01:51:22,210 --> 01:51:25,150
如果我有新的数组比老数组大

2792
01:51:25,210 --> 01:51:26,770
那就说明我是有新增的

2793
01:51:28,780 --> 01:51:29,920
那么我是有新增的

2794
01:51:32,130 --> 01:51:35,400
这两种情况也判断了创建就是创建新节点

2795
01:51:35,910 --> 01:51:39,660
如果是一个把把上面这些

2796
01:51:40,730 --> 01:51:41,960
都处理完了之后

2797
01:51:42,260 --> 01:51:42,680
然后呢

2798
01:51:42,680 --> 01:51:44,690
他在会统一的再来找一次

2799
01:51:44,690 --> 01:51:46,790
就是里边儿有没有可复用的

2800
01:51:47,910 --> 01:51:49,560
里面有没有可以统一找一次

2801
01:51:49,560 --> 01:51:50,400
这样避免遗漏

2802
01:51:51,120 --> 01:51:51,600
避免遗漏

2803
01:51:51,600 --> 01:51:53,400
我们从代码的逻辑上来看一下好不好

2804
01:51:58,170 --> 01:51:59,610
从代码的逻辑上再看看

2805
01:52:00,540 --> 01:52:01,050
第一

2806
01:52:01,440 --> 01:52:02,610
这第一次是第一次

2807
01:52:02,910 --> 01:52:04,080
大家这是第一个for

2808
01:52:07,650 --> 01:52:09,150
这是第一个负循环

2809
01:52:10,230 --> 01:52:11,340
第一个循环之后

2810
01:52:11,400 --> 01:52:13,140
它有一个二的forever

2811
01:52:14,650 --> 01:52:16,150
然后有一个new的index

2812
01:52:16,330 --> 01:52:17,290
他刚开始是零

2813
01:52:17,830 --> 01:52:21,700
然后是根据六桥墩的认识

2814
01:52:22,980 --> 01:52:23,610
为他的

2815
01:52:23,790 --> 01:52:25,290
为他的那个判断条件

2816
01:52:25,410 --> 01:52:27,150
然后一直加一直加

2817
01:52:27,690 --> 01:52:34,200
这第一轮其实就是判断的是我们的这个相同index的fiber是否可以服用

2818
01:52:34,560 --> 01:52:35,430
如果可以服用

2819
01:52:36,870 --> 01:52:37,830
其实就是这儿

2820
01:52:37,830 --> 01:52:39,510
这个updates lot这个函数

2821
01:52:39,690 --> 01:52:41,280
我直接给大家讲他的意思

2822
01:52:41,550 --> 01:52:42,210
它的功能

2823
01:52:42,750 --> 01:52:44,580
它它里边儿就是对比

2824
01:52:45,390 --> 01:52:47,910
相同index对象的K是否一致

2825
01:52:48,390 --> 01:52:51,150
如果是一致的话就返回该对象

2826
01:52:51,150 --> 01:52:54,240
如果不一致就返回那所以这儿的罗

2827
01:52:54,270 --> 01:52:56,310
所以这他直接是判断是否等于那

2828
01:52:56,790 --> 01:52:57,450
如果等于

2829
01:52:57,450 --> 01:52:59,190
那就说明K值不等

2830
01:52:59,460 --> 01:53:00,960
那就说明它的顺序变了

2831
01:53:00,990 --> 01:53:03,390
就不用对比拉结点不能服用

2832
01:53:03,840 --> 01:53:06,000
第一轮逻辑就不用就不用管了

2833
01:53:06,700 --> 01:53:08,170
就是第一轮复习完就结束了

2834
01:53:08,260 --> 01:53:09,880
如果K值相等

2835
01:53:09,880 --> 01:53:13,090
就意味着你没有几没有任何位置的变化

2836
01:53:13,420 --> 01:53:14,260
位置没有变化

2837
01:53:14,260 --> 01:53:14,860
那么他就

2838
01:53:15,680 --> 01:53:17,900
只对比相同指的K就行了

2839
01:53:18,170 --> 01:53:19,490
对比相同的K就行了

2840
01:53:22,050 --> 01:53:22,890
如果出现了

2841
01:53:22,890 --> 01:53:24,090
那就是写的有问题

2842
01:53:25,600 --> 01:53:30,100
所以就说为什么刚刚我讲的前面那个例子说他他是负向优化

2843
01:53:30,370 --> 01:53:32,050
如果你这样子写K

2844
01:53:32,380 --> 01:53:33,940
那么他就一定会出现一样的

2845
01:53:34,620 --> 01:53:36,660
那么这就是一个负向的优化

2846
01:53:40,620 --> 01:53:42,270
你就反而会给他增加麻烦

2847
01:53:43,690 --> 01:53:44,800
就如果出现的话

2848
01:53:44,860 --> 01:53:46,570
那你那你要调整代码

2849
01:53:47,050 --> 01:53:47,950
那个不能那么写

2850
01:53:53,830 --> 01:53:54,280
好

2851
01:53:57,460 --> 01:53:59,590
好他就先对比的相同index的

2852
01:54:00,620 --> 01:54:02,270
如果是

2853
01:54:02,970 --> 01:54:03,840
这是第一种情况

2854
01:54:03,840 --> 01:54:04,980
假如他已经跳出了吗

2855
01:54:05,670 --> 01:54:08,760
大家看刘index是不是上面内存循环

2856
01:54:09,400 --> 01:54:11,170
上面内层循环的

2857
01:54:12,460 --> 01:54:13,480
所执行到的认识

2858
01:54:13,480 --> 01:54:14,620
假如他的中途

2859
01:54:14,950 --> 01:54:16,540
如果他的中途被跳出了

2860
01:54:16,540 --> 01:54:17,440
大家大家看

2861
01:54:17,740 --> 01:54:18,970
假如他的中途

2862
01:54:19,060 --> 01:54:20,590
比如某有某一个K变了

2863
01:54:21,100 --> 01:54:21,880
K就不等了

2864
01:54:22,330 --> 01:54:23,470
跳出了就是break

2865
01:54:23,470 --> 01:54:25,390
这就只跳出了这种循环了

2866
01:54:25,420 --> 01:54:25,780
对不对

2867
01:54:27,230 --> 01:54:28,700
这种情况就直接跳出了

2868
01:54:29,000 --> 01:54:33,020
那么我的new index肯定是小于new children s的

2869
01:54:33,650 --> 01:54:34,670
这个大家能理解吗

2870
01:54:34,700 --> 01:54:35,930
就如果中途跳出了

2871
01:54:35,930 --> 01:54:37,670
我的new index肯定比他小

2872
01:54:39,800 --> 01:54:40,100
所以啊

2873
01:54:40,100 --> 01:54:41,210
能理解的扣个一

2874
01:54:41,600 --> 01:54:42,680
我中途跳出去了

2875
01:54:42,890 --> 01:54:43,700
我肯定比他小

2876
01:54:45,650 --> 01:54:46,100
好

2877
01:54:46,340 --> 01:54:48,260
下面就根据这个index的

2878
01:54:48,900 --> 01:54:49,530
来判断了

2879
01:54:49,830 --> 01:54:54,570
大家看如果new index等娱乐children刘超刘超吨的认识

2880
01:54:55,050 --> 01:54:55,770
这意味着什么

2881
01:54:55,770 --> 01:55:00,120
就说明我整个循环是不是都是整个循环都都走完了

2882
01:55:00,120 --> 01:55:01,410
中途没有跳出的情况

2883
01:55:03,030 --> 01:55:03,480
对不对

2884
01:55:03,570 --> 01:55:05,190
如果它等于了他

2885
01:55:05,250 --> 01:55:06,990
那就说明中途没有特殊情况

2886
01:55:06,990 --> 01:55:09,090
那就是顺序一直是一样的

2887
01:55:09,390 --> 01:55:10,710
顺序从来就没有变过

2888
01:55:11,430 --> 01:55:13,080
那么他这做了一个东西

2889
01:55:13,470 --> 01:55:14,940
之前讲的时候大家都蒙了

2890
01:55:16,660 --> 01:55:16,960
Delete

2891
01:55:16,960 --> 01:55:18,100
为什么还会delete

2892
01:55:18,580 --> 01:55:19,300
原因是啥

2893
01:55:20,200 --> 01:55:20,800
也就是说

2894
01:55:21,130 --> 01:55:22,780
也就是说在

2895
01:55:24,640 --> 01:55:26,740
在我整个都走完的情况下

2896
01:55:27,100 --> 01:55:29,320
我的new index全部都走完的情况下

2897
01:55:31,010 --> 01:55:32,630
存着极有可能存在一种

2898
01:55:33,370 --> 01:55:35,920
极有可能存在一种情况就说明

2899
01:55:36,770 --> 01:55:37,550
就是老的速度

2900
01:55:37,550 --> 01:55:38,240
假如老

2901
01:55:38,270 --> 01:55:39,260
因为他是根据

2902
01:55:39,860 --> 01:55:43,040
因为它是根据这个新数组的这个认识进行判断的

2903
01:55:43,100 --> 01:55:44,630
进行循环的那集

2904
01:55:44,630 --> 01:55:47,240
可能存在我老数组的认识的角度比较多

2905
01:55:47,480 --> 01:55:48,770
对我老数组有这么多

2906
01:55:49,350 --> 01:55:50,640
我心素只有这么多

2907
01:55:50,760 --> 01:55:53,280
我就算是Lin X等于六千点认识

2908
01:55:53,980 --> 01:55:54,550
又敲重点

2909
01:55:54,550 --> 01:55:55,450
认识到了这里

2910
01:55:56,320 --> 01:55:59,050
我这儿全都就是这全都是没变的

2911
01:55:59,680 --> 01:56:00,310
这全都没

2912
01:56:00,310 --> 01:56:01,270
顺序是没变的

2913
01:56:01,270 --> 01:56:02,080
顺序是没变的

2914
01:56:02,440 --> 01:56:07,420
但是我脑子是不是还可能还有有可能是还还有这种情况绝对存在

2915
01:56:08,070 --> 01:56:09,870
而在这种情况下

2916
01:56:09,900 --> 01:56:10,860
他做了一个优化

2917
01:56:11,250 --> 01:56:13,170
就直接把后面的给删掉

2918
01:56:13,710 --> 01:56:15,090
所以这出现了一个delete

2919
01:56:16,020 --> 01:56:18,720
因为因为前面的顺序没变的情况下

2920
01:56:18,900 --> 01:56:23,340
而极有可能存在新速度小于老树的认识的情况

2921
01:56:23,610 --> 01:56:25,110
那么就把后面的给它删掉

2922
01:56:26,140 --> 01:56:27,280
这个就不需要再判断了

2923
01:56:27,280 --> 01:56:28,540
这个大家能理解吗

2924
01:56:28,960 --> 01:56:30,160
因为已经不需要判断了

2925
01:56:30,160 --> 01:56:31,630
这肯定是减少了

2926
01:56:31,960 --> 01:56:33,310
因为你顺序没变吗

2927
01:56:36,380 --> 01:56:36,710
OK

2928
01:56:36,710 --> 01:56:38,360
好这里这都理解了

2929
01:56:39,150 --> 01:56:39,960
现在能理解了

2930
01:56:40,580 --> 01:56:41,060
然后

2931
01:56:41,960 --> 01:56:43,220
Old favor等于na

2932
01:56:44,040 --> 01:56:44,610
说明

2933
01:56:44,640 --> 01:56:47,190
数字中的就是老数字的东西

2934
01:56:47,640 --> 01:56:48,360
X等于

2935
01:56:48,360 --> 01:56:50,250
那老数组的东西都可以服用

2936
01:56:50,990 --> 01:56:52,040
这个是o

2937
01:56:52,040 --> 01:56:52,970
因为o的fiber

2938
01:56:53,300 --> 01:56:54,200
大家看o的fiber

2939
01:56:54,200 --> 01:56:57,890
他也是在曾随着新数组的就是new index增加

2940
01:56:57,890 --> 01:56:58,970
Old farmer也在变

2941
01:56:59,600 --> 01:57:02,780
看偶的发表一直等于sin o的发表也在变

2942
01:57:04,420 --> 01:57:07,060
就是old后面看old一直等于Selina

2943
01:57:07,270 --> 01:57:08,980
就等于next也在变

2944
01:57:09,040 --> 01:57:10,780
如果o的FAB等于line了

2945
01:57:10,810 --> 01:57:11,590
那说明什么

2946
01:57:12,040 --> 01:57:14,170
说明我old法儿都已经走完了

2947
01:57:14,350 --> 01:57:15,970
那这个其实是另外一种情况

2948
01:57:16,890 --> 01:57:20,820
其实写的虽然就是rock写的有点儿不太好懂

2949
01:57:20,820 --> 01:57:21,120
但是呢

2950
01:57:21,120 --> 01:57:22,230
逻辑是好懂的

2951
01:57:23,350 --> 01:57:24,250
逻辑是好着呢

2952
01:57:24,550 --> 01:57:27,070
New old fiber为难的情况

2953
01:57:27,070 --> 01:57:27,730
那就是这种

2954
01:57:28,210 --> 01:57:30,010
我所有的old都对比完了

2955
01:57:30,010 --> 01:57:30,700
还没有跳出

2956
01:57:30,700 --> 01:57:31,210
也就是

2957
01:57:32,170 --> 01:57:33,730
旧的节点

2958
01:57:33,730 --> 01:57:35,170
旧旧的数组

2959
01:57:35,170 --> 01:57:37,270
它是小于等于新的数组的

2960
01:57:38,670 --> 01:57:39,420
这样子我的

2961
01:57:39,540 --> 01:57:41,040
但是它有很有可能等于骂

2962
01:57:41,040 --> 01:57:42,510
这个情况肯定是存在的

2963
01:57:42,720 --> 01:57:43,920
但也有可能小于

2964
01:57:43,980 --> 01:57:46,380
就是我们新速度有可能有新的节点

2965
01:57:48,700 --> 01:57:48,910
有

2966
01:57:48,910 --> 01:57:50,230
也很可能有新的节点

2967
01:57:50,320 --> 01:57:52,630
我当我的FAB等于零的时候

2968
01:57:52,900 --> 01:57:53,350
OK

2969
01:57:53,650 --> 01:57:55,180
那么我们就看

2970
01:57:56,150 --> 01:57:58,160
还剩下几个对吧

2971
01:57:58,160 --> 01:57:59,300
这个是new index

2972
01:57:59,930 --> 01:58:00,650
如果X等于

2973
01:58:00,650 --> 01:58:02,090
那肯定只要找到这里

2974
01:58:02,120 --> 01:58:03,350
那new index等于他

2975
01:58:03,930 --> 01:58:04,350
对不对

2976
01:58:04,560 --> 01:58:05,400
那后面这些

2977
01:58:06,290 --> 01:58:07,820
如果存在那都是新的

2978
01:58:07,820 --> 01:58:08,690
那都要创建

2979
01:58:09,050 --> 01:58:10,190
因为这几个新的的话

2980
01:58:10,190 --> 01:58:11,300
也不需要再对比了

2981
01:58:11,330 --> 01:58:12,290
创建就完事儿了

2982
01:58:12,710 --> 01:58:13,610
再找人理解嘛

2983
01:58:13,880 --> 01:58:14,780
理解扣个一

2984
01:58:19,770 --> 01:58:22,500
对他逻辑其实你看这个代码写的复杂

2985
01:58:22,530 --> 01:58:23,820
但它逻辑是简单的

2986
01:58:24,120 --> 01:58:24,450
对不对

2987
01:58:24,450 --> 01:58:25,530
逻辑是简单的逻辑

2988
01:58:25,530 --> 01:58:27,870
我们我们如果自己要

2989
01:58:28,620 --> 01:58:29,340
做这样的

2990
01:58:30,290 --> 01:58:31,520
做这样的那个优化

2991
01:58:31,790 --> 01:58:33,530
我们可以不写他们这么复杂

2992
01:58:34,010 --> 01:58:35,150
他可能考虑的场景比较多

2993
01:58:35,150 --> 01:58:36,290
我们可以不写那么复杂

2994
01:58:36,290 --> 01:58:37,100
但是我们可以

2995
01:58:37,910 --> 01:58:39,170
使用他的这个逻辑

2996
01:58:39,170 --> 01:58:40,430
你看他什么呢

2997
01:58:40,430 --> 01:58:43,970
FAB等于linein X等于认识

2998
01:58:43,970 --> 01:58:44,690
Ad等于

2999
01:58:44,690 --> 01:58:46,550
那就是不好好给你写不

3000
01:58:46,730 --> 01:58:49,040
你重新用个上面变量给它标一下

3001
01:58:49,040 --> 01:58:51,950
是不是逻辑看起来会更加清晰好懂一些

3002
01:58:52,750 --> 01:58:53,740
但他但他没有

3003
01:58:54,040 --> 01:58:55,660
所以我们的逻辑好懂

3004
01:58:56,050 --> 01:58:57,130
但是代码不太好懂

3005
01:58:57,430 --> 01:58:58,180
就这个意思

3006
01:58:59,510 --> 01:59:00,080
下边儿

3007
01:59:00,930 --> 01:59:02,430
下边这个

3008
01:59:02,430 --> 01:59:04,200
就是最后最后一章

3009
01:59:04,470 --> 01:59:06,390
如果它顺序被打乱了呢

3010
01:59:06,480 --> 01:59:06,750
对吧

3011
01:59:06,810 --> 01:59:08,070
顺序要是被打乱了

3012
01:59:08,700 --> 01:59:09,690
那上面的情况

3013
01:59:09,690 --> 01:59:11,460
那肯定就是属于中途被跳出了

3014
01:59:12,150 --> 01:59:12,840
那么就是这

3015
01:59:13,940 --> 01:59:15,980
这其实也是一种很经典的一个

3016
01:59:17,390 --> 01:59:18,560
方法吧方法吧

3017
01:59:18,560 --> 01:59:19,940
就是他先

3018
01:59:20,570 --> 01:59:23,990
他先把老的做成一个map

3019
01:59:24,080 --> 01:59:26,120
大家看他把老的做成一个map

3020
01:59:26,510 --> 01:59:28,790
这个map to returning children

3021
01:59:29,120 --> 01:59:31,460
他把剩下的老的做成一个map

3022
01:59:32,270 --> 01:59:33,680
然后新的来找

3023
01:59:34,230 --> 01:59:36,090
来找他是

3024
01:59:36,740 --> 01:59:37,670
是否可以服用

3025
01:59:38,810 --> 01:59:39,920
这样子是干什么

3026
01:59:40,070 --> 01:59:42,710
这样的话可以减少复杂度

3027
01:59:43,190 --> 01:59:43,820
减少复杂度

3028
01:59:43,820 --> 01:59:46,160
这就相当于如果我们不用这种方案

3029
01:59:46,250 --> 01:59:46,670
其实他

3030
01:59:47,850 --> 01:59:49,080
现在他要做的事情

3031
01:59:49,080 --> 01:59:51,090
这个他要做的事情就是对比两个数组

3032
01:59:52,100 --> 01:59:53,630
他要对比两个数组

3033
01:59:55,160 --> 01:59:55,940
里面的东西

3034
01:59:56,790 --> 01:59:57,690
有没有一样的

3035
01:59:59,030 --> 02:00:00,320
按正常的想法对比

3036
02:00:00,320 --> 02:00:01,910
两个速度有没有一样的

3037
02:00:04,220 --> 02:00:05,180
最简单的逻辑

3038
02:00:05,270 --> 02:00:06,590
那肯定是双层循环

3039
02:00:07,180 --> 02:00:08,740
它的复杂度是o的平方

3040
02:00:08,740 --> 02:00:09,340
对不对

3041
02:00:09,940 --> 02:00:11,290
OPPO的a的平方

3042
02:00:13,470 --> 02:00:14,460
因为对比两个数组

3043
02:00:14,460 --> 02:00:15,240
你没有办法

3044
02:00:15,240 --> 02:00:15,960
你只能够

3045
02:00:16,670 --> 02:00:19,160
你只能够你要对比的准确的话

3046
02:00:19,730 --> 02:00:22,520
那么你只能够一个循环套一个循环OM的平方

3047
02:00:23,560 --> 02:00:26,860
而这实际上是一种非常非常普遍的一种优化

3048
02:00:26,860 --> 02:00:28,330
就是我把其中的一个

3049
02:00:28,570 --> 02:00:30,340
比如把它做成一个

3050
02:00:30,550 --> 02:00:31,510
做成一个map

3051
02:00:32,920 --> 02:00:33,850
这是一个map

3052
02:00:34,920 --> 02:00:37,500
那么它就相当于是循环了一次

3053
02:00:38,370 --> 02:00:39,960
在下面这个数字

3054
02:00:40,840 --> 02:00:42,820
然后便利下面这个数字

3055
02:00:42,850 --> 02:00:45,010
然后那从这个map中找

3056
02:00:45,010 --> 02:00:45,880
可能是ID

3057
02:00:45,880 --> 02:00:46,720
有可能是ID

3058
02:00:46,900 --> 02:00:47,890
这他是K值

3059
02:00:47,980 --> 02:00:49,360
这他是通过K值来找的

3060
02:00:49,840 --> 02:00:51,340
通过K值作为它的map

3061
02:00:51,890 --> 02:00:53,060
作为他那个漫步的K

3062
02:00:53,740 --> 02:00:55,660
那么K其实就是对象嘛

3063
02:00:55,660 --> 02:00:55,900
对吧

3064
02:00:55,900 --> 02:00:57,250
对象的键值对的K

3065
02:00:58,860 --> 02:01:00,210
也就是说它循环了一次

3066
02:01:00,240 --> 02:01:00,960
做成一个map

3067
02:01:00,990 --> 02:01:02,250
循环了第二次

3068
02:01:02,960 --> 02:01:03,980
来找他的K

3069
02:01:03,980 --> 02:01:04,550
这样的话

3070
02:01:04,700 --> 02:01:06,680
它的复杂度就是二的

3071
02:01:07,940 --> 02:01:09,830
二的N2的on

3072
02:01:10,460 --> 02:01:14,750
他把复杂度成功地从on的方降低了二的

3073
02:01:14,990 --> 02:01:16,250
这样能理解吗

3074
02:01:17,030 --> 02:01:17,990
理解的扣个一

3075
02:01:18,530 --> 02:01:19,520
不是你理解的扣个零

3076
02:01:20,210 --> 02:01:21,080
应该遇到过这

3077
02:01:21,410 --> 02:01:22,760
应该遇到过这种场景吧

3078
02:01:24,870 --> 02:01:27,840
上周有同有同学还还问过另外一个问题

3079
02:01:27,840 --> 02:01:32,070
其实就是就是比如说当时问的那个问题是我一个数字

3080
02:01:32,070 --> 02:01:33,660
一个老树组一个新数组

3081
02:01:33,720 --> 02:01:35,520
他想他要对比这个

3082
02:01:36,970 --> 02:01:37,870
他要对比

3083
02:01:38,740 --> 02:01:41,950
新的速度是就他这比那个

3084
02:01:43,480 --> 02:01:44,890
新数组里的那个

3085
02:01:46,620 --> 02:01:48,240
IDID如果等于老师的ID

3086
02:01:48,240 --> 02:01:49,470
他要把它替换掉

3087
02:01:50,040 --> 02:01:53,760
然后他想知道就是能不能不用三种情况的这种方式

3088
02:01:53,760 --> 02:01:55,050
有什么优化的方法

3089
02:01:55,580 --> 02:01:57,680
然后我就告诉他这种方法

3090
02:01:58,330 --> 02:02:00,550
就成功的把复杂度给降低了

3091
02:02:01,320 --> 02:02:01,860
就这样

3092
02:02:03,630 --> 02:02:04,170
就是这样

3093
02:02:04,590 --> 02:02:07,650
所以从源码里其实能学到不少东西

3094
02:02:07,920 --> 02:02:09,660
但这个你如果仔细的去想

3095
02:02:09,660 --> 02:02:10,500
其实也能想到

3096
02:02:11,270 --> 02:02:13,400
也不是他也不是他独有的也能想到

3097
02:02:14,680 --> 02:02:15,100
OK

3098
02:02:15,460 --> 02:02:18,280
单击点的不多点DF就讲完了

3099
02:02:18,460 --> 02:02:19,360
多点DF

3100
02:02:20,350 --> 02:02:22,030
会比单机的地方麻烦一些

3101
02:02:23,790 --> 02:02:26,430
咋不了K中判断会拿K中判断同学

3102
02:02:26,670 --> 02:02:28,800
但是我没把它代码列出来

3103
02:02:28,800 --> 02:02:29,910
它在这个方法里面

3104
02:02:30,580 --> 02:02:32,860
在这个update from APP里累不

3105
02:02:33,900 --> 02:02:34,800
这这我讲的吗

3106
02:02:34,800 --> 02:02:35,310
他这个

3107
02:02:35,980 --> 02:02:38,290
这个方法它会把它做成一个map

3108
02:02:38,290 --> 02:02:39,460
这个map的K值

3109
02:02:39,490 --> 02:02:40,870
这个map的那个键值对

3110
02:02:40,900 --> 02:02:41,920
其实就是键值对吗

3111
02:02:42,250 --> 02:02:43,390
键值对就是一个K

3112
02:02:43,390 --> 02:02:44,230
然后一个forever

3113
02:02:45,140 --> 02:02:47,720
所以他在update from map的时候

3114
02:02:47,720 --> 02:02:48,860
怎么from map

3115
02:02:48,980 --> 02:02:50,420
那他肯定通过K去找吗

3116
02:02:55,850 --> 02:02:57,200
但是他还要这个

3117
02:02:58,020 --> 02:02:59,730
不光是index的时候

3118
02:02:59,730 --> 02:03:01,140
他还要替换回去

3119
02:03:02,140 --> 02:03:03,310
他还要千万回去

3120
02:03:04,740 --> 02:03:04,890
对

3121
02:03:04,890 --> 02:03:06,090
你这个也是2N

3122
02:03:06,390 --> 02:03:07,500
你这个也是2N

3123
02:03:07,800 --> 02:03:08,850
但是你做成map

3124
02:03:09,120 --> 02:03:11,220
它的场景要更全面一些

3125
02:03:11,430 --> 02:03:13,020
你用include来对比的话

3126
02:03:13,200 --> 02:03:14,130
那你还要找到他

3127
02:03:14,130 --> 02:03:15,150
让他再给他付值

3128
02:03:15,210 --> 02:03:15,600
对不对

3129
02:03:16,140 --> 02:03:16,350
拍

3130
02:03:16,350 --> 02:03:17,400
再重新给它赋值

3131
02:03:19,770 --> 02:03:20,520
都是一样的

3132
02:03:21,100 --> 02:03:21,430
嗯

3133
02:03:24,400 --> 02:03:25,870
没K直接pass了吧

3134
02:03:25,960 --> 02:03:26,350
是的

3135
02:03:27,520 --> 02:03:28,210
没K的话

3136
02:03:28,210 --> 02:03:29,410
那既然没有K呢

3137
02:03:29,410 --> 02:03:30,130
就找不到吗

3138
02:03:31,240 --> 02:03:32,020
找不到的话

3139
02:03:32,680 --> 02:03:33,730
那么他就得充电了

3140
02:03:33,820 --> 02:03:34,510
就得充电了

3141
02:03:35,510 --> 02:03:36,560
这个逻辑我没有写

3142
02:03:36,560 --> 02:03:37,430
没有写出来

3143
02:03:37,610 --> 02:03:38,510
但是我跟了

3144
02:03:38,600 --> 02:03:40,670
我这是跟着带码的了

3145
02:03:40,670 --> 02:03:41,030
代码的

3146
02:03:41,030 --> 02:03:42,590
它这就是一个map

3147
02:03:43,470 --> 02:03:45,600
就是我们的绿数组的这个绿

3148
02:03:45,600 --> 02:03:47,700
就是JS里面的new map它的K

3149
02:03:47,700 --> 02:03:49,080
他那个建筑的K

3150
02:03:49,940 --> 02:03:51,140
就是里面这个克制

3151
02:03:52,270 --> 02:03:54,700
所以这对比也是很方便的

3152
02:03:54,730 --> 02:03:55,600
其实就是这个逻辑

3153
02:03:56,350 --> 02:03:56,680
对吧

3154
02:03:56,980 --> 02:03:58,060
还是说哪句话

3155
02:03:58,450 --> 02:03:59,410
他写的复杂了

3156
02:03:59,410 --> 02:04:01,090
他我觉得他写的复杂

3157
02:04:02,670 --> 02:04:03,480
可能不够

3158
02:04:03,480 --> 02:04:04,440
不够语义化

3159
02:04:05,210 --> 02:04:09,350
但是他的逻辑还是很好懂的逻辑还是挺挺容易懂的

3160
02:04:10,020 --> 02:04:10,380
对不对

3161
02:04:11,540 --> 02:04:11,990
OK

3162
02:04:12,020 --> 02:04:12,650
然后啊

3163
02:04:13,560 --> 02:04:17,880
剩下的在begin work里打上flag标记

3164
02:04:17,880 --> 02:04:18,870
这个就不说了

3165
02:04:18,870 --> 02:04:19,590
已经讲过了

3166
02:04:19,890 --> 02:04:21,480
毕竟这是re cons or

3167
02:04:21,960 --> 02:04:23,250
这个阶段就讲完了

3168
02:04:23,610 --> 02:04:24,570
这个阶段讲完了

3169
02:04:25,470 --> 02:04:27,420
接下来我们还剩一个大的模块

3170
02:04:27,420 --> 02:04:28,620
但是这个模块很好讲

3171
02:04:29,010 --> 02:04:29,610
很好讲

3172
02:04:29,610 --> 02:04:33,360
其实前面的主要主要的活儿就是re cons ter干的

3173
02:04:33,510 --> 02:04:34,500
Consider干了很多

3174
02:04:35,010 --> 02:04:38,370
接下来我就直接给大家讲这个人的阶段

3175
02:04:38,370 --> 02:04:39,330
或者说commit阶段

3176
02:04:39,600 --> 02:04:40,350
他做的一件

3177
02:04:40,350 --> 02:04:42,000
它其实主要就做一件事情

3178
02:04:42,740 --> 02:04:46,370
把变化的组建渲染到页面上这么一件最要紧的事情

3179
02:04:46,460 --> 02:04:49,850
而由于操作当时最昂贵的一件事情

3180
02:04:50,390 --> 02:04:51,920
JS的性能瓶颈在哪里

3181
02:04:52,070 --> 02:04:53,120
大家都知道吧

3182
02:04:53,540 --> 02:04:56,510
JS的性能瓶颈就是操作DOM上面

3183
02:04:56,930 --> 02:04:59,300
所以为什么刚开始从这块儿要过渡到

3184
02:04:59,890 --> 02:05:02,350
过渡到那个像react Vue这种数据

3185
02:05:02,350 --> 02:05:03,280
其实是框架

3186
02:05:03,640 --> 02:05:05,650
第一个原因是因为是响应式的

3187
02:05:05,980 --> 02:05:06,970
那么第二个原因是

3188
02:05:08,120 --> 02:05:08,960
用j query

3189
02:05:09,020 --> 02:05:12,230
他每次都要每他每掉一次就操作一次down

3190
02:05:12,960 --> 02:05:13,200
对吧

3191
02:05:13,200 --> 02:05:14,700
它的它的那个性能

3192
02:05:15,060 --> 02:05:18,240
它的性能的这个上限很高

3193
02:05:18,390 --> 02:05:19,710
下限同样很高

3194
02:05:19,920 --> 02:05:20,760
同样很低

3195
02:05:21,340 --> 02:05:23,080
因为你如果如果写的差的话

3196
02:05:23,080 --> 02:05:25,330
那你每次操作但不太多了

3197
02:05:25,420 --> 02:05:26,620
你的页面会极其的卡

3198
02:05:26,770 --> 02:05:27,820
但他上线又很高

3199
02:05:28,270 --> 02:05:31,300
上限就是你真的知道什么时候该操作

3200
02:05:31,480 --> 02:05:32,560
什么时候不该操作

3201
02:05:33,190 --> 02:05:33,670
那么

3202
02:05:34,120 --> 02:05:34,570
那么你

3203
02:05:34,570 --> 02:05:36,370
你的性能不一定比用react

3204
02:05:36,370 --> 02:05:38,200
用VB写性能差

3205
02:05:38,800 --> 02:05:39,130
这块

3206
02:05:39,770 --> 02:05:42,260
ER ret和view这种数据驱动视图的

3207
02:05:42,560 --> 02:05:44,720
他由于有JS的这么一个过程

3208
02:05:44,720 --> 02:05:46,940
就是结石做当地府对吧

3209
02:05:47,060 --> 02:05:48,950
向wreck的运行时的

3210
02:05:49,560 --> 02:05:50,730
逻辑尤为繁重

3211
02:05:50,970 --> 02:05:53,250
运势的这个开销尤为繁重

3212
02:05:54,590 --> 02:06:00,110
所以所以他他会额外比直接操作当会有一部分的开销

3213
02:06:00,720 --> 02:06:01,140
但是呢

3214
02:06:01,140 --> 02:06:02,520
他实际上是给你的一个君子

3215
02:06:02,520 --> 02:06:05,970
就是保证了你性能的最低限度是什么

3216
02:06:05,970 --> 02:06:06,750
他给你保证了

3217
02:06:06,900 --> 02:06:08,700
你就算写得非常一般

3218
02:06:08,880 --> 02:06:09,210
对吧

3219
02:06:09,660 --> 02:06:12,150
就算写得非常一般也也慢不到哪去

3220
02:06:12,840 --> 02:06:14,910
你要是再懂点儿优化的话就更好

3221
02:06:15,540 --> 02:06:17,790
你如果想要非常牛逼的性能

3222
02:06:18,240 --> 02:06:20,520
那么你肯定不会用没有react

3223
02:06:20,520 --> 02:06:24,240
因为他们会有一部分的JS是超杰

3224
02:06:24,240 --> 02:06:27,180
是运行的时候的一些性能开销

3225
02:06:27,270 --> 02:06:29,580
就比如说像这个re consider扔的

3226
02:06:30,250 --> 02:06:30,970
扔在阶段

3227
02:06:31,240 --> 02:06:32,770
那么这种心理开销他是存在的

3228
02:06:33,160 --> 02:06:37,570
所以他是我觉得他是保定的一个性能最低的一个下线儿

3229
02:06:37,780 --> 02:06:39,220
操作当非常的昂贵

3230
02:06:39,610 --> 02:06:41,110
所以在这个

3231
02:06:41,700 --> 02:06:42,870
操作昂贵的过程

3232
02:06:43,350 --> 02:06:45,270
它的优先级会是最高的

3233
02:06:45,450 --> 02:06:46,770
就是它会run with property

3234
02:06:46,770 --> 02:06:49,410
这儿有一个最高优先级的就是

3235
02:06:51,360 --> 02:06:54,300
就是那个immediate immediate priority

3236
02:06:56,210 --> 02:06:57,740
立刻执行的那个优先级

3237
02:06:58,040 --> 02:06:59,300
然后就执行compute

3238
02:07:00,680 --> 02:07:02,720
所以他就干这么一件事情

3239
02:07:02,720 --> 02:07:04,460
其他的啥也不干儿

3240
02:07:04,640 --> 02:07:05,900
干这么一件事情呢

3241
02:07:05,990 --> 02:07:07,370
分为三个阶段

3242
02:07:07,640 --> 02:07:08,450
第一个阶段是

3243
02:07:09,180 --> 02:07:10,470
更新当他的钱

3244
02:07:12,820 --> 02:07:13,600
但操作中

3245
02:07:14,890 --> 02:07:15,670
操作后

3246
02:07:16,270 --> 02:07:20,200
分别在当操作前和当操作后分别对应两个生命周期

3247
02:07:20,320 --> 02:07:22,000
而当操作的话就直接操作

3248
02:07:22,600 --> 02:07:25,090
当操作钱就是给你最后一次更改的机会

3249
02:07:25,090 --> 02:07:27,490
一个勾子叫做get snapshot before update

3250
02:07:27,910 --> 02:07:29,770
我们在begin work里也看到过他

3251
02:07:29,830 --> 02:07:32,080
只不过只是给他打上一个标记

3252
02:07:32,110 --> 02:07:32,530
对不对

3253
02:07:33,060 --> 02:07:34,440
只是已经看到过他了

3254
02:07:34,800 --> 02:07:36,150
只是把标记给他打好了

3255
02:07:36,720 --> 02:07:37,590
标记给他打好了

3256
02:07:38,250 --> 02:07:39,690
然后我们看一下他做了什么事情

3257
02:07:39,750 --> 02:07:40,110
第一

3258
02:07:40,260 --> 02:07:42,600
处理单结点渲染删除后的澳洲

3259
02:07:43,570 --> 02:07:45,310
FOX blue

3260
02:07:45,520 --> 02:07:48,190
Bloom逻辑这个的话其实还好

3261
02:07:48,700 --> 02:07:50,980
第二个就是当超

3262
02:07:50,980 --> 02:07:51,730
当宣传

3263
02:07:52,120 --> 02:07:53,890
就是当操作前骂

3264
02:07:54,840 --> 02:07:56,430
那咱们几点见点钱

3265
02:07:57,920 --> 02:07:59,570
就是要要更新前

3266
02:07:59,570 --> 02:08:00,740
然后做一些准备工作

3267
02:08:01,040 --> 02:08:02,960
再调一个你掉一个

3268
02:08:03,200 --> 02:08:06,290
你还有最后一次更改的这么一个机会

3269
02:08:07,020 --> 02:08:08,280
的一个生命周期的勾子

3270
02:08:08,310 --> 02:08:12,630
他是不是就类似于浏览器提供的那个叫request request animation frame

3271
02:08:12,660 --> 02:08:18,120
他也是在浏览器每一帧调用之前也给你一个机会执行方法吗

3272
02:08:19,060 --> 02:08:20,650
这其实也就是一个勾子

3273
02:08:21,490 --> 02:08:26,110
可以在当学生当真正操作前来掉第三个

3274
02:08:26,110 --> 02:08:27,640
它会调度you the fact

3275
02:08:28,360 --> 02:08:30,760
有同学可能这就有点迷糊了

3276
02:08:31,000 --> 02:08:32,470
之前有同学就迷糊了说

3277
02:08:33,380 --> 02:08:34,520
我记得就是有同学就说

3278
02:08:34,520 --> 02:08:36,230
老老师use the fact

3279
02:08:36,230 --> 02:08:37,370
我记得他适合

3280
02:08:38,120 --> 02:08:40,700
他是在当操作之后才掉的

3281
02:08:40,700 --> 02:08:43,250
他he demanded应该是同一个时期的

3282
02:08:44,090 --> 02:08:45,110
同一个时期的方法

3283
02:08:45,760 --> 02:08:46,450
说的没错

3284
02:08:46,900 --> 02:08:47,560
说的很对

3285
02:08:47,980 --> 02:08:50,635
但是这里他是我并没有说调用儿

3286
02:08:50,635 --> 02:08:52,930
说的是调度调度usage effective

3287
02:08:52,990 --> 02:08:53,410
因为

3288
02:08:54,000 --> 02:08:54,870
You the fact

3289
02:08:55,600 --> 02:08:57,910
他实际上并不完全等价于

3290
02:08:58,620 --> 02:09:00,120
Component demand

3291
02:09:02,370 --> 02:09:03,510
的那个调用时机

3292
02:09:03,930 --> 02:09:05,220
它是异步调用的

3293
02:09:05,850 --> 02:09:09,000
ER component did mount是同步调用什么

3294
02:09:09,180 --> 02:09:11,820
而他调度usage就是她

3295
02:09:12,430 --> 02:09:12,940
比如衣服

3296
02:09:12,940 --> 02:09:13,390
我们知道

3297
02:09:13,390 --> 02:09:15,430
就会给他设一个类似于山猫的

3298
02:09:15,430 --> 02:09:15,820
对不对

3299
02:09:16,240 --> 02:09:17,440
那他解假如

3300
02:09:17,440 --> 02:09:18,430
假如这么简单吗

3301
02:09:18,490 --> 02:09:18,940
他的C

3302
02:09:18,940 --> 02:09:19,690
他猫的时机

3303
02:09:19,690 --> 02:09:20,920
那就是在这个地方设了

3304
02:09:21,340 --> 02:09:25,000
于是他并不会在这个时候就立刻执行use effect

3305
02:09:25,000 --> 02:09:25,870
那个call back

3306
02:09:26,140 --> 02:09:26,980
这个能理解吗

3307
02:09:28,700 --> 02:09:29,360
这样能理解吗

3308
02:09:29,360 --> 02:09:30,500
他是在这个地方调度的

3309
02:09:31,180 --> 02:09:34,090
不然大家如果下来真的看代码的话

3310
02:09:34,450 --> 02:09:36,640
看到这儿可能就就觉得有点懵

3311
02:09:40,680 --> 02:09:41,340
他也不是注册

3312
02:09:41,340 --> 02:09:42,450
他是先

3313
02:09:42,450 --> 02:09:43,650
他就先发起了嘛

3314
02:09:44,010 --> 02:09:44,760
他就先发起了

3315
02:09:44,760 --> 02:09:46,170
但是因为他这个一步的

3316
02:09:46,620 --> 02:09:48,210
他在红任务当中运行

3317
02:09:48,600 --> 02:09:48,810
对吧

3318
02:09:48,810 --> 02:09:50,460
他也在红任务当中运行

3319
02:09:50,880 --> 02:09:54,900
所以他会等你整体这个主线程执行完了之后

3320
02:09:54,900 --> 02:09:56,970
再执行那个红任务当中的扣back

3321
02:09:58,060 --> 02:09:59,140
他在这儿已经发起了

3322
02:09:59,140 --> 02:10:01,900
但是这个课的最终执行并不是在这个位置

3323
02:10:02,740 --> 02:10:03,610
能理解吗

3324
02:10:06,710 --> 02:10:07,220
OK

3325
02:10:07,220 --> 02:10:09,230
然后我们就可以看一下代码

3326
02:10:09,230 --> 02:10:10,370
代码其实非常简单

3327
02:10:10,850 --> 02:10:14,420
这个是react已经优化过一部分的带一版的代码了

3328
02:10:14,420 --> 02:10:15,320
之前写的很乱

3329
02:10:15,380 --> 02:10:16,430
那现在写的比较简单

3330
02:10:16,820 --> 02:10:19,460
第1FAVOR得到一个第一个fiber

3331
02:10:20,060 --> 02:10:20,450
然后呢

3332
02:10:20,450 --> 02:10:21,290
如果发不等于

3333
02:10:21,290 --> 02:10:23,150
那那么看一下

3334
02:10:24,500 --> 02:10:26,570
如果看下是不是要删除的

3335
02:10:26,630 --> 02:10:27,470
如果是要删除的

3336
02:10:27,470 --> 02:10:31,970
就去注意它的一些out of focus blue的这些逻辑

3337
02:10:32,000 --> 02:10:33,200
这个就不展开讲了

3338
02:10:33,850 --> 02:10:36,460
拿这儿如果他有子节点大家看

3339
02:10:37,260 --> 02:10:38,580
如果有子节点

3340
02:10:38,640 --> 02:10:40,380
那么先处理这是递归

3341
02:10:41,020 --> 02:10:42,430
这个和它是一样的

3342
02:10:44,730 --> 02:10:45,450
打个标记

3343
02:10:47,080 --> 02:10:48,010
这个他是一样的

3344
02:10:48,040 --> 02:10:49,780
他这是在递归就是

3345
02:10:50,500 --> 02:10:52,570
然后这儿完了之后

3346
02:10:52,600 --> 02:10:58,300
它才会执行他自己的这个come come it before mute Asian effect in July

3347
02:10:58,540 --> 02:11:02,830
其实这个就是为什么说在REC的生命周期中

3348
02:11:03,250 --> 02:11:04,900
它的的MT也好

3349
02:11:04,930 --> 02:11:06,400
Complaint啊

3350
02:11:06,400 --> 02:11:07,840
给snapshot before update

3351
02:11:08,080 --> 02:11:08,800
他都是

3352
02:11:09,380 --> 02:11:12,470
子节点先执行这个生命周期

3353
02:11:13,460 --> 02:11:15,590
直接点先执行这个生命周期的逻辑

3354
02:11:15,590 --> 02:11:16,010
在这里

3355
02:11:16,460 --> 02:11:18,620
因为他是先帝规处理的子节点

3356
02:11:19,130 --> 02:11:20,060
然后才出去的

3357
02:11:20,060 --> 02:11:23,780
自己先先让自己的子节点的这个

3358
02:11:25,560 --> 02:11:26,400
先自己减

3359
02:11:26,400 --> 02:11:27,930
这个生命周期调

3360
02:11:28,640 --> 02:11:29,930
然后他们调完了之后

3361
02:11:30,170 --> 02:11:33,470
才会调用自己的就是地位处理子节点

3362
02:11:33,890 --> 02:11:34,790
他是不是又来到这儿

3363
02:11:34,790 --> 02:11:35,660
如果有直接点

3364
02:11:35,930 --> 02:11:37,340
那又又处理直接点

3365
02:11:37,400 --> 02:11:38,450
你知道没有子节点

3366
02:11:38,690 --> 02:11:39,140
然后呢

3367
02:11:39,140 --> 02:11:40,820
他才处理父节点

3368
02:11:41,620 --> 02:11:44,980
就是他在那个render节

3369
02:11:44,980 --> 02:11:47,320
就是render阶段和这个re consider阶段

3370
02:11:47,650 --> 02:11:51,970
他们的这个生命周期的这个调用的顺序是不一致的

3371
02:11:51,970 --> 02:11:53,440
他们完全是两套顺序

3372
02:11:55,120 --> 02:11:55,540
同学们

3373
02:11:55,540 --> 02:11:57,070
他们完全是两套顺序

3374
02:12:00,740 --> 02:12:01,160
然后呢

3375
02:12:01,160 --> 02:12:02,090
才返回兄弟

3376
02:12:06,400 --> 02:12:09,370
也是先先紧着自己的直接点

3377
02:12:10,460 --> 02:12:11,060
然后呢

3378
02:12:11,240 --> 02:12:11,930
再来自己

3379
02:12:14,880 --> 02:12:16,830
那自己处理完了再处理兄弟几天

3380
02:12:17,520 --> 02:12:18,210
就这么回事儿

3381
02:12:19,170 --> 02:12:21,750
这这就是第一个循环

3382
02:12:21,750 --> 02:12:24,690
其实对于render面试的时候

3383
02:12:25,600 --> 02:12:26,560
是非常好讲的

3384
02:12:26,830 --> 02:12:27,880
他就三个大外

3385
02:12:27,910 --> 02:12:29,080
就三个大循环

3386
02:12:29,900 --> 02:12:30,770
三个大胸

3387
02:12:30,770 --> 02:12:32,660
但肯定不是嵌套的三个

3388
02:12:32,990 --> 02:12:34,670
第一个就是这个

3389
02:12:35,620 --> 02:12:37,060
但操作前的这个大循环

3390
02:12:37,970 --> 02:12:40,130
第二个档操作中的单操作

3391
02:12:40,130 --> 02:12:41,840
这么来看同样也是一样

3392
02:12:42,550 --> 02:12:44,320
这个delete他每次都会这样

3393
02:12:44,530 --> 02:12:48,490
都会这样一下颜色family child不等于那的规

3394
02:12:48,940 --> 02:12:49,360
如果

3395
02:12:49,940 --> 02:12:50,840
如果等于浪了

3396
02:12:52,560 --> 02:12:53,040
自己

3397
02:12:54,160 --> 02:12:55,270
大家看这里的话

3398
02:12:55,510 --> 02:12:57,370
和上面的结构是完全一样的

3399
02:12:58,230 --> 02:12:58,440
死

3400
02:12:58,440 --> 02:12:59,160
完全一样

3401
02:13:00,570 --> 02:13:02,310
但是对删除组件呢

3402
02:13:02,310 --> 02:13:04,620
它就执行VRMT这个方法

3403
02:13:05,100 --> 02:13:06,360
这个是在

3404
02:13:07,060 --> 02:13:07,810
这个是在

3405
02:13:08,870 --> 02:13:10,400
这个是在

3406
02:13:12,420 --> 02:13:12,900
怎么啦

3407
02:13:13,750 --> 02:13:16,660
这个是在当操作中

3408
02:13:16,690 --> 02:13:19,390
当操作中这个阶段调用调用

3409
02:13:19,780 --> 02:13:21,190
所以严格来说

3410
02:13:21,730 --> 02:13:24,010
Component will mount的这个生命周期

3411
02:13:24,010 --> 02:13:26,050
它的执行时期肯定在determined之前

3412
02:13:26,720 --> 02:13:27,530
对不对的嘛

3413
02:13:27,530 --> 02:13:29,450
之前因为demand是在最后才执行的

3414
02:13:30,320 --> 02:13:31,010
这这这

3415
02:13:31,790 --> 02:13:33,080
大结构同样是一样

3416
02:13:35,200 --> 02:13:35,830
第三个

3417
02:13:37,890 --> 02:13:40,470
第三个这里稍微多一点点东西

3418
02:13:41,120 --> 02:13:41,510
怎么啦

3419
02:13:41,600 --> 02:13:43,520
一个是一个是

3420
02:13:44,400 --> 02:13:45,270
他要处理

3421
02:13:46,320 --> 02:13:47,700
一个是他要处理

3422
02:13:49,490 --> 02:13:52,610
按照上面的一个循环翘的不等于

3423
02:13:52,850 --> 02:13:53,690
然后就递归

3424
02:13:54,520 --> 02:13:56,590
递归还是先处理自己

3425
02:13:56,650 --> 02:13:57,220
自己点

3426
02:13:57,250 --> 02:13:58,000
如果自己点

3427
02:13:59,020 --> 02:13:59,980
没有那么就

3428
02:14:01,010 --> 02:14:04,220
在在走自己的带走自己的生命周期

3429
02:14:05,070 --> 02:14:09,600
这个地方是执行use layout INF ECT只会掉

3430
02:14:10,140 --> 02:14:14,370
如果这个地方是指的是方形comment方形comment

3431
02:14:14,980 --> 02:14:16,000
如果有hooks

3432
02:14:16,240 --> 02:14:18,250
那么他肯定就自行used your defect

3433
02:14:18,280 --> 02:14:20,680
这这处理的稍微多一点class的话

3434
02:14:20,680 --> 02:14:21,310
这就自信

3435
02:14:21,730 --> 02:14:25,180
真正执行的MT的地方就执行这个

3436
02:14:25,390 --> 02:14:26,350
所以严格来讲

3437
02:14:27,100 --> 02:14:31,630
Use layer odd effect才等于卡斯组件中的demand

3438
02:14:32,230 --> 02:14:34,960
ER you slay out you the fact的区别

3439
02:14:35,560 --> 02:14:37,180
这是面试常考问题

3440
02:14:37,660 --> 02:14:38,680
Usually you out

3441
02:14:40,290 --> 02:14:42,990
He you the layout affect和effect

3442
02:14:44,460 --> 02:14:45,060
区别

3443
02:14:47,510 --> 02:14:53,090
就是use effect是个异步的user yard是同步的usually I de fec

3444
02:14:53,090 --> 02:14:56,840
同步的ER usually or defect其次比较严格

3445
02:14:56,840 --> 02:14:57,380
等于

3446
02:14:57,940 --> 02:15:00,910
Component did mount的这么一个执行17

3447
02:15:01,900 --> 02:15:03,130
他们都是同步执行

3448
02:15:03,190 --> 02:15:08,890
就是在ER effect刚刚我们看到它其实会把它放到宏任务当中

3449
02:15:08,890 --> 02:15:10,270
执行一个异步的逻辑

3450
02:15:11,300 --> 02:15:11,900
衣服的逻辑

3451
02:15:13,130 --> 02:15:16,370
所以根据这个又衍生出了一个新的面试题

3452
02:15:16,430 --> 02:15:17,630
大家有没见过就是

3453
02:15:19,080 --> 02:15:19,800
就是这里

3454
02:15:20,880 --> 02:15:21,480
嗯

3455
02:15:22,830 --> 02:15:23,820
还是生命周期

3456
02:15:24,450 --> 02:15:25,650
就是生命周期的顺序

3457
02:15:26,650 --> 02:15:27,310
比如a

3458
02:15:27,400 --> 02:15:27,700
对吧

3459
02:15:27,700 --> 02:15:31,360
这是个比如方向组建和class组件

3460
02:15:31,360 --> 02:15:33,790
他们连在一起来考虑考察这个问题

3461
02:15:34,360 --> 02:15:36,700
比如ABC3个组件

3462
02:15:39,730 --> 02:15:41,200
ABC3个直线a

3463
02:15:45,370 --> 02:15:46,660
的生命有生命周期

3464
02:15:47,340 --> 02:15:47,850
然后呢

3465
02:15:48,420 --> 02:15:49,680
B有生命周期

3466
02:15:50,070 --> 02:15:51,420
C它没有生命周期

3467
02:15:51,420 --> 02:15:52,530
但是他这个hooks

3468
02:15:53,080 --> 02:15:54,790
那么他的执行顺序是什么

3469
02:15:55,490 --> 02:15:56,600
这个你

3470
02:15:56,780 --> 02:15:59,840
你非得了解you the effect he usually also affect

3471
02:15:59,840 --> 02:16:01,970
区别这我给大家说一嘴

3472
02:16:02,000 --> 02:16:03,440
Usually are you the effect

3473
02:16:03,590 --> 02:16:05,300
他这个CC肯定是最后的

3474
02:16:05,750 --> 02:16:06,230
不管怎样

3475
02:16:06,230 --> 02:16:07,190
他肯定是在最后

3476
02:16:08,380 --> 02:16:09,430
因为它是异步的吗

3477
02:16:09,460 --> 02:16:11,050
大家大家叫着他一步

3478
02:16:11,050 --> 02:16:12,160
他就会把它放在最后面

3479
02:16:12,160 --> 02:16:12,490
对不对

3480
02:16:12,580 --> 02:16:13,480
我们可以来看看

3481
02:16:14,250 --> 02:16:15,690
比如说a extension

3482
02:16:16,320 --> 02:16:16,740
那么

3483
02:16:17,550 --> 02:16:17,940
A

3484
02:16:17,970 --> 02:16:19,230
包含了两个组件

3485
02:16:19,230 --> 02:16:19,800
XBXC

3486
02:16:20,280 --> 02:16:21,960
这里一个demanded

3487
02:16:21,960 --> 02:16:24,630
一个get snapshot before update这两个

3488
02:16:25,360 --> 02:16:26,200
属性

3489
02:16:26,380 --> 02:16:29,200
这两个生命周期都是在任何阶段的

3490
02:16:29,230 --> 02:16:31,840
所以他们都是先优先直接点的

3491
02:16:31,840 --> 02:16:32,200
对不对

3492
02:16:32,560 --> 02:16:34,000
其实他们是优先子节点的

3493
02:16:34,300 --> 02:16:35,860
而他们的子节点是B和C

3494
02:16:38,630 --> 02:16:38,990
对

3495
02:16:39,500 --> 02:16:40,670
衣服的都放在最后

3496
02:16:40,850 --> 02:16:41,270
是的

3497
02:16:41,690 --> 02:16:42,320
但是你要

3498
02:16:42,470 --> 02:16:46,640
但是如果你不知道usually ah the fact he uses的区别的话

3499
02:16:46,970 --> 02:16:47,660
你就不懂

3500
02:16:47,990 --> 02:16:48,860
你就你就

3501
02:16:48,860 --> 02:16:49,550
你就做不对

3502
02:16:49,790 --> 02:16:51,080
就这个问题肯定就做不对

3503
02:16:53,240 --> 02:16:53,690
是不是

3504
02:16:54,480 --> 02:16:55,200
所以

3505
02:16:58,260 --> 02:17:00,480
我们就就看的MT就行了

3506
02:17:00,780 --> 02:17:04,650
这个snapshot的up data适合他的逻辑是一致的

3507
02:17:04,920 --> 02:17:05,580
你这

3508
02:17:05,580 --> 02:17:06,360
他有个的帽子

3509
02:17:06,360 --> 02:17:08,130
他一肯定不会先打呢

3510
02:17:08,130 --> 02:17:09,960
我们来看一下B和CB

3511
02:17:10,610 --> 02:17:11,210
B为底的话

3512
02:17:12,020 --> 02:17:14,270
那么他会先执行B对不对

3513
02:17:14,270 --> 02:17:15,020
先执行B

3514
02:17:15,350 --> 02:17:16,130
然后呢

3515
02:17:16,130 --> 02:17:19,220
执行C的弟弟

3516
02:17:20,140 --> 02:17:20,890
因为我说了

3517
02:17:20,890 --> 02:17:22,360
Usually are out effect

3518
02:17:23,560 --> 02:17:28,090
他基本上他比较类似于component的执行时机

3519
02:17:28,360 --> 02:17:31,030
所以他会先打二对不对

3520
02:17:31,060 --> 02:17:33,880
然后再打B的兄弟节点

3521
02:17:33,880 --> 02:17:36,160
C的这个u CL effect就是滴滴滴

3522
02:17:36,780 --> 02:17:37,170
二

3523
02:17:37,830 --> 02:17:38,340
滴滴的

3524
02:17:38,370 --> 02:17:40,140
而这个CC由于它是一部的

3525
02:17:40,140 --> 02:17:41,160
所以先不会执行

3526
02:17:42,120 --> 02:17:43,770
然然执行a的

3527
02:17:44,570 --> 02:17:45,020
一

3528
02:17:45,960 --> 02:17:47,430
最后自信谁谁谁

3529
02:17:49,840 --> 02:17:50,380
明白吗

3530
02:17:51,650 --> 02:17:51,845
对

3531
02:17:51,845 --> 02:17:53,630
有同学已经给出了正确答案了

3532
02:17:53,930 --> 02:17:54,380
很棒

3533
02:17:55,590 --> 02:17:57,510
同学们比较强

3534
02:18:00,210 --> 02:18:01,770
非常强大的

3535
02:18:02,340 --> 02:18:05,640
那么这个我觉得已经由这个问题延伸出来的

3536
02:18:05,850 --> 02:18:07,620
比如这个问题你们也会了

3537
02:18:08,040 --> 02:18:09,900
衍生出来的这个生命周期的问题

3538
02:18:09,900 --> 02:18:11,010
我觉得大家也会了

3539
02:18:11,070 --> 02:18:11,460
对不对

3540
02:18:12,300 --> 02:18:12,750
也会了

3541
02:18:13,840 --> 02:18:14,620
我们再来看

3542
02:18:16,080 --> 02:18:17,460
他除了这个还做了些什么

3543
02:18:17,550 --> 02:18:21,210
我们刚刚讲到他还做了一件非常重要的事情

3544
02:18:21,210 --> 02:18:22,260
这个复制瑞福

3545
02:18:22,680 --> 02:18:23,940
瑞福他也是在

3546
02:18:24,800 --> 02:18:27,200
因为他是可以拿到

3547
02:18:27,200 --> 02:18:28,700
如果对于当节点

3548
02:18:28,700 --> 02:18:30,050
它是可以拿到当元素

3549
02:18:30,140 --> 02:18:31,160
如果对于react组件

3550
02:18:31,160 --> 02:18:33,770
它是可以拿到整个reg组建的实力的

3551
02:18:34,310 --> 02:18:36,770
所以他的副职也是在

3552
02:18:38,010 --> 02:18:39,600
最后commit这个地方

3553
02:18:39,990 --> 02:18:42,750
就是最后commit阶段的第三个大V

3554
02:18:42,750 --> 02:18:45,270
就是demand这个阶段唱当操作之后

3555
02:18:45,810 --> 02:18:48,360
以及还有一个重要的不重要的一件事情

3556
02:18:49,060 --> 02:18:49,870
那就是

3557
02:18:53,600 --> 02:18:54,560
把

3558
02:18:56,920 --> 02:18:57,760
一

3559
02:18:58,420 --> 02:18:59,080
这个我

3560
02:18:59,080 --> 02:19:01,360
我打了黄色标记的care and a tree

3561
02:19:01,360 --> 02:19:03,190
在这个时候会发现纸箱会变

3562
02:19:03,950 --> 02:19:06,080
和我们之前所讲的就联系起来了

3563
02:19:06,110 --> 02:19:07,940
我们刚刚不是讲了双缓存结构嘛

3564
02:19:08,450 --> 02:19:09,890
一个ref I ber

3565
02:19:10,830 --> 02:19:11,160
对吧

3566
02:19:11,160 --> 02:19:12,480
一个是ER ECT routes

3567
02:19:12,720 --> 02:19:13,830
他有care and属性

3568
02:19:13,830 --> 02:19:15,960
指向了一个current组件

3569
02:19:16,440 --> 02:19:16,830
然后呢

3570
02:19:16,830 --> 02:19:18,660
构建一个新的working process street

3571
02:19:19,050 --> 02:19:19,920
然后当

3572
02:19:20,530 --> 02:19:21,850
页面变更完了之后

3573
02:19:22,210 --> 02:19:25,330
他就会把它给纸箱最后一股拿了纸箱

3574
02:19:26,000 --> 02:19:28,250
我们最新的work in progress the work in progress re

3575
02:19:28,250 --> 02:19:28,880
就转正了

3576
02:19:29,150 --> 02:19:30,380
就成了Karen的T了

3577
02:19:31,400 --> 02:19:32,390
这是chemistry

3578
02:19:32,810 --> 02:19:34,670
这个我好像没有粘出来

3579
02:19:35,300 --> 02:19:36,410
我可以找一找

3580
02:19:39,550 --> 02:19:40,510
我可以找一找

3581
02:19:42,720 --> 02:19:42,960
这样

3582
02:19:42,960 --> 02:19:43,560
我们就来

3583
02:19:44,740 --> 02:19:45,760
稍微看一下吧

3584
02:19:46,910 --> 02:19:49,310
再看一下他肯定在这个阶段做的

3585
02:19:54,560 --> 02:19:55,400
嗯

3586
02:20:04,320 --> 02:20:07,080
Black里面逻辑其实很多的同学们

3587
02:20:08,390 --> 02:20:11,000
很多的远远远远不止我讲的这些

3588
02:20:11,270 --> 02:20:11,720
但是

3589
02:20:12,420 --> 02:20:16,680
但是我讲的这些其实是它的最主要的价格的这个逻辑

3590
02:20:17,520 --> 02:20:19,470
有很多东西是可以往上靠的

3591
02:20:20,860 --> 02:20:21,730
负责riff

3592
02:20:24,270 --> 02:20:25,710
帮我找一找点Kevin

3593
02:20:31,990 --> 02:20:32,680
那就是

3594
02:20:39,080 --> 02:20:39,380
嗯

3595
02:20:41,330 --> 02:20:42,140
哪些人

3596
02:20:45,100 --> 02:20:46,570
应该是在调他之前

3597
02:20:50,470 --> 02:20:53,830
123串

3598
02:20:56,390 --> 02:20:57,440
我还在还在

3599
02:20:57,440 --> 02:20:57,950
他累不

3600
02:20:59,120 --> 02:20:59,840
四

3601
02:21:15,350 --> 02:21:15,950
干啥去

3602
02:21:18,290 --> 02:21:19,610
让我找找

3603
02:21:33,780 --> 02:21:34,620
否则re

3604
02:21:34,620 --> 02:21:35,910
否则这个地方

3605
02:21:37,470 --> 02:21:38,520
帮我看看饿的呢

3606
02:21:38,850 --> 02:21:39,870
看的有没有

3607
02:21:49,060 --> 02:21:51,310
这里漏点current等于

3608
02:21:52,180 --> 02:21:53,380
Finished work

3609
02:21:54,650 --> 02:21:55,100
Parent

3610
02:21:56,580 --> 02:21:57,540
Carrot变了

3611
02:22:00,120 --> 02:22:01,170
大家看current

3612
02:22:01,590 --> 02:22:02,280
这就是root

3613
02:22:02,280 --> 02:22:03,960
那个root的指向吗

3614
02:22:04,940 --> 02:22:05,810
绿色之下

3615
02:22:06,490 --> 02:22:07,270
嗯

3616
02:22:08,120 --> 02:22:09,050
咱这个地方

3617
02:22:09,930 --> 02:22:11,160
的那个双缓冲结构

3618
02:22:12,580 --> 02:22:13,510
烧化成结构

3619
02:22:14,130 --> 02:22:14,550
对不对

3620
02:22:15,150 --> 02:22:17,520
Wrote the current指向一遍

3621
02:22:18,180 --> 02:22:19,020
做这么一件事情

3622
02:22:20,020 --> 02:22:21,070
那这件事情在

3623
02:22:21,940 --> 02:22:22,840
哪里呢

3624
02:22:25,770 --> 02:22:26,760
也在

3625
02:22:27,360 --> 02:22:27,660
看

3626
02:22:29,690 --> 02:22:32,330
Commit commit mute Asian INF ECT

3627
02:22:32,870 --> 02:22:35,480
新的他的地方肯定发生

3628
02:22:35,510 --> 02:22:36,710
他的名字肯定变了

3629
02:22:37,580 --> 02:22:38,270
但是他的罗

3630
02:22:38,270 --> 02:22:39,710
他的地方肯定是不会变的

3631
02:22:40,220 --> 02:22:40,970
在此之后

3632
02:22:42,040 --> 02:22:44,230
如此奸嘅指向working progress

3633
02:22:45,180 --> 02:22:48,030
Working policy as commit a relation in fact

3634
02:22:49,920 --> 02:22:52,380
之后就是把党员县的页面之后

3635
02:22:53,090 --> 02:22:54,170
然后又在

3636
02:22:55,460 --> 02:22:57,440
又在这个函数之前

3637
02:22:57,800 --> 02:22:59,840
这个就是执行我们的

3638
02:23:00,900 --> 02:23:05,310
Component的demand生命这些之前他把它给变了

3639
02:23:06,810 --> 02:23:07,320
就是这样

3640
02:23:07,770 --> 02:23:11,280
这就是我们今天所讲的re consider和render

3641
02:23:12,140 --> 02:23:12,620
两块

3642
02:23:13,430 --> 02:23:13,670
Red

3643
02:23:13,670 --> 02:23:14,990
其实开干扰很简单

3644
02:23:14,990 --> 02:23:15,740
我们的RI cans are

3645
02:23:15,740 --> 02:23:17,060
我们大概讲了一个半小时

3646
02:23:17,390 --> 02:23:17,930
Render

3647
02:23:18,650 --> 02:23:20,150
可能就20分钟就讲完了

3648
02:23:20,660 --> 02:23:21,140
非常

3649
02:23:21,470 --> 02:23:22,790
因为它其实就三个well

3650
02:23:23,460 --> 02:23:24,690
没有什么过多可以讲的

3651
02:23:24,720 --> 02:23:25,740
接下来讲讲这个

3652
02:23:26,630 --> 02:23:28,100
Rock的刚re consider

3653
02:23:28,430 --> 02:23:31,940
这个就是我所说的re consider的单独的封装

3654
02:23:32,090 --> 02:23:34,670
Wrecked把re consider给封装成了一个独立的模块

3655
02:23:35,450 --> 02:23:36,020
什么好

3656
02:23:36,050 --> 02:23:39,950
这样做的一个好处就是你不管是浏览器的环境还是原生的环境

3657
02:23:40,650 --> 02:23:42,480
你如果用react的形式来构建

3658
02:23:42,540 --> 02:23:43,950
你都需要构建February

3659
02:23:44,160 --> 02:23:45,570
而这个逻辑是公用的

3660
02:23:46,180 --> 02:23:49,450
所以REC to re consider就可以完全拿来服用

3661
02:23:50,290 --> 02:23:51,880
就像我们的那个

3662
02:23:53,870 --> 02:23:55,160
京东的terra对吧

3663
02:23:55,160 --> 02:23:57,230
京东terra塌陷reg写法

3664
02:23:57,920 --> 02:24:00,230
那么它直接就用re cons ER就可以

3665
02:24:01,020 --> 02:24:03,450
然后开始就可以就这样浏览器

3666
02:24:04,200 --> 02:24:04,800
Write down

3667
02:24:05,190 --> 02:24:08,040
浏览器里面我们就结合right down right

3668
02:24:08,780 --> 02:24:09,860
只要re consider

3669
02:24:10,130 --> 02:24:11,660
当然red down的时候

3670
02:24:11,660 --> 02:24:13,490
他是不会让我们掉的

3671
02:24:13,910 --> 02:24:16,040
他是那个刀内部会直接掉

3672
02:24:16,040 --> 02:24:16,640
Re consider

3673
02:24:17,150 --> 02:24:18,140
它是内部就掉了

3674
02:24:19,230 --> 02:24:20,940
而像你如果想要写新的

3675
02:24:20,940 --> 02:24:21,360
比如

3676
02:24:21,630 --> 02:24:23,460
而且relative也是内部调的

3677
02:24:23,970 --> 02:24:24,840
如果你想写新的

3678
02:24:24,840 --> 02:24:25,650
比如像Tara

3679
02:24:26,790 --> 02:24:27,540
比如像Tara

3680
02:24:27,810 --> 02:24:30,060
那么他就引入这个red re cons are cool

3681
02:24:30,510 --> 02:24:31,200
然后呢

3682
02:24:31,380 --> 02:24:32,940
再写一个render e

3683
02:24:33,270 --> 02:24:34,380
我们来看一下这个方

3684
02:24:34,440 --> 02:24:35,610
我们看一下这个库

3685
02:24:36,120 --> 02:24:37,020
这其实是

3686
02:24:37,660 --> 02:24:41,590
如果说大家以后想写一个类似享用react的

3687
02:24:42,360 --> 02:24:43,080
写法

3688
02:24:43,470 --> 02:24:46,710
写一个类似的跨平台或者那么一个

3689
02:24:47,720 --> 02:24:48,560
框架的话

3690
02:24:50,060 --> 02:24:51,170
那么可以用到它

3691
02:24:51,200 --> 02:24:52,310
那么可以直接用到它

3692
02:24:52,580 --> 02:24:53,390
会非常方便

3693
02:24:53,960 --> 02:24:54,740
会非常方便

3694
02:24:54,740 --> 02:24:55,700
它用法很简单

3695
02:24:55,730 --> 02:24:56,090
第一

3696
02:24:56,700 --> 02:24:57,390
引入他

3697
02:24:57,960 --> 02:24:59,310
然后写一个config

3698
02:24:59,970 --> 02:25:02,970
把他关键的一些API给替换了就完事儿了

3699
02:25:02,970 --> 02:25:04,920
比如说在write down里面

3700
02:25:05,160 --> 02:25:06,390
在浏览器环境下

3701
02:25:06,750 --> 02:25:08,010
它创建一个元素

3702
02:25:08,040 --> 02:25:10,890
就是我们是不是叫做document.create element

3703
02:25:11,070 --> 02:25:12,840
这是创建函数的方法

3704
02:25:13,410 --> 02:25:16,860
创建创建元素的方法那么假如你是小程序

3705
02:25:17,280 --> 02:25:19,350
那么你就你就把这个方法给改了

3706
02:25:19,350 --> 02:25:20,760
就是create instance

3707
02:25:21,540 --> 02:25:22,890
你就把它给改了就行了

3708
02:25:22,890 --> 02:25:24,600
改成小程序创建名字上了

3709
02:25:25,680 --> 02:25:26,310
就完事儿了

3710
02:25:27,190 --> 02:25:27,730
然后呢

3711
02:25:27,760 --> 02:25:28,780
他有很多的

3712
02:25:29,380 --> 02:25:31,390
他有很多的就是一些

3713
02:25:32,200 --> 02:25:34,840
就是这个class里面会有很多的这个属性

3714
02:25:36,960 --> 02:25:38,430
这个它有很多这个属性

3715
02:25:38,910 --> 02:25:41,520
属性你你可以把它替换了就完事儿

3716
02:25:42,310 --> 02:25:43,450
所以这个写起来的话

3717
02:25:43,450 --> 02:25:47,050
你就相当于你重新创建了一个跨平台的一个方案

3718
02:25:47,410 --> 02:25:48,190
但实际上

3719
02:25:48,730 --> 02:25:50,650
但实际上他的逻辑却很简单

3720
02:25:50,650 --> 02:25:52,390
而且还服用了rap的这个

3721
02:25:53,040 --> 02:25:54,840
这个很强悍的运行时的优化

3722
02:25:56,720 --> 02:25:58,490
都说Tara的API不太全

3723
02:25:58,490 --> 02:25:59,510
网上解决方案也少

3724
02:25:59,510 --> 02:26:00,740
当时用的是是

3725
02:26:01,400 --> 02:26:02,060
Tara的

3726
02:26:02,730 --> 02:26:04,920
API你你是用的是

3727
02:26:05,560 --> 02:26:06,100
几啊

3728
02:26:07,960 --> 02:26:08,590
应该是几

3729
02:26:08,590 --> 02:26:09,850
后面应该还行

3730
02:26:11,430 --> 02:26:14,730
TARA3是他是38CHIRON ex

3731
02:26:14,730 --> 02:26:17,310
但是用telnet它就已经用了这种方案

3732
02:26:18,170 --> 02:26:20,090
因为你如果单用小程序写

3733
02:26:20,090 --> 02:26:23,510
已经就是来一个一个APP一个APP的转

3734
02:26:23,510 --> 02:26:24,380
已经不太方便了

3735
02:26:24,560 --> 02:26:26,420
所以TARA3就是最新的那一版

3736
02:26:26,420 --> 02:26:27,230
他用的这个方案

3737
02:26:29,050 --> 02:26:30,610
最新的那一版采用这个方案

3738
02:26:30,610 --> 02:26:31,990
以前的时候不是以前的

3739
02:26:31,990 --> 02:26:33,400
并不是直接调到X

3740
02:26:34,550 --> 02:26:35,270
最新的是

3741
02:26:35,980 --> 02:26:36,700
可以这么说

3742
02:26:37,210 --> 02:26:39,190
所以如果说大家有需求

3743
02:26:39,220 --> 02:26:40,150
自己想写一个

3744
02:26:40,510 --> 02:26:42,280
比如说想在shell上写个什么玩意儿

3745
02:26:43,120 --> 02:26:43,900
你可以用它

3746
02:26:44,710 --> 02:26:44,950
对吧

3747
02:26:44,950 --> 02:26:45,700
这是一种方案

3748
02:26:45,700 --> 02:26:49,870
如果说要需要你以后作为一个高级工程师

3749
02:26:49,930 --> 02:26:51,220
资深工程师

3750
02:26:51,520 --> 02:26:53,740
然后来做一个全面的方案选型的时候

3751
02:26:54,160 --> 02:26:56,080
那么这就是体现你价值的时候到了

3752
02:26:56,640 --> 02:26:58,590
你完全写一个不同平台的渲染器

3753
02:26:59,840 --> 02:27:01,610
那么是完全可以的

3754
02:27:02,270 --> 02:27:04,010
大家可以下来也可以看一下这个库

3755
02:27:05,180 --> 02:27:05,450
好

3756
02:27:05,450 --> 02:27:07,100
今天我们讲的话就讲到这儿吧

3757
02:27:07,310 --> 02:27:08,420
然后晚上的话

3758
02:27:08,420 --> 02:27:11,540
我们会再讲接下来的护士的源码的解读

3759
02:27:11,570 --> 02:27:14,480
以及以及Jess CA

3760
02:27:14,510 --> 02:27:17,510
然后REX18带来一些新的变化

3761
02:27:18,880 --> 02:27:21,130
现在就下课吧

3762
02:27:21,130 --> 02:27:21,520
同学们

3763
02:27:22,690 --> 02:27:23,620
可以休息会儿

3764
02:27:23,680 --> 02:27:24,160
休息会儿

3765
02:27:24,160 --> 02:27:25,570
晚上八点钟的时候我们再见

3766
02:27:26,260 --> 02:27:26,650
好吧

3767
02:27:42,700 --> 02:27:44,950
这儿绝对有bug

3768
02:27:46,210 --> 02:27:47,560
行

3769
02:27:47,560 --> 02:27:48,310
这块儿

3770
02:27:51,430 --> 02:27:54,580
这个咖啡的流程的流程这块儿能明白吗

3771
02:27:54,610 --> 02:27:55,660
明白了给大家

3772
02:27:56,340 --> 02:27:58,320
扣个一不能再扣一个呢

3773
02:27:58,920 --> 02:28:00,180
有意的话我们就下课了

3774
02:28:01,320 --> 02:28:02,430
行的话我再讲讲

3775
02:28:10,350 --> 02:28:10,920
同学

3776
02:28:11,190 --> 02:28:13,200
你刚刚有没有认真听

3777
02:28:13,710 --> 02:28:15,480
Get snapshot before update

3778
02:28:16,400 --> 02:28:18,470
Render看render有三个流程

3779
02:28:18,620 --> 02:28:19,580
有三个循环

3780
02:28:19,610 --> 02:28:20,330
第一个循环

3781
02:28:21,190 --> 02:28:22,390
适当操作前

3782
02:28:22,840 --> 02:28:26,380
他会调这个get a snapshot before update第二个循环

3783
02:28:26,380 --> 02:28:27,370
适当操作中

3784
02:28:28,430 --> 02:28:30,620
这个地方并不掉生命的记忆的方法

3785
02:28:31,040 --> 02:28:33,080
第三个循环是当操作后

3786
02:28:33,080 --> 02:28:34,790
这个地方会掉的MT

3787
02:28:35,150 --> 02:28:38,270
所以肯定是before update掀掉

3788
02:28:38,720 --> 02:28:40,130
然后did mount后调

3789
02:28:45,850 --> 02:28:46,180
好

3790
02:28:46,390 --> 02:28:47,620
这块还有不明白的吗

3791
02:28:57,460 --> 02:28:57,730
行

3792
02:28:57,730 --> 02:28:58,750
那就下课吧

3793
02:28:58,810 --> 02:28:59,440
你下课吧

3794
02:29:00,250 --> 02:29:02,170
下来晚上的时候我们再把

3795
02:29:02,900 --> 02:29:04,190
他妈收尾

3796
02:29:04,640 --> 02:29:05,390
反正在收尾

3797
02:29:05,960 --> 02:29:06,440
行

3798
02:29:08,260 --> 02:29:09,400
朋友们辛苦啦

3799
02:29:09,520 --> 02:29:09,940
拜拜

