1
00:01:16,300 --> 00:01:17,080
对符合实际

2
00:01:18,400 --> 00:01:20,350
要求孤独的风景

3
00:01:20,710 --> 00:01:25,780
自从开始时间还有什么事好关心

4
00:01:26,020 --> 00:01:27,880
他可真不再象征和平

5
00:01:27,880 --> 00:01:30,760
我从此被提醒着社会时的声音

6
00:01:31,690 --> 00:01:33,160
我用漂亮的押韵形容

7
00:01:33,160 --> 00:01:34,840
被偷的爱情

8
00:01:37,510 --> 00:01:37,840
开始

9
00:01:40,060 --> 00:01:42,040
整天在漫天飞行

10
00:01:42,040 --> 00:01:44,530
送你的白色玫瑰在纯白的花

11
00:01:44,530 --> 00:01:46,480
7101夜在树枝上

12
00:01:46,480 --> 00:01:47,680
诡异的很安静

13
00:01:47,680 --> 00:01:52,120
静静听我黑色的大衣的你日渐冰冷的回忆

14
00:01:52,120 --> 00:01:52,720
走过的走过

15
00:01:52,780 --> 00:01:54,400
生命还是迷茫

16
00:01:54,400 --> 00:01:56,620
无极在空旷的墓地老去

17
00:01:56,620 --> 00:01:57,640
我还爱你

18
00:01:59,440 --> 00:01:59,770
这首

19
00:02:00,820 --> 00:02:01,120
歌曲

20
00:02:01,780 --> 00:02:03,880
记得我死去的爱情

21
00:02:04,570 --> 00:02:06,880
点点风雨的声音

22
00:02:07,240 --> 00:02:07,840
青春

23
00:02:10,390 --> 00:02:10,810
再见

24
00:02:13,240 --> 00:02:14,200
美丽的森林

25
00:02:14,230 --> 00:02:14,890
很熟悉

26
00:02:23,860 --> 00:02:25,960
记得我死去的爱情

27
00:02:29,350 --> 00:02:30,460
在月光下

28
00:02:32,590 --> 00:02:32,980
新的

29
00:02:34,900 --> 00:02:35,920
还是如此

30
00:02:35,920 --> 00:02:36,820
那么热情

31
00:02:38,890 --> 00:02:39,250
的心

32
00:03:04,970 --> 00:03:07,940
这些歌词整天伸着森林

33
00:03:08,120 --> 00:03:10,100
而我的眼睛没有思考

34
00:03:11,090 --> 00:03:11,720
失去你

35
00:03:11,720 --> 00:03:13,430
泪水混浊不清

36
00:03:13,430 --> 00:03:14,135
失去你

37
00:03:14,135 --> 00:03:18,290
我连笑容都有放在咱们的顶

38
00:03:18,770 --> 00:03:25,190
我的伤心像一口没有水的估计经历的自信就会后悔莫及的爱情

39
00:03:29,090 --> 00:03:29,420
悲剧

40
00:03:30,050 --> 00:03:32,150
记得我死去的爱情

41
00:03:32,840 --> 00:03:35,150
偏偏风的声音

42
00:03:38,690 --> 00:03:39,080
再见

43
00:03:41,150 --> 00:03:43,160
我的思念很小心

44
00:03:44,630 --> 00:03:45,950
地盯着

45
00:03:52,840 --> 00:03:54,250
我死去的爱情

46
00:03:55,660 --> 00:03:56,260
甜蜜

47
00:03:57,640 --> 00:03:58,720
在月光下

48
00:04:03,190 --> 00:04:04,900
还是如此的热闹

49
00:04:04,900 --> 00:04:05,260
情景

50
00:04:07,180 --> 00:04:07,510
的新

51
00:04:14,920 --> 00:04:16,990
表情的风景

52
00:04:16,990 --> 00:04:18,940
自己也在开始

53
00:04:19,660 --> 00:04:21,670
时间还有什么时候

54
00:04:23,260 --> 00:04:27,130
都在想着隔壁的重复的提醒着什么是

55
00:04:30,790 --> 00:04:31,360
爱情

56
00:04:50,100 --> 00:04:50,430
同学们

57
00:04:50,430 --> 00:04:51,990
还是08:05开始啦

58
00:05:09,480 --> 00:05:11,970
老板转了咖啡

59
00:05:11,970 --> 00:05:12,780
我手一杯

60
00:05:12,960 --> 00:05:14,520
品尝你的美

61
00:05:15,120 --> 00:05:17,520
留下唇印的嘴

62
00:05:19,890 --> 00:05:21,750
花店玫瑰名字写错

63
00:05:22,020 --> 00:05:23,040
谁告白

64
00:05:23,040 --> 00:05:25,320
气球风吹到对街

65
00:05:25,650 --> 00:05:29,700
微笑在脸上飞

66
00:05:29,910 --> 00:05:32,130
你说你有点难追

67
00:05:32,310 --> 00:05:34,770
想让我知难而退

68
00:05:35,280 --> 00:05:37,410
礼物不需挑最贵

69
00:05:37,740 --> 00:05:40,140
只要香榭的落叶

70
00:05:40,710 --> 00:05:42,000
一场浪漫的

71
00:05:42,120 --> 00:05:45,450
约会不害怕搞砸一切

72
00:05:45,780 --> 00:05:49,800
拥有你就拥有全世界

73
00:05:50,700 --> 00:05:51,690
亲爱的

74
00:05:52,350 --> 00:05:53,985
爱上你

75
00:05:53,985 --> 00:05:59,400
从那天起甜蜜的很轻

76
00:06:01,380 --> 00:06:02,700
亲爱的

77
00:06:03,120 --> 00:06:04,470
别任性

78
00:06:04,800 --> 00:06:08,730
你的眼睛在说

79
00:06:08,730 --> 00:06:09,210
我

80
00:06:34,680 --> 00:06:35,160
知道了

81
00:06:35,160 --> 00:06:35,820
爸说

82
00:06:35,820 --> 00:06:37,095
安了个非

83
00:06:37,095 --> 00:06:37,650
我说

84
00:06:37,650 --> 00:06:39,870
一杯品尝你的美

85
00:06:40,410 --> 00:06:41,910
留下唇印的

86
00:06:42,100 --> 00:06:43,000
水

87
00:06:45,370 --> 00:06:45,700
蝴蝶

88
00:06:45,700 --> 00:06:47,320
玫瑰自己做鞋

89
00:06:47,980 --> 00:06:48,370
告白

90
00:06:48,370 --> 00:06:49,930
气球风吹到对街

91
00:06:51,130 --> 00:06:55,120
微笑在你的伤悲

92
00:06:55,120 --> 00:06:57,460
别说你有点难追

93
00:06:57,640 --> 00:07:00,130
想让我知难而退

94
00:07:00,370 --> 00:07:02,800
吕布不需挑最贵

95
00:07:03,070 --> 00:07:08,110
只要香榭的落叶隐藏浪漫的约会

96
00:07:08,620 --> 00:07:10,780
不害怕搞砸一切

97
00:07:11,110 --> 00:07:12,055
拥有你

98
00:07:12,055 --> 00:07:15,130
就拥有全世界

99
00:07:16,030 --> 00:07:17,170
亲爱的

100
00:07:17,710 --> 00:07:19,330
爱上你

101
00:07:19,330 --> 00:07:24,760
从那天起甜蜜的很轻

102
00:07:26,710 --> 00:07:27,850
亲爱的

103
00:07:28,450 --> 00:07:29,800
别任性

104
00:07:30,160 --> 00:07:34,030
你的眼睛在说

105
00:07:37,360 --> 00:07:38,350
亲爱的

106
00:07:38,380 --> 00:07:42,040
爱上你

107
00:07:42,120 --> 00:07:43,020
日记

108
00:07:43,740 --> 00:07:46,560
飘香水的回忆

109
00:07:48,180 --> 00:07:51,150
你曾经的梦境

110
00:07:51,150 --> 00:07:53,100
全都有你

111
00:07:54,390 --> 00:07:57,180
搅拌在一起

112
00:07:58,680 --> 00:08:00,420
亲爱的

113
00:08:00,450 --> 00:08:01,860
别任性

114
00:08:03,000 --> 00:08:04,620
你的眼睛

115
00:08:06,960 --> 00:08:08,130
再说

116
00:08:08,130 --> 00:08:09,450
我愿意

117
00:08:32,070 --> 00:08:34,410
拼命开始

118
00:08:38,300 --> 00:08:42,590
悲伤要怎么变成

119
00:08:43,650 --> 00:08:45,660
我的天天上

120
00:08:47,360 --> 00:08:48,410
中炸弹

121
00:08:50,270 --> 00:08:53,540
一抹浅浅的

122
00:08:58,130 --> 00:09:00,080
医用春雨说

123
00:09:00,080 --> 00:09:01,580
你要离开

124
00:09:05,030 --> 00:09:08,930
难过无声般留下来

125
00:09:09,800 --> 00:09:12,170
潮水

126
00:09:13,310 --> 00:09:15,530
一定平凡

127
00:09:16,520 --> 00:09:18,200
不是难

128
00:09:18,680 --> 00:09:19,160
而是

129
00:09:23,060 --> 00:09:23,630
总是

130
00:09:25,940 --> 00:09:28,430
话说不出来

131
00:09:29,060 --> 00:09:34,760
海鸟跟鱼相爱只是一场意外

132
00:09:36,410 --> 00:09:41,180
我们的爱假一直存在

133
00:09:42,830 --> 00:09:43,610
梦中

134
00:09:45,260 --> 00:09:47,060
之类情深深

135
00:09:49,340 --> 00:09:50,930
转身离开

136
00:09:51,830 --> 00:09:52,580
分手

137
00:09:52,580 --> 00:09:54,560
说不出来

138
00:09:55,100 --> 00:09:58,070
蔚蓝的珊瑚海

139
00:09:58,340 --> 00:10:00,950
错过瞬间苍白

140
00:10:02,600 --> 00:10:03,590
当初彼此

141
00:10:05,000 --> 00:10:06,530
不够成熟

142
00:10:06,650 --> 00:10:07,700
坦白

143
00:10:09,500 --> 00:10:10,070
寂寞

144
00:10:11,180 --> 00:10:12,380
的笑容

145
00:10:12,410 --> 00:10:18,290
勉强不来爱上南山竹海

146
00:10:23,530 --> 00:10:27,100
毁坏的沙雕重来

147
00:10:30,110 --> 00:10:34,280
有裂痕的爱怎么重开

148
00:10:35,350 --> 00:10:36,910
只是一切

149
00:10:38,620 --> 00:10:40,510
结束太快

150
00:10:42,040 --> 00:10:45,160
你说你无法

151
00:10:49,840 --> 00:10:50,800
被看

152
00:10:50,800 --> 00:10:52,600
隐藏什么

153
00:10:56,380 --> 00:11:00,790
我们也已经无心猜猜猜

154
00:11:01,720 --> 00:11:03,130
面向海风

155
00:11:05,050 --> 00:11:06,010
咸咸的

156
00:11:06,520 --> 00:11:07,750
深深的

157
00:11:08,230 --> 00:11:10,210
撑不住

158
00:11:10,210 --> 00:11:12,880
还有未来

159
00:11:14,830 --> 00:11:15,430
诠释

160
00:11:17,710 --> 00:11:18,100
着

161
00:11:18,100 --> 00:11:20,230
说不出来

162
00:11:20,620 --> 00:11:22,900
还要等于相爱

163
00:11:23,800 --> 00:11:25,510
只是一场

164
00:11:28,870 --> 00:11:30,160
爱

165
00:11:31,540 --> 00:11:32,950
一直存在

166
00:11:37,060 --> 00:11:39,550
天泪器蒸下

167
00:11:40,950 --> 00:11:41,610
好了

168
00:11:41,610 --> 00:11:41,970
同学们

169
00:11:41,970 --> 00:11:42,510
时间到了

170
00:11:42,510 --> 00:11:43,110
我们就

171
00:11:43,920 --> 00:11:46,020
你们就正式开始今天晚上的课程啦

172
00:11:50,710 --> 00:11:51,070
OK

173
00:11:51,070 --> 00:11:55,570
今天的话主要讲的是X的对hooks的源码分析

174
00:11:56,020 --> 00:11:59,620
Hooks这块因为是X16.8

175
00:11:59,620 --> 00:12:02,170
然后新更新出来的一个功能

176
00:12:02,170 --> 00:12:04,000
而且在现在

177
00:12:04,580 --> 00:12:06,650
一般大厂的话用的也比较频繁

178
00:12:07,250 --> 00:12:09,530
而且他也又有一定的上手难度

179
00:12:09,860 --> 00:12:10,340
所以呢

180
00:12:10,340 --> 00:12:13,400
在面试的过程当中被问到的频率

181
00:12:14,920 --> 00:12:19,060
都是比其他的温暖的频率要高很多的

182
00:12:19,710 --> 00:12:20,460
所以把它

183
00:12:21,580 --> 00:12:22,780
单独拿了出来

184
00:12:22,780 --> 00:12:25,840
然后我们做一个比较完整的一个讲解

185
00:12:25,900 --> 00:12:27,190
这个比较完整的讲解

186
00:12:27,670 --> 00:12:30,250
首先就是面试官一般在

187
00:12:31,560 --> 00:12:32,220
护士

188
00:12:32,900 --> 00:12:34,010
这块地是问的

189
00:12:34,010 --> 00:12:36,200
会问很多相关问题

190
00:12:36,470 --> 00:12:37,130
其中呢

191
00:12:37,800 --> 00:12:39,030
这就是一开

192
00:12:39,030 --> 00:12:40,980
一开始可能会首先问问他

193
00:12:40,980 --> 00:12:41,580
就是为什么

194
00:12:41,580 --> 00:12:42,600
就是hooks

195
00:12:42,600 --> 00:12:45,630
她到底为什么hooks会流行起来

196
00:12:45,660 --> 00:12:48,600
然后hook解决了一个什么样的问题

197
00:12:48,900 --> 00:12:50,010
解决什么样的问题

198
00:12:52,440 --> 00:12:53,430
在

199
00:12:57,000 --> 00:12:59,010
再大点那个字也看不到

200
00:13:01,480 --> 00:13:02,530
就在有hooks之前

201
00:13:02,530 --> 00:13:03,460
我要讲一下

202
00:13:03,490 --> 00:13:04,270
大概讲一下

203
00:13:04,300 --> 00:13:05,380
再有hook之前

204
00:13:05,530 --> 00:13:07,420
其实在的reg代码里

205
00:13:07,420 --> 00:13:09,940
一般是以class component为主

206
00:13:09,970 --> 00:13:11,440
也就是以class为主

207
00:13:11,680 --> 00:13:13,240
因为它可以定义生命周期

208
00:13:13,270 --> 00:13:14,170
可以定义stated

209
00:13:14,710 --> 00:13:16,420
所以他的能力比较齐全

210
00:13:16,780 --> 00:13:17,980
在没有户口之前呢

211
00:13:17,980 --> 00:13:20,230
我们的function component只能打辅助

212
00:13:21,090 --> 00:13:24,390
主要的原因就是因为他不能够定义state

213
00:13:24,420 --> 00:13:26,220
而且也没有任何的生命周期

214
00:13:26,640 --> 00:13:29,490
所以在hooks出现之前

215
00:13:29,580 --> 00:13:29,940
他的

216
00:13:30,860 --> 00:13:31,940
最佳实践什么

217
00:13:31,940 --> 00:13:33,770
在乎出现之前的最佳实践

218
00:13:35,160 --> 00:13:35,880
护士

219
00:13:37,260 --> 00:13:38,490
出现前的

220
00:13:41,870 --> 00:13:46,070
最佳时间就是class comma

221
00:13:47,130 --> 00:13:48,870
做容器组件对

222
00:13:48,870 --> 00:13:49,350
这个

223
00:13:50,640 --> 00:13:52,350
做容器

224
00:13:53,610 --> 00:13:54,210
组件

225
00:13:56,970 --> 00:13:59,070
然后发现component

226
00:14:05,300 --> 00:14:06,050
做

227
00:14:06,960 --> 00:14:08,340
Class component做容器组件

228
00:14:08,340 --> 00:14:11,070
Function component做

229
00:14:11,100 --> 00:14:11,880
UI组件

230
00:14:13,710 --> 00:14:18,660
原因就是因为我们的方向和那个时候的能力实际上是不足的

231
00:14:19,020 --> 00:14:21,420
他他只能够通过props

232
00:14:22,170 --> 00:14:24,180
把C的传递进来是一种方式

233
00:14:25,240 --> 00:14:28,030
这一种方式而自己不能定死的

234
00:14:28,030 --> 00:14:30,400
而且也没有生命周期这种概念

235
00:14:30,850 --> 00:14:34,060
因此这就是以前的生命这个最佳时间

236
00:14:34,390 --> 00:14:34,870
但是

237
00:14:35,840 --> 00:14:38,780
如果遇到比如想一下这个问题

238
00:14:38,780 --> 00:14:43,130
你刚开始把一个组件写成了容器组件写成写成了UI组件

239
00:14:43,820 --> 00:14:45,920
如果说随着需求的迭代

240
00:14:46,280 --> 00:14:46,490
对吧

241
00:14:46,490 --> 00:14:47,420
随着需求迭代

242
00:14:47,570 --> 00:14:50,120
比如那个组件的功能越来越大

243
00:14:50,120 --> 00:14:50,780
越来越大

244
00:14:50,810 --> 00:14:52,730
这种事情是非常有可能发生的

245
00:14:53,530 --> 00:14:53,860
对不对

246
00:14:53,860 --> 00:14:55,390
那么怎么办呢

247
00:14:55,980 --> 00:14:59,610
唯一唯一唯一的办法就是你可能你可以继续的

248
00:15:00,340 --> 00:15:02,860
通过props把父组件传递进来

249
00:15:03,160 --> 00:15:04,900
那可能传递的属性越来越多

250
00:15:04,900 --> 00:15:05,530
越来越多

251
00:15:06,320 --> 00:15:07,400
那么如果

252
00:15:08,280 --> 00:15:13,020
当需求更改到就是你觉得已经没办法维护的时候

253
00:15:13,050 --> 00:15:16,590
然后你可能会想办法把它重新又改造成class组件

254
00:15:17,220 --> 00:15:17,970
改成开始建

255
00:15:17,970 --> 00:15:19,620
这样的后期才会更好的维护

256
00:15:19,770 --> 00:15:22,590
总之你的业务的复杂度越高

257
00:15:22,590 --> 00:15:24,930
你就会觉得放心卡盟他就越不适用

258
00:15:25,510 --> 00:15:26,680
这些之前的一个问题

259
00:15:26,740 --> 00:15:27,640
这样一个问题

260
00:15:28,150 --> 00:15:31,420
那可能有代码里很大量的都是卡组件

261
00:15:31,660 --> 00:15:33,430
卡组件当然也挺不错的

262
00:15:33,430 --> 00:15:37,750
但是但是他的但他他的那个代码量其实会比较庞大

263
00:15:38,230 --> 00:15:38,770
比较大

264
00:15:38,770 --> 00:15:40,660
我们要定义非常多的生命周期

265
00:15:41,230 --> 00:15:41,860
然后呢

266
00:15:43,200 --> 00:15:45,780
然后一般要写这次写代码的时候

267
00:15:45,780 --> 00:15:46,860
可能已经十多行了

268
00:15:47,190 --> 00:15:48,060
已经十多行了

269
00:15:48,970 --> 00:15:49,330
对啊

270
00:15:49,690 --> 00:15:51,790
像这种props比较多的时候用过

271
00:15:52,440 --> 00:15:53,970
对象包揽一下不可以吗

272
00:15:53,970 --> 00:15:55,920
那你的那你的主见

273
00:15:56,340 --> 00:15:57,840
那你的主见就会永远更新

274
00:15:57,840 --> 00:15:59,850
就是任何一个属性更新的时候

275
00:16:00,270 --> 00:16:02,820
你的那个UI组件是不是会永远更新

276
00:16:03,660 --> 00:16:05,400
任何一个属性的变化

277
00:16:06,200 --> 00:16:07,760
你的都会变好

278
00:16:09,620 --> 00:16:10,280
这就是

279
00:16:11,340 --> 00:16:12,030
一开始

280
00:16:13,920 --> 00:16:15,900
一开始就是这么搞的

281
00:16:16,020 --> 00:16:17,700
那么hooks出现之后

282
00:16:19,110 --> 00:16:20,490
出现之后那么

283
00:16:21,840 --> 00:16:22,890
有一个什么变化

284
00:16:22,890 --> 00:16:23,790
就是在hooks里

285
00:16:24,090 --> 00:16:25,080
就是在函数组件里

286
00:16:25,080 --> 00:16:27,600
因为他就是为函数组件添加功能似的

287
00:16:28,420 --> 00:16:31,840
那么会出现之后我们在函数间里

288
00:16:32,690 --> 00:16:33,380
已经可以

289
00:16:33,380 --> 00:16:35,480
以及函数线就可以自定义state

290
00:16:35,540 --> 00:16:37,040
也可以模拟生命周期

291
00:16:37,610 --> 00:16:38,210
然后呢

292
00:16:38,360 --> 00:16:39,770
从而减少

293
00:16:40,220 --> 00:16:42,080
减少就是减少了那个

294
00:16:42,080 --> 00:16:43,670
既补齐了函数组件的功能

295
00:16:44,060 --> 00:16:47,510
同时你用class组件就大家就发现一件事情

296
00:16:48,050 --> 00:16:49,880
你用class组件所做的事情

297
00:16:50,150 --> 00:16:54,440
你用函数组件大概花一半的代码量就能够把这个事情给做好

298
00:16:54,680 --> 00:16:56,600
而且逻辑的话会更加的清晰

299
00:16:56,750 --> 00:16:57,260
因为他是

300
00:16:58,270 --> 00:17:00,730
基于函数的逻辑会更加清晰

301
00:17:01,120 --> 00:17:03,130
然后大家再上手了之后

302
00:17:03,130 --> 00:17:04,660
然后就觉得这玩意儿挺好使的

303
00:17:05,370 --> 00:17:05,790
都

304
00:17:06,440 --> 00:17:07,880
但是他有一些定的问题

305
00:17:08,630 --> 00:17:10,910
但是也不妨碍大家对它的热情

306
00:17:10,910 --> 00:17:12,680
因为大家都是想少写几行代码

307
00:17:13,130 --> 00:17:14,360
都是想少写几行代码

308
00:17:14,720 --> 00:17:16,340
而且这个诱惑是非常非常大的

309
00:17:16,370 --> 00:17:17,120
刚开始的时候

310
00:17:17,680 --> 00:17:18,640
诱惑是非常大的

311
00:17:19,270 --> 00:17:21,130
所以它解决了什么样的问题

312
00:17:21,400 --> 00:17:23,050
解决了函数组件

313
00:17:23,350 --> 00:17:26,410
它为函数组件增加了定义state

314
00:17:27,010 --> 00:17:28,000
定义state膜

315
00:17:28,000 --> 00:17:29,320
还有模拟生命周期

316
00:17:29,320 --> 00:17:32,050
然后使用context能力补齐的能力

317
00:17:32,350 --> 00:17:33,040
然后呢

318
00:17:33,160 --> 00:17:34,450
显著地减少了代码量

319
00:17:34,450 --> 00:17:35,290
而且提升了

320
00:17:35,780 --> 00:17:38,510
提升了那个代码的可读性

321
00:17:38,990 --> 00:17:41,390
这都是hooks hooks带来的变化

322
00:17:42,510 --> 00:17:43,560
这就是为什么

323
00:17:43,620 --> 00:17:45,420
就是它解决什么这样的问题

324
00:17:45,630 --> 00:17:47,190
这也就是大场面

325
00:17:47,460 --> 00:17:48,870
或者说很多的程序员

326
00:17:49,470 --> 00:17:52,080
都喜欢选择它的一个比较重要的原因

327
00:17:52,590 --> 00:17:53,460
比较重要的原因

328
00:17:54,720 --> 00:17:55,350
然后

329
00:17:56,380 --> 00:18:00,370
那么我们就接下来要讲那个hooks的会有什么问题

330
00:18:00,670 --> 00:18:01,570
Looks有什么问题

331
00:18:01,570 --> 00:18:02,770
待会给大家讲

332
00:18:02,770 --> 00:18:04,000
待会给大家

333
00:18:07,380 --> 00:18:08,910
孩子出现什么问题呢

334
00:18:09,150 --> 00:18:09,720
没什么问题

335
00:18:09,720 --> 00:18:10,320
我说是

336
00:18:10,380 --> 00:18:11,940
或者是它可能会有一些坑

337
00:18:12,450 --> 00:18:13,770
他可能会有一定的坑

338
00:18:13,770 --> 00:18:14,970
你都踩过你才知道

339
00:18:15,830 --> 00:18:16,280
不然的话

340
00:18:16,280 --> 00:18:17,630
你用起来的话

341
00:18:17,840 --> 00:18:21,620
它的上手上手成本会比class组件要大一些

342
00:18:22,420 --> 00:18:23,020
要大一些

343
00:18:24,220 --> 00:18:26,350
所以这也是这也是为什么

344
00:18:26,830 --> 00:18:29,230
这也是为什么就是面试的时候老爱问这个

345
00:18:29,230 --> 00:18:31,330
因为它真的是比克拉组建

346
00:18:31,330 --> 00:18:33,040
他的上手难度是存在的

347
00:18:33,930 --> 00:18:34,380
蔡澜

348
00:18:34,380 --> 00:18:35,100
都是存在的

349
00:18:35,310 --> 00:18:36,120
有一定的坑

350
00:18:36,120 --> 00:18:36,270
你

351
00:18:36,270 --> 00:18:37,650
你不踩的话你就不知道

352
00:18:39,040 --> 00:18:39,460
我们

353
00:18:40,490 --> 00:18:42,740
接下来讲一下那个hooks基本用法

354
00:18:43,380 --> 00:18:43,920
基本用法

355
00:18:43,920 --> 00:18:47,550
这个可能大多数的同学都是知道的

356
00:18:47,610 --> 00:18:50,790
比如比如他有很多hooks

357
00:18:51,000 --> 00:18:51,660
有很多hooks

358
00:18:51,660 --> 00:18:54,810
我们就选选几个我们经常用的

359
00:18:55,760 --> 00:18:56,930
常用的比如这个

360
00:18:57,560 --> 00:18:58,490
Use context

361
00:18:59,930 --> 00:19:02,330
我看一下use context

362
00:19:02,510 --> 00:19:03,950
我们大概讲一下它的原

363
00:19:03,950 --> 00:19:04,220
它的

364
00:19:04,220 --> 00:19:05,150
它是什么作用

365
00:19:05,480 --> 00:19:06,350
Use context

366
00:19:07,090 --> 00:19:08,770
在之前在

367
00:19:09,430 --> 00:19:10,030
函数组件

368
00:19:10,030 --> 00:19:11,650
你不能够使用context

369
00:19:12,130 --> 00:19:13,060
不能够使用context

370
00:19:13,090 --> 00:19:17,530
所以use context的顾名思义也就是能够在函数组件里使用context

371
00:19:18,380 --> 00:19:20,150
Use rid use effect

372
00:19:20,480 --> 00:19:23,750
这个是比较重要的一个属性

373
00:19:23,930 --> 00:19:25,940
向use effect usually ah the fact

374
00:19:26,000 --> 00:19:27,200
这两个他们都是

375
00:19:27,880 --> 00:19:29,260
使用方法都是差不多的

376
00:19:29,260 --> 00:19:30,790
只是一个同步一个异步的

377
00:19:31,120 --> 00:19:33,610
它们的功能就是模拟生殖器

378
00:19:33,820 --> 00:19:36,940
比如像的MT的DA up date he will amount

379
00:19:37,150 --> 00:19:38,500
这三个生命周期

380
00:19:38,920 --> 00:19:39,640
You the fact

381
00:19:39,640 --> 00:19:41,830
它一个一个hooks

382
00:19:41,830 --> 00:19:43,960
就可以把他们三个都给模拟到位

383
00:19:44,550 --> 00:19:46,230
而且用的代码量还很少

384
00:19:46,590 --> 00:19:51,300
这就是他的一个比较大的优势u c Mo它主要的作用是缓存

385
00:19:51,300 --> 00:19:52,140
缓存一个值

386
00:19:52,770 --> 00:19:53,640
You school back

387
00:19:54,090 --> 00:19:55,890
它的作用是缓冲一个函数

388
00:19:57,580 --> 00:20:02,980
Uf它就是能够在函数组件也正常的riff

389
00:20:03,610 --> 00:20:05,260
Use date就是最常用

390
00:20:05,260 --> 00:20:06,730
最常用的一个功能呢

391
00:20:07,120 --> 00:20:10,390
就是定义state和改变state的能力

392
00:20:11,020 --> 00:20:12,730
定义色彩和改变色的能力

393
00:20:13,360 --> 00:20:16,030
大概平常非常常用的有这些

394
00:20:16,120 --> 00:20:17,740
但还有一些其他的

395
00:20:21,380 --> 00:20:22,070
还有其他的

396
00:20:22,130 --> 00:20:23,390
我们现在一个一个来看

397
00:20:24,590 --> 00:20:26,480
这几个平常都会用到的

398
00:20:27,190 --> 00:20:28,690
然后依据这些

399
00:20:29,170 --> 00:20:32,440
然后就会有非常非常多的面试的问题

400
00:20:33,040 --> 00:20:33,580
比如说

401
00:20:34,770 --> 00:20:35,700
比如这个

402
00:20:35,970 --> 00:20:36,510
比如在乎

403
00:20:36,510 --> 00:20:37,890
试问一下在hooks里

404
00:20:38,560 --> 00:20:39,610
怎么让他做

405
00:20:40,360 --> 00:20:44,740
在就是在函数组件里怎么让他做类似于pure component的事情

406
00:20:44,740 --> 00:20:46,930
对props做钱比较

407
00:20:46,930 --> 00:20:48,310
做前比较

408
00:20:49,480 --> 00:20:50,920
这是should component update吗

409
00:20:55,160 --> 00:20:58,400
Should component update的

410
00:20:59,720 --> 00:21:01,640
学Java的

411
00:21:01,640 --> 00:21:02,030
好吧

412
00:21:02,750 --> 00:21:05,630
就是类似pen的的事情

413
00:21:05,630 --> 00:21:07,520
因为component是他

414
00:21:07,520 --> 00:21:10,130
它的功能就是对props做前比较

415
00:21:10,490 --> 00:21:14,300
然后如果钱比较没有任何的变化的话就不渲染

416
00:21:15,400 --> 00:21:16,360
钱比较

417
00:21:17,410 --> 00:21:17,860
就是

418
00:21:18,890 --> 00:21:20,120
Props没有变化

419
00:21:25,230 --> 00:21:27,240
就不重新选就不重新算的

420
00:21:28,410 --> 00:21:28,710
对不对

421
00:21:28,710 --> 00:21:30,660
在乎可以怎么做这样的一件事情

422
00:21:31,620 --> 00:21:32,490
刚有同学

423
00:21:32,610 --> 00:21:34,590
我看已经有同学在抢答了

424
00:21:34,620 --> 00:21:35,880
用user memo

425
00:21:36,590 --> 00:21:37,790
You Yong use memo

426
00:21:39,210 --> 00:21:42,810
一般一般他都在pure component

427
00:21:43,440 --> 00:21:43,650
其实

428
00:21:43,650 --> 00:21:45,180
Peer component在relatively

429
00:21:46,400 --> 00:21:48,470
他首先他肯定是一个class component

430
00:21:48,710 --> 00:21:50,360
其实right提供了另外一个

431
00:21:50,840 --> 00:21:54,770
另外一个API是专门对

432
00:21:55,300 --> 00:21:56,620
是专门对那个

433
00:21:57,240 --> 00:22:00,330
函数组件来做封装的就是remo

434
00:22:00,330 --> 00:22:00,720
对

435
00:22:01,050 --> 00:22:02,550
Write down ready memo

436
00:22:03,750 --> 00:22:06,720
spread.member它里面就会做一层铅比较

437
00:22:08,570 --> 00:22:10,610
会做起来比较

438
00:22:11,840 --> 00:22:13,910
而且这个是只针对hooks

439
00:22:13,910 --> 00:22:16,880
是只针对函数组件的

440
00:22:20,620 --> 00:22:23,230
那有同学就有疑问了

441
00:22:23,260 --> 00:22:23,620
老师

442
00:22:23,620 --> 00:22:25,000
我们不是讲hooks吗

443
00:22:25,690 --> 00:22:26,230
Memo

444
00:22:26,380 --> 00:22:27,880
他好像并不是一个hooks

445
00:22:27,880 --> 00:22:28,090
对吧

446
00:22:28,090 --> 00:22:30,610
我们上面讲的是use memory read member

447
00:22:30,610 --> 00:22:31,600
并不是一个hooks

448
00:22:31,600 --> 00:22:33,340
如果说ready memo

449
00:22:33,490 --> 00:22:35,200
而且真正的是函数组件

450
00:22:35,990 --> 00:22:37,550
针对的是函数组件的嘛

451
00:22:38,300 --> 00:22:40,760
那么跟hooks好像就是没有hooks的话

452
00:22:40,760 --> 00:22:41,630
他也能做到

453
00:22:42,180 --> 00:22:43,770
他似乎也是能够做到的

454
00:22:44,470 --> 00:22:44,890
对吧

455
00:22:45,370 --> 00:22:46,270
好像是这么个道理

456
00:22:46,270 --> 00:22:48,730
但实际上如果你只用regular member的话

457
00:22:48,730 --> 00:22:50,290
你会发现不行

458
00:22:51,200 --> 00:22:52,460
我们可以尝试一下

459
00:22:52,460 --> 00:22:54,830
假如说假如说举个例子

460
00:22:56,180 --> 00:22:57,410
假设举一个简单例子

461
00:22:57,410 --> 00:23:00,560
比如说这个翻新

462
00:23:04,020 --> 00:23:04,800
APP

463
00:23:06,150 --> 00:23:07,320
拿着return一个

464
00:23:08,870 --> 00:23:10,070
这就是填一个a吧

465
00:23:11,640 --> 00:23:15,180
然后我这一个方形a

466
00:23:16,500 --> 00:23:20,220
那我再return一个DV

467
00:23:24,350 --> 00:23:24,740
第二位

468
00:23:24,740 --> 00:23:26,660
然后我给他传一个截图

469
00:23:26,660 --> 00:23:27,500
给他传一个

470
00:23:29,980 --> 00:23:31,960
我不记这是一个对象

471
00:23:32,680 --> 00:23:37,030
或者再传一个千金

472
00:23:37,090 --> 00:23:37,900
的一个方法

473
00:23:39,790 --> 00:23:43,210
然后现在我想现在我想

474
00:23:44,930 --> 00:23:45,860
我再来一个吧

475
00:23:54,290 --> 00:23:54,830
我再来

476
00:23:56,200 --> 00:23:58,120
然后再来一个cost

477
00:23:59,800 --> 00:24:01,660
然后呢

478
00:24:14,840 --> 00:24:15,380
这是我

479
00:24:17,750 --> 00:24:18,320
来做

480
00:24:20,880 --> 00:24:21,240
好

481
00:24:21,240 --> 00:24:22,260
前进name的时候

482
00:24:22,260 --> 00:24:23,640
我就给他set name

483
00:24:24,780 --> 00:24:26,550
或者再做点其他什么事情

484
00:24:28,720 --> 00:24:29,740
好在这里其他东西

485
00:24:29,740 --> 00:24:30,310
然后呢

486
00:24:30,400 --> 00:24:32,680
假如我把这个name传给他

487
00:24:37,120 --> 00:24:40,540
就是change令传给他

488
00:24:41,670 --> 00:24:43,110
然后B的话就穿一个

489
00:24:45,280 --> 00:24:46,660
接着我去参一个

490
00:24:49,340 --> 00:24:49,910
Object

491
00:24:54,690 --> 00:24:54,990
OK

492
00:24:55,920 --> 00:24:56,820
那我再传一个

493
00:24:58,260 --> 00:25:01,050
注意这样的一个

494
00:25:03,140 --> 00:25:05,120
就这样的一个非常简单的一个调用

495
00:25:05,150 --> 00:25:06,230
一个非常简单的调用

496
00:25:06,530 --> 00:25:08,960
那假如说我我APP里的更新

497
00:25:09,230 --> 00:25:12,050
那么我肯定是我肯定是期望什么呢

498
00:25:12,320 --> 00:25:14,420
我肯定是希望我的

499
00:25:14,450 --> 00:25:15,770
比如我的name变化

500
00:25:16,290 --> 00:25:17,400
那么我不影响

501
00:25:17,520 --> 00:25:19,650
我不影响我的B组线对不对

502
00:25:19,650 --> 00:25:21,060
我的B组线不要跟着变

503
00:25:21,510 --> 00:25:24,090
我的假如我的奥秘借遍了

504
00:25:24,980 --> 00:25:25,640
这个变了

505
00:25:26,400 --> 00:25:28,500
我希望他不要影响我a组件

506
00:25:28,500 --> 00:25:29,730
不要让我a组间发生

507
00:25:30,360 --> 00:25:32,610
那个RN的不想让他重新渲染

508
00:25:33,670 --> 00:25:34,180
Na

509
00:25:35,120 --> 00:25:35,780
可能会想

510
00:25:35,780 --> 00:25:38,030
那么我们就要操作了

511
00:25:38,060 --> 00:25:38,810
怎么操作呢

512
00:25:39,700 --> 00:25:41,890
通常情况下对它做一个

513
00:25:42,930 --> 00:25:44,310
做一个封装

514
00:25:44,760 --> 00:25:45,630
把它变成

515
00:25:45,810 --> 00:25:46,920
这里就把它变成

516
00:25:48,010 --> 00:25:48,820
这个是咖色

517
00:25:52,320 --> 00:25:52,560
对吧

518
00:25:52,560 --> 00:25:54,270
这是原本是一个函数线

519
00:25:54,420 --> 00:25:55,650
那就把它包裹在

520
00:25:57,870 --> 00:25:58,890
regular member中

521
00:25:59,340 --> 00:26:00,510
包括remember中

522
00:26:00,900 --> 00:26:01,890
但这样行不行

523
00:26:01,890 --> 00:26:03,780
如果大家去尝试的话就会发现

524
00:26:04,700 --> 00:26:05,420
还是不行

525
00:26:05,450 --> 00:26:06,230
我的OBG

526
00:26:06,230 --> 00:26:08,690
假如一遍我的我的这个a

527
00:26:09,140 --> 00:26:10,580
我的a组建的组建

528
00:26:10,580 --> 00:26:12,080
它还是会发生重新生的

529
00:26:12,410 --> 00:26:13,640
她仍然会重新扔的

530
00:26:21,550 --> 00:26:23,230
我的这个a还是会重新扔的

531
00:26:23,740 --> 00:26:24,580
原因是什么呢

532
00:26:25,460 --> 00:26:27,590
原因是我在我在

533
00:26:28,100 --> 00:26:30,530
比如我的那个name一遍

534
00:26:30,680 --> 00:26:32,240
就是如果我的name一遍

535
00:26:32,240 --> 00:26:34,010
一般是通过city name改变的吗

536
00:26:34,130 --> 00:26:35,720
我通过city name e改

537
00:26:36,360 --> 00:26:37,170
改了之后

538
00:26:39,340 --> 00:26:40,120
CM

539
00:26:40,150 --> 00:26:40,690
OK吧

540
00:26:40,720 --> 00:26:41,380
假如OBG

541
00:26:41,380 --> 00:26:44,290
我通过CDOBJ1改我的这个函数题

542
00:26:44,350 --> 00:26:46,210
根据我们今天白天所讲到的

543
00:26:46,600 --> 00:26:48,250
我们又发起了一次更新

544
00:26:48,250 --> 00:26:49,240
发起一次更新

545
00:26:49,240 --> 00:26:51,220
我们要重新构建February

546
00:26:51,250 --> 00:26:53,110
那么就会走到begin work那个地方

547
00:26:53,740 --> 00:26:55,120
在begin work那个地方

548
00:26:55,120 --> 00:26:56,980
由由于它是一个函数组件

549
00:26:57,160 --> 00:26:59,230
那么他肯定会执行它的函数体

550
00:26:59,230 --> 00:27:01,210
也就说这个会重新执行

551
00:27:02,780 --> 00:27:04,310
这块重新执行之后

552
00:27:04,730 --> 00:27:07,280
那么我们的name还是之前那个没问题

553
00:27:07,610 --> 00:27:09,200
但是我们的change name

554
00:27:09,410 --> 00:27:12,740
我们的change name他就变成了一个新的函数了

555
00:27:12,770 --> 00:27:14,600
大家看因为因为什么

556
00:27:15,860 --> 00:27:16,970
因为这个函数题

557
00:27:16,970 --> 00:27:19,070
整个函数体已经被重新执行了

558
00:27:19,310 --> 00:27:20,570
之前那个千金链

559
00:27:20,840 --> 00:27:24,050
我们每每我们美这样子操作

560
00:27:24,410 --> 00:27:25,550
美这样子调一番

561
00:27:25,850 --> 00:27:27,740
我们得到的这个方方法

562
00:27:27,770 --> 00:27:29,930
他总会是一个新的函数儿

563
00:27:29,930 --> 00:27:32,900
这个新的函数和上一次更新的那个老的函数

564
00:27:32,900 --> 00:27:35,240
虽然长得是一模一样的

565
00:27:35,700 --> 00:27:38,280
但是大家知道在在那个JS里

566
00:27:38,370 --> 00:27:40,560
就像两个长得一模一样的对象

567
00:27:40,770 --> 00:27:42,510
只要它的指向不一样

568
00:27:42,540 --> 00:27:43,290
就只要他在

569
00:27:43,880 --> 00:27:45,860
它的内存的地址不一样

570
00:27:45,860 --> 00:27:46,400
那么它

571
00:27:47,000 --> 00:27:48,320
被判断她

572
00:27:48,320 --> 00:27:49,790
他就一定会判断为假

573
00:27:49,820 --> 00:27:50,210
对不对

574
00:27:50,480 --> 00:27:51,200
这也是一样

575
00:27:51,380 --> 00:27:53,930
虽然说这个切面它并没有任何的变化

576
00:27:54,380 --> 00:27:56,780
但是由于他是被重新创建了

577
00:27:56,780 --> 00:28:00,770
它在内存中的地址和上一次的存存的地址是不一样的

578
00:28:01,040 --> 00:28:02,780
所以即使是reading memo

579
00:28:03,540 --> 00:28:04,860
在进行钱比较的时候

580
00:28:04,860 --> 00:28:06,600
他是永远会比成first

581
00:28:06,690 --> 00:28:07,800
就当时传的时候

582
00:28:07,800 --> 00:28:08,610
一个方法的时候

583
00:28:09,030 --> 00:28:11,160
他永远会比成force那么

584
00:28:11,700 --> 00:28:12,120
因此

585
00:28:12,150 --> 00:28:13,500
你只用read the memo

586
00:28:14,360 --> 00:28:15,380
把自制件包裹了

587
00:28:15,380 --> 00:28:16,430
你会发现没有用

588
00:28:17,040 --> 00:28:17,640
就发现没用

589
00:28:17,640 --> 00:28:18,870
只要你传了方法

590
00:28:18,870 --> 00:28:19,650
你就发现没有用

591
00:28:20,530 --> 00:28:21,100
原因就是

592
00:28:21,340 --> 00:28:25,360
原因就是虽然说他们的方法的名字就是方法

593
00:28:25,480 --> 00:28:26,410
内容也是一样的

594
00:28:26,410 --> 00:28:27,520
感觉什么都是一样的

595
00:28:27,700 --> 00:28:28,840
也确实什么都是一样的

596
00:28:29,320 --> 00:28:30,760
但是地址不一样

597
00:28:30,790 --> 00:28:32,170
他们就是两个不同的东西

598
00:28:32,950 --> 00:28:34,810
因此为了解决这个问题

599
00:28:34,930 --> 00:28:36,280
就有了use Co BAC

600
00:28:37,150 --> 00:28:38,350
通过u SCO back

601
00:28:45,260 --> 00:28:46,610
它的用法很简单

602
00:28:47,090 --> 00:28:48,110
第一个是一个含

603
00:28:48,140 --> 00:28:50,000
第一个参数是一个函数体

604
00:28:50,420 --> 00:28:52,760
第二个参数是它的依赖函数

605
00:28:52,790 --> 00:28:53,480
叫做依赖

606
00:28:54,610 --> 00:28:55,150
我们看一下

607
00:28:55,150 --> 00:28:56,320
我们现在会看到这种写法

608
00:28:56,320 --> 00:29:01,390
然后我们把我们把这个方法包裹在use back的

609
00:29:02,250 --> 00:29:03,210
第一个参数里

610
00:29:03,420 --> 00:29:05,310
第一个第一个参数中

611
00:29:06,060 --> 00:29:08,820
那么这种情况一般是这样

612
00:29:08,820 --> 00:29:10,110
就是你依赖着什么

613
00:29:10,410 --> 00:29:11,130
你在函数

614
00:29:11,130 --> 00:29:14,940
你在这个函数体内调用使用了什么变量

615
00:29:14,940 --> 00:29:17,040
你就把这个变量加到她的依赖数组里

616
00:29:17,540 --> 00:29:18,470
他这是什么意思呢

617
00:29:18,470 --> 00:29:21,260
意思是只有N变化的时候

618
00:29:21,590 --> 00:29:23,600
它会重新创建一个函数

619
00:29:23,750 --> 00:29:29,390
否则他就使用使用之前的那个函数的一个引用

620
00:29:30,260 --> 00:29:31,490
就假如说我的N不变

621
00:29:31,490 --> 00:29:32,630
比如OBG变了吗

622
00:29:32,630 --> 00:29:32,990
对吧

623
00:29:33,110 --> 00:29:34,220
我的N没有变化

624
00:29:34,370 --> 00:29:38,750
那么即使是我的这个APP又重新render了我的这个千金链

625
00:29:38,750 --> 00:29:40,550
得到的还是之前那一个引用

626
00:29:41,160 --> 00:29:41,610
那么

627
00:29:42,380 --> 00:29:44,270
我的这个a组件就不会变

628
00:29:44,480 --> 00:29:46,760
我的组件就不会重新登的

629
00:29:47,330 --> 00:29:48,470
这样才能达到效果

630
00:29:49,100 --> 00:29:50,450
那假如N遍了呢

631
00:29:50,690 --> 00:29:52,190
N遍了那么

632
00:29:52,830 --> 00:29:56,580
为了让他内部的函数体拿到最新的值

633
00:29:56,610 --> 00:29:57,840
最新的N这个值

634
00:29:58,170 --> 00:30:01,500
那么钱GM就会创建一个新的函数

635
00:30:01,860 --> 00:30:03,660
这个时候才会创建一个新的函数

636
00:30:03,810 --> 00:30:05,160
然后才会传给

637
00:30:05,160 --> 00:30:06,780
这个时候是正常的

638
00:30:06,780 --> 00:30:07,380
没有问题

639
00:30:07,440 --> 00:30:09,810
因为你的属性其实是正常的变化

640
00:30:10,780 --> 00:30:12,130
这块大家有听明白吗

641
00:30:12,220 --> 00:30:16,600
如果说要进行一个在hooks里进行一个前比较

642
00:30:18,490 --> 00:30:20,050
光是用REC ton memo

643
00:30:20,110 --> 00:30:21,760
这个是得不了分的

644
00:30:21,760 --> 00:30:24,400
如果面试官问了你光用writing memo

645
00:30:24,610 --> 00:30:26,110
这个是没办法得分的

646
00:30:26,650 --> 00:30:27,850
你必须要辅以

647
00:30:29,330 --> 00:30:30,320
Use the back

648
00:30:31,440 --> 00:30:34,830
你必须辅以use Co BAC来对函数做缓存

649
00:30:35,400 --> 00:30:37,950
如果你要传递的是一个对象

650
00:30:37,950 --> 00:30:38,580
大家瞧

651
00:30:38,640 --> 00:30:40,230
如果你要传递的是一个对象

652
00:30:40,780 --> 00:30:42,220
那么其实也是有问题的

653
00:30:42,250 --> 00:30:43,870
因为你的对象就算没变

654
00:30:45,120 --> 00:30:46,350
这个这个还好

655
00:30:46,470 --> 00:30:48,420
假如你是假如你就是

656
00:30:52,910 --> 00:30:53,540
Or BG

657
00:30:54,650 --> 00:30:55,490
假币是这样的

658
00:30:56,180 --> 00:30:58,310
你传递给了B这个组件

659
00:30:58,820 --> 00:31:00,140
就算没有任何的

660
00:31:00,590 --> 00:31:01,310
同样也是一样

661
00:31:01,310 --> 00:31:02,210
因为它是一个什么

662
00:31:02,210 --> 00:31:03,470
它虽然是一个值

663
00:31:03,500 --> 00:31:03,830
它不是

664
00:31:03,830 --> 00:31:04,700
它不是边

665
00:31:04,700 --> 00:31:05,570
他不是函数

666
00:31:05,960 --> 00:31:08,330
但是它是一个引用类型的值

667
00:31:08,630 --> 00:31:09,080
对不对

668
00:31:09,080 --> 00:31:11,030
他和函数面临的是同一个问题

669
00:31:12,740 --> 00:31:14,720
他函数面临的是同一个问题

670
00:31:14,720 --> 00:31:17,630
所以对于直怎么办

671
00:31:17,720 --> 00:31:21,290
对于执有一个方法叫做use memo对不对

672
00:31:21,350 --> 00:31:22,010
Use memo

673
00:31:25,560 --> 00:31:27,510
它会返回一个值

674
00:31:28,380 --> 00:31:29,970
它它的使用方式也是一样的

675
00:31:29,970 --> 00:31:34,980
也是一个大数字music back说白了是对函数的

676
00:31:35,580 --> 00:31:36,840
是对函数的缓存

677
00:31:37,290 --> 00:31:40,320
Use memo是对对象的缓存

678
00:31:40,320 --> 00:31:41,850
你可以理解为是对象的缓存

679
00:31:42,840 --> 00:31:45,060
通过这两个东西再加上

680
00:31:46,120 --> 00:31:50,200
Use或者use memo再加上memo的

681
00:31:50,800 --> 00:31:53,110
再加上memo的这个钱比较

682
00:31:53,680 --> 00:31:56,740
然后才能够完整的做一次

683
00:31:57,600 --> 00:31:58,710
漂component的事情

684
00:32:00,540 --> 00:32:00,930
Perhaps

685
00:32:00,930 --> 00:32:02,280
没有变化就不重新更改

686
00:32:02,400 --> 00:32:03,660
这样才能够完整的做出来

687
00:32:05,760 --> 00:32:08,670
use regular member可以替换成u SCO back吗

688
00:32:10,260 --> 00:32:11,850
Remember是必须的

689
00:32:12,390 --> 00:32:13,800
但是光有它还不够

690
00:32:14,810 --> 00:32:17,300
要用regular member包裹在子组件上

691
00:32:17,300 --> 00:32:17,840
大家看

692
00:32:18,200 --> 00:32:19,820
Memo是包括在子组件上

693
00:32:20,240 --> 00:32:21,260
包括在a上的

694
00:32:21,620 --> 00:32:23,000
ER you strike

695
00:32:23,060 --> 00:32:24,020
他是在父组件

696
00:32:24,590 --> 00:32:26,780
因为我要用父组件传递给他

697
00:32:26,840 --> 00:32:30,170
传递给他属性是包括在父组件传递给他属性上的

698
00:32:30,320 --> 00:32:31,520
他们两个要一起用

699
00:32:31,850 --> 00:32:32,900
单独用的话

700
00:32:33,590 --> 00:32:35,090
有可能是没有效果的

701
00:32:35,090 --> 00:32:36,110
但也有可能有效果

702
00:32:36,110 --> 00:32:38,150
如果说如果你只这样传

703
00:32:38,150 --> 00:32:38,390
对吧

704
00:32:38,390 --> 00:32:39,170
你只传一个

705
00:32:39,800 --> 00:32:40,760
只传一个是菌

706
00:32:40,820 --> 00:32:41,720
那么它是有效果的

707
00:32:41,780 --> 00:32:43,790
但你的只要你的变量一家

708
00:32:44,630 --> 00:32:47,600
变量易家这没有用Excel包起来

709
00:32:47,870 --> 00:32:49,490
那么他的钱比较就是做不了的

710
00:32:50,280 --> 00:32:51,540
这点能理解吗同学们

711
00:32:52,760 --> 00:32:54,470
能理解的扣一个一

712
00:32:59,930 --> 00:33:00,320
OK

713
00:33:00,320 --> 00:33:00,710
好的

714
00:33:01,250 --> 00:33:03,350
这个面试常问的常问的

715
00:33:03,350 --> 00:33:05,990
一般来说一一般来说

716
00:33:05,990 --> 00:33:09,170
因为因为它的官方网站里就说的是

717
00:33:09,930 --> 00:33:10,290
什么呢

718
00:33:10,290 --> 00:33:12,750
就是music可以用来做

719
00:33:13,360 --> 00:33:14,860
用来做那个缓存吗

720
00:33:14,920 --> 00:33:15,700
用来做缓存

721
00:33:15,880 --> 00:33:16,480
但是呢

722
00:33:16,660 --> 00:33:18,310
之前的时候有一些

723
00:33:18,610 --> 00:33:20,080
有一些来面试的一些同学

724
00:33:20,080 --> 00:33:20,770
可能并不知道

725
00:33:20,770 --> 00:33:22,690
他需要和memo结合享用

726
00:33:23,110 --> 00:33:23,980
Memo结合享用

727
00:33:24,010 --> 00:33:27,190
而且很多可能并没有真实的来做优化

728
00:33:27,310 --> 00:33:28,720
只是听别人说过一嘴

729
00:33:28,750 --> 00:33:29,230
现在

730
00:33:29,910 --> 00:33:32,880
现在就是如果说大家在面试中

731
00:33:33,500 --> 00:33:34,250
中问到了

732
00:33:34,280 --> 00:33:37,310
那么他一定是要结合起来使用才会有效果的

733
00:33:37,640 --> 00:33:39,650
否则的话是没有办法得分的

734
00:33:40,240 --> 00:33:41,590
这个地方就得不了分

735
00:33:43,450 --> 00:33:44,140
OK

736
00:33:44,170 --> 00:33:44,830
这个就是

737
00:33:45,070 --> 00:33:47,230
那么我们至少我们知道啦

738
00:33:47,290 --> 00:33:49,060
Use Co BAC use memo

739
00:33:49,630 --> 00:33:50,470
的作用是什么

740
00:33:50,470 --> 00:33:51,550
他们两个其实差不多

741
00:33:51,790 --> 00:33:53,830
但是只是一个缓存function

742
00:33:53,830 --> 00:33:54,970
一个缓存值

743
00:33:55,660 --> 00:33:56,470
一个缓动值

744
00:33:57,340 --> 00:33:59,770
You j EST我们刚刚也定义了对不对

745
00:34:00,160 --> 00:34:03,250
You state的方使用方式就是通过

746
00:34:04,450 --> 00:34:06,460
通过这他有接受一个参数

747
00:34:06,460 --> 00:34:07,480
这个参数是

748
00:34:08,140 --> 00:34:09,400
是它的初始值

749
00:34:09,520 --> 00:34:10,450
是它初始值

750
00:34:10,690 --> 00:34:11,800
然后返回一个数组

751
00:34:11,800 --> 00:34:12,700
第一项是

752
00:34:13,400 --> 00:34:15,350
直第二项是更改值的方法

753
00:34:15,890 --> 00:34:16,790
第二项是更改的方法

754
00:34:16,790 --> 00:34:17,690
这就是它的用法

755
00:34:18,020 --> 00:34:21,140
而他这个值就是初始值

756
00:34:21,140 --> 00:34:22,340
既可以是一个

757
00:34:23,550 --> 00:34:24,930
既可以是一个变量

758
00:34:24,930 --> 00:34:25,800
既可以是一个

759
00:34:25,800 --> 00:34:27,000
比如比如说这种

760
00:34:28,930 --> 00:34:30,070
数字就是

761
00:34:30,720 --> 00:34:32,820
这个是一个那个基本类型的

762
00:34:33,120 --> 00:34:34,290
也可以是引用类型

763
00:34:34,290 --> 00:34:35,850
而且也可以是一个方形

764
00:34:35,970 --> 00:34:37,050
如果是一个方形的话

765
00:34:37,050 --> 00:34:38,130
那么你需要给他

766
00:34:38,880 --> 00:34:40,740
你需要你需要一个return的

767
00:34:40,740 --> 00:34:43,800
你要反馈的东西也可以是一个方形都可以

768
00:34:44,820 --> 00:34:46,410
都给它还是比较

769
00:34:48,070 --> 00:34:49,600
就是对函数是比较友好的

770
00:34:49,600 --> 00:34:51,040
你什么地方都可以查函数

771
00:34:51,400 --> 00:34:53,200
而且有的时候是有用的

772
00:34:53,440 --> 00:34:54,310
有的时候是有用的

773
00:34:56,410 --> 00:34:57,820
You state就是这样做的

774
00:34:57,970 --> 00:34:58,720
就这样用的

775
00:34:59,560 --> 00:35:00,580
我们再来看一下

776
00:35:01,360 --> 00:35:03,520
You the effect so you the effect

777
00:35:04,240 --> 00:35:05,200
You the fac的

778
00:35:05,590 --> 00:35:07,330
它可以模拟三个生命周期

779
00:35:07,510 --> 00:35:09,910
我刚刚讲过可以模拟三个生命周期对吧

780
00:35:10,510 --> 00:35:12,730
那么它分别怎么办的呢

781
00:35:13,210 --> 00:35:14,290
我就直接给大家

782
00:35:15,160 --> 00:35:18,940
我就直接给大家写一写比如如果在cars里面

783
00:35:20,220 --> 00:35:23,790
那么他一般来说会定义complaint demanded对不对

784
00:35:24,420 --> 00:35:26,460
那么它的写法也是

785
00:35:26,460 --> 00:35:28,620
也是和刚刚use call back一样

786
00:35:29,040 --> 00:35:30,450
一个他一个

787
00:35:31,210 --> 00:35:32,770
函数第一个参数是一个函数

788
00:35:32,770 --> 00:35:34,150
第二个是一个数组

789
00:35:34,420 --> 00:35:35,650
第一个他的依赖宿主

790
00:35:35,740 --> 00:35:37,270
而这儿的意思是

791
00:35:37,970 --> 00:35:39,320
如果把它藏为空

792
00:35:39,980 --> 00:35:41,390
如果把它传为了空

793
00:35:42,350 --> 00:35:49,550
意思是他只有在第一次就是choose mount阶段MT阶段会执行一次

794
00:35:54,740 --> 00:35:56,390
其他的时候就再也不会自信了

795
00:35:57,000 --> 00:35:58,200
所以当我们这样写的时候

796
00:35:58,380 --> 00:35:59,130
由于她的依赖

797
00:35:59,130 --> 00:36:00,060
速度是空的

798
00:36:00,750 --> 00:36:02,220
由于她的依赖速度是空的

799
00:36:02,430 --> 00:36:03,840
所以他只会执行一次

800
00:36:03,840 --> 00:36:05,670
而这个执行一次的时机

801
00:36:06,310 --> 00:36:08,860
执行涉时机和那个

802
00:36:09,600 --> 00:36:13,110
执行的实际和那个component did mount是差不多的

803
00:36:13,140 --> 00:36:14,430
只是他是个一补呢

804
00:36:14,430 --> 00:36:15,000
他是个一补

805
00:36:15,000 --> 00:36:15,240
他

806
00:36:15,240 --> 00:36:17,970
他肯定也是会再当渲染之后才执行

807
00:36:18,330 --> 00:36:20,040
如果你想要完美地模拟

808
00:36:20,550 --> 00:36:23,910
完美地模拟就是complaint demanded

809
00:36:23,910 --> 00:36:25,290
那就用user you out

810
00:36:26,310 --> 00:36:28,500
Effect这两个都可以

811
00:36:28,650 --> 00:36:32,160
但是建议大官方是建议大家使用use effect

812
00:36:32,370 --> 00:36:34,830
因为它是一部你这里面如果做了什么

813
00:36:35,690 --> 00:36:36,680
大的操作

814
00:36:36,860 --> 00:36:38,690
那么他实际上他是不会影响的

815
00:36:39,170 --> 00:36:41,390
那么什么时候用官方建议

816
00:36:41,390 --> 00:36:44,060
什么时候用use your out effect呢

817
00:36:45,060 --> 00:36:47,130
你有什么和党有关的东西

818
00:36:47,490 --> 00:36:48,240
那么你可以

819
00:36:48,450 --> 00:36:50,760
那么你在这里用同步的去改就行了

820
00:36:50,970 --> 00:36:51,690
就不用等

821
00:36:52,110 --> 00:36:52,740
就不用等

822
00:36:52,770 --> 00:36:53,670
就同步的去改

823
00:36:54,400 --> 00:36:54,850
所以

824
00:36:55,060 --> 00:36:57,370
所以这两者的区别就是一个是同步

825
00:36:57,370 --> 00:36:58,420
一个是异步

826
00:36:58,450 --> 00:36:59,290
一个同步

827
00:36:59,470 --> 00:37:04,090
这两个的区别就是我们现在就按最常用的you the fact来讲

828
00:37:04,660 --> 00:37:06,490
它们两个的用法都是一模一样的

829
00:37:07,100 --> 00:37:12,980
而我写的这这一段的号代码就是类似于在component did mount里

830
00:37:13,250 --> 00:37:15,830
Component did mount里做一做一件事情

831
00:37:16,280 --> 00:37:18,710
这就相当于模拟了component did mount的生命周期

832
00:37:18,710 --> 00:37:21,050
因为他也执行只执行一次

833
00:37:22,790 --> 00:37:23,540
第二种

834
00:37:23,720 --> 00:37:25,550
我要模拟component did update

835
00:37:26,480 --> 00:37:27,260
其实对于

836
00:37:27,970 --> 00:37:30,160
You d find的时候就非常轻松

837
00:37:30,400 --> 00:37:32,230
比如说我的泪没变化

838
00:37:32,590 --> 00:37:32,830
对吧

839
00:37:32,830 --> 00:37:33,580
我立马变了

840
00:37:34,090 --> 00:37:34,540
那么

841
00:37:36,280 --> 00:37:37,930
他会执行两次这个函数

842
00:37:37,930 --> 00:37:39,010
它会执行两次

843
00:37:39,070 --> 00:37:42,040
第一次也是在也是在mount阶段

844
00:37:43,000 --> 00:37:44,980
初始化页面初始化的时候

845
00:37:44,980 --> 00:37:45,880
它会执行一次

846
00:37:46,150 --> 00:37:47,110
然后呢

847
00:37:47,320 --> 00:37:48,190
在name

848
00:37:48,220 --> 00:37:49,810
只要发生name发生了更改

849
00:37:50,080 --> 00:37:51,400
大家看name只要一改

850
00:37:51,400 --> 00:37:52,420
他就会立刻掉一次

851
00:37:53,910 --> 00:37:55,290
内容一改他就立刻掉

852
00:37:55,680 --> 00:37:59,370
是不是就相当于相当于掉了component

853
00:37:59,980 --> 00:38:00,670
Di DA Di LA

854
00:38:00,670 --> 00:38:03,730
因为component的它类似于一次聚合

855
00:38:03,730 --> 00:38:05,080
就是你任何的

856
00:38:05,720 --> 00:38:07,520
你任何的那个stayed一遍

857
00:38:07,940 --> 00:38:08,720
他都会掉一次

858
00:38:08,720 --> 00:38:10,850
然后还需要你手动的去判断

859
00:38:10,940 --> 00:38:13,430
你可能要写很多个if去判断

860
00:38:13,760 --> 00:38:14,300
If啊

861
00:38:14,300 --> 00:38:16,970
比如props.name等

862
00:38:17,300 --> 00:38:19,400
不等于上一个prove

863
00:38:19,990 --> 00:38:22,960
Proof那个stayed in name还有这样子判断

864
00:38:23,140 --> 00:38:25,450
然后他这其实是

865
00:38:25,990 --> 00:38:27,430
自动的就给你拆开的

866
00:38:27,460 --> 00:38:29,710
它是符合我们那个程序开发的一个

867
00:38:30,380 --> 00:38:32,420
程序开发的一个单一职责的原则的

868
00:38:32,780 --> 00:38:35,270
所以他看他写起来也会非常的

869
00:38:35,270 --> 00:38:41,570
你就觉得写起来的时候会比会比component did update会更加的清晰

870
00:38:41,930 --> 00:38:44,120
是不是我这很明显一个

871
00:38:44,640 --> 00:38:45,600
就是的

872
00:38:45,600 --> 00:38:46,410
戴帽子的时候

873
00:38:47,060 --> 00:38:48,560
要做的事情一个是

874
00:38:49,310 --> 00:38:50,900
Name变化的时候要做的事情

875
00:38:51,080 --> 00:38:53,540
一个是a级变化的时候要做事情非常清晰

876
00:38:53,660 --> 00:38:55,190
每一块的功能都是拆出来的

877
00:38:55,220 --> 00:38:56,030
都是拆开的

878
00:38:56,650 --> 00:38:59,260
但你如果想要多个也可以

879
00:38:59,290 --> 00:39:00,370
但是你一定要

880
00:39:01,080 --> 00:39:01,710
你一定要

881
00:39:02,300 --> 00:39:05,150
注意区分就是你在添加依赖的时候一定要特别小心

882
00:39:05,150 --> 00:39:06,230
一定要特别小心

883
00:39:06,470 --> 00:39:07,310
不要加多了

884
00:39:07,640 --> 00:39:08,330
加多了的话

885
00:39:08,330 --> 00:39:11,930
你的寒你的这个函数的执行次数可能会比较多

886
00:39:13,660 --> 00:39:14,830
如果那么改啦

887
00:39:15,710 --> 00:39:17,720
立马调用一次也还是异步的吗

888
00:39:19,500 --> 00:39:20,070
什么意思

889
00:39:23,980 --> 00:39:24,880
内蒙改啦

890
00:39:26,780 --> 00:39:27,290
对啊

891
00:39:27,290 --> 00:39:30,050
有这个函数是不是也是吏部的

892
00:39:30,080 --> 00:39:30,710
也是一部

893
00:39:31,380 --> 00:39:32,070
更新了是吗

894
00:39:33,020 --> 00:39:34,250
如果能改了

895
00:39:34,250 --> 00:39:35,360
内蒙一更改

896
00:39:36,320 --> 00:39:37,370
那没更改

897
00:39:38,400 --> 00:39:39,480
因为他是state吗

898
00:39:39,510 --> 00:39:40,650
那么肯定是一个state

899
00:39:40,770 --> 00:39:42,390
如果这个state一遍

900
00:39:42,930 --> 00:39:46,710
那么它会导致你的整个它是不是就发起了一次更新

901
00:39:47,830 --> 00:39:51,220
待会我们会待会给大家更详细的演示

902
00:39:51,220 --> 00:39:51,940
演示一番

903
00:39:52,360 --> 00:39:54,700
但是我就大致说一说内幕一遍

904
00:39:54,880 --> 00:39:57,220
他是不是就发起一次更新

905
00:39:57,220 --> 00:39:58,210
发起一次更新的时候

906
00:39:58,210 --> 00:39:59,500
它就会走我们白天的流程

907
00:39:59,530 --> 00:40:00,940
先走schedule

908
00:40:01,000 --> 00:40:01,660
然后再走

909
00:40:01,660 --> 00:40:03,190
再走那个re consider

910
00:40:03,430 --> 00:40:04,210
然后再走

911
00:40:04,600 --> 00:40:05,860
再走commit阶段

912
00:40:06,510 --> 00:40:09,090
然后当他又到达commit阶段的时候

913
00:40:09,690 --> 00:40:11,430
那么他还是在第三

914
00:40:11,610 --> 00:40:15,060
他还是在卡密特完之后

915
00:40:15,480 --> 00:40:21,150
然后那个异步的就是异步的异步的红任务当中执行这段代码

916
00:40:22,190 --> 00:40:24,740
执行资料代码对他的流程其实很长

917
00:40:24,740 --> 00:40:29,030
但是它是靠在咱们咱们白天所讲的那个流程上的

918
00:40:29,640 --> 00:40:31,290
待会给大家详细的分析

919
00:40:31,410 --> 00:40:33,780
它并不是说你那么一遍内容变了

920
00:40:33,780 --> 00:40:35,460
不会马上执行这个口感

921
00:40:36,020 --> 00:40:36,770
肯定是不会的

922
00:40:39,830 --> 00:40:40,250
OK

923
00:40:40,840 --> 00:40:43,780
然后第二个生命周期我已经模拟完了

924
00:40:44,110 --> 00:40:46,720
那么第三个不是说还有一个

925
00:40:49,110 --> 00:40:50,280
We are amount嘛

926
00:40:50,310 --> 00:40:52,380
对就是组件卸载的时候

927
00:40:52,890 --> 00:40:53,910
逐渐卸载的时候

928
00:40:55,000 --> 00:40:56,740
那么他其实是很巧妙

929
00:40:57,790 --> 00:40:59,230
如果你有存在return

930
00:40:59,920 --> 00:41:00,640
这是它的用法

931
00:41:00,640 --> 00:41:02,440
就是我为什么会先讲它的用法

932
00:41:02,710 --> 00:41:04,510
因为有同学可能没有用过X

933
00:41:05,030 --> 00:41:07,100
那么我如果直接上来讲源码的话

934
00:41:07,100 --> 00:41:09,170
那么连用法都不知道

935
00:41:09,170 --> 00:41:10,670
那你肯定是听不懂的

936
00:41:10,910 --> 00:41:13,250
我再讲第一节课的时候就说过

937
00:41:13,250 --> 00:41:14,690
我们要学习源码

938
00:41:14,690 --> 00:41:18,020
首先要去学习一下他的API到底是怎么死的

939
00:41:18,200 --> 00:41:19,460
如果你不会用法

940
00:41:19,460 --> 00:41:20,330
那你肯定是

941
00:41:20,910 --> 00:41:22,200
看源码也看不明白

942
00:41:22,880 --> 00:41:25,100
所以要先大致的讲一下它的用法

943
00:41:25,740 --> 00:41:26,220
OK

944
00:41:26,670 --> 00:41:27,330
现在

945
00:41:27,990 --> 00:41:29,880
用component will UN mount

946
00:41:30,580 --> 00:41:32,230
模拟的情况是这样的

947
00:41:35,940 --> 00:41:36,270
嗯

948
00:41:36,920 --> 00:41:38,810
阿曼达模拟情况是这样的

949
00:41:38,810 --> 00:41:39,560
比如说smart

950
00:41:40,340 --> 00:41:42,140
如果说有一个

951
00:41:43,280 --> 00:41:47,000
如果说你的you the fact里你return的一个函数

952
00:41:47,120 --> 00:41:47,780
同学们注意

953
00:41:47,810 --> 00:41:49,670
你一定要是return是一个函数

954
00:41:49,910 --> 00:41:52,400
那么它就会在你的组件卸载的时候

955
00:41:57,380 --> 00:41:59,390
调用这个妈的就是

956
00:42:00,120 --> 00:42:01,650
如果说你对他的一个函数

957
00:42:01,680 --> 00:42:03,570
那么我在组件卸载的时候就掉他

958
00:42:03,600 --> 00:42:05,250
如果你没有对他的感触

959
00:42:05,250 --> 00:42:06,090
那就啥也没有

960
00:42:06,120 --> 00:42:06,930
那就不用管

961
00:42:07,410 --> 00:42:08,820
因此就这么

962
00:42:09,060 --> 00:42:10,380
其实你整体来看

963
00:42:10,410 --> 00:42:13,560
就这么1234566行代码

964
00:42:14,010 --> 00:42:14,760
它就已经

965
00:42:15,310 --> 00:42:16,090
可以模拟

966
00:42:16,810 --> 00:42:18,370
Demanded update

967
00:42:19,070 --> 00:42:21,410
Where are mt3个生命周期就模拟完了

968
00:42:22,360 --> 00:42:28,750
我们一般经常做的一些需要在逐渐逐渐卸载的时候立刻销毁掉的东西

969
00:42:28,780 --> 00:42:30,070
比如说绑定事件

970
00:42:31,330 --> 00:42:31,780
对不对

971
00:42:31,960 --> 00:42:32,800
大家能不能点

972
00:42:33,190 --> 00:42:35,680
比如ADD event

973
00:42:38,350 --> 00:42:39,010
Listener

974
00:42:39,460 --> 00:42:40,780
比如我给他一个

975
00:42:41,770 --> 00:42:42,490
Screw

976
00:42:45,250 --> 00:42:46,150
Bill gates group

977
00:42:47,960 --> 00:42:48,830
这叫做

978
00:42:50,810 --> 00:42:52,310
昂酥肉

979
00:42:55,850 --> 00:42:56,510
咋

980
00:42:59,050 --> 00:43:00,130
Well his crew呢

981
00:43:00,130 --> 00:43:00,970
可能你没调这个

982
00:43:00,970 --> 00:43:02,170
你可能只掉一个click

983
00:43:02,350 --> 00:43:03,100
那就click吧

984
00:43:03,970 --> 00:43:05,650
这是我的名字都写好了

985
00:43:06,490 --> 00:43:07,930
因为CPU的开销比较大

986
00:43:07,960 --> 00:43:08,950
所以我就写了他

987
00:43:09,560 --> 00:43:13,430
如果你用click或者没有没有把它及时给销毁掉的话

988
00:43:13,670 --> 00:43:15,350
可能你觉得对你影响不是很大

989
00:43:15,380 --> 00:43:16,280
但你用screw

990
00:43:16,580 --> 00:43:18,290
那么你的开销可能就比较大了

991
00:43:18,680 --> 00:43:20,240
那么你毫无疑问

992
00:43:20,720 --> 00:43:22,730
你再卸载这个组件的时候

993
00:43:22,730 --> 00:43:24,440
你就一定要把这个代码给加上

994
00:43:37,580 --> 00:43:38,000
你看

995
00:43:39,430 --> 00:43:40,480
大家大家瞧一瞧

996
00:43:40,480 --> 00:43:45,790
相比于之前如果我要在那个喀什监理用的话就卡死

997
00:43:47,500 --> 00:43:49,030
我们看一下它有什么优势

998
00:43:50,640 --> 00:43:53,940
Component did mount

999
00:43:55,530 --> 00:43:56,610
那么我们是这么写的

1000
00:43:56,610 --> 00:43:57,780
我们必须这样写

1001
00:43:58,740 --> 00:44:00,420
然后这是this点

1002
00:44:03,470 --> 00:44:05,300
Hello component will mount

1003
00:44:14,080 --> 00:44:15,250
然后是这样写

1004
00:44:15,760 --> 00:44:16,960
有的同学可能觉得

1005
00:44:16,960 --> 00:44:19,000
这样写也还是虽然多了抢代码

1006
00:44:19,000 --> 00:44:21,730
但是也还是很清晰这是我这样

1007
00:44:21,760 --> 00:44:22,720
我现在这么展示

1008
00:44:22,720 --> 00:44:25,510
大家这么感觉是因为我没有其他逻辑

1009
00:44:25,660 --> 00:44:26,830
我如果有其他的逻辑

1010
00:44:26,890 --> 00:44:28,420
假如我在这里又加了很多

1011
00:44:28,450 --> 00:44:29,770
中间又加了很多函数

1012
00:44:30,280 --> 00:44:31,630
中间又加了N多个函数

1013
00:44:31,630 --> 00:44:33,040
这里又加了很多其他的逻辑

1014
00:44:33,430 --> 00:44:34,660
那么你的这个逻辑

1015
00:44:34,690 --> 00:44:37,240
你的这个ad和remove

1016
00:44:37,930 --> 00:44:40,540
他们实际上是同一个功能的两个部分

1017
00:44:40,900 --> 00:44:41,230
对不对

1018
00:44:41,230 --> 00:44:42,760
同一个功能的两个部分

1019
00:44:43,300 --> 00:44:44,650
你你写这个功能的时候

1020
00:44:44,650 --> 00:44:46,120
你ad VO CA lists and的时候

1021
00:44:46,120 --> 00:44:48,130
毫无疑问你肯定会想办法

1022
00:44:48,130 --> 00:44:49,540
下一个你就要写remove

1023
00:44:49,930 --> 00:44:51,700
它实际上逻辑是很分散的

1024
00:44:51,730 --> 00:44:53,440
他也就分散在两个方法功能

1025
00:44:53,830 --> 00:44:55,420
两个两个生命周期内了

1026
00:44:55,810 --> 00:44:57,490
你中间可能会加N多个东西

1027
00:44:57,490 --> 00:45:00,040
就会导致他的东西很分散

1028
00:45:00,190 --> 00:45:01,420
你如果写的不好的话

1029
00:45:01,630 --> 00:45:02,380
找也难找

1030
00:45:02,380 --> 00:45:03,130
看也难看

1031
00:45:04,060 --> 00:45:04,990
但是这儿的话

1032
00:45:05,020 --> 00:45:06,850
大家看它是一个玩具合成呢

1033
00:45:06,850 --> 00:45:08,380
实际上是一个完整的一个整体

1034
00:45:08,650 --> 00:45:11,650
大家有没有发现它是一个完整的整体

1035
00:45:12,010 --> 00:45:14,860
你你在u这个UCS中写了

1036
00:45:14,860 --> 00:45:16,300
你就给他返回一个return

1037
00:45:16,300 --> 00:45:17,620
然后就把它给扔掉

1038
00:45:18,520 --> 00:45:19,810
就直接把他给删掉

1039
00:45:21,910 --> 00:45:22,660
功能的话

1040
00:45:22,720 --> 00:45:24,910
它是一个整体的一个整体的一个模块儿

1041
00:45:24,910 --> 00:45:29,050
也非常符合我们代码开发的那个单一职责的一个原则的一个

1042
00:45:30,050 --> 00:45:31,820
这种原则是非常符合的

1043
00:45:33,300 --> 00:45:36,570
为什么我建议大家在做这种有副作用的操作的时候

1044
00:45:36,570 --> 00:45:37,260
一定要写

1045
00:45:37,260 --> 00:45:38,280
一定要写这个

1046
00:45:39,720 --> 00:45:40,830
一定要写这个函数

1047
00:45:41,250 --> 00:45:42,750
Destroy这个函数是一定要写的

1048
00:45:43,020 --> 00:45:43,650
原因是啥

1049
00:45:43,650 --> 00:45:46,110
你比如说这个SQL的开销比较大

1050
00:45:46,950 --> 00:45:47,280
对吧

1051
00:45:47,310 --> 00:45:48,270
看起来比较大

1052
00:45:48,300 --> 00:45:49,410
但是他也不会出错

1053
00:45:49,770 --> 00:45:52,410
你如果要进行set interval的话就是

1054
00:45:52,980 --> 00:45:54,330
你要进行interview的话

1055
00:45:54,330 --> 00:45:55,560
如果不给他清掉了

1056
00:45:55,590 --> 00:45:57,210
因为它是根据计时器来的吗

1057
00:45:57,880 --> 00:46:00,580
你的你的那个可能程序直接就乱了

1058
00:46:01,180 --> 00:46:03,670
比如说你那个计时他可能就是乱的

1059
00:46:04,320 --> 00:46:06,810
因为因为他可能创建N多个计时器

1060
00:46:07,020 --> 00:46:09,540
然后它这个几个技师之间就完全就乱了

1061
00:46:10,960 --> 00:46:12,280
你如果比比对

1062
00:46:12,820 --> 00:46:13,450
这个是

1063
00:46:13,870 --> 00:46:15,520
这个是有血泪教训的

1064
00:46:17,020 --> 00:46:18,550
刚开始如果不写这个

1065
00:46:18,550 --> 00:46:19,540
真的就是两行泪

1066
00:46:19,540 --> 00:46:21,400
你们真的就只有两行泪

1067
00:46:22,580 --> 00:46:23,840
比如set interval的时候

1068
00:46:24,520 --> 00:46:25,810
在在护士当中

1069
00:46:26,140 --> 00:46:27,880
你如果把他不把这个给清掉

1070
00:46:28,740 --> 00:46:30,210
如果把这个给清掉的话

1071
00:46:31,150 --> 00:46:32,170
会非常的

1072
00:46:36,020 --> 00:46:39,140
你的程序可能就是直接是错的程序会直接出错

1073
00:46:39,830 --> 00:46:42,200
下面两个可能只是性性能不好

1074
00:46:42,820 --> 00:46:44,650
而他就感觉像是一个bug一样

1075
00:46:45,350 --> 00:46:46,700
就感觉像是一个bug

1076
00:46:52,170 --> 00:46:53,160
他到时候会感

1077
00:46:53,190 --> 00:46:54,570
如果你不清他就是一个

1078
00:46:54,750 --> 00:46:55,740
他感觉是一个bug

1079
00:46:56,160 --> 00:46:56,670
一定会

1080
00:46:56,670 --> 00:46:57,960
你大家可以下去试一试

1081
00:46:58,050 --> 00:46:59,550
如果有同学不相信

1082
00:46:59,550 --> 00:47:00,420
可以下去试一试

1083
00:47:00,900 --> 00:47:03,330
但是如果就算你在后面王了之后

1084
00:47:03,420 --> 00:47:05,730
如果你能够及时地回想起来

1085
00:47:06,630 --> 00:47:07,770
及时地回想起来

1086
00:47:07,770 --> 00:47:10,650
Sight in TE我们王乐你如果时间以后

1087
00:47:10,650 --> 00:47:12,930
大家在处理的时候发现时间乱了

1088
00:47:13,520 --> 00:47:16,790
就是一种本来是应该是59秒

1089
00:47:17,030 --> 00:47:18,350
本来应该是59秒

1090
00:47:18,560 --> 00:47:19,910
突然一下子变成了40

1091
00:47:20,150 --> 00:47:21,680
变成了其他什么几个树

1092
00:47:21,710 --> 00:47:22,910
老师也想不明白了

1093
00:47:23,300 --> 00:47:24,800
你就要想你的这个CD

1094
00:47:24,800 --> 00:47:26,480
英特尔到底有没有把它给清掉

1095
00:47:26,480 --> 00:47:28,640
那个坑到底有没有他坑掉

1096
00:47:29,950 --> 00:47:31,180
到底有没有把它扔掉

1097
00:47:31,240 --> 00:47:31,990
你把他坑掉

1098
00:47:31,990 --> 00:47:32,740
你就会发现

1099
00:47:32,740 --> 00:47:33,430
它又正常了

1100
00:47:34,140 --> 00:47:36,810
就是这为什么要多提这么一嘴呢

1101
00:47:37,290 --> 00:47:38,100
多提这么一嘴

1102
00:47:38,100 --> 00:47:40,140
因为你第一次遇到这个问题的时候

1103
00:47:40,140 --> 00:47:40,980
你可能是蒙的

1104
00:47:41,040 --> 00:47:43,410
你不知道我就是正常的设了一个CD

1105
00:47:43,410 --> 00:47:44,250
英特尔而已

1106
00:47:44,790 --> 00:47:45,570
他怎么一下子

1107
00:47:45,570 --> 00:47:46,740
他怎么一下子就

1108
00:47:48,020 --> 00:47:48,920
奇奇怪怪的

1109
00:47:48,950 --> 00:47:49,640
非常奇怪

1110
00:47:51,270 --> 00:47:51,900
就这个原因

1111
00:47:51,930 --> 00:47:52,680
因为你没有气

1112
00:47:54,630 --> 00:47:55,050
OK

1113
00:47:55,320 --> 00:47:57,870
然后这个关于这段you the fact的功能

1114
00:47:57,870 --> 00:47:59,250
大家能理解能理解吗

1115
00:47:59,670 --> 00:48:00,870
能理解的扣个一

1116
00:48:01,200 --> 00:48:02,160
能理解扣个零

1117
00:48:07,590 --> 00:48:10,560
这也是代码中脑出的问题

1118
00:48:10,590 --> 00:48:13,020
老出的问题都是一些经验之谈

1119
00:48:13,800 --> 00:48:14,220
OK

1120
00:48:14,250 --> 00:48:16,470
那我们来看它其实还有一些其他的问题

1121
00:48:17,320 --> 00:48:18,160
还有其他的问题

1122
00:48:20,630 --> 00:48:22,760
或者是其他常见问题

1123
00:48:23,640 --> 00:48:24,060
第一

1124
00:48:24,480 --> 00:48:26,610
使用use date或者使用hooks

1125
00:48:26,820 --> 00:48:28,680
这个太宽泛了

1126
00:48:29,310 --> 00:48:30,300
就使用cooks

1127
00:48:30,810 --> 00:48:32,370
只能在顶层使用

1128
00:48:32,370 --> 00:48:34,020
不能出现在条件语句当中

1129
00:48:34,050 --> 00:48:36,030
任何的条件语句当中都不可以

1130
00:48:36,620 --> 00:48:37,310
什么意思

1131
00:48:38,400 --> 00:48:40,110
这个可能大家也有所耳闻

1132
00:48:40,110 --> 00:48:40,710
就算没有

1133
00:48:40,740 --> 00:48:41,820
就算没有用过的

1134
00:48:41,820 --> 00:48:43,200
应该也是有所耳闻的

1135
00:48:44,650 --> 00:48:45,340
比如

1136
00:48:46,520 --> 00:48:47,330
我如果

1137
00:48:48,310 --> 00:48:49,390
比如我想在

1138
00:48:50,310 --> 00:48:50,730
嗯

1139
00:48:52,710 --> 00:48:53,340
If

1140
00:48:53,730 --> 00:48:54,150
对吧

1141
00:48:54,210 --> 00:48:55,860
If tu ni

1142
00:48:55,860 --> 00:48:57,750
我想在这里用一个you the fact

1143
00:49:02,360 --> 00:49:03,080
能不能用

1144
00:49:03,650 --> 00:49:04,160
不能

1145
00:49:04,760 --> 00:49:07,190
不能用同学不能用我之前

1146
00:49:07,840 --> 00:49:08,980
遇到过有同学说

1147
00:49:09,010 --> 00:49:11,320
就是我问use use that能不能放在

1148
00:49:11,800 --> 00:49:13,360
能不能放在这个

1149
00:49:14,020 --> 00:49:15,040
分支里

1150
00:49:15,280 --> 00:49:16,060
他说不可以

1151
00:49:16,450 --> 00:49:17,050
早上好

1152
00:49:17,050 --> 00:49:18,460
我说you the fact能放吗

1153
00:49:18,850 --> 00:49:20,005
他说可以

1154
00:49:20,005 --> 00:49:21,820
我说为什么you state可以

1155
00:49:21,820 --> 00:49:22,900
You the fact不行

1156
00:49:23,800 --> 00:49:24,970
那就不知道了

1157
00:49:25,330 --> 00:49:26,710
You the fact也不行

1158
00:49:27,640 --> 00:49:29,200
所以我刚刚在这儿调整了一下

1159
00:49:29,200 --> 00:49:31,810
就是只要是hooks use use effect

1160
00:49:31,810 --> 00:49:32,860
毫无疑问也是hooks

1161
00:49:32,860 --> 00:49:33,340
对不对

1162
00:49:34,010 --> 00:49:35,570
Use effect也不可以

1163
00:49:36,240 --> 00:49:37,410
我会给大家讲原因

1164
00:49:38,540 --> 00:49:40,400
也也会给大家会给大家讲原因

1165
00:49:40,400 --> 00:49:41,240
原因是什么呢

1166
00:49:41,390 --> 00:49:43,790
我们不不论是used也好

1167
00:49:43,940 --> 00:49:45,140
You are back也好

1168
00:49:45,500 --> 00:49:47,420
You the fac也不能

1169
00:49:47,450 --> 00:49:48,110
都不能

1170
00:49:48,850 --> 00:49:49,840
Use the state也好

1171
00:49:49,840 --> 00:49:51,520
Use call back you the fact也好

1172
00:49:51,550 --> 00:49:52,660
所有的hooks

1173
00:49:53,230 --> 00:49:54,550
她实际上在你的

1174
00:49:54,760 --> 00:49:56,020
它都会在你的这个

1175
00:49:56,050 --> 00:49:56,980
我们这个APP

1176
00:49:57,100 --> 00:49:58,330
它是一个函数组件吗

1177
00:49:58,750 --> 00:50:00,400
这个函数组件

1178
00:50:00,400 --> 00:50:02,260
他在rap的内部里

1179
00:50:03,630 --> 00:50:04,710
在red内不理

1180
00:50:04,920 --> 00:50:06,270
他会给你描述

1181
00:50:06,390 --> 00:50:07,620
描述为一个什么呢

1182
00:50:07,830 --> 00:50:11,310
描述为一个fiber node节点

1183
00:50:11,310 --> 00:50:13,380
这个大家这个大家应该知道

1184
00:50:13,380 --> 00:50:13,800
对不对

1185
00:50:13,950 --> 00:50:14,910
Fiber node节点

1186
00:50:15,270 --> 00:50:16,800
他会描述一个发怒的节点

1187
00:50:16,890 --> 00:50:18,270
而这个发怒的节点

1188
00:50:19,160 --> 00:50:24,170
他把所有的hooks他是用一条链表存起来的

1189
00:50:24,680 --> 00:50:25,130
比如

1190
00:50:26,600 --> 00:50:28,400
我这是一个final的一个节点

1191
00:50:28,760 --> 00:50:31,790
我有专门有一个属性来存hooks的

1192
00:50:32,470 --> 00:50:34,720
这个发热建有一个呼属性成分

1193
00:50:35,200 --> 00:50:36,880
是专门来护城hooks的

1194
00:50:37,210 --> 00:50:38,350
不管你是use data

1195
00:50:38,740 --> 00:50:40,270
对他来讲他是一个hooks

1196
00:50:40,940 --> 00:50:41,420
对不对

1197
00:50:42,000 --> 00:50:43,710
然后user back他的列表

1198
00:50:43,710 --> 00:50:44,910
又练到下一个books

1199
00:50:45,590 --> 00:50:46,190
Use effect

1200
00:50:46,190 --> 00:50:47,510
又练到下一个hooks

1201
00:50:47,720 --> 00:50:49,040
然后又练到下一个X

1202
00:50:49,190 --> 00:50:50,510
然后又练到下一个X

1203
00:50:51,910 --> 00:50:53,410
他是一个列表来的

1204
00:50:53,680 --> 00:50:54,430
然后呢

1205
00:50:55,000 --> 00:50:55,390
然后呢

1206
00:50:55,390 --> 00:50:57,760
当这是初始化的时候嘛

1207
00:50:57,760 --> 00:50:59,140
就是第一次慢的阶段的时候

1208
00:50:59,350 --> 00:51:00,790
他就注册了一个这样的列表

1209
00:51:01,660 --> 00:51:02,200
但是呢

1210
00:51:02,200 --> 00:51:03,850
你一更新的时候

1211
00:51:03,880 --> 00:51:04,780
比如你一更新

1212
00:51:06,240 --> 00:51:07,500
你任何一个数

1213
00:51:07,530 --> 00:51:08,940
你任何一个变量与更新

1214
00:51:09,330 --> 00:51:12,630
那么他下下一次他就重新扔的这个函数题

1215
00:51:12,990 --> 00:51:14,160
重新扔的这个函数题

1216
00:51:14,340 --> 00:51:16,470
而重新中的这个函数体之后

1217
00:51:16,620 --> 00:51:18,480
他就执行的是更新逻辑了

1218
00:51:18,840 --> 00:51:20,820
更新逻辑他要找到

1219
00:51:21,000 --> 00:51:22,380
就比如这个set name

1220
00:51:22,860 --> 00:51:23,820
他要找到什么

1221
00:51:23,820 --> 00:51:25,380
他要找到对应的这个name

1222
00:51:25,770 --> 00:51:27,930
它是根据它就是根据顺序直接来找的

1223
00:51:27,930 --> 00:51:29,700
比如说我的这个said name

1224
00:51:29,700 --> 00:51:30,780
他一定就指向他

1225
00:51:31,020 --> 00:51:32,400
他就一定指向这个位置

1226
00:51:32,640 --> 00:51:35,400
我下面一个赛特他就指向这个位置

1227
00:51:36,030 --> 00:51:36,960
下面就是这个

1228
00:51:36,960 --> 00:51:38,520
它就是按位置来对应的

1229
00:51:38,670 --> 00:51:40,320
如果你有任何一个if

1230
00:51:40,500 --> 00:51:41,580
比如你这个F了

1231
00:51:42,230 --> 00:51:43,250
比如你这个衣服了

1232
00:51:43,430 --> 00:51:47,360
那么它的对应关系就会一下子错乱掉

1233
00:51:47,480 --> 00:51:48,470
就有可能错乱了

1234
00:51:48,470 --> 00:51:50,720
你的程序代码就直接就是错的了

1235
00:51:51,340 --> 00:51:52,000
你就会发现

1236
00:51:52,300 --> 00:51:54,340
本来我要改变的是我的内蒙

1237
00:51:54,520 --> 00:51:55,960
怎么一下子改了age了

1238
00:51:56,410 --> 00:51:57,100
你就有

1239
00:51:57,160 --> 00:51:58,750
你如果用了if

1240
00:51:58,990 --> 00:52:00,340
那么它就出现这种场景

1241
00:52:00,900 --> 00:52:01,710
这毫无疑问

1242
00:52:01,710 --> 00:52:03,240
代码直接就是错误的

1243
00:52:03,820 --> 00:52:05,320
所以压根儿不能这么写

1244
00:52:06,380 --> 00:52:06,920
有同学问

1245
00:52:06,920 --> 00:52:08,330
自定义hooks可不可以

1246
00:52:08,750 --> 00:52:10,220
自定义hooks也不可以

1247
00:52:10,430 --> 00:52:15,410
原因是为啥你的自定义hooks你实际上会用到hooks

1248
00:52:15,910 --> 00:52:16,330
对不对

1249
00:52:16,360 --> 00:52:18,370
你的自定义hooks会用到hooks

1250
00:52:20,330 --> 00:52:22,850
所以它包括了hooks

1251
00:52:23,270 --> 00:52:26,300
那hooks能不能放在放放在条件分支点不行

1252
00:52:26,540 --> 00:52:28,070
所以你要制定hooks也不可以

1253
00:52:28,870 --> 00:52:29,740
那有同学说了

1254
00:52:29,740 --> 00:52:30,910
那我就制定hooks

1255
00:52:30,910 --> 00:52:32,080
假如没有福克斯呢

1256
00:52:32,810 --> 00:52:34,520
那你就只是一个普通的方法而已

1257
00:52:34,520 --> 00:52:35,420
那就不是自定义

1258
00:52:35,420 --> 00:52:36,740
福克斯能理解吗

1259
00:52:40,480 --> 00:52:41,680
能理解的扣个一

1260
00:52:41,890 --> 00:52:42,910
不理解扣个零

1261
00:52:45,950 --> 00:52:46,340
对

1262
00:52:47,020 --> 00:52:49,060
他就是你永远记住他是一个练

1263
00:52:49,060 --> 00:52:50,080
它就是一个链条

1264
00:52:50,320 --> 00:52:51,370
它后面更新的时候

1265
00:52:51,370 --> 00:52:52,540
我要准确的找到她

1266
00:52:52,930 --> 00:52:53,860
你只要有个if

1267
00:52:53,860 --> 00:52:55,840
我就我就没办法准确的找到它了

1268
00:52:56,410 --> 00:52:57,430
他就可能找错

1269
00:52:58,100 --> 00:53:00,230
那这绝对是不能不能被允许的

1270
00:53:00,710 --> 00:53:03,590
但就是record也不允许你这么做

1271
00:53:03,650 --> 00:53:04,910
他可以直接给你报错的

1272
00:53:05,240 --> 00:53:07,940
就是如果面试官问到了这个问题的话

1273
00:53:08,600 --> 00:53:10,430
那么我们的回答就可以是这样

1274
00:53:10,880 --> 00:53:11,630
就是这样卫生

1275
00:53:11,630 --> 00:53:12,290
这为什么

1276
00:53:12,620 --> 00:53:14,660
但我们会再看代码的时候

1277
00:53:14,660 --> 00:53:17,120
其实能够给大家讲到这一块儿

1278
00:53:17,330 --> 00:53:18,350
能给大家讲到这一块儿

1279
00:53:19,770 --> 00:53:21,630
这是第一个

1280
00:53:22,250 --> 00:53:25,970
经常就是几个容易出问题的地方吧

1281
00:53:26,930 --> 00:53:30,260
容易出问题的

1282
00:53:31,820 --> 00:53:32,240
地方

1283
00:53:32,510 --> 00:53:33,470
第二使用

1284
00:53:40,720 --> 00:53:41,440
嗯

1285
00:53:44,030 --> 00:53:44,720
史俊华

1286
00:53:45,200 --> 00:53:46,130
什么事

1287
00:53:46,130 --> 00:53:47,030
这什么意思呢

1288
00:53:58,680 --> 00:53:59,610
喜欢什么意思

1289
00:53:59,640 --> 00:54:00,930
比如说我又

1290
00:54:03,060 --> 00:54:06,270
这个是刚用户的时候老出这种问题

1291
00:54:07,310 --> 00:54:08,060
老师这个问题

1292
00:54:08,060 --> 00:54:09,080
而面试官呢

1293
00:54:09,260 --> 00:54:10,550
也很喜欢问这些问题

1294
00:54:13,520 --> 00:54:14,180
比如啊

1295
00:54:15,760 --> 00:54:16,450
分析一个

1296
00:54:17,120 --> 00:54:17,630
什么

1297
00:54:19,890 --> 00:54:20,400
孕妇吧

1298
00:54:22,320 --> 00:54:23,940
应该是关于也爱问

1299
00:54:25,950 --> 00:54:26,490
然后呢

1300
00:54:26,490 --> 00:54:27,390
一般来说对不对

1301
00:54:27,390 --> 00:54:31,050
加的废气什么叉叉叉

1302
00:54:31,590 --> 00:54:32,850
然后点认

1303
00:54:33,960 --> 00:54:34,920
然后

1304
00:54:35,870 --> 00:54:37,070
Stan Jason

1305
00:54:41,300 --> 00:54:42,260
一般这么写的吗

1306
00:54:42,440 --> 00:54:43,040
点赞

1307
00:54:46,430 --> 00:54:47,390
然后比如我这

1308
00:54:50,000 --> 00:54:50,990
Set name

1309
00:54:55,830 --> 00:54:58,140
S假如假如

1310
00:54:58,500 --> 00:55:00,030
然后这里name变化

1311
00:55:25,750 --> 00:55:26,170
好

1312
00:55:26,200 --> 00:55:27,010
这样一写

1313
00:55:27,520 --> 00:55:28,930
一个死循环诞生了

1314
00:55:29,500 --> 00:55:31,480
我来给大家解读一下

1315
00:55:31,480 --> 00:55:33,790
我在家用use that bag包起来也是一样的

1316
00:55:40,810 --> 00:55:41,500
Use the fact

1317
00:55:41,500 --> 00:55:43,420
刚刚给大家讲了当name一遍

1318
00:55:44,240 --> 00:55:45,470
当内没变化的时候

1319
00:55:45,470 --> 00:55:47,060
那么他肯定要肺气

1320
00:55:47,090 --> 00:55:48,530
因为肺经发对不对

1321
00:55:49,470 --> 00:55:51,090
飞机或飞机完了之后

1322
00:55:51,090 --> 00:55:52,470
它又会重新设定

1323
00:55:53,180 --> 00:55:54,380
重新测量之后

1324
00:55:54,380 --> 00:55:55,070
Name又变了

1325
00:55:55,070 --> 00:55:57,440
他又要飞进凤飞尽复

1326
00:55:58,330 --> 00:55:59,080
又变了

1327
00:55:59,110 --> 00:56:00,490
那么他要重新设定

1328
00:56:01,280 --> 00:56:03,350
那么这就是一个循环

1329
00:56:03,410 --> 00:56:04,220
这就是一个

1330
00:56:05,350 --> 00:56:06,940
永远不会间断的一个循环

1331
00:56:06,940 --> 00:56:09,790
你会发现你的你的那个谷歌浏览器

1332
00:56:09,820 --> 00:56:13,000
它就会瞬间发几十条几百条的请求出去

1333
00:56:13,240 --> 00:56:14,080
把那个项目

1334
00:56:14,980 --> 00:56:15,370
就这样

1335
00:56:15,400 --> 00:56:19,240
那有同学说老师这种这个代码其实明显有问题

1336
00:56:19,240 --> 00:56:19,930
太傻了

1337
00:56:20,440 --> 00:56:20,860
我跟你说

1338
00:56:20,860 --> 00:56:23,050
有的时候有的时候并不傻

1339
00:56:23,080 --> 00:56:24,850
比如说比如我

1340
00:56:25,860 --> 00:56:27,540
这配音吗

1341
00:56:27,540 --> 00:56:27,900
就那个

1342
00:56:28,290 --> 00:56:29,730
假如我要用它来判断一下

1343
00:56:30,440 --> 00:56:33,260
我假如我判断她比如等不等于一扔

1344
00:56:34,130 --> 00:56:35,240
你就算不传

1345
00:56:36,140 --> 00:56:36,410
对啊

1346
00:56:36,410 --> 00:56:37,910
就是说我根本不会用

1347
00:56:37,940 --> 00:56:38,960
不会涉及到

1348
00:56:38,960 --> 00:56:40,820
这样我怎么会传一个名字

1349
00:56:40,820 --> 00:56:42,200
然后又改一个名字呢

1350
00:56:42,650 --> 00:56:44,420
那假如你就只这样进行判断

1351
00:56:44,420 --> 00:56:45,620
这种情况很常见吧

1352
00:56:46,300 --> 00:56:47,050
是不是很常见

1353
00:56:47,140 --> 00:56:49,180
你只是在进行一个判断而已

1354
00:56:49,390 --> 00:56:51,160
但是你也要把它作为你的依赖

1355
00:56:51,800 --> 00:56:52,940
他照样是一个师兄

1356
00:56:57,830 --> 00:56:58,250
对不对

1357
00:57:00,050 --> 00:57:03,290
这种情况是刚开始非常非常容易遇到的

1358
00:57:09,370 --> 00:57:10,090
没有没有

1359
00:57:10,910 --> 00:57:12,530
Use effect是一个hooks

1360
00:57:12,530 --> 00:57:15,320
我是在use effect函数里面用的衣服

1361
00:57:16,440 --> 00:57:17,010
明白不

1362
00:57:18,760 --> 00:57:19,750
它定义的地方

1363
00:57:19,780 --> 00:57:21,190
它定义的地方不能够

1364
00:57:21,340 --> 00:57:23,620
就是你不能够把它这样放

1365
00:57:26,220 --> 00:57:27,750
你不能够把它这样放

1366
00:57:29,620 --> 00:57:30,730
这样放是不行的

1367
00:57:35,340 --> 00:57:36,480
这样是不行的

1368
00:57:39,770 --> 00:57:40,010
对

1369
00:57:40,010 --> 00:57:44,090
这个use if you stayed还是hooks used a sad state

1370
00:57:44,090 --> 00:57:44,840
他并不是

1371
00:57:44,840 --> 00:57:45,950
他并不是hooks

1372
00:57:48,260 --> 00:57:49,100
这样不行

1373
00:57:52,160 --> 00:57:52,520
好

1374
00:57:53,690 --> 00:57:54,980
那么这个死循环怎么办

1375
00:57:55,190 --> 00:57:57,800
量一般来说

1376
00:57:57,920 --> 00:57:59,120
我知道的有

1377
00:58:00,030 --> 00:58:01,740
两种通常有两种吧

1378
00:58:01,740 --> 00:58:02,400
有两种方法

1379
00:58:02,400 --> 00:58:05,070
有两种方法有两种方法来做

1380
00:58:05,100 --> 00:58:05,580
但是

1381
00:58:07,170 --> 00:58:07,590
就

1382
00:58:08,220 --> 00:58:11,280
最有偶尔的时候可以通过这种方式

1383
00:58:11,280 --> 00:58:11,700
比如

1384
00:58:13,070 --> 00:58:14,120
你这有依赖对吧

1385
00:58:14,630 --> 00:58:15,590
你这儿有这个依赖

1386
00:58:16,760 --> 00:58:17,870
我们的这个city name

1387
00:58:17,960 --> 00:58:19,340
我先讲一下这个CDM

1388
00:58:20,030 --> 00:58:20,660
这个M

1389
00:58:20,660 --> 00:58:22,790
它它可以给它传一个值

1390
00:58:23,430 --> 00:58:24,810
他也可以给他传

1391
00:58:25,420 --> 00:58:27,100
他也可以给他传一个函数

1392
00:58:27,850 --> 00:58:29,680
如果你给他传一个函数的时候

1393
00:58:30,010 --> 00:58:30,460
那么

1394
00:58:31,170 --> 00:58:32,880
你的这个比如你的这个

1395
00:58:34,070 --> 00:58:37,430
这个函数里面会默认给你填充一个参数

1396
00:58:37,430 --> 00:58:40,880
这个参数就是最新的最新的我们的那个name的值

1397
00:58:41,900 --> 00:58:42,650
有的情况下

1398
00:58:42,650 --> 00:58:44,480
你用它其实可以解决

1399
00:58:44,930 --> 00:58:49,790
因为比如说你我如果布局这种布局这种例子举个例子

1400
00:58:49,790 --> 00:58:52,400
我我在哪呢

1401
00:58:55,720 --> 00:58:56,440
我在这儿吧

1402
00:58:57,060 --> 00:58:58,200
我改一改稍等

1403
00:59:01,140 --> 00:59:02,010
改一改

1404
00:59:03,990 --> 00:59:06,030
比如说在这衣服

1405
00:59:06,810 --> 00:59:08,490
比如name等于等于

1406
00:59:11,160 --> 00:59:11,730
一登

1407
00:59:12,840 --> 00:59:13,500
然后我就

1408
00:59:14,210 --> 00:59:14,870
我觉得他

1409
00:59:16,190 --> 00:59:17,450
对不对那么

1410
00:59:19,040 --> 00:59:20,810
这种情况同样是死循环的

1411
00:59:20,930 --> 00:59:22,280
我给大家讲一下为什么

1412
00:59:22,550 --> 00:59:24,080
因为内蒙一遍

1413
00:59:24,680 --> 00:59:26,720
就是我第一次use effect的时候肯定会掉

1414
00:59:26,720 --> 00:59:30,470
他又飞机佛飞机in for1掉那么

1415
00:59:31,000 --> 00:59:33,010
他这个set name name一遍

1416
00:59:33,600 --> 00:59:34,470
那么一个变化

1417
00:59:34,980 --> 00:59:38,280
那么导致你的这个飞机因或有变化了

1418
00:59:38,370 --> 00:59:39,450
飞机或就会变

1419
00:59:39,450 --> 00:59:41,370
就会产生一个新的函数

1420
00:59:41,820 --> 00:59:42,960
这个新的函数与变化

1421
00:59:42,960 --> 00:59:45,000
你的you the fact同样是会变化的

1422
00:59:45,060 --> 00:59:46,620
那么同样是一个死循环

1423
00:59:47,270 --> 00:59:48,470
然后在这种情况下

1424
00:59:49,420 --> 00:59:51,130
现在

1425
00:59:51,160 --> 00:59:53,920
他这个时间段产生的原因就是我记忆中的

1426
00:59:53,920 --> 00:59:56,110
我既用到了这个state

1427
00:59:56,530 --> 00:59:58,420
同时我还更改了这个state

1428
00:59:58,600 --> 01:00:00,190
这个就是产生它的原因

1429
01:00:00,430 --> 01:00:02,230
那么我要做的事情是什么呢

1430
01:00:02,230 --> 01:00:03,340
要做的事情就是

1431
01:00:04,600 --> 01:00:06,610
把这个链条给断掉对不对

1432
01:00:07,260 --> 01:00:09,330
我是不是想要把这个链条给断掉

1433
01:00:10,130 --> 01:00:11,570
只要我不恶一

1434
01:00:11,570 --> 01:00:13,460
我只要不依赖他不就完事儿了吗

1435
01:00:13,580 --> 01:00:15,200
是不是我只要不依赖他就完事儿

1436
01:00:16,060 --> 01:00:20,020
不一样就完事儿这种一般第一种方法就是

1437
01:00:20,560 --> 01:00:22,810
这种应该就只能通过用use rid了

1438
01:00:23,200 --> 01:00:23,650
比如

1439
01:00:24,340 --> 01:00:25,450
比如写一个riff

1440
01:00:25,540 --> 01:00:27,220
对一个riff我刚入

1441
01:00:27,220 --> 01:00:28,330
我给大家讲if

1442
01:00:29,140 --> 01:00:35,410
他可以在他在那个hooks里可以使用react的riff

1443
01:00:35,500 --> 01:00:36,910
就是可以使用if

1444
01:00:36,970 --> 01:00:41,140
同时也可以把它当做一个当做一个变量来时

1445
01:00:41,380 --> 01:00:42,460
可以把它当做一个变量来

1446
01:00:42,460 --> 01:00:46,480
是因为rift的变化并不会引发大家注意

1447
01:00:46,920 --> 01:00:47,130
可以

1448
01:00:47,130 --> 01:00:49,320
之所以可以把它用这种方式来做的原因是

1449
01:00:49,320 --> 01:00:52,020
Rough的变化并不会引发你的整个

1450
01:00:52,530 --> 01:00:54,300
并不会引发一次更新

1451
01:00:54,810 --> 01:00:55,740
他变了就变了

1452
01:00:56,500 --> 01:00:59,230
不会造成你的这个组件又重新render

1453
01:00:59,740 --> 01:01:00,760
那么你可以把它

1454
01:01:00,790 --> 01:01:02,800
比如你可以把它放在屋里

1455
01:01:06,860 --> 01:01:09,020
你可以把它放到roughly或者说

1456
01:01:09,020 --> 01:01:11,720
你这个如果说你内容变化你要实时更新的话

1457
01:01:12,050 --> 01:01:12,830
那么你可以

1458
01:01:14,270 --> 01:01:16,640
rift.charon to点亮

1459
01:01:17,390 --> 01:01:19,460
等于等你你判断的时候

1460
01:01:19,760 --> 01:01:21,800
你就不用这个这个来判断

1461
01:01:21,800 --> 01:01:22,700
你用ref来判断

1462
01:01:23,580 --> 01:01:24,480
用F来判断

1463
01:01:24,720 --> 01:01:25,530
那么你这个

1464
01:01:26,430 --> 01:01:27,990
链条就一下子就解开了

1465
01:01:28,470 --> 01:01:29,520
就一下子就解开了

1466
01:01:30,410 --> 01:01:32,090
通过rift因为rift的变更

1467
01:01:33,020 --> 01:01:34,460
并不会引起

1468
01:01:35,120 --> 01:01:36,080
那假如你这

1469
01:01:39,050 --> 01:01:39,410
对吧

1470
01:01:40,820 --> 01:01:42,080
这样子就是一个完整的

1471
01:01:42,140 --> 01:01:44,300
你的ref变化了也没关系

1472
01:01:44,660 --> 01:01:48,260
他并不会引起你的整个逐渐的重新变化

1473
01:01:48,260 --> 01:01:50,120
而且瑞否则也是不需要放在

1474
01:01:50,700 --> 01:01:52,830
一般的情况下是不需要放在你的

1475
01:01:52,830 --> 01:01:53,850
这个依赖是图中的

1476
01:01:54,090 --> 01:01:56,100
不用他能够拿到最新的值

1477
01:01:56,840 --> 01:01:57,590
通过内服

1478
01:01:58,280 --> 01:02:00,800
是解决这种这种

1479
01:02:01,910 --> 01:02:06,770
死循环的一个最通常的一种通常的一种解法就是

1480
01:02:08,550 --> 01:02:09,300
对对

1481
01:02:09,300 --> 01:02:10,260
在hooks当中

1482
01:02:10,260 --> 01:02:12,480
Riff可以不放在down上

1483
01:02:12,510 --> 01:02:13,320
你就可以把它

1484
01:02:13,900 --> 01:02:14,800
当做一个

1485
01:02:15,040 --> 01:02:17,830
你可以把它当作一个类似于全局变量这样的玩意儿

1486
01:02:23,980 --> 01:02:26,665
但是hooks里面是这么这么用是可以的

1487
01:02:26,665 --> 01:02:27,250
是可以的

1488
01:02:27,900 --> 01:02:28,320
当然

1489
01:02:28,500 --> 01:02:29,670
它也可以放在档上

1490
01:02:31,800 --> 01:02:32,790
他也可以看得到了

1491
01:02:34,560 --> 01:02:34,920
嗯

1492
01:02:36,340 --> 01:02:36,580
对

1493
01:02:36,580 --> 01:02:37,960
Rift and is可以

1494
01:02:37,960 --> 01:02:38,950
对是这个意思

1495
01:02:40,300 --> 01:02:41,050
是这个意思

1496
01:02:43,250 --> 01:02:45,560
死循环大概就是这样的写法

1497
01:02:45,620 --> 01:02:47,390
我刚刚说还有另外一个方式呢

1498
01:02:47,690 --> 01:02:48,800
可能用到的

1499
01:02:50,530 --> 01:02:51,850
没有这个没有这个

1500
01:02:52,450 --> 01:02:55,510
没有瑞福这个方式用的这么广泛

1501
01:02:55,840 --> 01:02:57,220
没有她用的这么广泛

1502
01:02:57,220 --> 01:02:58,510
我们可以再举另外一个例子

1503
01:02:58,510 --> 01:03:01,030
比如use effect

1504
01:03:04,850 --> 01:03:05,480
类似啊

1505
01:03:05,480 --> 01:03:06,290
叫做还是name

1506
01:03:06,770 --> 01:03:08,840
然后再判断了name

1507
01:03:10,550 --> 01:03:12,320
等于等于什么

1508
01:03:13,240 --> 01:03:13,750
然后呢

1509
01:03:13,750 --> 01:03:15,460
我要如果它等于了什么

1510
01:03:15,460 --> 01:03:16,840
我要重新设的这个类

1511
01:03:17,960 --> 01:03:19,070
我要重新设置这个

1512
01:03:19,430 --> 01:03:20,420
假如这种情况

1513
01:03:21,670 --> 01:03:24,190
这种简单的那么定

1514
01:03:24,190 --> 01:03:26,020
再重新定义一个rift的值

1515
01:03:26,080 --> 01:03:27,640
就有点儿就是有点儿

1516
01:03:29,740 --> 01:03:30,580
大材小用了

1517
01:03:30,700 --> 01:03:31,390
大材小用

1518
01:03:31,390 --> 01:03:33,460
因为我们可以用C的name就完全可以解决

1519
01:03:33,490 --> 01:03:34,150
怎么解决呢

1520
01:03:34,420 --> 01:03:36,190
就是通过传递一个方法的形式

1521
01:03:36,580 --> 01:03:38,410
我直接通过传递一个方法

1522
01:03:39,280 --> 01:03:39,910
然后呢

1523
01:03:40,910 --> 01:03:41,360
嗯

1524
01:03:42,030 --> 01:03:42,720
衣服

1525
01:03:49,420 --> 01:03:52,000
等于一灯

1526
01:03:53,980 --> 01:03:54,610
飞机灯

1527
01:03:54,850 --> 01:03:55,450
然后呢

1528
01:03:56,320 --> 01:03:57,070
就是

1529
01:03:57,070 --> 01:03:58,000
加一个什么

1530
01:03:59,170 --> 01:04:01,600
什么2022随便加个

1531
01:04:07,560 --> 01:04:08,880
事故给大家拉出来

1532
01:04:10,760 --> 01:04:11,600
做一个区分

1533
01:04:16,340 --> 01:04:17,360
就这两种写法

1534
01:04:17,780 --> 01:04:19,340
假如是一种比较简单的场景

1535
01:04:19,340 --> 01:04:20,360
这这肯定有的

1536
01:04:20,360 --> 01:04:21,500
这种场景是肯定存在的

1537
01:04:21,620 --> 01:04:22,580
我就遇到过很多次

1538
01:04:24,660 --> 01:04:25,710
本来这样很简单

1539
01:04:25,710 --> 01:04:27,810
就是判断它有一种特殊场景的时候

1540
01:04:28,140 --> 01:04:29,370
我需要给他加个东西

1541
01:04:29,760 --> 01:04:30,120
对吧

1542
01:04:32,100 --> 01:04:33,150
逻辑就这么简单

1543
01:04:33,480 --> 01:04:35,550
但是这因为要依赖一个

1544
01:04:35,550 --> 01:04:36,660
依赖它的内部的变化

1545
01:04:36,660 --> 01:04:38,010
不能娶不到最新的值

1546
01:04:38,430 --> 01:04:40,050
所以导致一个死循环

1547
01:04:40,380 --> 01:04:42,990
导致一个死循环你你会发现代码会被卡死

1548
01:04:43,730 --> 01:04:46,370
而这里大家看我的依赖并没有

1549
01:04:46,370 --> 01:04:47,930
我并没有把name传进去

1550
01:04:48,200 --> 01:04:49,940
那我name怎么拿到最新的值呢

1551
01:04:50,330 --> 01:04:52,670
就是在CD name这个方法的

1552
01:04:52,700 --> 01:04:54,110
我传给他这个方法中

1553
01:04:54,720 --> 01:04:56,430
他会给你填充这种

1554
01:04:56,460 --> 01:04:57,960
他会给你默认填充一个值

1555
01:04:57,960 --> 01:04:59,670
而这个值就是这个name

1556
01:05:00,120 --> 01:05:03,420
所以我在他的这个C的name的方法里方法其中

1557
01:05:04,110 --> 01:05:05,490
可以做到这样的一件事情

1558
01:05:05,910 --> 01:05:07,500
那这就sorry

1559
01:05:07,500 --> 01:05:08,010
这就

1560
01:05:08,690 --> 01:05:09,830
这直接就是return

1561
01:05:10,130 --> 01:05:11,780
这里面肯定不能再调一次

1562
01:05:11,780 --> 01:05:13,670
就那个直接就是return

1563
01:05:17,540 --> 01:05:18,470
这种也是可以的

1564
01:05:18,470 --> 01:05:19,040
但是呢

1565
01:05:19,100 --> 01:05:22,040
它的场景是用并没有瑞福那么多

1566
01:05:22,280 --> 01:05:23,210
如果你不会这种

1567
01:05:23,210 --> 01:05:24,830
那么你掌握瑞福一种也就够了

1568
01:05:26,250 --> 01:05:26,760
能理解吗

1569
01:05:26,760 --> 01:05:27,780
能理解可以各一

1570
01:05:28,820 --> 01:05:29,810
让你姐开个呢

1571
01:05:38,340 --> 01:05:38,670
OK

1572
01:05:38,670 --> 01:05:39,150
好

1573
01:05:40,160 --> 01:05:40,460
好

1574
01:05:40,460 --> 01:05:41,060
下面

1575
01:05:42,000 --> 01:05:43,110
这个

1576
01:05:43,770 --> 01:05:45,780
使循环对循环也是

1577
01:05:47,360 --> 01:05:48,290
经常遇到的

1578
01:05:48,320 --> 01:05:49,190
经常遇到的问题

1579
01:05:49,190 --> 01:05:51,590
我们九点了休息五分钟吧

1580
01:05:51,590 --> 01:05:52,460
09:05的时候继续

1581
01:05:53,180 --> 01:05:54,350
大家可以去喝点水

1582
01:10:41,010 --> 01:10:41,430
好了

1583
01:10:41,820 --> 01:10:43,080
同学们都回来了吗

1584
01:10:43,140 --> 01:10:44,790
我们继续看下一个问题吧

1585
01:10:45,870 --> 01:10:47,790
进度好像有点慢

1586
01:10:50,250 --> 01:10:50,850
这个急了

1587
01:10:50,850 --> 01:10:52,230
我们就可以来看源码了

1588
01:10:52,800 --> 01:10:54,630
这个锁完了就来看源码

1589
01:10:55,080 --> 01:10:59,580
Capture value capture value一开始也是REC hooks所怎么说呢

1590
01:10:59,610 --> 01:11:00,630
带来的一个问题

1591
01:11:00,960 --> 01:11:01,650
我们可以

1592
01:11:02,530 --> 01:11:03,760
也是大概的

1593
01:11:05,520 --> 01:11:06,690
大概的演示一下

1594
01:11:09,140 --> 01:11:10,190
其实这应该是

1595
01:11:16,170 --> 01:11:17,940
稍等稍等

1596
01:11:19,910 --> 01:11:20,630
这是金

1597
01:11:20,630 --> 01:11:21,680
是上节课

1598
01:11:22,440 --> 01:11:23,280
上一个信

1599
01:11:44,050 --> 01:11:45,130
那就把拷过来吧

1600
01:11:58,230 --> 01:12:00,240
比如这个

1601
01:12:06,500 --> 01:12:07,760
是不是把答案都写

1602
01:12:07,760 --> 01:12:08,570
都写出来

1603
01:12:10,760 --> 01:12:11,870
什么是开票value

1604
01:12:12,020 --> 01:12:15,890
就是还是从一个问题还是一个问题给大家解说

1605
01:12:16,340 --> 01:12:17,030
大家解说

1606
01:12:17,600 --> 01:12:18,380
比如这个

1607
01:12:19,520 --> 01:12:20,090
a级吧

1608
01:12:20,240 --> 01:12:20,990
就是a级

1609
01:12:22,610 --> 01:12:24,230
然后背景

1610
01:12:29,170 --> 01:12:29,770
我这儿

1611
01:12:29,830 --> 01:12:35,500
假如我在这里赛特埃及埃及加一对吧

1612
01:12:35,770 --> 01:12:37,210
我一看刚开始是零吗

1613
01:12:38,740 --> 01:12:39,490
看看是他

1614
01:12:47,580 --> 01:12:49,950
一开始假如四个零四个零

1615
01:12:49,950 --> 01:12:50,550
然后再

1616
01:12:51,320 --> 01:12:52,490
点这个方法的时候

1617
01:12:52,790 --> 01:12:54,380
那么给他先加个一

1618
01:12:55,560 --> 01:12:56,280
加一

1619
01:12:57,810 --> 01:12:59,100
那么再过三秒

1620
01:12:59,100 --> 01:13:01,230
C33他猫的三秒之后

1621
01:13:01,710 --> 01:13:03,420
然后打印这个a的值

1622
01:13:03,810 --> 01:13:05,550
打印这个a的值会是多少

1623
01:13:07,690 --> 01:13:08,590
大约会是多少

1624
01:13:09,280 --> 01:13:10,210
三秒后打印出来

1625
01:13:10,210 --> 01:13:11,440
这个a的值会是多少

1626
01:13:12,200 --> 01:13:14,120
大家可以给一下答案

1627
01:13:23,940 --> 01:13:25,380
三为啥子撒

1628
01:13:27,330 --> 01:13:27,960
还有吗

1629
01:13:30,120 --> 01:13:33,570
就正常就觉得大家第一第一眼觉得是什么就是什么

1630
01:13:43,260 --> 01:13:45,150
0123我肯定只有一个值

1631
01:13:47,930 --> 01:13:48,320
好吧

1632
01:13:50,460 --> 01:13:53,370
正确答案是零正确答案是零

1633
01:13:54,640 --> 01:13:56,260
这个为什么是你

1634
01:13:56,260 --> 01:13:58,360
因为你的埃及

1635
01:13:59,230 --> 01:14:00,940
这个就是所谓的capture value了

1636
01:14:01,600 --> 01:14:05,590
开了字面意思就是什么

1637
01:14:06,360 --> 01:14:08,550
快照变量快照变量

1638
01:14:09,200 --> 01:14:10,670
我来给大家解释一下

1639
01:14:10,970 --> 01:14:11,990
发生了什么事情

1640
01:14:12,020 --> 01:14:12,950
为什么会是零

1641
01:14:13,220 --> 01:14:15,440
大家觉得可能是怎么都都该是个一

1642
01:14:15,440 --> 01:14:15,950
对不对

1643
01:14:16,070 --> 01:14:18,710
如果按照在class component里面的经验

1644
01:14:18,710 --> 01:14:19,220
他怎么了

1645
01:14:19,220 --> 01:14:20,030
这个是个一

1646
01:14:21,050 --> 01:14:24,320
但实际上这个零原因是在

1647
01:14:25,080 --> 01:14:26,880
进行这个u SCO back的时候

1648
01:14:27,750 --> 01:14:28,500
我给大家

1649
01:14:30,300 --> 01:14:31,080
来理一遍

1650
01:14:31,080 --> 01:14:32,760
理一遍再account

1651
01:14:33,390 --> 01:14:34,290
点击APP的时候

1652
01:14:34,290 --> 01:14:37,410
假如一开始aid ma是零点几的CAD的时候

1653
01:14:37,830 --> 01:14:40,290
那么首先掉了一个C的age

1654
01:14:40,410 --> 01:14:40,770
对不对

1655
01:14:40,830 --> 01:14:41,760
掉了一个age

1656
01:14:42,350 --> 01:14:44,090
调了这个C的age之后

1657
01:14:45,090 --> 01:14:46,560
然后掉了一个set timeout

1658
01:14:46,800 --> 01:14:49,590
而这个system out13秒钟之后才执行的

1659
01:14:50,280 --> 01:14:51,450
我这个C的age

1660
01:14:51,720 --> 01:14:53,490
他实际上是发起了一次更新

1661
01:14:53,520 --> 01:14:54,270
大家理解吧

1662
01:14:54,420 --> 01:14:56,130
大家和class函数

1663
01:14:56,550 --> 01:14:59,490
Class函数里调用CS的是一样的

1664
01:14:59,490 --> 01:15:00,390
发起一次更新

1665
01:15:00,660 --> 01:15:02,250
而我这次更新之后

1666
01:15:02,250 --> 01:15:05,190
可能他时他的时间应该还没有三秒

1667
01:15:05,800 --> 01:15:06,940
他发起更新的时间

1668
01:15:06,940 --> 01:15:09,310
一直到他渲染完都没不会有三秒对不对

1669
01:15:09,340 --> 01:15:11,440
一般我们我们的经验是这样子

1670
01:15:12,540 --> 01:15:14,730
然后他发起一次更新之后

1671
01:15:15,840 --> 01:15:17,070
他发几次更新之后

1672
01:15:19,350 --> 01:15:20,040
他就会

1673
01:15:20,800 --> 01:15:23,740
走到我们白天所讲到的那些流程上去

1674
01:15:23,740 --> 01:15:25,480
叫做

1675
01:15:25,750 --> 01:15:26,140
对吧

1676
01:15:26,650 --> 01:15:28,390
Schedule or对不对

1677
01:15:28,420 --> 01:15:30,700
然后再re consider里面的begin work里

1678
01:15:31,030 --> 01:15:32,590
他又重新把这个函数

1679
01:15:33,310 --> 01:15:35,320
他又重新把这个函数给创建了

1680
01:15:35,710 --> 01:15:37,240
这个函数重新被render了

1681
01:15:37,270 --> 01:15:38,080
被执行掉

1682
01:15:38,110 --> 01:15:38,770
被执行了

1683
01:15:39,370 --> 01:15:40,600
被执行了之后

1684
01:15:42,190 --> 01:15:43,000
被执行了之后

1685
01:15:43,000 --> 01:15:44,260
因为a级变化了

1686
01:15:44,920 --> 01:15:45,340
同学们

1687
01:15:45,340 --> 01:15:46,630
我们的变化了对不对

1688
01:15:47,080 --> 01:15:48,010
A级变化了

1689
01:15:48,160 --> 01:15:52,510
那么我们的这个account他就变成了一个新的函数

1690
01:15:53,210 --> 01:15:53,540
是不是

1691
01:15:53,540 --> 01:15:55,100
是不是一个新的函数儿

1692
01:15:55,100 --> 01:15:57,110
这个cmos恶心的函数

1693
01:15:57,110 --> 01:15:59,660
同样一个三毛儿

1694
01:15:59,660 --> 01:16:00,800
变成了新的函数之后

1695
01:16:00,800 --> 01:16:04,430
我们整个整个组件也就全部更新到页面上了

1696
01:16:06,700 --> 01:16:07,450
不要着急嘛

1697
01:16:07,510 --> 01:16:09,160
整个组件也更新到页面上了

1698
01:16:09,490 --> 01:16:10,060
但是

1699
01:16:11,120 --> 01:16:13,400
按理说旧的旧的这个

1700
01:16:13,430 --> 01:16:16,070
因为我们ad现在是一个新的函数了

1701
01:16:16,430 --> 01:16:17,090
大家理解吧

1702
01:16:17,180 --> 01:16:18,350
ADD是一个新的函数

1703
01:16:18,770 --> 01:16:21,350
就是函数按理说应该要被销毁掉

1704
01:16:22,330 --> 01:16:24,790
就的函数应该按理说是要被销毁掉的

1705
01:16:25,420 --> 01:16:28,210
可是由于我们的system out的存在

1706
01:16:28,210 --> 01:16:29,410
它一直把这个

1707
01:16:29,560 --> 01:16:33,370
他一直是把这个里面的a级变量是持有的

1708
01:16:33,490 --> 01:16:35,920
他持有的这个内内存变量

1709
01:16:36,540 --> 01:16:38,610
形成了一个臂包对形成了一个臂包

1710
01:16:38,940 --> 01:16:39,660
所以

1711
01:16:40,640 --> 01:16:46,040
所以在老的老的这个account并没有当时并没有立刻把他给杀掉

1712
01:16:46,280 --> 01:16:48,860
而这个是他特MT持有的这个B包

1713
01:16:48,860 --> 01:16:50,090
还是之前的那个

1714
01:16:51,190 --> 01:16:54,580
A等于零的那个a级已经不是这个新的APP了

1715
01:16:54,940 --> 01:16:56,770
所以这个a级永远是零

1716
01:16:57,500 --> 01:16:58,370
大家能理解吗

1717
01:17:00,480 --> 01:17:01,680
能理解的可以各一

1718
01:17:01,860 --> 01:17:02,850
理解可以零

1719
01:17:11,640 --> 01:17:19,770
两者两者区别在所以所以这个情况它实际上它的影响它的原因是闭包是闭包

1720
01:17:19,980 --> 01:17:23,700
可是可是由于直接在hooks中间有这个问题

1721
01:17:24,090 --> 01:17:24,930
空间有这个问题

1722
01:17:24,930 --> 01:17:27,750
所以所以官方把它命名为一个名字叫做kept

1723
01:17:27,750 --> 01:17:29,610
就是快到变量你的这个

1724
01:17:29,610 --> 01:17:31,110
你就算再有spike里

1725
01:17:31,470 --> 01:17:32,430
在APP里

1726
01:17:32,430 --> 01:17:33,990
你无论赛他妈的怎样

1727
01:17:33,990 --> 01:17:34,590
System out

1728
01:17:35,770 --> 01:17:37,000
输了他妈的多久

1729
01:17:37,030 --> 01:17:38,470
你的这个a级永远不会变

1730
01:17:38,470 --> 01:17:39,940
因为你刷新了之后

1731
01:17:40,300 --> 01:17:42,220
你的这个心已经是一个新的东西了

1732
01:17:42,400 --> 01:17:43,630
已经是一个新的函数了

1733
01:17:43,720 --> 01:17:44,980
你这个旧的函数的值

1734
01:17:45,010 --> 01:17:45,730
它保存着

1735
01:17:46,270 --> 01:17:49,720
他所用的这个APP还永远是老的那个a级

1736
01:17:49,840 --> 01:17:51,490
而不是新的那个a级

1737
01:17:52,830 --> 01:17:54,570
所以它叫做快照变量

1738
01:17:54,750 --> 01:17:56,550
叫做capture capture变量

1739
01:17:57,390 --> 01:17:58,200
对这个意思

1740
01:17:58,680 --> 01:18:03,630
这一次就是官方就是官网里边儿其实也老也讲过这个问题

1741
01:18:03,660 --> 01:18:05,100
也讲讲讲过这个问题

1742
01:18:05,460 --> 01:18:06,840
那怎么解决这个问题呢

1743
01:18:07,460 --> 01:18:08,360
怎么解决这个问题

1744
01:18:08,360 --> 01:18:09,410
其实也是通过riff

1745
01:18:09,680 --> 01:18:11,540
因为riff是不受这样的限制

1746
01:18:13,220 --> 01:18:14,870
比如这个riff对吧

1747
01:18:14,900 --> 01:18:17,990
你就瑞府里面所以热

1748
01:18:17,990 --> 01:18:19,160
你就感觉他是一个

1749
01:18:20,060 --> 01:18:20,780
很多时候

1750
01:18:21,290 --> 01:18:24,080
很多时候什么你感觉出现了大问题

1751
01:18:24,080 --> 01:18:26,300
你就用ref Le你就用riff

1752
01:18:26,720 --> 01:18:27,530
你会发现

1753
01:18:27,530 --> 01:18:28,070
非常好

1754
01:18:28,220 --> 01:18:28,970
非常好解决

1755
01:18:29,770 --> 01:18:30,820
Billionaire if

1756
01:18:32,550 --> 01:18:33,900
你如果一定要这么死

1757
01:18:34,650 --> 01:18:35,580
也是能死的

1758
01:18:39,350 --> 01:18:39,560
对

1759
01:18:39,560 --> 01:18:40,520
平面也行

1760
01:18:40,550 --> 01:18:41,570
快走也可以解决

1761
01:18:42,020 --> 01:18:42,710
你用riff

1762
01:18:44,170 --> 01:18:45,550
这他就变成一

1763
01:18:46,120 --> 01:18:46,930
它就变成一

1764
01:18:46,990 --> 01:18:47,710
就没这问题了

1765
01:18:48,370 --> 01:18:49,780
那么有同学就问了

1766
01:18:49,930 --> 01:18:52,450
只有胡才有吗

1767
01:18:52,450 --> 01:18:53,380
其实就是闭包

1768
01:18:53,710 --> 01:18:56,200
但是在class component里它不会存在这个问题

1769
01:18:56,200 --> 01:18:58,360
大家在class component里从来没遇到过

1770
01:18:58,360 --> 01:18:58,750
对不对

1771
01:18:59,280 --> 01:19:01,170
S e class component里有this

1772
01:19:01,440 --> 01:19:04,350
他有this这个东西我们所有的state都保存在地上的

1773
01:19:05,050 --> 01:19:06,010
所以他不会丢

1774
01:19:06,070 --> 01:19:06,790
他不会丢

1775
01:19:07,180 --> 01:19:10,180
但是函数逐渐的他一个函数一个坑

1776
01:19:10,540 --> 01:19:11,350
韩束一变

1777
01:19:11,740 --> 01:19:13,330
那么它内存自然就变了

1778
01:19:14,130 --> 01:19:15,420
内存地址都不一样了

1779
01:19:16,380 --> 01:19:17,310
是的是的

1780
01:19:17,310 --> 01:19:18,750
这就是cap

1781
01:19:18,750 --> 01:19:20,820
所谓capture value其实就是这个样子

1782
01:19:22,300 --> 01:19:23,740
如果说

1783
01:19:23,740 --> 01:19:26,260
那个什么面试官可能会老会这么问题

1784
01:19:26,290 --> 01:19:30,220
你在用hosts里面有没有遇到一些让你比较印象深刻的问题

1785
01:19:30,800 --> 01:19:32,150
你就在

1786
01:19:32,150 --> 01:19:33,560
看这俩打一个

1787
01:19:35,050 --> 01:19:35,800
然后呢

1788
01:19:35,860 --> 01:19:37,810
紫郡华达一个

1789
01:19:38,380 --> 01:19:40,510
然后那个我们的那个

1790
01:19:41,260 --> 01:19:43,090
A regular member he used back

1791
01:19:43,480 --> 01:19:45,070
这个来用它来作

1792
01:19:45,280 --> 01:19:49,690
用它来做钱比较打一个基本上答完了之后

1793
01:19:50,550 --> 01:19:51,540
基本上答完了之后

1794
01:19:51,540 --> 01:19:55,860
问题就是基本上就挺比较过关了

1795
01:19:55,860 --> 01:19:57,240
比较过关老师

1796
01:19:57,240 --> 01:19:59,400
这个不相当于一个局部的臂包吗

1797
01:19:59,910 --> 01:20:00,240
是啊

1798
01:20:00,240 --> 01:20:01,320
我就说他是闭包

1799
01:20:03,420 --> 01:20:05,160
是不是hooks欠的太多

1800
01:20:08,140 --> 01:20:08,560
什么意思

1801
01:20:08,620 --> 01:20:09,700
Whose欠的太多

1802
01:20:09,700 --> 01:20:11,830
闭包也会很多

1803
01:20:12,520 --> 01:20:13,480
那如何优化

1804
01:20:14,520 --> 01:20:16,380
那如果他调完了之后

1805
01:20:19,030 --> 01:20:20,500
三秒之后

1806
01:20:20,500 --> 01:20:22,150
他现在这个B包之所以存在

1807
01:20:22,150 --> 01:20:23,950
是因为他妈的他持有了吗

1808
01:20:24,990 --> 01:20:25,650
大家能理解吗

1809
01:20:25,710 --> 01:20:27,720
原本的如果没有在他们的这个东西

1810
01:20:28,170 --> 01:20:29,640
他肯定会被销毁掉

1811
01:20:29,760 --> 01:20:31,020
就比如说如果你没有他

1812
01:20:32,100 --> 01:20:33,120
如果你没有他

1813
01:20:34,170 --> 01:20:36,090
那么他的GC就是把这个回收的

1814
01:20:36,880 --> 01:20:37,840
如果没有这个

1815
01:20:38,140 --> 01:20:40,570
就算是比如发起了一次C的age

1816
01:20:40,690 --> 01:20:41,110
对吧

1817
01:20:41,200 --> 01:20:42,430
发起了一次次的age

1818
01:20:43,740 --> 01:20:44,760
他是age

1819
01:20:44,970 --> 01:20:47,010
那么重新render之后

1820
01:20:47,160 --> 01:20:49,890
我们的我们的account变成了一个新的函数

1821
01:20:50,310 --> 01:20:52,830
那么这个函数因为已经没有持有了吗

1822
01:20:53,100 --> 01:20:55,590
他后面自然就会被JC给回收掉

1823
01:20:55,800 --> 01:20:58,440
因为它的引用技术已经清零了

1824
01:20:59,010 --> 01:21:00,660
同学乙用激素它已经没了

1825
01:21:01,620 --> 01:21:05,760
这只所以它存在这个背包是他mote这个东西存在吗

1826
01:21:05,760 --> 01:21:07,980
它这个功能还还在

1827
01:21:08,040 --> 01:21:10,200
还一直把他持有的

1828
01:21:11,580 --> 01:21:13,050
所以说这个变量

1829
01:21:13,350 --> 01:21:17,730
所以就导致就导致他的这个方法也被持有了

1830
01:21:17,760 --> 01:21:19,800
就是也也没有办法被销毁掉

1831
01:21:20,190 --> 01:21:22,200
那当他调完了之后

1832
01:21:22,870 --> 01:21:23,890
帮他调完了之后

1833
01:21:23,890 --> 01:21:25,210
那么就没有地方在

1834
01:21:25,210 --> 01:21:25,810
只有他了

1835
01:21:25,810 --> 01:21:28,900
他后面还是会那么的GC可能不会立刻

1836
01:21:29,110 --> 01:21:29,590
但是呢

1837
01:21:29,620 --> 01:21:31,030
下一次就把他给干掉了

1838
01:21:34,700 --> 01:21:35,030
对吧

1839
01:21:35,090 --> 01:21:35,750
没问题了吧

1840
01:21:35,750 --> 01:21:36,170
这块儿

1841
01:21:43,520 --> 01:21:45,200
如果有多个遍

1842
01:21:45,230 --> 01:21:46,430
你写多个就好了吧

1843
01:21:47,990 --> 01:21:49,160
写多个就好了吗

1844
01:21:55,120 --> 01:21:57,400
每一个hooks都可以定义多个同学

1845
01:21:58,420 --> 01:21:59,800
你定义N个都行

1846
01:21:59,800 --> 01:22:01,480
你自己随便命个名吧

1847
01:22:01,720 --> 01:22:02,080
对吧

1848
01:22:02,080 --> 01:22:03,100
AA级

1849
01:22:04,260 --> 01:22:05,010
妹妹啊

1850
01:22:05,160 --> 01:22:06,810
你随便秘密就行了

1851
01:22:07,950 --> 01:22:09,630
都每个都可以定义很多个了

1852
01:22:10,260 --> 01:22:14,550
只是他要求你一定要在一定要在函数组件的头部定义就行

1853
01:22:19,730 --> 01:22:20,120
好

1854
01:22:20,600 --> 01:22:21,320
大概

1855
01:22:22,030 --> 01:22:23,590
大概就是hooks的

1856
01:22:23,590 --> 01:22:24,130
怎么算

1857
01:22:24,780 --> 01:22:26,790
用法我们就先讲到这么多

1858
01:22:26,970 --> 01:22:27,840
就先讲了这么多

1859
01:22:27,840 --> 01:22:29,130
其实

1860
01:22:29,130 --> 01:22:31,410
来面对一般的利润

1861
01:22:31,410 --> 01:22:32,730
一般那个问护士的问题

1862
01:22:32,730 --> 01:22:33,930
其实也都已经够了

1863
01:22:33,960 --> 01:22:34,350
已经够了

1864
01:22:34,350 --> 01:22:34,980
接下来的话

1865
01:22:35,130 --> 01:22:40,140
我们才才要开始正式的进入我们的那个圆满的一个

1866
01:22:40,870 --> 01:22:41,860
简单的分析了

1867
01:22:42,780 --> 01:22:44,100
原版那个简单的分析

1868
01:22:45,170 --> 01:22:46,580
我们来看一下

1869
01:22:46,700 --> 01:22:48,740
如果要简版的实现一个

1870
01:22:50,010 --> 01:22:51,570
简版的实现一个use date

1871
01:22:51,690 --> 01:22:53,790
我们回顾一下use什么功能

1872
01:22:53,820 --> 01:22:56,070
首先它接受一个值

1873
01:22:56,160 --> 01:22:56,430
对吧

1874
01:22:56,430 --> 01:22:57,330
接受一个参数

1875
01:22:57,630 --> 01:22:58,830
它返回了两个值

1876
01:22:58,860 --> 01:23:00,120
一个是变量

1877
01:23:00,330 --> 01:23:03,000
另外一个是更改变量的方法

1878
01:23:03,360 --> 01:23:05,340
那么如果要写一个非常非常简短的

1879
01:23:05,340 --> 01:23:06,090
如果不依

1880
01:23:06,120 --> 01:23:08,100
不把他给挂载在

1881
01:23:08,970 --> 01:23:10,680
REC的就是

1882
01:23:11,280 --> 01:23:13,230
Black的那个整体架构之上

1883
01:23:13,590 --> 01:23:14,910
那么其实很简单

1884
01:23:15,060 --> 01:23:15,360
对

1885
01:23:15,450 --> 01:23:16,380
逻辑非常简单

1886
01:23:16,440 --> 01:23:18,780
秘密秘密一个全局变量

1887
01:23:19,880 --> 01:23:20,630
秘密的钱

1888
01:23:20,630 --> 01:23:21,560
这也不是全局变量

1889
01:23:21,590 --> 01:23:22,970
秘密一个外部的臂包吗

1890
01:23:23,600 --> 01:23:24,470
外部的一个变量

1891
01:23:24,800 --> 01:23:25,220
然后呢

1892
01:23:25,220 --> 01:23:26,390
通过use date

1893
01:23:27,290 --> 01:23:29,840
这就是这就传进一个默认的值

1894
01:23:30,200 --> 01:23:30,740
然后呢

1895
01:23:31,340 --> 01:23:33,590
如果这个值不存在的时候

1896
01:23:34,400 --> 01:23:35,390
就是C的不存在的

1897
01:23:35,390 --> 01:23:36,710
就是没有被复制过

1898
01:23:37,100 --> 01:23:38,270
就让它等于默认的字

1899
01:23:38,540 --> 01:23:39,200
否则

1900
01:23:40,410 --> 01:23:41,430
就等于芯子

1901
01:23:41,430 --> 01:23:42,540
就等于最新的值

1902
01:23:43,050 --> 01:23:44,970
然后这个stage就是更改他的

1903
01:23:45,540 --> 01:23:45,870
对不对

1904
01:23:46,110 --> 01:23:48,810
这有可能是这个schedule是什么呢

1905
01:23:48,930 --> 01:23:50,820
这个schedule是rock里边儿的

1906
01:23:50,820 --> 01:23:52,950
Rock里边儿它的更新一个词的时候

1907
01:23:52,950 --> 01:23:56,460
会需要他引引起整个

1908
01:23:57,290 --> 01:23:58,910
需要他引起一次更新

1909
01:23:59,210 --> 01:24:00,050
所以就会掉一次

1910
01:24:00,050 --> 01:24:01,910
schedule在这里是不需要的

1911
01:24:01,910 --> 01:24:03,830
我只是之前好像写写成这样

1912
01:24:04,640 --> 01:24:05,780
之前写成这个样子

1913
01:24:06,380 --> 01:24:09,590
那么这就是一个最简版的X的一个实现

1914
01:24:09,680 --> 01:24:10,220
但是呢

1915
01:24:10,730 --> 01:24:14,000
这个最简单的弧线真的是太简单了

1916
01:24:14,030 --> 01:24:14,630
原因是啥

1917
01:24:14,990 --> 01:24:17,300
第一它只能够在一个

1918
01:24:18,460 --> 01:24:19,270
函数的使用

1919
01:24:19,270 --> 01:24:21,400
而且只能定义一个X

1920
01:24:21,460 --> 01:24:22,120
大家看到没有

1921
01:24:22,480 --> 01:24:24,070
他此人定义一个state

1922
01:24:24,880 --> 01:24:26,290
因为它就只有一个值吗

1923
01:24:26,650 --> 01:24:28,510
所以这个实在太简陋了

1924
01:24:28,990 --> 01:24:30,280
如果我们想要给他

1925
01:24:31,330 --> 01:24:33,940
如果我们想要给他搞得稍微复杂一点点

1926
01:24:34,640 --> 01:24:35,930
搞得稍微复杂一点点

1927
01:24:37,110 --> 01:24:40,170
那么就需要把他的

1928
01:24:40,990 --> 01:24:44,530
状态堆和上下文堆在储存多个状态

1929
01:24:45,180 --> 01:24:47,880
来让多个函数都可以进行调用

1930
01:24:47,940 --> 01:24:49,770
就是要把这个扩展一下

1931
01:24:50,220 --> 01:24:52,770
那么就需要有一个上下文债的概念

1932
01:24:53,130 --> 01:24:54,660
为什么要用上下文债

1933
01:24:55,410 --> 01:24:58,560
其实在react它里边儿用的也是上下文件

1934
01:24:59,320 --> 01:25:03,850
但是他用的比较和和我们这个数组的方式不太一样

1935
01:25:03,850 --> 01:25:05,260
因为它原本是链表嘛

1936
01:25:05,680 --> 01:25:07,810
所以他只有他会再进入的时候

1937
01:25:08,200 --> 01:25:09,100
在record里

1938
01:25:09,520 --> 01:25:11,620
他在进入那个函数之前

1939
01:25:11,860 --> 01:25:14,320
我们刚刚我们白天的时候就讲过

1940
01:25:14,320 --> 01:25:16,120
他会他会注册hooks

1941
01:25:16,120 --> 01:25:16,735
对不对

1942
01:25:16,735 --> 01:25:19,660
在执行函数的函数体之前

1943
01:25:19,870 --> 01:25:22,120
他会先把hooks给他注册上

1944
01:25:23,160 --> 01:25:24,090
Hooks给他住

1945
01:25:24,150 --> 01:25:26,640
就是hooks的上下文先给他注册上

1946
01:25:27,090 --> 01:25:29,010
然后等函数执行完了之后

1947
01:25:29,040 --> 01:25:31,320
他又把那个上下文给他销毁掉

1948
01:25:31,590 --> 01:25:32,760
这其实也是一个

1949
01:25:33,620 --> 01:25:35,120
类似的一个上下文的堆栈

1950
01:25:35,540 --> 01:25:37,640
而他注册了一个上下文

1951
01:25:37,970 --> 01:25:40,100
就是当前要处理的那个fiber

1952
01:25:40,250 --> 01:25:41,570
就是我们这个是一样的

1953
01:25:41,960 --> 01:25:47,240
这儿的这个上下文对待就是你要处理的那个函数

1954
01:25:47,330 --> 01:25:49,370
它就会把它放到最后一个

1955
01:25:49,370 --> 01:25:50,930
放在速度的最后一个

1956
01:25:50,930 --> 01:25:52,100
我们可以轻易拿到

1957
01:25:53,600 --> 01:25:55,250
我们可以非常轻松的拿到它

1958
01:25:55,400 --> 01:25:56,870
他是第一个还是最后一个

1959
01:25:57,290 --> 01:25:59,030
所以这也是一个三角形的

1960
01:25:59,030 --> 01:25:59,930
如果有了它

1961
01:26:00,200 --> 01:26:00,650
那么

1962
01:26:01,250 --> 01:26:02,090
理论上来说

1963
01:26:02,090 --> 01:26:05,570
我们可以通过用visit的方式来给大家进行包裹

1964
01:26:07,010 --> 01:26:09,890
你看大家看我们这儿用with state

1965
01:26:10,280 --> 01:26:11,690
这儿这个方法用visit

1966
01:26:11,690 --> 01:26:14,930
就是就类似于我们在react那个源码中的

1967
01:26:15,550 --> 01:26:17,860
用源码中的注册hooks那个概念

1968
01:26:18,220 --> 01:26:20,890
它在调用真正的方法之前就是这个function

1969
01:26:21,500 --> 01:26:22,850
调用真正的方法之前

1970
01:26:23,150 --> 01:26:23,870
他先把他

1971
01:26:24,740 --> 01:26:26,510
他他先把当前的这个上下文

1972
01:26:27,020 --> 01:26:28,640
我们这个是states什么

1973
01:26:28,640 --> 01:26:31,850
当前这个函数的需要用的state

1974
01:26:32,300 --> 01:26:34,220
它当前的上下文给它压进去

1975
01:26:34,220 --> 01:26:34,610
对不对

1976
01:26:35,030 --> 01:26:38,630
然后当然后再执行执行他执行完了之后

1977
01:26:38,870 --> 01:26:39,980
再把它给弹出来

1978
01:26:40,690 --> 01:26:41,500
再把他扛起来

1979
01:26:41,530 --> 01:26:42,790
都是用这种方式

1980
01:26:42,940 --> 01:26:46,150
其实这个简版写法也是非常精妙的

1981
01:26:46,420 --> 01:26:48,490
对这个简版写法也是非常精妙的

1982
01:26:48,730 --> 01:26:49,420
一般来讲

1983
01:26:49,420 --> 01:26:53,260
如果说让你在十分钟之内让你把它copy

1984
01:26:53,560 --> 01:26:54,820
让你把它给敲出来

1985
01:26:55,120 --> 01:26:56,290
还是有一定难度的

1986
01:26:56,620 --> 01:26:57,760
还是有一定的难度的

1987
01:26:57,880 --> 01:26:58,840
我们可以来看一下

1988
01:26:59,340 --> 01:27:00,930
这个大体逻辑的话

1989
01:27:00,930 --> 01:27:02,400
其实

1990
01:27:02,400 --> 01:27:03,780
最要紧的其实就是这样

1991
01:27:03,780 --> 01:27:04,410
就是这个吗

1992
01:27:04,500 --> 01:27:06,030
Directly这样的写法

1993
01:27:06,660 --> 01:27:08,040
也给大家看了很多了

1994
01:27:08,370 --> 01:27:09,450
也给大家看了很多了

1995
01:27:09,930 --> 01:27:10,890
就比如那个啥

1996
01:27:11,500 --> 01:27:19,270
设置设置那个什么执行上下文QQ什么can cure a t con text对吧

1997
01:27:19,390 --> 01:27:22,540
设置执行三角纹也是这样设的

1998
01:27:22,900 --> 01:27:25,270
也是在调用他真实的方法之前

1999
01:27:25,780 --> 01:27:28,930
给它加上射完了之后给他干掉

2000
01:27:29,350 --> 01:27:30,400
给他干掉就是这样

2001
01:27:31,390 --> 01:27:33,700
这里visit state就是包裹的

2002
01:27:33,700 --> 01:27:35,830
我们调用的时候就用with state

2003
01:27:36,040 --> 01:27:36,880
如果想要在

2004
01:27:37,920 --> 01:27:38,850
这里面用hooks

2005
01:27:38,850 --> 01:27:40,200
我们就给他包裹一下

2006
01:27:40,410 --> 01:27:41,430
稍微包裹一下

2007
01:27:41,580 --> 01:27:43,200
那么他就可以使用use date了

2008
01:27:44,140 --> 01:27:45,910
那这里的方法

2009
01:27:47,750 --> 01:27:49,280
大家看就是因为有了这个

2010
01:27:49,370 --> 01:27:50,330
有了context

2011
01:27:50,780 --> 01:27:51,410
有了contact

2012
01:27:51,410 --> 01:27:53,060
所以他能够做到什么呢

2013
01:27:53,060 --> 01:27:54,470
能够做到支持

2014
01:27:55,510 --> 01:27:57,490
多就是多函数

2015
01:27:57,640 --> 01:27:59,020
多个函数都可以调

2016
01:27:59,470 --> 01:28:00,280
多个函数都可以调

2017
01:28:00,550 --> 01:28:02,440
这个state也给它更新了一下

2018
01:28:02,470 --> 01:28:04,030
上面的state只是一个什么

2019
01:28:04,480 --> 01:28:06,250
上面的这只是一个单个的值

2020
01:28:06,250 --> 01:28:07,780
所以只能定义一个state

2021
01:28:08,400 --> 01:28:09,060
这个state

2022
01:28:09,900 --> 01:28:11,370
这个state可以是一个对象

2023
01:28:11,370 --> 01:28:12,270
这是一个对象

2024
01:28:12,690 --> 01:28:14,970
那么他可以定义多个state

2025
01:28:15,510 --> 01:28:16,140
定义多个sit

2026
01:28:16,140 --> 01:28:18,540
那么通过这几行代码我们的

2027
01:28:19,360 --> 01:28:20,350
我们的单

2028
01:28:21,480 --> 01:28:24,390
就是多组件使用护士

2029
01:28:25,750 --> 01:28:26,380
还有

2030
01:28:27,130 --> 01:28:30,430
一个组件内使用多个hooks的功能就都实现了

2031
01:28:30,670 --> 01:28:34,600
大概我们可以来大致的大致的盘一盘

2032
01:28:34,810 --> 01:28:35,830
首先这个方形

2033
01:28:35,980 --> 01:28:37,180
大家看这个方式

2034
01:28:38,490 --> 01:28:40,530
肯定就是我们要用的函数组件

2035
01:28:40,980 --> 01:28:42,900
但是类似这个VC

2036
01:28:42,900 --> 01:28:44,130
它只是一个简版的

2037
01:28:44,780 --> 01:28:45,830
这个只是一个简版的

2038
01:28:45,830 --> 01:28:47,270
他并不是真正的实现

2039
01:28:47,300 --> 01:28:48,830
真正的实现我们待会还会看

2040
01:28:49,100 --> 01:28:50,270
还会看到真正的实现

2041
01:28:50,480 --> 01:28:53,930
但是我觉得这个展板的实现也非常的精妙

2042
01:28:54,710 --> 01:28:56,990
而且这个脚本的时间对于我们来说

2043
01:28:56,990 --> 01:28:58,400
要把它实现出来的话

2044
01:28:58,400 --> 01:29:00,290
也并没有特别困难

2045
01:29:00,290 --> 01:29:01,790
我们只需要了解他的逻辑

2046
01:29:02,210 --> 01:29:03,050
然后呢

2047
01:29:03,410 --> 01:29:04,580
然后呢把它给记住

2048
01:29:04,730 --> 01:29:06,140
后面自己也就能实现了

2049
01:29:06,750 --> 01:29:07,290
我们看

2050
01:29:08,850 --> 01:29:10,440
Wei to state

2051
01:29:10,440 --> 01:29:11,280
这有一个

2052
01:29:11,950 --> 01:29:12,160
对

2053
01:29:12,160 --> 01:29:13,060
UC的方法

2054
01:29:13,960 --> 01:29:14,650
这个方法

2055
01:29:15,870 --> 01:29:18,450
只有在包被包裹在VC的时候

2056
01:29:18,960 --> 01:29:20,310
里边的函数才能用

2057
01:29:20,340 --> 01:29:21,390
原因是为啥

2058
01:29:21,390 --> 01:29:24,780
原因是因为你只有被包裹在VCD里

2059
01:29:24,780 --> 01:29:25,740
你才有上下文

2060
01:29:26,190 --> 01:29:28,290
你如果没有上下文就不能调这个和

2061
01:29:28,910 --> 01:29:31,640
这个和react里真正的逻辑是一模一样的

2062
01:29:31,940 --> 01:29:33,620
你没有上下文你就调不了

2063
01:29:34,160 --> 01:29:35,330
所以他只有包裹起来

2064
01:29:35,690 --> 01:29:36,800
包裹起来做一件事情

2065
01:29:37,830 --> 01:29:40,830
好先把他先把3000给他压进去对不对

2066
01:29:41,480 --> 01:29:43,190
三下午给他压进去

2067
01:29:43,190 --> 01:29:45,740
进去之后他就有了一个空的state

2068
01:29:45,860 --> 01:29:47,540
大家看一个空的state

2069
01:29:47,540 --> 01:29:52,370
这个就类似于我们我们函数组件里的那个

2070
01:29:52,370 --> 01:29:57,650
储存储存hooks的那个链表链表他但这是一个对象

2071
01:29:58,240 --> 01:29:59,110
这是一个对象

2072
01:29:59,500 --> 01:30:01,060
这个对象可以帮助我们

2073
01:30:01,510 --> 01:30:02,650
可以帮助我们定义

2074
01:30:02,650 --> 01:30:04,420
我们定义多个stay的也没有问题

2075
01:30:05,060 --> 01:30:05,660
所以呀

2076
01:30:05,660 --> 01:30:07,040
进去的就是一个空的

2077
01:30:07,670 --> 01:30:08,690
一个空的一个对象

2078
01:30:08,690 --> 01:30:11,810
这就是来储存他的state的一个位置

2079
01:30:12,170 --> 01:30:13,940
然后我们再来用对不对

2080
01:30:13,940 --> 01:30:14,930
我传了一个默认值

2081
01:30:14,960 --> 01:30:16,970
这个和上面逻辑是一样的

2082
01:30:17,420 --> 01:30:19,220
然后拿到他的第一件事情

2083
01:30:19,220 --> 01:30:20,390
拿到它的上下文

2084
01:30:21,050 --> 01:30:22,250
拿到上下文

2085
01:30:22,550 --> 01:30:23,330
然后呢

2086
01:30:24,500 --> 01:30:27,080
如果第一个第一个state

2087
01:30:27,080 --> 01:30:27,800
那么这个

2088
01:30:28,460 --> 01:30:29,840
No就是number嘛

2089
01:30:29,840 --> 01:30:30,380
就是零

2090
01:30:30,380 --> 01:30:31,910
然后后面就一直加一直加

2091
01:30:32,270 --> 01:30:34,640
那么得到第一个值

2092
01:30:34,640 --> 01:30:37,160
它就是等于零是多少

2093
01:30:37,160 --> 01:30:38,210
STATE1是多少岁的

2094
01:30:38,210 --> 01:30:38,840
二是多少

2095
01:30:39,260 --> 01:30:40,310
然后

2096
01:30:41,000 --> 01:30:42,410
然后这个呢

2097
01:30:42,410 --> 01:30:45,020
就相当于类似于一个Stuart

2098
01:30:45,590 --> 01:30:49,550
这个state就类似于一个包裹多个state的一个集合吗

2099
01:30:49,790 --> 01:30:50,120
对吧

2100
01:30:50,450 --> 01:30:51,470
多个C的集合

2101
01:30:51,650 --> 01:30:52,790
你你要哪个的话

2102
01:30:52,820 --> 01:30:53,870
你就肯定不一样

2103
01:30:53,870 --> 01:30:58,130
就拿到哪个这赛特赛特states他也会

2104
01:30:58,620 --> 01:31:02,490
他也是根据你的当前这个B包的值

2105
01:31:03,100 --> 01:31:03,850
到底是什么

2106
01:31:03,880 --> 01:31:05,950
它就会给你更改哪一个的值

2107
01:31:06,370 --> 01:31:07,240
更改一个值

2108
01:31:07,300 --> 01:31:08,320
这样就实现了

2109
01:31:09,380 --> 01:31:09,740
你

2110
01:31:10,470 --> 01:31:11,400
第一个use date

2111
01:31:11,400 --> 01:31:12,720
那么N140

2112
01:31:12,810 --> 01:31:13,590
那么你的

2113
01:31:15,160 --> 01:31:17,260
比如我掉了这一行代码

2114
01:31:17,470 --> 01:31:19,390
那么它内部就变成了

2115
01:31:21,160 --> 01:31:22,930
我们可以给大家模拟一下

2116
01:31:23,320 --> 01:31:24,370
假如这样的代码

2117
01:31:25,470 --> 01:31:26,760
那么a是多少

2118
01:31:26,760 --> 01:31:27,390
A是零

2119
01:31:27,870 --> 01:31:28,710
那么states呢

2120
01:31:28,710 --> 01:31:29,460
就变成了

2121
01:31:30,860 --> 01:31:32,390
零零

2122
01:31:32,690 --> 01:31:35,690
这个铃是这个铃是它的值

2123
01:31:35,960 --> 01:31:38,510
而这个零是它的前面这个妞

2124
01:31:39,560 --> 01:31:40,070
对不对

2125
01:31:40,250 --> 01:31:42,080
而如果我们在掉了第二个hooks

2126
01:31:44,860 --> 01:31:45,880
我们在第二个X

2127
01:31:45,880 --> 01:31:47,620
我们又变化了

2128
01:31:47,710 --> 01:31:48,730
它就变成了一

2129
01:31:49,330 --> 01:31:49,690
然后呢

2130
01:31:49,690 --> 01:31:51,940
我们总的state里就有了一

2131
01:31:55,090 --> 01:31:55,510
Name

2132
01:31:57,290 --> 01:31:59,240
如果有第三个、第四个

2133
01:31:59,240 --> 01:32:00,080
就以此类推

2134
01:32:00,110 --> 01:32:03,440
他同同样的也能拿到所有的内容的

2135
01:32:03,530 --> 01:32:05,450
就是所有的state的值

2136
01:32:05,450 --> 01:32:06,320
它都是可以拿到的

2137
01:32:06,500 --> 01:32:08,060
有一个state就是不同的变化

2138
01:32:08,270 --> 01:32:08,960
你的妞

2139
01:32:09,580 --> 01:32:09,940
No

2140
01:32:09,940 --> 01:32:12,760
每一次他都会把它作为一个B包

2141
01:32:12,940 --> 01:32:13,840
把它放在那儿

2142
01:32:14,140 --> 01:32:14,560
对不对

2143
01:32:14,800 --> 01:32:15,580
就这个no

2144
01:32:15,670 --> 01:32:18,670
它的c EST里实际上就持有了这个B包

2145
01:32:19,600 --> 01:32:21,460
他们因为这个B包已经持有了

2146
01:32:21,670 --> 01:32:24,580
所以他总能找到和他对应的那个值

2147
01:32:26,030 --> 01:32:28,340
那么你这就算定义多个也没有问题

2148
01:32:29,180 --> 01:32:32,210
那么这个就是相比于上面那个简版

2149
01:32:32,820 --> 01:32:35,100
这个他实际上功能更加强大

2150
01:32:35,100 --> 01:32:37,740
我甚至觉得这个基地已经非常的精妙

2151
01:32:37,770 --> 01:32:39,270
已经可以

2152
01:32:39,270 --> 01:32:40,770
如果是一个非常简单的裤子的话

2153
01:32:40,770 --> 01:32:42,210
都可以直接拿来用了

2154
01:32:42,880 --> 01:32:43,690
这个直接拿来用了

2155
01:32:43,690 --> 01:32:47,710
大家可以学习一下这种代码后面后面可以尝试写一写

2156
01:32:48,160 --> 01:32:48,940
这能理解吗

2157
01:32:48,940 --> 01:32:50,020
能理解的扣个一

2158
01:32:50,380 --> 01:32:51,580
不能理解的扣一个零

2159
01:32:52,230 --> 01:32:52,440
对

2160
01:32:52,440 --> 01:32:54,750
这个with state he he

2161
01:32:55,730 --> 01:32:57,170
Use的这个东西

2162
01:32:57,820 --> 01:32:58,180
OK

2163
01:32:58,210 --> 01:32:58,450
好

2164
01:32:58,870 --> 01:33:01,840
这个代码我个人觉得还是很妙的妙

2165
01:33:03,380 --> 01:33:04,370
比如state就

2166
01:33:05,420 --> 01:33:08,420
大概最简版的方式我们就已经实现了

2167
01:33:09,400 --> 01:33:10,000
然后

2168
01:33:11,260 --> 01:33:15,400
Use effect use effect的功能我刚刚讲已经讲过了

2169
01:33:15,880 --> 01:33:16,810
功能第一个

2170
01:33:17,860 --> 01:33:20,800
第一个还第一个参数是一个function

2171
01:33:20,800 --> 01:33:21,520
是一个call back

2172
01:33:21,940 --> 01:33:23,350
第二个参数是一个依赖

2173
01:33:23,680 --> 01:33:24,910
那么实际上它

2174
01:33:25,680 --> 01:33:26,700
当依赖变化的时候

2175
01:33:26,700 --> 01:33:28,890
我们要做的有两件事情

2176
01:33:30,490 --> 01:33:31,570
没有依赖的时候

2177
01:33:32,190 --> 01:33:34,320
只执行一次依赖变化的时候

2178
01:33:34,680 --> 01:33:37,290
那么我们也要值依赖变化的时候

2179
01:33:37,320 --> 01:33:38,880
要执行一次

2180
01:33:39,120 --> 01:33:40,020
同时要把这个

2181
01:33:41,420 --> 01:33:46,370
同时要把同时要在函数里面要需要得到他最新的值

2182
01:33:47,010 --> 01:33:47,370
对吧

2183
01:33:47,460 --> 01:33:49,950
所以我们在这个you the fact哩

2184
01:33:50,600 --> 01:33:51,410
他要七分

2185
01:33:51,440 --> 01:33:52,730
他要七分首先

2186
01:33:53,660 --> 01:33:55,430
你的这个依赖速度如果为空

2187
01:33:55,430 --> 01:33:55,730
对了

2188
01:33:55,760 --> 01:33:56,420
有一种情况

2189
01:33:56,420 --> 01:33:57,350
刚刚我给大家说了

2190
01:33:57,410 --> 01:33:59,420
如果在record里这么写

2191
01:33:59,810 --> 01:34:01,370
这个是不能不能这么写的

2192
01:34:02,050 --> 01:34:03,460
如果你不传依赖函数

2193
01:34:03,460 --> 01:34:06,010
这就是非常严重的一个问题

2194
01:34:06,430 --> 01:34:08,170
你如果不传这个依赖数组

2195
01:34:08,440 --> 01:34:10,210
那么无论任何属性的变化

2196
01:34:10,210 --> 01:34:11,920
你的这个函数题都是会执行的

2197
01:34:11,920 --> 01:34:12,310
同学们

2198
01:34:12,700 --> 01:34:14,350
这个依赖宿主是必须要传的

2199
01:34:14,680 --> 01:34:16,120
而你如果想让他执行一次

2200
01:34:16,120 --> 01:34:16,930
是要传空

2201
01:34:17,480 --> 01:34:18,290
而不是不传

2202
01:34:18,320 --> 01:34:20,060
不传的话是每一次都会执行

2203
01:34:20,480 --> 01:34:21,680
这个大家要注意

2204
01:34:22,580 --> 01:34:23,630
没有依赖宿主

2205
01:34:23,870 --> 01:34:24,620
实际上

2206
01:34:24,740 --> 01:34:28,010
实际上它的性能开销是非常大非常大

2207
01:34:28,010 --> 01:34:29,840
因为你任何一次变化它都会执行

2208
01:34:30,880 --> 01:34:31,510
他都会自行

2209
01:34:32,730 --> 01:34:33,330
这也是这样

2210
01:34:33,330 --> 01:34:34,320
如果没有依赖速度

2211
01:34:34,350 --> 01:34:37,260
就是如果没有依赖速度的情况下

2212
01:34:38,340 --> 01:34:39,300
没有依赖数字

2213
01:34:40,180 --> 01:34:41,980
那么他每次都要执行这个call back

2214
01:34:42,560 --> 01:34:43,400
对没有依赖数字

2215
01:34:43,850 --> 01:34:45,740
第二就是依赖速度变化的时候

2216
01:34:45,920 --> 01:34:46,820
它执行这个bug

2217
01:34:47,180 --> 01:34:48,620
什么是依赖速度变化呢

2218
01:34:48,890 --> 01:34:49,670
依赖速度的变化

2219
01:34:49,670 --> 01:34:50,870
他会去递归

2220
01:34:50,900 --> 01:34:52,040
就是他们不是递归

2221
01:34:52,250 --> 01:34:55,250
他是去对这个数组

2222
01:34:55,550 --> 01:34:56,180
然后呢

2223
01:34:56,210 --> 01:35:00,860
每一项和每一项和当前的那个值进行对比

2224
01:35:01,190 --> 01:35:02,990
对比中有任何一项改变了

2225
01:35:03,760 --> 01:35:04,480
这就是有

2226
01:35:04,510 --> 01:35:06,160
这是有任何一项改变

2227
01:35:06,430 --> 01:35:07,720
只要有一个改变了

2228
01:35:08,080 --> 01:35:08,860
那么就说明

2229
01:35:09,440 --> 01:35:10,880
有依赖变化

2230
01:35:11,740 --> 01:35:12,970
只要有一来一遍

2231
01:35:13,610 --> 01:35:13,820
对吧

2232
01:35:13,820 --> 01:35:15,770
只要有依赖一遍那么

2233
01:35:16,360 --> 01:35:17,590
我最可怕的叫自信

2234
01:35:18,480 --> 01:35:19,470
折扣要执行

2235
01:35:19,740 --> 01:35:24,900
这个其实就是you z u the fact减半的时限是这么实现的

2236
01:35:25,350 --> 01:35:25,980
但是呢

2237
01:35:27,140 --> 01:35:28,010
在hooks里

2238
01:35:28,880 --> 01:35:30,200
在那个write books里

2239
01:35:30,200 --> 01:35:32,000
他逻辑并没有这么简单

2240
01:35:32,090 --> 01:35:32,600
为什么呢

2241
01:35:33,530 --> 01:35:35,660
因为他除了J这点功能之外

2242
01:35:35,840 --> 01:35:38,090
他有其他的功能是它无所无法实现的

2243
01:35:38,510 --> 01:35:40,370
比如UCUCH

2244
01:35:40,370 --> 01:35:44,360
它最主要的一个他是要他是要发起一次更新的

2245
01:35:44,920 --> 01:35:47,110
再发起一次更新

2246
01:35:47,110 --> 01:35:49,240
在离开react他就发起不了

2247
01:35:49,420 --> 01:35:50,500
你必须在react里

2248
01:35:50,530 --> 01:35:52,720
你知道它实际上属于wrecked独有的逻辑

2249
01:35:53,300 --> 01:35:54,200
是独有的逻辑

2250
01:35:54,410 --> 01:35:56,480
而这个you the fact同样也是

2251
01:35:56,750 --> 01:35:58,580
那么他的执行实际在哪里

2252
01:35:58,970 --> 01:36:04,040
那么这个也是需要在我们真正的rock的源码中缺少答案的他

2253
01:36:04,100 --> 01:36:04,910
你没有办法

2254
01:36:04,910 --> 01:36:06,590
你没有办法只通过

2255
01:36:07,590 --> 01:36:09,780
这么个简版就就看

2256
01:36:09,930 --> 01:36:13,410
虽然简版它可以帮助我们把逻辑理得更清楚明白一些

2257
01:36:13,770 --> 01:36:15,540
但是他没有办法

2258
01:36:15,540 --> 01:36:18,120
完全完全完全的让我们理解的这个东西

2259
01:36:18,480 --> 01:36:21,390
所以我们接下来要看VIP的真正的原版的分析

2260
01:36:21,630 --> 01:36:26,910
我就只分析稍微难一点的这两个u state he you the fact

2261
01:36:27,240 --> 01:36:28,440
比如像use rift

2262
01:36:28,560 --> 01:36:29,670
其实非常的简单

2263
01:36:30,240 --> 01:36:31,950
You school back就是缓存一下

2264
01:36:32,040 --> 01:36:32,700
都非常简单

2265
01:36:32,700 --> 01:36:36,030
就没有没有把这两个讲明白了

2266
01:36:36,030 --> 01:36:37,560
剩下的大家可以自己下去看

2267
01:36:38,010 --> 01:36:38,640
非常简单

2268
01:36:38,940 --> 01:36:39,480
非常简单

2269
01:36:40,410 --> 01:36:40,920
就这两个

2270
01:36:40,920 --> 01:36:42,720
我觉得稍微会困难一些

2271
01:36:43,020 --> 01:36:43,590
困难一些

2272
01:36:43,920 --> 01:36:46,620
那我们就开始讲解那个use data

2273
01:36:46,950 --> 01:36:48,570
它原本的逻辑到底是怎么样的

2274
01:36:49,520 --> 01:36:50,120
首先

2275
01:36:51,220 --> 01:36:54,730
我们就直接现在直接大家带大家跳代码啦

2276
01:36:56,290 --> 01:36:56,650
Use

2277
01:36:56,650 --> 01:36:58,150
大家跳代码啦

2278
01:36:59,690 --> 01:37:00,830
就看得明白一些

2279
01:37:03,860 --> 01:37:04,520
看一下

2280
01:37:06,470 --> 01:37:07,850
Books that looks

2281
01:37:08,620 --> 01:37:09,790
Realize father whose

2282
01:37:18,210 --> 01:37:19,050
大家看

2283
01:37:19,720 --> 01:37:22,720
在我们在找到这个护士源码的时候

2284
01:37:22,750 --> 01:37:26,290
会发现他这个u state不光不光值

2285
01:37:26,710 --> 01:37:27,940
它是把蒙特

2286
01:37:28,880 --> 01:37:29,120
好

2287
01:37:29,180 --> 01:37:31,220
Update是严格的区分开的

2288
01:37:31,250 --> 01:37:32,390
就是第一次的时候

2289
01:37:33,070 --> 01:37:34,210
对use来讲

2290
01:37:35,120 --> 01:37:36,590
他第一次就是MT阶段

2291
01:37:36,620 --> 01:37:38,060
他就执行mount set

2292
01:37:38,730 --> 01:37:39,630
如果是更新的时候

2293
01:37:39,630 --> 01:37:40,950
就有自信更心碎的

2294
01:37:41,070 --> 01:37:42,630
他们两块的逻辑还不太一样

2295
01:37:43,050 --> 01:37:45,780
不太一样的我们看MT阶段的时候发生了什么

2296
01:37:47,580 --> 01:37:48,180
MT

2297
01:37:51,550 --> 01:37:51,850
好

2298
01:37:52,180 --> 01:37:53,290
这就是我们第一次

2299
01:37:54,150 --> 01:37:55,410
注册一个use date

2300
01:37:56,250 --> 01:37:58,140
注册use的时候我们会传一个

2301
01:37:58,890 --> 01:37:59,640
初始值

2302
01:38:00,210 --> 01:38:01,950
这个初始值可以是一个

2303
01:38:02,580 --> 01:38:06,900
可以是一个基本类型或者对象数组

2304
01:38:07,260 --> 01:38:09,120
同时它也可以是一个function

2305
01:38:09,480 --> 01:38:10,350
他也是一个function

2306
01:38:10,960 --> 01:38:12,340
这两个方式都可以

2307
01:38:14,050 --> 01:38:20,980
再创建一个amount of working progress MT MT a work in progress fiber

2308
01:38:21,520 --> 01:38:22,090
我看一下

2309
01:38:22,680 --> 01:38:25,260
大家看他这实际上创建了一个户口

2310
01:38:25,860 --> 01:38:28,170
所有的不管是you stayed也好

2311
01:38:28,500 --> 01:38:29,700
还是you the fact也好

2312
01:38:29,850 --> 01:38:31,620
他都会创建这么一个对象

2313
01:38:31,980 --> 01:38:34,080
这个对象就是就是一个hooks对象

2314
01:38:34,740 --> 01:38:35,760
这是一个湖的对象

2315
01:38:36,150 --> 01:38:39,570
也就是我们所谓的一个一个

2316
01:38:40,080 --> 01:38:40,650
Hooks

2317
01:38:40,680 --> 01:38:41,790
我们所谓的一个hooks

2318
01:38:41,820 --> 01:38:43,290
她就是指的是他

2319
01:38:43,290 --> 01:38:44,880
是不是这样的一个hook对象

2320
01:38:45,240 --> 01:38:46,710
我们可以来看一下

2321
01:38:46,800 --> 01:38:47,670
所以他是一个链表

2322
01:38:47,670 --> 01:38:48,270
当然是一个

2323
01:38:48,270 --> 01:38:49,050
他一个next

2324
01:38:49,170 --> 01:38:49,695
对不对

2325
01:38:49,695 --> 01:38:52,170
他next就是指向下一个hooks

2326
01:38:52,930 --> 01:38:54,520
这儿有一个memory state

2327
01:38:54,730 --> 01:38:56,680
这个memory state是来存放

2328
01:38:57,010 --> 01:38:58,720
对于我们的u state来讲

2329
01:38:58,900 --> 01:39:00,670
它是存放我们的state的

2330
01:39:01,670 --> 01:39:03,110
这儿有个base seat

2331
01:39:04,130 --> 01:39:05,420
对我们来说它是纯

2332
01:39:05,420 --> 01:39:06,560
它也是穿S的

2333
01:39:06,740 --> 01:39:08,270
但是它的区别在哪儿

2334
01:39:08,300 --> 01:39:11,960
它区别在于这个有可能是拿来做优化用的

2335
01:39:12,520 --> 01:39:14,050
就他可memory state

2336
01:39:15,160 --> 01:39:17,230
一在某一个阶段他会

2337
01:39:17,840 --> 01:39:18,620
在某一个阶段

2338
01:39:18,620 --> 01:39:20,060
他们并不完全相等

2339
01:39:20,680 --> 01:39:22,150
他他们并不完全相等

2340
01:39:22,150 --> 01:39:24,430
但是在最后是相等的

2341
01:39:24,820 --> 01:39:25,480
因为这个

2342
01:39:26,780 --> 01:39:29,330
他会在浏览器有空闲的时候

2343
01:39:29,330 --> 01:39:30,800
如果浏览器有空闲的时候

2344
01:39:31,160 --> 01:39:32,750
他会考虑

2345
01:39:33,520 --> 01:39:35,380
提前执行那个setup

2346
01:39:35,590 --> 01:39:39,190
比如city name that age函数题可能会提前执行

2347
01:39:39,430 --> 01:39:40,210
提前执行之后

2348
01:39:40,210 --> 01:39:41,650
他就会把直线存在这儿

2349
01:39:42,410 --> 01:39:43,940
然后后面的时候再付给他

2350
01:39:44,390 --> 01:39:46,310
对这个实际上是一个优化项

2351
01:39:46,520 --> 01:39:47,960
是一个优化项这

2352
01:39:48,520 --> 01:39:48,910
Queen

2353
01:39:49,210 --> 01:39:51,430
这个queen就是更新的更新队列

2354
01:39:51,460 --> 01:39:53,560
就是牛发情有哪些更新

2355
01:39:53,920 --> 01:39:54,490
有哪些更新

2356
01:39:54,490 --> 01:39:55,330
有更新的队列

2357
01:39:56,230 --> 01:39:56,500
OK

2358
01:39:56,500 --> 01:39:57,730
这就是创建了一个hook

2359
01:39:58,480 --> 01:39:59,260
参见hooks

2360
01:39:59,860 --> 01:40:00,520
然后呢

2361
01:40:00,730 --> 01:40:03,100
Working progress look等于浪的时候

2362
01:40:04,020 --> 01:40:04,530
就

2363
01:40:05,740 --> 01:40:12,880
就把这个顾客就相当于是把这个新产品的户口复制复制给复制给他嘛

2364
01:40:12,970 --> 01:40:13,780
就复制给他

2365
01:40:14,770 --> 01:40:15,670
因为这个

2366
01:40:16,480 --> 01:40:20,590
Currently render fiber其实就是我们的filed节点

2367
01:40:20,620 --> 01:40:22,240
同学们这个发怒的节点

2368
01:40:30,080 --> 01:40:32,630
这个就指的是当前要处理的FAB的节点

2369
01:40:33,020 --> 01:40:35,000
这个发展的节点有一个属性

2370
01:40:35,270 --> 01:40:37,040
我刚刚不是说

2371
01:40:37,040 --> 01:40:39,860
我刚刚在说他们只能够在顶层使用

2372
01:40:40,250 --> 01:40:43,970
然后说道有一个属性会来存整个hooks列表

2373
01:40:44,150 --> 01:40:45,500
就是这个member state

2374
01:40:46,080 --> 01:40:47,280
这个绝对给大家说过的

2375
01:40:47,280 --> 01:40:47,850
我们可以

2376
01:40:48,460 --> 01:40:49,240
可以看一下

2377
01:40:49,860 --> 01:40:50,640
在这个地方

2378
01:40:51,290 --> 01:40:52,430
可能当时提了一嘴

2379
01:40:52,460 --> 01:40:53,630
然后现在给大家再

2380
01:40:54,460 --> 01:40:55,570
再把音箱给

2381
01:40:56,500 --> 01:40:58,120
再把印象给

2382
01:41:01,810 --> 01:41:02,470
换起来

2383
01:41:03,320 --> 01:41:05,270
这儿有一个叫做对看

2384
01:41:05,900 --> 01:41:08,840
这个是一个发怒的节点的节点

2385
01:41:09,200 --> 01:41:13,340
Filed的节点里有一个属性叫做memories date

2386
01:41:14,160 --> 01:41:16,920
这个memory的state里存放的就是hooks

2387
01:41:17,460 --> 01:41:18,030
Box列表

2388
01:41:19,360 --> 01:41:19,960
Looks and

2389
01:41:22,290 --> 01:41:25,290
所以没有的时候就把它放在列表上

2390
01:41:25,290 --> 01:41:25,650
有

2391
01:41:26,070 --> 01:41:27,210
那么就把它放在下一个

2392
01:41:27,240 --> 01:41:29,850
放到当前列表的最后一个

2393
01:41:30,710 --> 01:41:31,040
对

2394
01:41:31,040 --> 01:41:32,570
放在当前任务的最后一个

2395
01:41:33,330 --> 01:41:34,230
这个就是

2396
01:41:35,480 --> 01:41:39,920
MT working progress hook所做的事情我们可以看到

2397
01:41:41,060 --> 01:41:42,320
我们可以看到

2398
01:41:44,740 --> 01:41:46,210
根据我们刚刚的分析

2399
01:41:46,900 --> 01:41:47,800
他做了什么事情

2400
01:41:47,800 --> 01:41:48,730
也创建了一个

2401
01:41:50,020 --> 01:41:51,190
创建了一个

2402
01:41:52,660 --> 01:41:54,130
box对象对不对

2403
01:41:55,000 --> 01:41:55,690
福克斯

2404
01:41:57,280 --> 01:41:58,150
列表对象

2405
01:42:00,600 --> 01:42:02,490
然后存放在

2406
01:42:04,430 --> 01:42:05,780
尘封在那个

2407
01:42:06,570 --> 01:42:08,790
Fiber node的

2408
01:42:09,650 --> 01:42:14,690
MEM mor rise the state

2409
01:42:15,750 --> 01:42:16,590
史姓钟

2410
01:42:19,610 --> 01:42:22,070
属性中为什么要讲这么详细

2411
01:42:22,160 --> 01:42:26,180
因为因为这块儿可能如果大家以后遇到了问题要调试的时候

2412
01:42:27,610 --> 01:42:31,000
遇到问题需要调试的时候就会比较有帮助

2413
01:42:31,510 --> 01:42:32,320
这就是一个户口

2414
01:42:32,710 --> 01:42:34,270
然后这一步

2415
01:42:36,890 --> 01:42:39,500
这个然后如果是一个函数

2416
01:42:39,500 --> 01:42:40,700
那么就把它执行一下

2417
01:42:40,760 --> 01:42:42,440
得到得到值

2418
01:42:43,090 --> 01:42:47,050
然后初始值把它放在hooks大家看

2419
01:42:47,050 --> 01:42:48,550
这个hook的memories date

2420
01:42:49,090 --> 01:42:51,880
而不是filed的memories的我

2421
01:42:51,880 --> 01:42:54,490
我一开始看的时候被这两个属性搞晕了

2422
01:42:55,500 --> 01:42:57,840
我一开始看的时候被这两个属性直接搞晕了

2423
01:42:58,480 --> 01:42:59,200
这是怎么回事

2424
01:42:59,200 --> 01:43:02,410
一会儿又放在他怎么有两个妹妹state

2425
01:43:02,410 --> 01:43:05,020
他们怎么可以放两个完全不同的东西

2426
01:43:05,640 --> 01:43:06,930
后面我再一看

2427
01:43:06,990 --> 01:43:10,080
发现他们这个是hooked memories date

2428
01:43:11,470 --> 01:43:14,530
而这个地方它是把它存在范本

2429
01:43:15,130 --> 01:43:18,910
诺德的memories这里他们两个属性的名字一样

2430
01:43:19,600 --> 01:43:20,590
我觉得这个有点坑

2431
01:43:20,650 --> 01:43:22,060
老师我觉得这个有点坑

2432
01:43:23,120 --> 01:43:24,380
他们两个的名字一样

2433
01:43:24,380 --> 01:43:26,060
但是成的东西完全不一样

2434
01:43:27,060 --> 01:43:27,630
挺坑的

2435
01:43:30,350 --> 01:43:31,310
然后放在里面

2436
01:43:31,670 --> 01:43:32,120
第三

2437
01:43:32,300 --> 01:43:33,080
新建一个query

2438
01:43:33,350 --> 01:43:34,430
为什么要建一个呢

2439
01:43:34,460 --> 01:43:35,990
这个就是reactor里边儿的

2440
01:43:36,410 --> 01:43:38,570
如果record里发起一次的更新

2441
01:43:39,050 --> 01:43:40,730
它就把它放在一个教会里面

2442
01:43:41,540 --> 01:43:42,200
包括

2443
01:43:42,830 --> 01:43:46,670
Class里面的选CC的他同样会发起一次叫做queen

2444
01:43:47,000 --> 01:43:48,230
他同样会发起一个Z

2445
01:43:48,980 --> 01:43:49,820
重新发起一个

2446
01:43:50,460 --> 01:43:52,020
他新建了一个更新

2447
01:43:52,050 --> 01:43:53,310
就说明我们有更新嘛

2448
01:43:53,310 --> 01:43:53,790
很正常

2449
01:43:53,790 --> 01:43:56,040
因为我们本来就是要更新state的

2450
01:43:56,820 --> 01:43:57,360
然后呢

2451
01:43:57,660 --> 01:43:59,340
把这个微信传递给dispatch

2452
01:43:59,790 --> 01:44:02,100
最后把我们的默认值

2453
01:44:02,160 --> 01:44:03,690
因为默认值已经付给了他

2454
01:44:04,020 --> 01:44:04,440
对不对

2455
01:44:04,800 --> 01:44:07,920
然后这个despite就是更改默认值的值

2456
01:44:08,250 --> 01:44:09,300
更改默认值的方法

2457
01:44:09,900 --> 01:44:11,970
这里大家看这里绑定了两个东西

2458
01:44:12,670 --> 01:44:14,830
一个就是当前的这个fiber

2459
01:44:15,820 --> 01:44:17,380
一个就是当前这个fiber

2460
01:44:17,410 --> 01:44:19,810
另外一个就是这个要发起

2461
01:44:19,810 --> 01:44:21,700
到底具体要发起的是哪个更新

2462
01:44:22,390 --> 01:44:22,810
OK

2463
01:44:22,840 --> 01:44:23,560
和这一样

2464
01:44:23,680 --> 01:44:25,060
大家看和这里是一样的

2465
01:44:34,900 --> 01:44:36,280
大家看这个state

2466
01:44:37,130 --> 01:44:38,930
这个C的C的它里面是不是

2467
01:44:39,600 --> 01:44:42,120
里边同样也依赖了一个叫做a的变量

2468
01:44:42,210 --> 01:44:45,660
这个new的变量就类似于它绑定的这个变量

2469
01:44:46,170 --> 01:44:46,890
你必须要找

2470
01:44:46,890 --> 01:44:48,210
因为你只有通过他

2471
01:44:48,910 --> 01:44:51,370
你才能够准确的找到是哪个版本

2472
01:44:52,440 --> 01:44:54,090
你只能能找到是哪个发

2473
01:44:54,090 --> 01:44:57,180
不然你你你再多个组件里用fiber

2474
01:44:57,180 --> 01:44:58,710
你他就会混

2475
01:44:58,710 --> 01:44:59,520
他就混掉

2476
01:44:59,670 --> 01:45:00,480
肯定是要把它

2477
01:45:01,250 --> 01:45:04,280
这两个是唯一的唯一确定能力

2478
01:45:04,940 --> 01:45:05,960
他们这两个值

2479
01:45:06,170 --> 01:45:07,070
那唯一确定的

2480
01:45:07,070 --> 01:45:09,950
你要更改的那个hooks是谁是谁

2481
01:45:10,220 --> 01:45:12,500
谁返回了当前值和despite

2482
01:45:12,800 --> 01:45:14,990
这个是MT阶段做的事情

2483
01:45:14,990 --> 01:45:16,100
我们来整理一下

2484
01:45:16,190 --> 01:45:16,730
整理一下

2485
01:45:17,120 --> 01:45:19,370
其实在这边也整理整理的有

2486
01:45:20,240 --> 01:45:21,020
你直接看吗

2487
01:45:22,330 --> 01:45:22,720
的

2488
01:45:24,510 --> 01:45:26,070
默认如果是一个函数

2489
01:45:26,100 --> 01:45:27,720
就执行函数得到初始state

2490
01:45:27,750 --> 01:45:31,770
所得state存放在memory state新建一个queen

2491
01:45:32,130 --> 01:45:33,690
把queen传递给dispatch

2492
01:45:33,780 --> 01:45:35,550
然后返回默认值和dispatch

2493
01:45:36,360 --> 01:45:37,950
这是慢的阶段要做的事情

2494
01:45:38,310 --> 01:45:41,160
其实我大概把UC的拆成了三个阶段

2495
01:45:41,580 --> 01:45:43,410
就是我擅自把它拆成了三个阶段

2496
01:45:43,410 --> 01:45:44,520
第一个MT就是注册

2497
01:45:44,910 --> 01:45:47,880
因为在这个时候我们实际上还是没有发起更新的

2498
01:45:49,220 --> 01:45:55,280
第二个我认为就是发起更新也是我们把这个use date这整个流程串起来看

2499
01:45:55,310 --> 01:45:58,070
就发现有初始的state就是

2500
01:45:58,720 --> 01:45:59,320
初始值啊

2501
01:45:59,320 --> 01:46:00,160
给它设初始值

2502
01:46:00,790 --> 01:46:02,650
那么第二个阶段就是更改它的值

2503
01:46:03,160 --> 01:46:04,810
第三个阶段就是更改了它的值

2504
01:46:04,840 --> 01:46:05,470
更新

2505
01:46:05,500 --> 01:46:06,400
我们要更新state

2506
01:46:06,400 --> 01:46:07,270
要怎么更新呢

2507
01:46:07,510 --> 01:46:08,830
我把它分为这三个阶段

2508
01:46:09,250 --> 01:46:12,610
第一个阶段他大概就这么就做了这件事情

2509
01:46:13,340 --> 01:46:14,300
就做了这件事情

2510
01:46:14,300 --> 01:46:15,860
还是非常的简单的

2511
01:46:16,520 --> 01:46:17,270
还是非常简单的

2512
01:46:17,300 --> 01:46:18,020
我们可以

2513
01:46:21,790 --> 01:46:22,870
看一下第二个

2514
01:46:22,900 --> 01:46:23,380
第二个

2515
01:46:23,770 --> 01:46:24,700
如果是第二个的话

2516
01:46:24,700 --> 01:46:25,990
就是dispatch action

2517
01:46:27,480 --> 01:46:28,620
Dispatch action

2518
01:46:29,340 --> 01:46:30,000
大概也做了

2519
01:46:30,000 --> 01:46:31,620
这大概做了四件事情

2520
01:46:31,740 --> 01:46:33,120
但是他最重要的事情是

2521
01:46:33,870 --> 01:46:34,860
这个链接看一下

2522
01:46:36,010 --> 01:46:36,310
挨

2523
01:46:38,020 --> 01:46:38,950
了好几次了

2524
01:46:39,760 --> 01:46:40,150
行

2525
01:46:42,690 --> 01:46:43,200
嗯

2526
01:46:43,670 --> 01:46:46,910
Dispatch action其实就是跟他叫这个名字

2527
01:46:47,240 --> 01:46:49,520
这个是他在L的名字

2528
01:46:49,910 --> 01:46:52,670
你你我们一般用它的时候就是用什么

2529
01:46:52,700 --> 01:46:56,120
就是那个

2530
01:46:56,270 --> 01:46:56,750
CTECTEA减

2531
01:46:56,750 --> 01:46:59,210
类似类似这个调用

2532
01:47:00,340 --> 01:47:00,940
吊他了

2533
01:47:02,120 --> 01:47:04,490
这样就在更新直根性的这个方法

2534
01:47:04,490 --> 01:47:05,930
其实就是这个dispatch action

2535
01:47:06,380 --> 01:47:07,220
我们来看一下

2536
01:47:09,740 --> 01:47:10,730
Despite the action

2537
01:47:10,730 --> 01:47:12,620
他到底做了什么呢

2538
01:47:17,720 --> 01:47:18,140
嗯

2539
01:47:25,240 --> 01:47:26,950
DV1先把它去掉

2540
01:47:27,490 --> 01:47:28,870
首先创建了一个update

2541
01:47:28,870 --> 01:47:31,150
大家看这里终于创建了一个update了

2542
01:47:31,150 --> 01:47:32,680
因为我们本来就是要更新吗

2543
01:47:32,980 --> 01:47:34,180
所以他创建一个update

2544
01:47:34,180 --> 01:47:35,350
这个是合乎常理的

2545
01:47:35,650 --> 01:47:37,510
然后这里给他设了一个烂

2546
01:47:38,120 --> 01:47:38,840
剩了一个烂

2547
01:47:39,170 --> 01:47:42,530
然后action这个action来看这个action是什么

2548
01:47:42,740 --> 01:47:47,480
这个action就是我们的c aged的传递那个参数

2549
01:47:48,060 --> 01:47:49,590
比如我们c age啦

2550
01:47:49,890 --> 01:47:50,880
我可以给他传值

2551
01:47:50,880 --> 01:47:51,780
我刚才讲过对不对

2552
01:47:51,780 --> 01:47:52,680
我可以传值

2553
01:47:53,010 --> 01:47:55,950
也可以传一个函数都可以

2554
01:47:56,190 --> 01:47:58,560
那么他在这里面的命名就是一个action

2555
01:47:58,620 --> 01:48:00,960
把这个action也给到了这个update

2556
01:48:01,170 --> 01:48:05,580
他在后面调查这个有个m EST he l reduce or

2557
01:48:05,760 --> 01:48:08,370
这个就是来闲暇的时候计算state的

2558
01:48:09,060 --> 01:48:09,600
同样

2559
01:48:09,690 --> 01:48:11,370
如果你有多个对吧

2560
01:48:11,370 --> 01:48:12,270
假如你有多个

2561
01:48:12,570 --> 01:48:13,440
你更新了多个

2562
01:48:13,470 --> 01:48:16,020
那么你同样也可以有一个LIST1列表

2563
01:48:16,640 --> 01:48:17,750
这是创建一个对

2564
01:48:18,290 --> 01:48:19,550
那么既然创建对的

2565
01:48:19,550 --> 01:48:21,470
他是不是应该把它添加到我们的那个

2566
01:48:22,250 --> 01:48:23,450
更新队列里面去

2567
01:48:23,930 --> 01:48:25,070
更新队列里面去对

2568
01:48:25,370 --> 01:48:30,110
然后它就会把这个APP的添加到我们的更新对面这个喷顶

2569
01:48:30,680 --> 01:48:34,010
就是代表这个队列需要做的更新是哪些

2570
01:48:34,310 --> 01:48:36,110
会把添加到更新队列中

2571
01:48:36,770 --> 01:48:39,590
这就是把添加更新最终这第二件事情

2572
01:48:40,160 --> 01:48:41,420
第一件事情传给update

2573
01:48:41,810 --> 01:48:43,610
第二件事情添加到更新队列中

2574
01:48:44,280 --> 01:48:46,260
每一个更新都是这么干的

2575
01:48:46,260 --> 01:48:46,650
同学们

2576
01:48:46,950 --> 01:48:48,270
只是之前我没有给大家

2577
01:48:48,540 --> 01:48:49,770
没有给大家挑代码

2578
01:48:50,010 --> 01:48:50,730
给大家代码

2579
01:48:50,730 --> 01:48:51,840
所以这个不要晕

2580
01:48:51,990 --> 01:48:52,380
不要晕

2581
01:48:52,380 --> 01:48:53,970
你就理解这个queen

2582
01:48:53,970 --> 01:48:56,370
他就是L内部的常规操作

2583
01:48:56,900 --> 01:48:59,660
他常规操作就是有一个更新队列

2584
01:49:00,300 --> 01:49:02,700
每发其实更新就会创建这么一个方法

2585
01:49:02,730 --> 01:49:04,800
就创建这么一个对象

2586
01:49:05,280 --> 01:49:05,820
然后呢

2587
01:49:05,940 --> 01:49:08,040
会把这个对象给添加到队列里面去

2588
01:49:08,980 --> 01:49:09,910
添丁里面去

2589
01:49:10,480 --> 01:49:11,110
然后

2590
01:49:15,160 --> 01:49:16,930
如果说当前队列为空

2591
01:49:16,930 --> 01:49:18,430
这个时候是根据什么

2592
01:49:18,430 --> 01:49:19,090
是根据

2593
01:49:19,510 --> 01:49:21,460
是根据

2594
01:49:22,330 --> 01:49:23,620
当前是否处于共享

2595
01:49:23,620 --> 01:49:26,050
就是是否react

2596
01:49:26,050 --> 01:49:28,660
我们的j c j c rat里没有任务

2597
01:49:28,660 --> 01:49:30,220
这个是reg没有其他的任务

2598
01:49:30,700 --> 01:49:33,790
那么他就会提前大家看它就会提前把

2599
01:49:34,550 --> 01:49:36,200
把这个action给执行了

2600
01:49:36,710 --> 01:49:37,700
把值给计算出来

2601
01:49:37,700 --> 01:49:38,720
保存在F里

2602
01:49:38,780 --> 01:49:39,890
但这是一个优化项

2603
01:49:40,130 --> 01:49:41,330
其实一般严格来说

2604
01:49:41,330 --> 01:49:42,350
他不会在这里执行

2605
01:49:42,860 --> 01:49:43,820
这是一个优化项

2606
01:49:43,940 --> 01:49:45,020
如果说有空

2607
01:49:45,050 --> 01:49:46,070
就是有空的时候

2608
01:49:46,370 --> 01:49:47,720
他就先把state计算出来

2609
01:49:47,720 --> 01:49:48,830
保存在这里边儿

2610
01:49:49,400 --> 01:49:49,850
拿不动

2611
01:49:50,480 --> 01:49:51,800
最后最重要的一部

2612
01:49:51,800 --> 01:49:52,640
最最重要一步

2613
01:49:52,640 --> 01:49:55,280
在这里调用一次schedule update on fiber

2614
01:49:55,580 --> 01:49:57,350
进入调度触发方式

2615
01:49:57,350 --> 01:49:58,100
重新进行一次

2616
01:49:58,370 --> 01:49:59,720
这里边儿他进了哪里

2617
01:49:59,750 --> 01:50:00,500
他就进了

2618
01:50:06,240 --> 01:50:07,560
大家看熟不熟悉

2619
01:50:08,010 --> 01:50:09,600
看看这个函数有没有很熟悉

2620
01:50:22,390 --> 01:50:23,860
Scheduled on favor

2621
01:50:24,620 --> 01:50:25,490
看到这样的代码

2622
01:50:31,330 --> 01:50:33,880
Priority re等于think ly

2623
01:50:35,060 --> 01:50:35,750
然后呢

2624
01:50:36,080 --> 01:50:37,430
Execution context

2625
01:50:38,080 --> 01:50:40,750
Render con tax on budget con tax不等于

2626
01:50:41,660 --> 01:50:42,320
No context

2627
01:50:42,380 --> 01:50:46,520
大家看这个是不是就是我一开始给大家粘的热热代码

2628
01:50:47,970 --> 01:50:50,280
一开始schedule later代码对不对

2629
01:50:50,280 --> 01:50:51,240
他是不是进来了

2630
01:50:51,570 --> 01:50:53,940
他是不是就进到了right的主流程中间来了

2631
01:51:05,120 --> 01:51:05,450
嗨

2632
01:51:05,720 --> 01:51:06,380
走到这儿来了

2633
01:51:06,380 --> 01:51:06,800
对不对

2634
01:51:07,310 --> 01:51:10,280
是不是就进到我们的三大模块中的第一块了

2635
01:51:10,820 --> 01:51:15,590
然后判断它是否是就是判断他是不是需要立即执行

2636
01:51:15,950 --> 01:51:16,400
然后呢

2637
01:51:16,400 --> 01:51:18,380
优先级优先级这块儿

2638
01:51:19,270 --> 01:51:20,110
所以就进来了

2639
01:51:20,710 --> 01:51:22,090
优先级走完了之后

2640
01:51:22,180 --> 01:51:25,510
我们会会发现它会掉什么performance single肉

2641
01:51:25,510 --> 01:51:27,760
它就会掉到这里边来了

2642
01:51:28,600 --> 01:51:29,080
对不对

2643
01:51:29,740 --> 01:51:31,810
他调到re consider里面来了

2644
01:51:33,850 --> 01:51:34,270
嗯

2645
01:51:35,520 --> 01:51:37,080
可能这个文件写的太多了

2646
01:51:37,960 --> 01:51:39,760
他已经他已经杀不过来了

2647
01:51:41,490 --> 01:51:43,740
他就调到re con c Lai re currently

2648
01:51:43,740 --> 01:51:46,200
我们都知道又要重新构建fairytale

2649
01:51:46,840 --> 01:51:48,130
大家发一个发一个tree

2650
01:51:48,130 --> 01:51:51,280
是不是又会重新执行begin work呀

2651
01:51:51,920 --> 01:51:52,910
直线BTS了之后

2652
01:51:52,910 --> 01:51:54,710
我们的函数体是不是重新更新了

2653
01:51:56,370 --> 01:51:58,470
然后就回到了我们

2654
01:51:59,220 --> 01:52:02,520
回到了我们上节课所讲的流程中去了

2655
01:52:03,600 --> 01:52:08,640
所以我说所以我说如果说我们单看来护士源码其实真的很难看懂

2656
01:52:08,940 --> 01:52:10,110
因为你永远不知道

2657
01:52:10,680 --> 01:52:12,720
因为如果直接单开那个会员吗

2658
01:52:13,080 --> 01:52:14,040
你根本不知道

2659
01:52:14,920 --> 01:52:16,030
这段代码一调

2660
01:52:16,030 --> 01:52:17,080
到底发生了什么

2661
01:52:17,590 --> 01:52:19,660
与我们前两节课的铺垫我们就知道了

2662
01:52:20,080 --> 01:52:20,500
OK

2663
01:52:20,620 --> 01:52:22,540
他下一次这张代码一掉

2664
01:52:22,990 --> 01:52:25,210
那么它首先会进入优先级的判断

2665
01:52:25,570 --> 01:52:26,740
优先级的判断完了之后

2666
01:52:27,010 --> 01:52:28,540
等下他要重新构建

2667
01:52:28,540 --> 01:52:29,200
纷纷退了

2668
01:52:29,890 --> 01:52:31,120
构建反而去之后

2669
01:52:32,100 --> 01:52:34,590
韩束体会重新运行

2670
01:52:35,400 --> 01:52:37,650
函数题如果重新运行了之后

2671
01:52:38,160 --> 01:52:40,650
我们的就是不是就进入到我们的

2672
01:52:41,940 --> 01:52:43,800
又重新进入函数体的更新了

2673
01:52:44,070 --> 01:52:45,270
那么他就会来到这里

2674
01:52:47,160 --> 01:52:48,720
重新执行我们的函数题

2675
01:52:49,020 --> 01:52:50,010
重新执行函数题

2676
01:52:50,040 --> 01:52:53,400
那么我们就要调一次这个use date

2677
01:52:54,340 --> 01:52:55,450
掉到了UC的时候

2678
01:52:55,450 --> 01:52:56,500
这这个时候

2679
01:52:57,170 --> 01:52:59,270
这个时候他就会执行update的

2680
01:53:08,000 --> 01:53:08,240
不对

2681
01:53:08,240 --> 01:53:09,050
是这个时候

2682
01:53:09,820 --> 01:53:11,830
这个时候就相当于第二次第三次

2683
01:53:11,980 --> 01:53:13,390
那么他就直接up的

2684
01:53:14,480 --> 01:53:15,920
我们来看一下update的set a

2685
01:53:17,300 --> 01:53:21,260
他是把它作为了update to reduce or的一个特殊的一个姐

2686
01:53:21,470 --> 01:53:23,330
相当于他是他的一个B

2687
01:53:23,360 --> 01:53:24,800
它是它的一个特殊类型

2688
01:53:25,470 --> 01:53:26,100
特殊类型

2689
01:53:26,490 --> 01:53:29,640
同样这是update working progress hooks差不多

2690
01:53:30,090 --> 01:53:30,930
然后这个这

2691
01:53:31,950 --> 01:53:33,240
这这就是为啥

2692
01:53:33,330 --> 01:53:34,320
同学们这就是为啥

2693
01:53:34,320 --> 01:53:35,820
我说

2694
01:53:36,210 --> 01:53:37,050
之前介绍了

2695
01:53:37,050 --> 01:53:40,320
就是只能够在能够把它放在

2696
01:53:40,350 --> 01:53:43,800
不能够把胡子放在衣服L这样的判断逻辑之中

2697
01:53:44,010 --> 01:53:44,460
大家看

2698
01:53:45,200 --> 01:53:45,830
大家看

2699
01:53:47,100 --> 01:53:48,360
他就是一个一个找的

2700
01:53:48,810 --> 01:53:50,250
他就直接是等于next

2701
01:53:51,090 --> 01:53:53,340
如果比如说你第一个他就是拿第一个

2702
01:53:53,580 --> 01:53:54,510
你第一个没有

2703
01:53:54,600 --> 01:53:55,680
第二个拿过了

2704
01:53:55,860 --> 01:53:56,820
他就拿next

2705
01:53:57,240 --> 01:53:58,980
然后就点next的next

2706
01:53:59,040 --> 01:54:00,450
所以它就是按顺序拿

2707
01:54:00,930 --> 01:54:01,650
你如果

2708
01:54:02,350 --> 01:54:03,550
他就是按顺序拿

2709
01:54:03,880 --> 01:54:06,100
你如果顺序一遍

2710
01:54:06,100 --> 01:54:07,600
那么他就拿不到最新的

2711
01:54:08,110 --> 01:54:08,680
能理解吗

2712
01:54:09,860 --> 01:54:11,180
这块逻辑和我们的

2713
01:54:11,690 --> 01:54:14,720
我们之前讲的那一块儿联系起来了

2714
01:54:17,940 --> 01:54:18,660
Upset

2715
01:54:20,430 --> 01:54:21,120
Update

2716
01:54:21,740 --> 01:54:22,670
那么他拿着这个户口

2717
01:54:22,670 --> 01:54:23,540
就是按顺序来

2718
01:54:26,120 --> 01:54:30,920
按顺序拿到之前存的X

2719
01:54:33,270 --> 01:54:34,230
他就是点next

2720
01:54:34,470 --> 01:54:35,790
它算不它不是个数组

2721
01:54:35,790 --> 01:54:37,860
所以他用他是个列表一点next

2722
01:54:38,340 --> 01:54:39,120
然后拿到

2723
01:54:39,720 --> 01:54:40,110
Queen

2724
01:54:41,010 --> 01:54:41,730
之后呢

2725
01:54:41,850 --> 01:54:44,670
如果说你的你的那个被洗存在

2726
01:54:46,600 --> 01:54:47,530
这个不是不是这样

2727
01:54:48,360 --> 01:54:49,620
我们看一下这个逻辑

2728
01:54:50,660 --> 01:54:52,730
那第一位先不管第一位先不管

2729
01:54:56,150 --> 01:54:56,870
这是

2730
01:54:58,150 --> 01:54:59,500
这里有个优先级的判断

2731
01:54:59,770 --> 01:55:00,550
优先级的判断

2732
01:55:00,550 --> 01:55:01,390
如果优先级

2733
01:55:02,120 --> 01:55:03,500
如果有更高优先级

2734
01:55:03,500 --> 01:55:05,270
这意味着有更高优先级的过来

2735
01:55:05,270 --> 01:55:07,250
还是存在被打断的逻辑

2736
01:55:07,490 --> 01:55:08,660
还是能被打断的逻辑

2737
01:55:10,050 --> 01:55:13,170
这这其实就是优先级的一个简单的一个判断

2738
01:55:13,890 --> 01:55:15,270
一个判断她也是通过

2739
01:55:17,490 --> 01:55:18,000
怎么说呢

2740
01:55:18,600 --> 01:55:19,920
他也是通过

2741
01:55:20,580 --> 01:55:22,800
二进制二进制比较二进制比较

2742
01:55:23,600 --> 01:55:24,140
来做的

2743
01:55:24,620 --> 01:55:27,800
我在想给大家找的是找的是那个队

2744
01:55:27,830 --> 01:55:29,480
这里如果你的update的点

2745
01:55:30,080 --> 01:55:31,340
Egg or reduce or

2746
01:55:31,550 --> 01:55:32,390
给了reduce or

2747
01:55:32,810 --> 01:55:36,650
那就说明你曾你之前已经处理过

2748
01:55:36,650 --> 01:55:37,970
就是egg a state

2749
01:55:38,300 --> 01:55:40,070
这个m EST我刚刚讲过

2750
01:55:40,520 --> 01:55:41,270
就是在

2751
01:55:42,080 --> 01:55:42,770
Wrecked

2752
01:55:43,070 --> 01:55:44,030
空闲的时候

2753
01:55:44,660 --> 01:55:48,920
那个时候就是发起发起一次写着age写成name这样

2754
01:55:49,340 --> 01:55:52,700
那么如果当时浏览器还是就是我们浏览器处于空闲

2755
01:55:52,820 --> 01:55:54,140
没有REC其他的任务

2756
01:55:54,780 --> 01:55:55,980
那么他就会先给你计算好

2757
01:55:55,980 --> 01:55:56,700
放在这里边儿

2758
01:55:57,340 --> 01:55:58,120
大家看放在里面

2759
01:55:58,120 --> 01:55:58,810
他现在用了

2760
01:55:58,900 --> 01:56:00,130
如果有他就用了

2761
01:56:00,160 --> 01:56:00,970
如果没有的话

2762
01:56:01,640 --> 01:56:02,780
咨询一下他的action

2763
01:56:03,780 --> 01:56:04,230
大

2764
01:56:04,860 --> 01:56:05,760
牛state

2765
01:56:06,210 --> 01:56:07,200
然后递归

2766
01:56:08,180 --> 01:56:09,920
第一个这个就这个样子

2767
01:56:11,720 --> 01:56:14,810
之后再把它反馈回来这个despite

2768
01:56:14,990 --> 01:56:17,540
大家看这个despite并不会返回新的

2769
01:56:17,540 --> 01:56:18,440
这还是返回老的

2770
01:56:18,470 --> 01:56:19,730
只是这个值会刷新

2771
01:56:20,340 --> 01:56:24,240
这个执事会刷新的值刷新了despite不刷新

2772
01:56:24,660 --> 01:56:26,040
所以我们可以把这三块儿

2773
01:56:26,580 --> 01:56:28,170
当我们把它连起来看的时候

2774
01:56:29,350 --> 01:56:30,430
才算是一个整体

2775
01:56:31,180 --> 01:56:32,020
Mon EST

2776
01:56:32,500 --> 01:56:32,980
首先

2777
01:56:33,630 --> 01:56:35,580
Mana c的他创建第一步

2778
01:56:35,580 --> 01:56:36,270
他叫什么

2779
01:56:36,420 --> 01:56:37,380
我先写个零吧

2780
01:56:40,760 --> 01:56:41,600
创建

2781
01:56:44,600 --> 01:56:46,580
创建hooks列表

2782
01:56:49,440 --> 01:56:52,140
放在那个什么fiber

2783
01:56:53,400 --> 01:56:54,180
诺德的

2784
01:56:55,390 --> 01:56:56,830
MEM or eyes

2785
01:56:57,970 --> 01:56:58,570
state

2786
01:56:59,710 --> 01:57:00,460
属性你

2787
01:57:02,260 --> 01:57:03,370
这是他做第一步

2788
01:57:03,490 --> 01:57:04,000
第二步

2789
01:57:04,810 --> 01:57:05,650
那如果是function

2790
01:57:05,650 --> 01:57:07,360
执行function c的

2791
01:57:07,360 --> 01:57:08,200
放在memories

2792
01:57:08,260 --> 01:57:09,040
新建queen

2793
01:57:09,520 --> 01:57:10,780
把queen传递dispatch

2794
01:57:11,020 --> 01:57:12,550
然后返回默认之后dispatch

2795
01:57:12,550 --> 01:57:13,900
这是MT阶段做的事情

2796
01:57:14,020 --> 01:57:14,920
其实很简单

2797
01:57:15,160 --> 01:57:15,790
其实很简单

2798
01:57:15,970 --> 01:57:18,460
只不过这个第一步就是要写下来

2799
01:57:18,460 --> 01:57:21,520
他还是为了和后面的update update进行联动

2800
01:57:22,420 --> 01:57:24,130
然后我们创建完之后

2801
01:57:24,130 --> 01:57:27,430
当我们有一个时间需要更新一个APP的时候

2802
01:57:27,760 --> 01:57:29,290
那么他会创建一个update

2803
01:57:30,200 --> 01:57:30,560
然后呢

2804
01:57:30,560 --> 01:57:31,730
把它添加到昆呢

2805
01:57:32,970 --> 01:57:37,080
如果空闲的时候提前计算出最新的state去保存一下

2806
01:57:37,500 --> 01:57:40,050
最后一次调用一次schedule up down fiber

2807
01:57:40,530 --> 01:57:45,000
这次就会进入schedule流程出发进入schedule之后还会

2808
01:57:45,030 --> 01:57:48,210
那么就会进入

2809
01:57:48,840 --> 01:57:49,860
Re consider a

2810
01:57:53,060 --> 01:57:53,840
出发

2811
01:57:54,170 --> 01:57:56,060
出发方形会重新执行一次

2812
01:57:56,780 --> 01:57:58,670
这样的方式重新执行了之后

2813
01:57:58,670 --> 01:57:59,750
是不是就来到了up

2814
01:58:01,180 --> 01:58:03,820
第二次再调used a的时候

2815
01:58:04,640 --> 01:58:06,590
他就用update

2816
01:58:08,830 --> 01:58:09,790
还是一个零

2817
01:58:13,520 --> 01:58:14,780
零零的话就是

2818
01:58:16,130 --> 01:58:16,940
按顺序

2819
01:58:18,500 --> 01:58:24,470
按顺序获得找到之前的

2820
01:58:26,240 --> 01:58:26,660
X

2821
01:58:26,810 --> 01:58:28,370
所以因为这个原因

2822
01:58:28,640 --> 01:58:29,900
所以他没办法放在

2823
01:58:30,530 --> 01:58:33,530
代码块里就是代码块的逻辑分支里

2824
01:58:34,580 --> 01:58:35,090
然后呢

2825
01:58:35,120 --> 01:58:36,500
第一个执行update

2826
01:58:36,530 --> 01:58:37,550
计算最新的state

2827
01:58:37,550 --> 01:58:38,720
复制给默默state

2828
01:58:39,440 --> 01:58:40,700
这个就是use date

2829
01:58:41,670 --> 01:58:42,360
的逻辑

2830
01:58:42,660 --> 01:58:43,890
其实整体来讲

2831
01:58:43,890 --> 01:58:46,440
他比我们刚刚那个简版要复杂一些

2832
01:58:46,830 --> 01:58:51,210
之所以复杂是因为它必须要挂载在整个rock的主流程之上

2833
01:58:51,360 --> 01:58:52,050
这样子的话

2834
01:58:52,200 --> 01:58:53,550
他的逻辑才是完整的

2835
01:58:54,140 --> 01:58:55,280
这块大家能理解吗

2836
01:58:55,640 --> 01:58:56,690
就这三块儿能理解吗

2837
01:58:56,690 --> 01:58:57,680
能理解扣个一

2838
01:58:58,160 --> 01:58:59,150
不能理解扣个零

2839
01:59:17,450 --> 01:59:18,260
其他同学呢

2840
01:59:34,600 --> 01:59:35,590
信息有点大

2841
01:59:35,740 --> 01:59:36,910
也能理解代码客户

2842
01:59:37,240 --> 01:59:38,620
代码客户还要研究下

2843
01:59:40,360 --> 01:59:41,590
对

2844
01:59:41,590 --> 01:59:44,560
原因是因为因为REC的这个

2845
01:59:45,200 --> 01:59:46,580
这个流程比较复杂

2846
01:59:47,300 --> 01:59:49,700
但是中间有一块儿原因

2847
01:59:49,760 --> 01:59:52,400
你们现在还能理解的原因是中间有一块儿

2848
01:59:53,670 --> 01:59:57,450
这个队友说这个逻辑我其实不用怎么给大家讲

2849
01:59:57,450 --> 01:59:58,170
大家都明白

2850
01:59:58,200 --> 01:59:58,560
对不对

2851
01:59:58,980 --> 02:00:00,330
这块我不用怎么给大家讲

2852
02:00:00,330 --> 02:00:01,020
大家都明白

2853
02:00:01,320 --> 02:00:02,790
但其实这块是最难的

2854
02:00:03,240 --> 02:00:04,980
而且我们前两节课讲了两节

2855
02:00:05,250 --> 02:00:08,220
前两节课讲了两节才把他给捋明白

2856
02:00:08,850 --> 02:00:12,030
其实大家要理解这个usage的过程

2857
02:00:12,030 --> 02:00:13,290
你最好是这这么

2858
02:00:13,290 --> 02:00:14,160
最好是这么来

2859
02:00:14,670 --> 02:00:15,540
这是第一次

2860
02:00:15,540 --> 02:00:17,340
要把它分为第一次

2861
02:00:19,540 --> 02:00:20,440
执行

2862
02:00:21,330 --> 02:00:26,580
我给大家再捋一捋第一次执行比如说APP函数

2863
02:00:27,840 --> 02:00:29,550
那么第二次

2864
02:00:31,020 --> 02:00:32,370
执行APP函数

2865
02:00:37,180 --> 02:00:38,260
第一次之前比分数

2866
02:00:38,980 --> 02:00:40,600
第二次执行APP函数

2867
02:00:41,560 --> 02:00:43,150
那么第一次执行APP函数

2868
02:00:44,570 --> 02:00:46,010
比如我们的u state

2869
02:00:47,480 --> 02:00:49,610
那么他就用的是MT MT state

2870
02:00:51,220 --> 02:00:52,690
他就调的是mind EST

2871
02:00:52,720 --> 02:00:54,850
那么因为他是从零到有吗

2872
02:00:54,910 --> 02:00:56,230
所以他会创建列表

2873
02:00:56,710 --> 02:00:57,340
然后呢

2874
02:00:58,630 --> 02:01:00,460
默认值这这

2875
02:01:00,790 --> 02:01:02,530
然后会把state放在mistake

2876
02:01:02,530 --> 02:01:03,520
然后建一个queen

2877
02:01:04,420 --> 02:01:09,310
然后就返回这个其实我就是我们通过代码就是代码的调用

2878
02:01:09,310 --> 02:01:10,450
应该能明白这个事情

2879
02:01:10,450 --> 02:01:11,110
然后返回

2880
02:01:13,290 --> 02:01:17,280
最终是创建一个创建一个hooks

2881
02:01:18,320 --> 02:01:18,650
对不对

2882
02:01:18,650 --> 02:01:20,300
代码内部创建了一个hooks

2883
02:01:23,050 --> 02:01:23,650
然后

2884
02:01:25,110 --> 02:01:27,870
返回一个默认值

2885
02:01:29,940 --> 02:01:31,650
返回一个默认值和

2886
02:01:32,760 --> 02:01:33,420
更改

2887
02:01:36,190 --> 02:01:37,960
默认值的

2888
02:01:37,990 --> 02:01:39,490
Dispatch action

2889
02:01:40,060 --> 02:01:42,880
而且给他绑定了绑定了当前的fiber

2890
02:01:43,530 --> 02:01:43,740
好

2891
02:01:43,740 --> 02:01:44,970
可以这样子

2892
02:01:44,970 --> 02:01:46,110
能够唯一地找到

2893
02:01:46,110 --> 02:01:49,020
能够唯一地确定我们的X

2894
02:01:49,640 --> 02:01:51,620
我们的那个是哪个函数下的hooks

2895
02:01:52,390 --> 02:01:52,810
那么

2896
02:01:53,580 --> 02:01:55,200
这是这是第一步

2897
02:01:55,650 --> 02:01:57,000
那么第二步当调用

2898
02:01:57,540 --> 02:02:00,840
那么当调用dispatch action的时候

2899
02:02:04,700 --> 02:02:05,480
第二个场景

2900
02:02:06,940 --> 02:02:08,110
调用dispatch action的

2901
02:02:08,110 --> 02:02:09,190
也就是我们所谓的

2902
02:02:10,540 --> 02:02:12,970
发起字要更新state的时候嘛

2903
02:02:13,120 --> 02:02:13,420
对吧

2904
02:02:13,960 --> 02:02:16,510
要更新state的时候要更新state

2905
02:02:18,710 --> 02:02:20,180
他这儿就创建一个更新

2906
02:02:21,430 --> 02:02:22,390
添加的困呢

2907
02:02:28,190 --> 02:02:29,150
把这个更新

2908
02:02:29,540 --> 02:02:31,160
这个更新就要更改这个值

2909
02:02:33,080 --> 02:02:34,370
更改那个state

2910
02:02:37,870 --> 02:02:38,650
看一下state

2911
02:02:39,070 --> 02:02:39,700
然后呢

2912
02:02:40,270 --> 02:02:41,410
我们先不管优化

2913
02:02:41,440 --> 02:02:45,730
那么它最要紧的一步就是发起调用这个

2914
02:02:50,000 --> 02:02:52,820
我们先不管优化多少级优化

2915
02:02:52,820 --> 02:02:54,170
它就是会提前计算的

2916
02:02:54,200 --> 02:02:57,440
这个先不管由于调用了schedule up down cyber

2917
02:02:57,470 --> 02:03:00,380
所以我们的APP函数一定会在更新一次

2918
02:03:01,250 --> 02:03:01,700
对不对

2919
02:03:01,790 --> 02:03:03,980
我们的APP函数一定会再更新一次

2920
02:03:04,680 --> 02:03:06,180
那么它更新了一次之后

2921
02:03:06,690 --> 02:03:08,130
他首先找到之前的户口

2922
02:03:10,280 --> 02:03:11,840
他首先找到之前的户口

2923
02:03:12,290 --> 02:03:12,830
然后

2924
02:03:16,020 --> 02:03:16,920
返回

2925
02:03:18,040 --> 02:03:19,000
就是计算

2926
02:03:20,040 --> 02:03:21,150
计算那个action

2927
02:03:22,470 --> 02:03:23,340
得到

2928
02:03:24,880 --> 02:03:25,530
如果没有

2929
02:03:25,530 --> 02:03:27,730
没有优化的情况下得到最新的值

2930
02:03:29,620 --> 02:03:31,180
然后还是返回

2931
02:03:31,750 --> 02:03:33,160
返回一个最新的值

2932
02:03:34,510 --> 02:03:34,930
和

2933
02:03:37,070 --> 02:03:37,880
Dispatch action

2934
02:03:40,510 --> 02:03:42,760
Dispatch action要把它

2935
02:03:43,210 --> 02:03:46,090
如果我们把它当作两次更新来看

2936
02:03:46,300 --> 02:03:47,530
是会不会清晰一些

2937
02:03:48,730 --> 02:03:51,250
这样会不会清晰一些对

2938
02:03:52,230 --> 02:03:53,130
现在能理解吗

2939
02:03:56,750 --> 02:04:00,170
因为你这最关键一点就是你

2940
02:04:00,710 --> 02:04:04,250
需要通过这个dispatch action把他们两个给关联起来

2941
02:04:04,880 --> 02:04:05,390
关联起来

2942
02:04:05,390 --> 02:04:07,160
他们并不是一个割裂的过程

2943
02:04:07,370 --> 02:04:10,970
这就是react代码里比较难懂的一部分

2944
02:04:11,390 --> 02:04:12,110
你必须得

2945
02:04:12,380 --> 02:04:13,430
你必须得把他的

2946
02:04:14,150 --> 02:04:17,510
你你你你如果想要完整的调试他的话

2947
02:04:17,750 --> 02:04:18,920
你就得把它整个

2948
02:04:19,480 --> 02:04:23,920
就是整个那个价格都得有个大概的了解才可以

2949
02:04:24,370 --> 02:04:26,800
不然他后面如果再加一个什么新的功能

2950
02:04:27,100 --> 02:04:30,850
我相信他还是必须要依附在我们整个FAB价格之上

2951
02:04:31,440 --> 02:04:31,950
来做

2952
02:04:33,320 --> 02:04:35,030
来做这样来实现的新功能

2953
02:04:35,030 --> 02:04:36,350
所以同样有依赖感

2954
02:04:41,540 --> 02:04:44,180
新建的queen他是一个更新队列

2955
02:04:44,600 --> 02:04:47,450
同学们理解为是一个更新队列

2956
02:04:47,870 --> 02:04:51,200
然后你可以往你更新队列里面添加好几个更新

2957
02:04:51,900 --> 02:04:53,100
参加很多的更新

2958
02:04:53,280 --> 02:04:59,730
这些更新其实这些更新就是比如说你的a组件的name变了

2959
02:05:00,120 --> 02:05:00,960
B组建的

2960
02:05:02,440 --> 02:05:03,250
名字变了

2961
02:05:03,460 --> 02:05:06,340
那么他都是他都会认为是一个更新

2962
02:05:06,820 --> 02:05:07,210
对不对

2963
02:05:07,270 --> 02:05:08,290
这样的一个更新

2964
02:05:08,290 --> 02:05:09,760
后面的话会在

2965
02:05:10,450 --> 02:05:12,490
会在schedule up down files里

2966
02:05:13,190 --> 02:05:16,970
那么begin work里面的时候他就会

2967
02:05:17,960 --> 02:05:19,460
它就会创建fiber吗

2968
02:05:19,460 --> 02:05:20,390
创建新的fiber

2969
02:05:20,780 --> 02:05:21,410
然后呢

2970
02:05:21,830 --> 02:05:24,560
来给他计算他的更新是什么

2971
02:05:25,180 --> 02:05:27,130
到底该怎么处理这样子

2972
02:05:28,130 --> 02:05:29,270
所以每发几次更新

2973
02:05:29,270 --> 02:05:30,350
这个其实最right

2974
02:05:30,350 --> 02:05:31,610
也是一个常规操作

2975
02:05:32,280 --> 02:05:34,050
无论你是sits date也好

2976
02:05:35,390 --> 02:05:39,260
还是这个护士的这个这个的产品也好

2977
02:05:39,380 --> 02:05:41,030
它都是有一个queen

2978
02:05:41,270 --> 02:05:44,990
有个queen的depend喷的那个喷的里面

2979
02:05:45,650 --> 02:05:46,910
都会有一个更新的队列

2980
02:05:47,520 --> 02:05:48,360
就这样放下

2981
02:05:51,200 --> 02:05:51,410
好

2982
02:05:51,410 --> 02:05:54,470
我们hooks you state大概就讲这么多

2983
02:05:54,770 --> 02:05:56,240
接下来讲个you the fact

2984
02:05:56,750 --> 02:05:59,060
就讲这两个他们真的源码

2985
02:06:00,110 --> 02:06:00,980
You the fact

2986
02:06:03,490 --> 02:06:04,240
也比较简单

2987
02:06:05,120 --> 02:06:05,840
有有

2988
02:06:06,020 --> 02:06:08,540
但是他他和他和UC一样

2989
02:06:09,710 --> 02:06:11,510
他也是把

2990
02:06:12,360 --> 02:06:15,660
Mount阶段和up的阶段区分的非常的开

2991
02:06:15,990 --> 02:06:16,890
区分得非常开

2992
02:06:17,310 --> 02:06:20,610
比如浪子阶段的时候我们看一下

2993
02:06:22,470 --> 02:06:23,700
现在去看一下

2994
02:06:26,940 --> 02:06:28,020
Use effect

2995
02:06:33,730 --> 02:06:35,080
我们在看这些逻辑的时候

2996
02:06:35,080 --> 02:06:36,940
一定要牢记它的用法

2997
02:06:36,940 --> 02:06:38,530
我们要牢记它的用法才行

2998
02:06:39,920 --> 02:06:40,760
MT的时候

2999
02:06:41,030 --> 02:06:42,110
他要传一个函数

3000
02:06:43,390 --> 02:06:44,410
还差一个函数

3001
02:06:45,480 --> 02:06:46,260
第一个是一个函数

3002
02:06:46,260 --> 02:06:48,360
第二个是一个依赖数组

3003
02:06:48,480 --> 02:06:48,900
对不对

3004
02:06:48,960 --> 02:06:49,860
是依赖数组

3005
02:06:51,160 --> 02:06:53,020
在忙的阶段要做什么

3006
02:06:54,800 --> 02:06:56,570
忙的阶段

3007
02:06:57,110 --> 02:06:58,100
首先蒙阶段

3008
02:06:58,100 --> 02:06:58,520
毫无疑问

3009
02:06:58,520 --> 02:06:59,930
他并不需要怎么样了

3010
02:06:59,930 --> 02:07:00,260
同学们

3011
02:07:00,290 --> 02:07:03,740
他并不需要对比你的依赖值的变化

3012
02:07:04,370 --> 02:07:06,020
你直接无脑需要执行一遍

3013
02:07:06,440 --> 02:07:07,670
无脑执行一遍就行

3014
02:07:08,500 --> 02:07:09,070
但是呢

3015
02:07:09,160 --> 02:07:10,180
他可能会有什么

3016
02:07:10,180 --> 02:07:11,350
他可能会有自己的

3017
02:07:12,390 --> 02:07:13,110
Destroy

3018
02:07:13,140 --> 02:07:17,880
那个destroy就是它的类似于component will UN mount的东西

3019
02:07:18,180 --> 02:07:19,890
所以我们还是需要好好的

3020
02:07:21,960 --> 02:07:23,910
好的给它那个那个啥也行

3021
02:07:24,820 --> 02:07:25,210
的

3022
02:07:25,930 --> 02:07:26,860
嗯

3023
02:07:29,880 --> 02:07:31,170
我在这里先给大家捋一遍吧

3024
02:07:31,200 --> 02:07:32,670
免得一跳代码又蒙了

3025
02:07:34,630 --> 02:07:35,200
Use effect

3026
02:07:35,200 --> 02:07:36,460
我们用法是咋样

3027
02:07:37,120 --> 02:07:38,020
The fact

3028
02:07:43,820 --> 02:07:44,540
这样对不对

3029
02:07:44,630 --> 02:07:45,560
这是1FACT

3030
02:07:45,620 --> 02:07:45,980
同学们

3031
02:07:46,010 --> 02:07:46,820
这是effect

3032
02:07:47,540 --> 02:07:49,400
然后这是他的comeback

3033
02:07:53,450 --> 02:07:55,520
我们在调这个you the fact的时候

3034
02:07:55,880 --> 02:07:59,000
外面这个use effect就是注册阶段去注册的时候

3035
02:08:00,770 --> 02:08:03,620
毫无疑问她是在begin work的时候

3036
02:08:05,060 --> 02:08:06,260
begin work掉

3037
02:08:07,220 --> 02:08:08,000
APP的

3038
02:08:10,090 --> 02:08:13,450
函数题的时候是不是注册的u ti fact

3039
02:08:14,240 --> 02:08:16,340
把那个优积分给他注册上了吗

3040
02:08:16,820 --> 02:08:21,590
他这个当然他是Co BAC的执行还是在那个

3041
02:08:22,160 --> 02:08:23,450
页面渲染完成之后

3042
02:08:23,750 --> 02:08:24,800
页面渲染完成之后

3043
02:08:25,480 --> 02:08:26,980
所以当掉

3044
02:08:27,070 --> 02:08:28,630
所以当执行这块逻辑

3045
02:08:29,850 --> 02:08:31,890
当执行这个MT effect这个逻辑的时候

3046
02:08:31,920 --> 02:08:33,090
肯定在begin work里

3047
02:08:33,660 --> 02:08:33,840
对

3048
02:08:33,840 --> 02:08:35,160
在begin work那个阶段

3049
02:08:35,840 --> 02:08:36,170
对不对

3050
02:08:36,500 --> 02:08:39,470
那么在这我们看MT effect in July

3051
02:08:40,600 --> 02:08:44,140
这里同样也是创建一个户口

3052
02:08:44,820 --> 02:08:46,710
春节后可到这里

3053
02:08:48,730 --> 02:08:49,570
处理他的依赖

3054
02:08:50,080 --> 02:08:51,460
他的那个依赖值是多少

3055
02:08:51,670 --> 02:08:54,070
大家看这儿会给他设置一个flex

3056
02:08:54,580 --> 02:08:56,680
这个flag他认为因为这就是一个副作用

3057
02:08:56,890 --> 02:08:57,280
对不对

3058
02:08:57,280 --> 02:08:58,600
它本身you the flag

3059
02:08:58,600 --> 02:08:59,980
它本身就是一个副作用

3060
02:09:00,520 --> 02:09:02,380
所以无脑给他打成一个flag

3061
02:09:03,260 --> 02:09:04,730
再无脑给他打成一个flag

3062
02:09:05,450 --> 02:09:07,010
然后这个湖北的memories

3063
02:09:07,580 --> 02:09:09,020
大家看我这写了

3064
02:09:09,900 --> 02:09:10,770
有个注意事项

3065
02:09:11,190 --> 02:09:12,810
对于这个memory state

3066
02:09:12,810 --> 02:09:13,620
对于United States

3067
02:09:13,620 --> 02:09:15,390
我们刚刚讲讲讲过

3068
02:09:15,390 --> 02:09:16,470
对于United States来讲

3069
02:09:16,470 --> 02:09:18,870
它的memory state是存放它的初始值的

3070
02:09:19,380 --> 02:09:22,500
但是我们的u z fec他并没有初始值

3071
02:09:23,220 --> 02:09:26,190
他这个mistake它存放的是这样的一个对象

3072
02:09:27,110 --> 02:09:27,890
这样的一个对象

3073
02:09:27,890 --> 02:09:29,480
这个就是you the fact

3074
02:09:31,200 --> 02:09:34,140
的这个对象就是这个一负作用对象

3075
02:09:34,440 --> 02:09:36,180
这个tag我们讲一下

3076
02:09:36,180 --> 02:09:38,340
他肯定就是他的还是

3077
02:09:39,270 --> 02:09:41,100
节点的类型

3078
02:09:41,370 --> 02:09:42,210
Create

3079
02:09:42,890 --> 02:09:45,260
这个create就是

3080
02:09:46,880 --> 02:09:47,840
就是这个函数题

3081
02:09:47,900 --> 02:09:48,860
这个就是create

3082
02:09:50,330 --> 02:09:51,800
这个回调就是create

3083
02:09:54,500 --> 02:09:58,520
然后destroy destroy它实际上是这个

3084
02:09:59,120 --> 02:10:01,520
Create执行之后获得的

3085
02:10:02,120 --> 02:10:02,630
也就是说

3086
02:10:02,690 --> 02:10:03,890
那么在初始化的时候

3087
02:10:03,890 --> 02:10:05,510
他肯定是没有的题

3088
02:10:05,510 --> 02:10:08,300
所以后面我们会讲会看到他的在哪复制的

3089
02:10:09,360 --> 02:10:10,500
会看他在哪儿负责

3090
02:10:10,530 --> 02:10:11,880
他其实就是我们的

3091
02:10:12,540 --> 02:10:13,590
我们如果说

3092
02:10:14,410 --> 02:10:15,160
再给大家看

3093
02:10:15,550 --> 02:10:17,560
假如我在这里再扔一个

3094
02:10:21,540 --> 02:10:22,560
赞助他那个东西

3095
02:10:24,020 --> 02:10:25,640
那么这个return的这个函数

3096
02:10:26,290 --> 02:10:28,300
这个函数那么就是destroy

3097
02:10:28,630 --> 02:10:30,640
只是他现在还没有被赋值

3098
02:10:31,490 --> 02:10:32,930
Defense依赖next

3099
02:10:32,930 --> 02:10:33,950
下一个OK

3100
02:10:34,730 --> 02:10:37,070
这些都是常见的

3101
02:10:37,070 --> 02:10:38,030
这些都是常见的照

3102
02:10:38,330 --> 02:10:40,310
那么我们在MT阶段的时候

3103
02:10:40,310 --> 02:10:41,660
其实做的事情非常有限

3104
02:10:43,000 --> 02:10:46,570
出发地穿非常直接执行它本身的逻辑

3105
02:10:47,020 --> 02:10:48,640
打上了一个flex标记

3106
02:10:49,000 --> 02:10:49,630
然后呢

3107
02:10:49,660 --> 02:10:51,400
Push了一个effect

3108
02:10:51,730 --> 02:10:52,240
大家注意

3109
02:10:52,920 --> 02:10:53,820
他打上了标记

3110
02:10:53,820 --> 02:10:56,040
铺起了一个effect就完了

3111
02:10:56,040 --> 02:10:57,780
大家之前有同学就问了

3112
02:10:57,780 --> 02:11:00,780
就说老师他的函数题怎么没有执行

3113
02:11:01,260 --> 02:11:04,380
就是它的这个它这个回调怎么没有执行

3114
02:11:04,680 --> 02:11:05,430
这别晕

3115
02:11:05,430 --> 02:11:07,680
它回调不是在这个阶段执行的

3116
02:11:08,220 --> 02:11:09,990
他现在还在创建发展阶段

3117
02:11:10,940 --> 02:11:13,280
他所以现在只是打上一个标记

3118
02:11:13,520 --> 02:11:14,540
他的这个effect呢

3119
02:11:14,540 --> 02:11:16,670
肯定要在

3120
02:11:17,400 --> 02:11:19,110
当创建之后才会执行

3121
02:11:19,560 --> 02:11:20,670
当创建之后才会执行

3122
02:11:20,700 --> 02:11:23,580
那么就可以接下来我们就可以来到跟随

3123
02:11:24,210 --> 02:11:27,360
跟随我们整个的fiber架构的构建

3124
02:11:27,360 --> 02:11:28,680
我们可以来到commit阶段

3125
02:11:28,710 --> 02:11:30,390
假如就在layout if it阶段

3126
02:11:30,930 --> 02:11:32,520
它就会执行这个方法

3127
02:11:32,910 --> 02:11:33,480
然后呢

3128
02:11:33,690 --> 02:11:35,490
在这里会执行create的方法

3129
02:11:36,600 --> 02:11:38,760
我们可以看一下这就是

3130
02:11:39,610 --> 02:11:41,380
真正执行这个函数体的时候

3131
02:11:41,710 --> 02:11:42,700
它肯定是在

3132
02:11:46,550 --> 02:11:48,650
真正执行这个函数是大家看

3133
02:11:50,910 --> 02:11:51,660
Create

3134
02:11:52,540 --> 02:11:52,810
对吧

3135
02:11:52,870 --> 02:11:53,800
可爱的存在

3136
02:11:54,340 --> 02:11:55,360
那么它执行了

3137
02:11:55,960 --> 02:11:56,500
然后呢

3138
02:11:56,650 --> 02:11:58,690
把它的结果复制给了destroy

3139
02:11:59,930 --> 02:12:01,250
结果复制给他的处理

3140
02:12:01,250 --> 02:12:02,240
然后再来下一个

3141
02:12:02,570 --> 02:12:04,220
然后再慢慢的递归

3142
02:12:04,520 --> 02:12:11,510
递归就是说之前有同学有疑问的点在哪执行use effect本身的这个注册逻辑的时候

3143
02:12:11,780 --> 02:12:13,490
他只做了这么两件事情

3144
02:12:13,940 --> 02:12:15,470
然后有同学就搞不明白

3145
02:12:15,620 --> 02:12:18,680
它的它的回调为什么没有执行

3146
02:12:18,710 --> 02:12:21,230
就是为什么没有没有代码来执行

3147
02:12:22,380 --> 02:12:23,100
原因是因为

3148
02:12:23,580 --> 02:12:24,390
原因是因为

3149
02:12:25,650 --> 02:12:28,380
原因是因为他不像我们写的那个简单的DEMO

3150
02:12:28,380 --> 02:12:29,040
那个样子

3151
02:12:29,430 --> 02:12:29,880
那个样子

3152
02:12:29,880 --> 02:12:30,390
那么剪

3153
02:12:30,390 --> 02:12:31,110
那么简单

3154
02:12:31,320 --> 02:12:34,110
它需要把它挂载在整个react

3155
02:12:34,790 --> 02:12:36,710
React价格之上来做

3156
02:12:37,070 --> 02:12:39,680
那么你只要给他打上一个flag标记

3157
02:12:39,830 --> 02:12:41,000
Push了一个effect

3158
02:12:41,240 --> 02:12:45,290
那么在layout的这么个阶段里在执行

3159
02:12:46,110 --> 02:12:49,590
在执行相对应来处理这个IP的逻辑就行了

3160
02:12:50,820 --> 02:12:53,220
因此在我们也看到他执行的快的方法

3161
02:12:53,520 --> 02:12:55,530
然后有反馈的就反馈给了destroy

3162
02:12:57,040 --> 02:12:58,120
在这儿能理解吗

3163
02:12:58,950 --> 02:13:04,050
关于她和她函数和关于you the fact和它的回调

3164
02:13:04,050 --> 02:13:06,030
这个执行的时机这块有理解到吗

3165
02:13:06,060 --> 02:13:07,470
同学们理解到的扣个一

3166
02:13:08,010 --> 02:13:09,090
没理解到扣个零

3167
02:13:15,680 --> 02:13:16,070
嗯

3168
02:13:16,700 --> 02:13:17,840
所以我们讲hooks

3169
02:13:17,840 --> 02:13:19,490
我我觉得他不是很困难的

3170
02:13:19,490 --> 02:13:21,470
原因就是我每次讲话时

3171
02:13:21,470 --> 02:13:23,450
大家后面都能听明白

3172
02:13:23,930 --> 02:13:28,550
听能听明白的一个很大的一个原因就是前面儿是懂了

3173
02:13:29,120 --> 02:13:30,170
在前面是懂的

3174
02:13:30,500 --> 02:13:32,000
那么这个逻辑就没有问题

3175
02:13:32,270 --> 02:13:34,400
不然绝对绝对搞不明白

3176
02:13:36,570 --> 02:13:37,980
这第一

3177
02:13:38,850 --> 02:13:39,450
不是的

3178
02:13:40,120 --> 02:13:41,560
相当于时间表不是

3179
02:13:42,520 --> 02:13:45,760
Use effect这个依赖它是一个数组

3180
02:13:46,210 --> 02:13:47,260
这儿的是一个数组

3181
02:13:47,260 --> 02:13:48,100
它不是列表

3182
02:13:49,080 --> 02:13:50,460
比如说ABI

3183
02:13:50,820 --> 02:13:51,990
它不是个列表

3184
02:13:52,620 --> 02:13:53,850
Hooks列表是啥

3185
02:13:54,360 --> 02:13:56,490
Hooks列表是五个fiber对象上

3186
02:14:01,730 --> 02:14:03,110
比如说这个February

3187
02:14:03,110 --> 02:14:05,000
像他有个属性叫什么state

3188
02:14:05,390 --> 02:14:06,770
比如我弟那个use date

3189
02:14:06,770 --> 02:14:07,490
它是一个

3190
02:14:08,140 --> 02:14:08,590
X

3191
02:14:09,240 --> 02:14:11,190
Dinner you the facts you hooks

3192
02:14:11,700 --> 02:14:15,270
第10X这个X线表儿

3193
02:14:15,390 --> 02:14:16,620
比如这个use effect

3194
02:14:17,220 --> 02:14:18,360
它有两个参数嘛

3195
02:14:18,540 --> 02:14:18,930
对吧

3196
02:14:19,290 --> 02:14:21,330
第一个参数就是它

3197
02:14:22,680 --> 02:14:24,810
第二个参数就是它这个是它的依赖速度

3198
02:14:25,470 --> 02:14:28,230
这一个数字是指和她有关的

3199
02:14:28,410 --> 02:14:29,250
只和她有关的

3200
02:14:29,670 --> 02:14:31,770
和这个链表本身没有太大的关系

3201
02:14:31,860 --> 02:14:32,490
能理解吗

3202
02:14:36,470 --> 02:14:37,670
Use the fact

3203
02:14:39,940 --> 02:14:41,950
A commit TE可以发给list month

3204
02:14:41,950 --> 02:14:42,820
这个干嘛来着

3205
02:14:46,270 --> 02:14:46,870
这个

3206
02:14:47,110 --> 02:14:47,620
这个

3207
02:14:47,650 --> 02:14:49,840
Commit TE KI fec ti sta MT

3208
02:14:51,410 --> 02:14:56,660
这个是在我们所讲白天所讲的这个render过程的这三个阶段

3209
02:14:57,490 --> 02:15:00,130
第一个阶段是当操作前

3210
02:15:00,310 --> 02:15:01,660
第二个阶段当操作中

3211
02:15:01,810 --> 02:15:03,160
第三个阶段操作后

3212
02:15:03,550 --> 02:15:05,080
再当操作后之后

3213
02:15:06,130 --> 02:15:11,290
这个layout会执行这个come come it lay out the effect

3214
02:15:11,650 --> 02:15:13,240
在这个函数里

3215
02:15:13,240 --> 02:15:14,740
他对于hooks

3216
02:15:14,740 --> 02:15:17,230
就对于对于那个function component

3217
02:15:17,500 --> 02:15:20,590
他会再调一个commit或beef at least MT

3218
02:15:22,180 --> 02:15:22,690
然后呢

3219
02:15:22,690 --> 02:15:27,160
来执行我们的you the fact的这个回调逻辑

3220
02:15:27,950 --> 02:15:32,060
也就是因为我们usage相当于component did mount吗

3221
02:15:32,090 --> 02:15:33,530
他肯定在这个阶段执行

3222
02:15:34,180 --> 02:15:35,230
执行那个回调逻辑

3223
02:15:35,230 --> 02:15:37,330
它是把它单独放到这个方法里面的

3224
02:15:39,250 --> 02:15:40,030
The fact but

3225
02:15:40,030 --> 02:15:43,000
为啥不能直接使用a sync的原因

3226
02:15:45,120 --> 02:15:47,490
Call back为啥不能直接使用think

3227
02:15:50,420 --> 02:15:51,080
嗯

3228
02:15:52,130 --> 02:15:53,330
他这里没有支持

3229
02:15:53,510 --> 02:15:54,890
你看大家看

3230
02:15:55,340 --> 02:15:56,930
如果你要直线I think的话

3231
02:15:58,210 --> 02:15:59,560
那么我这里应该怎么调

3232
02:15:59,980 --> 02:16:02,020
那么我这儿是不是要给他写一个sin卡

3233
02:16:07,250 --> 02:16:08,300
那我是不是得这么写

3234
02:16:10,200 --> 02:16:11,340
我得这么写才行吧

3235
02:16:11,460 --> 02:16:11,880
对不对

3236
02:16:12,390 --> 02:16:14,070
REC他在处理这个

3237
02:16:14,520 --> 02:16:16,410
REC他在处理这个CAD的时候

3238
02:16:16,410 --> 02:16:18,510
就是把它当做的是一个同步的方法

3239
02:16:18,780 --> 02:16:19,950
同步的方法来做了

3240
02:16:20,550 --> 02:16:25,140
所以你没办法直接在里面用think如果你实在想用

3241
02:16:25,170 --> 02:16:27,330
那么那么你的最外层肯定

3242
02:16:27,540 --> 02:16:29,820
那如果你实在是想用的话

3243
02:16:29,820 --> 02:16:31,500
你只能这么写

3244
02:16:31,740 --> 02:16:33,300
其实应该你也明白对不对

3245
02:16:33,300 --> 02:16:36,420
不然你也不会说直接直接不能直接用

3246
02:16:37,170 --> 02:16:38,430
如果你实在想用的话

3247
02:16:38,430 --> 02:16:41,040
你可以在你可以在里边定义一个

3248
02:16:42,300 --> 02:16:42,900
Pasta

3249
02:16:47,080 --> 02:16:47,380
A

3250
02:16:47,380 --> 02:16:48,070
等于

3251
02:16:49,180 --> 02:16:49,750
来

3252
02:16:51,550 --> 02:16:54,370
如果你再想用那些在里面怎么用

3253
02:16:55,450 --> 02:16:57,100
这个我我觉得同学应该明白

3254
02:16:57,100 --> 02:16:59,200
不然不然不会这么问对吧

3255
02:16:59,870 --> 02:17:01,460
但他这他确实没有做支持

3256
02:17:01,970 --> 02:17:02,930
但是确实没做支持

3257
02:17:02,930 --> 02:17:04,190
我一看到这个逻辑

3258
02:17:14,080 --> 02:17:14,620
好了

3259
02:17:14,860 --> 02:17:15,850
继续往下讲了

3260
02:17:19,200 --> 02:17:20,790
这是MT阶段的事情

3261
02:17:21,730 --> 02:17:22,330
然后呢

3262
02:17:25,340 --> 02:17:27,050
Update其实就比较简单了

3263
02:17:27,200 --> 02:17:29,450
首先给destroy副职

3264
02:17:30,540 --> 02:17:32,280
Update effect destroy负责

3265
02:17:32,280 --> 02:17:34,620
因为我们这个时候很有可能已经有destroy了

3266
02:17:35,190 --> 02:17:36,900
然后就对比依赖有没有变化

3267
02:17:36,900 --> 02:17:37,980
这个一样

3268
02:17:38,490 --> 02:17:39,420
打上flag标记

3269
02:17:39,420 --> 02:17:39,930
这个一样

3270
02:17:39,930 --> 02:17:40,290
因为

3271
02:17:40,560 --> 02:17:41,940
因为它还是一个副作用

3272
02:17:42,060 --> 02:17:43,410
再普及一个you the fact

3273
02:17:44,850 --> 02:17:46,020
Up的effect

3274
02:17:46,440 --> 02:17:48,150
我们把那个猫的effect加

3275
02:17:48,150 --> 02:17:49,140
如果理解了的话

3276
02:17:49,200 --> 02:17:52,530
Update就就其实没有什么难度了

3277
02:17:53,540 --> 02:17:57,590
再看这同样是找到还是找到

3278
02:17:58,590 --> 02:17:59,640
对应的hook

3279
02:17:59,820 --> 02:18:00,750
找到对应的户口

3280
02:18:02,060 --> 02:18:05,150
这和之前我们那个简版的写法是一样的

3281
02:18:06,130 --> 02:18:07,150
看他有没有变化

3282
02:18:07,240 --> 02:18:09,580
如果这里只是发生了变化的话

3283
02:18:10,060 --> 02:18:12,850
那么就谱写一个新的effect记上去

3284
02:18:13,550 --> 02:18:14,300
只发生了变化

3285
02:18:14,300 --> 02:18:16,280
这就是因为变化了之后嘛

3286
02:18:16,670 --> 02:18:18,410
它它的功能就是变化了之后

3287
02:18:19,690 --> 02:18:21,460
要更新要更新对不对

3288
02:18:22,140 --> 02:18:22,920
所以才谱写

3289
02:18:22,950 --> 02:18:23,880
否则就不谱写

3290
02:18:24,330 --> 02:18:25,050
然后第一次错

3291
02:18:25,050 --> 02:18:25,890
你看有没有直

3292
02:18:26,070 --> 02:18:27,420
如果第一次错有值的话

3293
02:18:28,520 --> 02:18:30,500
那么就把这个题是错也不写上去

3294
02:18:30,980 --> 02:18:34,040
她在卸载的时候就会调用这个低级错误

3295
02:18:35,030 --> 02:18:35,540
其实

3296
02:18:36,160 --> 02:18:38,080
这个例子所以就是它调用时机

3297
02:18:38,260 --> 02:18:41,080
调用时机就在卸载的那个时候会调用

3298
02:18:41,140 --> 02:18:42,400
这个我就不给大家发代码

3299
02:18:42,940 --> 02:18:44,620
就很其实就非常简单了

3300
02:18:44,860 --> 02:18:47,950
他就在就在where a r MT那个差不多那个位置

3301
02:18:48,670 --> 02:18:49,180
把他

3302
02:18:49,270 --> 02:18:51,820
然后他的归的归我们所有的effect

3303
02:18:51,820 --> 02:18:54,130
看有没有destroy destroy就执行一下

3304
02:18:54,370 --> 02:18:54,940
非常简单

3305
02:18:55,520 --> 02:18:56,930
然后设置一下塔

3306
02:18:57,170 --> 02:18:58,010
这都是一样的

3307
02:18:58,430 --> 02:18:59,090
这都是一样的

3308
02:19:01,280 --> 02:19:01,730
好

3309
02:19:02,030 --> 02:19:02,930
这就是我们

3310
02:19:04,140 --> 02:19:04,800
嗯

3311
02:19:05,970 --> 02:19:07,590
Effect就是effect

3312
02:19:08,610 --> 02:19:09,000
得空了

3313
02:19:09,000 --> 02:19:10,200
我再给大家捋一捋

3314
02:19:10,350 --> 02:19:11,610
The fact首先

3315
02:19:13,260 --> 02:19:14,040
注册的时候

3316
02:19:14,310 --> 02:19:17,280
他在begin work里调APP函数体的时候

3317
02:19:17,520 --> 02:19:18,300
它会掉这个

3318
02:19:18,390 --> 02:19:21,300
它会执行use effect本身的逻辑

3319
02:19:21,360 --> 02:19:22,080
什么逻辑呢

3320
02:19:23,060 --> 02:19:23,960
打上一个标记

3321
02:19:23,990 --> 02:19:24,830
突袭一个

3322
02:19:25,720 --> 02:19:26,050
答

3323
02:19:26,080 --> 02:19:27,280
打上一个flex标记

3324
02:19:27,460 --> 02:19:29,140
然后push一个effect

3325
02:19:29,470 --> 02:19:32,770
但是这个时候并不并不执行他的comeback

3326
02:19:33,190 --> 02:19:34,030
并不是comeback

3327
02:19:34,510 --> 02:19:34,900
然后呢

3328
02:19:34,900 --> 02:19:40,000
再commit阶段的layout effect阶段其实也就是

3329
02:19:40,650 --> 02:19:42,750
Down更新之后的那个阶段

3330
02:19:43,910 --> 02:19:45,170
他执行的这个方法

3331
02:19:45,200 --> 02:19:50,960
这个方法就是专门来处理hooks的这个effect的执行的correct有反馈

3332
02:19:50,960 --> 02:19:52,130
直接反馈给destroy

3333
02:19:53,240 --> 02:19:54,920
就做了这么一件事情

3334
02:19:55,040 --> 02:19:55,760
做这件事情

3335
02:19:56,330 --> 02:19:57,680
如果state发生了变化

3336
02:19:58,130 --> 02:19:58,520
那么

3337
02:19:59,930 --> 02:20:01,520
接下来函数体执行的时候

3338
02:20:01,520 --> 02:20:03,200
它就会掉update的effect

3339
02:20:04,010 --> 02:20:05,810
这个是首先他要给的错误

3340
02:20:05,810 --> 02:20:06,740
回去给他赋值

3341
02:20:07,360 --> 02:20:07,930
复制之后

3342
02:20:07,930 --> 02:20:10,600
把他的所以也复制给那个effect

3343
02:20:10,930 --> 02:20:12,760
然后重新发起一个effect

3344
02:20:14,440 --> 02:20:15,430
然后打上标记

3345
02:20:15,670 --> 02:20:16,480
把它普及一下

3346
02:20:17,600 --> 02:20:19,550
然后在lear在咖啡的阶段

3347
02:20:20,280 --> 02:20:26,040
那么如果如果说在组件卸载的时候会自行destroy

3348
02:20:26,070 --> 02:20:28,830
这个方法其实我给他列在这里了

3349
02:20:29,980 --> 02:20:30,490
如果

3350
02:20:31,000 --> 02:20:32,230
如果

3351
02:20:34,790 --> 02:20:39,200
然后就接着执行那个就是由由于这个存在的时候就是有变化的

3352
02:20:39,200 --> 02:20:39,890
有更新的时候

3353
02:20:39,920 --> 02:20:42,170
又在执行一次这个方法

3354
02:20:42,200 --> 02:20:44,030
去把那个跟右直行是correct

3355
02:20:44,680 --> 02:20:46,690
然后如果有的错误有返回值

3356
02:20:46,690 --> 02:20:48,370
又把这个返回值赋值给的错误

3357
02:20:48,640 --> 02:20:51,250
其实更新阶段相比于

3358
02:20:52,340 --> 02:20:53,180
Com BI的阶段

3359
02:20:53,980 --> 02:20:57,190
多了一个事情就是依赖只有变化

3360
02:20:57,640 --> 02:20:59,590
变化的时候就重新发起一个

3361
02:21:00,200 --> 02:21:00,830
Effect

3362
02:21:02,570 --> 02:21:03,080
编号

3363
02:21:03,080 --> 02:21:04,280
重新发起一个fat

3364
02:21:04,280 --> 02:21:05,690
其他的其实都差不多

3365
02:21:06,340 --> 02:21:07,000
都差不多一样

3366
02:21:07,000 --> 02:21:10,810
而且第二个变化是他可能会有的错儿

3367
02:21:11,500 --> 02:21:12,250
他可能有第四

3368
02:21:12,250 --> 02:21:13,300
如果有的错的话

3369
02:21:13,300 --> 02:21:15,940
就把他的错也复制给这个object就行

3370
02:21:16,150 --> 02:21:18,040
就就就这儿不一样的

3371
02:21:18,520 --> 02:21:19,360
如果有

3372
02:21:20,610 --> 02:21:22,890
但如果有destroy

3373
02:21:23,310 --> 02:21:26,160
他的这个destroy也给到了这个IP的内部

3374
02:21:28,060 --> 02:21:28,390
嗯

3375
02:21:30,530 --> 02:21:30,890
对吧

3376
02:21:30,980 --> 02:21:33,470
他也把他就把这个地址可以直接复制给他

3377
02:21:34,180 --> 02:21:36,100
那么当需要用到它的时候

3378
02:21:36,250 --> 02:21:37,510
就是在逐渐卸载的时候

3379
02:21:37,660 --> 02:21:38,380
就把它调一下

3380
02:21:38,860 --> 02:21:40,540
所以use the fact he

3381
02:21:41,500 --> 02:21:43,900
Use date的源码大概就是这个样子

3382
02:21:44,440 --> 02:21:47,530
会比会比我们的那个简版要复杂一点

3383
02:21:48,010 --> 02:21:49,570
要复杂的地方主要在哪

3384
02:21:49,600 --> 02:21:54,220
主要在于因为主要在于它要是配我们整个react的价格

3385
02:21:55,780 --> 02:21:56,140
在哪儿

3386
02:21:56,140 --> 02:21:56,740
能理解吗

3387
02:21:56,770 --> 02:21:57,760
能理解的扣个一

3388
02:21:58,800 --> 02:21:59,730
本人也开个呢

3389
02:22:01,020 --> 02:22:01,980
配的应该还好吧

3390
02:22:02,520 --> 02:22:02,910
是吧

3391
02:22:03,330 --> 02:22:04,560
他其实就多了一点吗

3392
02:22:06,780 --> 02:22:07,200
OK

3393
02:22:07,230 --> 02:22:08,610
我们就暂时想这两个了

3394
02:22:09,090 --> 02:22:10,260
然后我们来看一下

3395
02:22:12,380 --> 02:22:14,330
这个时期的

3396
02:22:14,330 --> 02:22:16,610
其实这个没有什么好讲的就是

3397
02:22:17,390 --> 02:22:18,530
以前的结擦

3398
02:22:20,060 --> 02:22:21,140
他新特性吗

3399
02:22:21,140 --> 02:22:25,790
这个如果说面试官说X最近有什么新特性

3400
02:22:26,790 --> 02:22:28,020
然后有什么新特性

3401
02:22:28,050 --> 02:22:29,370
比如REC17讲了

3402
02:22:29,370 --> 02:22:32,760
这个旧的JSX转换会把GSX

3403
02:22:33,660 --> 02:22:34,740
他那不转变的时候

3404
02:22:34,740 --> 02:22:37,470
会把它转变成reckon create element对不对

3405
02:22:37,740 --> 02:22:41,700
所以如果我们以前要用的时候

3406
02:22:41,760 --> 02:22:42,720
比如我们这样用

3407
02:22:43,690 --> 02:22:44,560
所以报错了

3408
02:22:44,590 --> 02:22:47,170
为啥他因为他的JESCA

3409
02:22:48,400 --> 02:22:49,480
我们转换之后

3410
02:22:49,480 --> 02:22:52,090
它就会变成react.create element

3411
02:22:52,330 --> 02:22:52,810
所以呢

3412
02:22:52,810 --> 02:22:54,490
React必须要引用

3413
02:22:55,290 --> 02:22:55,830
明白吗

3414
02:22:55,830 --> 02:22:56,160
冉

3415
02:22:56,160 --> 02:22:57,060
你必须要加上

3416
02:22:57,060 --> 02:22:58,530
你不加上他会报错的

3417
02:22:59,540 --> 02:23:01,280
就算你没有感觉你没有用

3418
02:23:01,430 --> 02:23:02,390
没有你直接用

3419
02:23:02,420 --> 02:23:03,110
但实际上

3420
02:23:04,160 --> 02:23:04,700
你用了

3421
02:23:04,730 --> 02:23:05,780
但实际上你用了

3422
02:23:07,980 --> 02:23:09,450
如果是新的话就不用了

3423
02:23:09,480 --> 02:23:11,880
如果是新的REC17

3424
02:23:12,060 --> 02:23:15,720
那么它就变成它的编译之后就变异成这个样子

3425
02:23:16,310 --> 02:23:17,390
你就不需要

3426
02:23:18,220 --> 02:23:19,600
再再引一个react

3427
02:23:21,310 --> 02:23:21,880
这个地方

3428
02:23:21,910 --> 02:23:26,200
其实它就方便你把GSX这块逻辑也能够给剥离出来

3429
02:23:27,180 --> 02:23:28,710
玻璃是加了这么一个东西

3430
02:23:29,400 --> 02:23:29,820
然后呢

3431
02:23:29,820 --> 02:23:31,110
事件委托也有变化

3432
02:23:32,020 --> 02:23:36,070
但是在black事件系统显示他自己封装的事件系统

3433
02:23:36,640 --> 02:23:38,710
他这个事件系统呢

3434
02:23:39,510 --> 02:23:41,580
他并不是因为rock的live绑定的时候

3435
02:23:41,580 --> 02:23:43,380
并不是绑定的真实的当吗

3436
02:23:43,500 --> 02:23:43,860
对吧

3437
02:23:44,010 --> 02:23:45,540
不是绑定绑定的真实的

3438
02:23:45,960 --> 02:23:48,240
所以它是利用的是事件委托

3439
02:23:48,660 --> 02:23:52,110
就是把一个就是把真正的

3440
02:23:52,680 --> 02:23:55,590
绑定事件绑定在了自己的根节点

3441
02:23:55,980 --> 02:23:58,110
绑定之前是绑定在document节点

3442
02:23:58,500 --> 02:24:03,810
在以下十十七之前是绑定的document之前哒哒的节点

3443
02:24:03,990 --> 02:24:06,420
比如说你在比如你在一个div上

3444
02:24:06,420 --> 02:24:09,930
你自己写的div上绑定了一个on click实际上

3445
02:24:10,690 --> 02:24:14,860
实际上真实真实的事就是真实的浏览器跑的时候

3446
02:24:15,480 --> 02:24:16,680
你的你的那个

3447
02:24:18,200 --> 02:24:19,640
那个第二节点上

3448
02:24:19,970 --> 02:24:21,230
他确实有一个事件

3449
02:24:21,860 --> 02:24:22,940
他确实有一个事件

3450
02:24:23,000 --> 02:24:23,480
这个事件

3451
02:24:23,480 --> 02:24:26,270
但这个事件是一个空的一个空的

3452
02:24:27,970 --> 02:24:29,320
更早的版本是没有

3453
02:24:29,740 --> 02:24:30,730
现在是有一个空的

3454
02:24:30,730 --> 02:24:31,450
大家可以去看

3455
02:24:31,510 --> 02:24:32,590
其实是有的是有

3456
02:24:32,740 --> 02:24:33,640
但是是个空的

3457
02:24:34,000 --> 02:24:39,760
他用的最终响应事件还是响应的是document.create element document

3458
02:24:39,760 --> 02:24:42,160
点那个ADD listener

3459
02:24:43,110 --> 02:24:45,270
大概的点呢

3460
02:24:45,910 --> 02:24:46,810
添加listener

3461
02:24:46,930 --> 02:24:48,310
在document上响应的

3462
02:24:48,940 --> 02:24:49,420
然后呢

3463
02:24:50,100 --> 02:24:50,940
这个事件委托

3464
02:24:50,940 --> 02:24:52,020
这就是一个事件委托

3465
02:24:53,050 --> 02:24:55,150
但是如果一考虑到一个问题

3466
02:24:55,150 --> 02:24:57,130
你的页面上如果有多个reg版本的话

3467
02:24:57,130 --> 02:24:57,820
就会出问题

3468
02:24:57,880 --> 02:24:59,950
因为他们都住在顶层的

3469
02:25:00,620 --> 02:25:03,560
所以这种嵌套结构阻止的事件冒泡

3470
02:25:03,980 --> 02:25:08,420
因此wrecked实际中react不再向document附加事件处理器

3471
02:25:08,810 --> 02:25:13,400
而将事件处理器添加到了react树的根当容器之中

3472
02:25:14,090 --> 02:25:15,380
也就是说如果我们这样写

3473
02:25:15,410 --> 02:25:17,600
我们因为APP里是可以写多个Ren de you

3474
02:25:18,360 --> 02:25:21,570
多个人热点忍者都可以对不对那么

3475
02:25:22,750 --> 02:25:25,060
这个APP里面的事件都注册在他上

3476
02:25:25,510 --> 02:25:27,580
Head里面所有的建筑在踏上

3477
02:25:27,970 --> 02:25:29,560
Food里面的建筑在他上

3478
02:25:29,560 --> 02:25:31,090
你就算有这样子的话

3479
02:25:31,090 --> 02:25:33,430
就把它给区分开了

3480
02:25:34,110 --> 02:25:36,360
这是他时间委托做了新的更新

3481
02:25:37,180 --> 02:25:38,230
然后现在就是

3482
02:25:39,200 --> 02:25:41,630
这两点X17加的

3483
02:25:42,940 --> 02:25:43,270
S8

3484
02:25:44,410 --> 02:25:45,940
X8也带来了一些新的变化

3485
02:25:48,050 --> 02:25:49,190
He人十堰是个啥

3486
02:25:49,880 --> 02:25:50,510
嗯

3487
02:25:52,820 --> 02:25:55,100
和城市间就是REC的

3488
02:25:56,380 --> 02:25:58,240
事件首先来个事件

3489
02:26:00,080 --> 02:26:03,740
他并不是我们刚刚讲了REC的他

3490
02:26:04,010 --> 02:26:05,570
因为它是属于那个VLAN嘛

3491
02:26:05,570 --> 02:26:06,560
对不对

3492
02:26:07,010 --> 02:26:07,520
We大

3493
02:26:07,940 --> 02:26:11,900
所以它的事件首先是全部利用的事件委托

3494
02:26:12,350 --> 02:26:12,920
然后呢

3495
02:26:13,420 --> 02:26:15,250
他内部由于他想要

3496
02:26:15,250 --> 02:26:16,990
他还要区分

3497
02:26:16,990 --> 02:26:18,640
比如说他要区分你的优先级

3498
02:26:19,260 --> 02:26:20,340
这个区分优先级

3499
02:26:20,670 --> 02:26:23,310
那么它在它的这个事件响应的过程当中

3500
02:26:23,850 --> 02:26:25,590
那么他就还会做一些事情

3501
02:26:26,450 --> 02:26:27,890
他就还会这些事情

3502
02:26:28,010 --> 02:26:30,290
所谓的所谓的那个

3503
02:26:30,860 --> 02:26:32,810
和城市间随着合成事件

3504
02:26:33,740 --> 02:26:35,390
想一下这个名词是否是

3505
02:26:36,200 --> 02:26:38,570
这个名词是否是准确的

3506
02:26:39,370 --> 02:26:40,780
还有和四季

3507
02:26:42,190 --> 02:26:43,750
看一下看一下这块代码吧

3508
02:26:44,640 --> 02:26:46,350
应该能找到

3509
02:26:53,100 --> 02:26:53,490
Touch

3510
02:26:56,620 --> 02:26:58,090
他真的对吧

3511
02:26:58,090 --> 02:26:58,810
当疑问词

3512
02:27:02,920 --> 02:27:09,100
他在调这个事件之前谁掉这个事件是通过委托的形式转发的

3513
02:27:09,700 --> 02:27:10,060
第二

3514
02:27:10,090 --> 02:27:11,440
他在调这个事件之前

3515
02:27:11,740 --> 02:27:12,940
他实际上做了一些事情

3516
02:27:22,300 --> 02:27:23,560
有这么多的

3517
02:27:31,380 --> 02:27:32,040
是这个吗

3518
02:27:32,070 --> 02:27:33,900
我看看有点忘了

3519
02:27:42,880 --> 02:27:45,250
老同学很棒同学

3520
02:27:45,250 --> 02:27:46,780
之前看过原码是吗

3521
02:27:49,490 --> 02:27:50,720
很棒

3522
02:27:53,280 --> 02:27:54,210
性格问题

3523
02:27:56,140 --> 02:27:57,580
三个院子的结实

3524
02:28:27,490 --> 02:28:28,270
我要找

3525
02:28:30,090 --> 02:28:31,170
我要找那个

3526
02:28:32,770 --> 02:28:33,550
挺多的

3527
02:28:50,200 --> 02:28:52,000
因为我没找到想要找的东西

3528
02:28:53,750 --> 02:28:54,170
嗯

3529
02:28:58,410 --> 02:28:59,310
是这个吗

3530
02:29:26,000 --> 02:29:27,470
我没有找到想要找的东西

3531
02:29:27,500 --> 02:29:28,910
不过大概的逻辑的话

3532
02:29:29,920 --> 02:29:30,610
大概逻辑的话

3533
02:29:30,700 --> 02:29:32,980
大概逻辑的话是它并不是

3534
02:29:32,980 --> 02:29:37,270
它并不是一个就是我们react里面的事件

3535
02:29:37,270 --> 02:29:38,140
他和那个圆

3536
02:29:38,170 --> 02:29:43,480
它并不是直接就调用的那个浏览器的原生时间

3537
02:29:43,570 --> 02:29:44,350
因为我知道

3538
02:29:45,950 --> 02:29:46,670
有这

3539
02:29:49,740 --> 02:29:50,460
你再把他给

3540
02:29:51,210 --> 02:29:52,590
再把它给包了一下是吧

3541
02:29:52,950 --> 02:29:53,550
Even TE

3542
02:29:54,170 --> 02:29:55,100
你的face

3543
02:29:56,140 --> 02:29:57,340
Even interface

3544
02:29:58,150 --> 02:29:59,320
他是一个模拟的

3545
02:29:59,440 --> 02:30:00,520
模拟的一个事件

3546
02:30:01,030 --> 02:30:01,840
模拟一个事件

3547
02:30:01,840 --> 02:30:02,260
然后

3548
02:30:03,090 --> 02:30:03,960
在这个地方

3549
02:30:05,410 --> 02:30:09,130
他实现了几个实践中的几个方法

3550
02:30:09,990 --> 02:30:10,500
然后呢

3551
02:30:10,890 --> 02:30:12,780
夹杂了一些他自己的逻辑

3552
02:30:12,780 --> 02:30:13,920
加载他自己的逻辑

3553
02:30:14,190 --> 02:30:14,700
就这些

3554
02:30:15,430 --> 02:30:17,440
一个我们每都有一个prevent default

3555
02:30:17,440 --> 02:30:17,980
对不对

3556
02:30:18,280 --> 02:30:23,620
我们我们拿到REC的的那个event里面有prevent the effort

3557
02:30:23,710 --> 02:30:24,760
让他自己实现的

3558
02:30:25,900 --> 02:30:29,680
Stopped stopped publication也自己实现的

3559
02:30:30,130 --> 02:30:31,690
这个其实也挺有用的

3560
02:30:31,690 --> 02:30:33,910
有的时候会处理一些bug来使用

3561
02:30:34,520 --> 02:30:39,200
所以好像是LSLS有的时候有点bug

3562
02:30:39,710 --> 02:30:42,620
那么会给他一个persistence

3563
02:30:43,300 --> 02:30:44,080
Persistence

3564
02:30:44,960 --> 02:30:45,380
然后呢

3565
02:30:45,380 --> 02:30:46,730
再按click

3566
02:30:46,730 --> 02:30:48,680
真实的在调用on click的时候

3567
02:30:48,710 --> 02:30:49,640
那么他还会给他

3568
02:30:50,310 --> 02:30:51,690
附上那个

3569
02:30:51,990 --> 02:30:53,250
这是要按click的时候

3570
02:30:53,520 --> 02:30:54,990
他会判判断你的

3571
02:30:56,550 --> 02:30:57,780
事件类型到底是什么

3572
02:30:57,780 --> 02:30:58,590
比如说it

3573
02:30:59,010 --> 02:31:00,000
或者是input

3574
02:31:00,360 --> 02:31:00,720
然后呢

3575
02:31:00,720 --> 02:31:01,920
他会给你加上不同的

3576
02:31:02,620 --> 02:31:03,880
不同的那个优先级

3577
02:31:04,390 --> 02:31:05,800
优先级的方式来驱动

3578
02:31:06,220 --> 02:31:06,760
然后

3579
02:31:07,480 --> 02:31:08,950
再之后再

3580
02:31:09,620 --> 02:31:10,520
在调那个

3581
02:31:12,060 --> 02:31:13,170
这然后才会掉

3582
02:31:13,170 --> 02:31:14,250
他真实的那个会掉

3583
02:31:14,940 --> 02:31:17,700
其实就是X和城市间是这么来的

3584
02:31:18,380 --> 02:31:20,240
但是掉的那个地方我没有找到

3585
02:31:20,270 --> 02:31:22,040
刚刚好像不在这个地方

3586
02:31:22,990 --> 02:31:26,140
就给他家优先级那个好像没有在这个地方

3587
02:31:29,110 --> 02:31:29,860
大概就这样

3588
02:31:38,760 --> 02:31:40,890
意思是reg的事件不是单纯的事件

3589
02:31:40,890 --> 02:31:42,330
而是有很多复杂的功能

3590
02:31:43,910 --> 02:31:44,510
Record

3591
02:31:45,310 --> 02:31:45,610
对啊

3592
02:31:45,610 --> 02:31:46,300
他肯定不是

3593
02:31:46,300 --> 02:31:48,220
他并不是对同学

3594
02:31:48,220 --> 02:31:53,320
他不是直接掉到浏览器原生的都直接掉浏览器原生的功能

3595
02:31:53,650 --> 02:31:55,690
它合成了一部分自己的能力

3596
02:31:55,690 --> 02:31:56,830
机箱机箱里

3597
02:31:56,830 --> 02:31:58,600
比如说你用console log对吧

3598
02:31:59,600 --> 02:32:00,410
咱们看的那个

3599
02:32:00,980 --> 02:32:02,600
如果你想要

3600
02:32:02,960 --> 02:32:04,070
我这只是一个假设

3601
02:32:04,100 --> 02:32:05,150
如果你想要重写

3602
02:32:05,540 --> 02:32:08,330
如果你想要对所有的抗生素打抗生素的地方

3603
02:32:08,330 --> 02:32:09,830
你想要发送日志

3604
02:32:10,250 --> 02:32:11,150
那么你要干什么

3605
02:32:11,150 --> 02:32:11,810
你要把它

3606
02:32:15,020 --> 02:32:16,130
是不是要这么写

3607
02:32:17,130 --> 02:32:19,080
Console log

3608
02:32:22,380 --> 02:32:22,860
对啊

3609
02:32:23,460 --> 02:32:24,030
然后

3610
02:32:24,920 --> 02:32:27,830
他说那个等于他react里面不

3611
02:32:29,320 --> 02:32:30,550
这个里面并不是

3612
02:32:31,180 --> 02:32:32,590
这么简单粗暴的这么干的

3613
02:32:33,820 --> 02:32:35,140
但是你不这么简单粗暴干涉

3614
02:32:35,140 --> 02:32:36,040
我是举个例子

3615
02:32:36,070 --> 02:32:37,720
这个例子比较形象

3616
02:32:38,230 --> 02:32:40,120
然后你可以这么干对不对

3617
02:32:40,480 --> 02:32:40,900
然后呢

3618
02:32:40,900 --> 02:32:41,380
你可以

3619
02:32:41,890 --> 02:32:43,180
然后你这里可以上传

3620
02:32:44,450 --> 02:32:47,300
或者你打印也行

3621
02:32:47,300 --> 02:32:48,350
做什么其他的事情

3622
02:32:52,490 --> 02:32:53,090
上传啊

3623
02:32:58,840 --> 02:32:59,650
一般可以这么搞

3624
02:32:59,680 --> 02:33:01,330
但REC他并不是这么简单粗暴

3625
02:33:01,960 --> 02:33:03,040
他不是这么简单粗暴

3626
02:33:03,100 --> 02:33:05,080
这个为了方便丢了

3627
02:33:19,500 --> 02:33:20,430
我先不刷新吧

3628
02:33:21,050 --> 02:33:21,890
先不操心这个

3629
02:33:21,890 --> 02:33:23,060
但这个太大了

3630
02:33:23,800 --> 02:33:24,520
这个太大

3631
02:33:25,970 --> 02:33:29,870
然后他有些有些功能是它自己加的

3632
02:33:29,870 --> 02:33:31,100
比如说a click的时候

3633
02:33:31,250 --> 02:33:32,090
像我刚刚说了

3634
02:33:33,860 --> 02:33:35,720
他会给大家优先级

3635
02:33:35,930 --> 02:33:37,070
因为因为因为

3636
02:33:38,000 --> 02:33:39,200
你的每一个操作

3637
02:33:39,200 --> 02:33:40,100
你的每一个操作来讲

3638
02:33:40,100 --> 02:33:43,280
对react他内部来说是不太一样的

3639
02:33:43,280 --> 02:33:43,880
是不太一样的

3640
02:33:43,880 --> 02:33:44,870
它不然的话

3641
02:33:44,870 --> 02:33:45,830
它优先级的判断

3642
02:33:46,160 --> 02:33:48,230
对用户的这个优先级的判断是没法谈起

3643
02:33:51,180 --> 02:33:51,900
那还有一些

3644
02:33:51,900 --> 02:33:53,310
比如像合成的

3645
02:33:53,310 --> 02:33:54,570
如果你不用black的话

3646
02:33:54,570 --> 02:33:55,590
像fast click

3647
02:33:56,220 --> 02:33:56,490
对吧

3648
02:33:56,490 --> 02:33:59,400
发丝click这种应该有用过吧

3649
02:34:00,720 --> 02:34:01,980
发丝click这种裤

3650
02:34:03,060 --> 02:34:03,480
同样

3651
02:34:04,700 --> 02:34:07,880
他就也为了解决cn click的这么一些问题

3652
02:34:08,390 --> 02:34:10,790
那么他也做了内部也做了非常多的处理

3653
02:34:11,660 --> 02:34:12,560
这是他的智力

3654
02:34:14,650 --> 02:34:15,610
Max吧

3655
02:34:16,460 --> 02:34:20,510
其实我X8功能上

3656
02:34:21,440 --> 02:34:23,270
大概有两点有三个吧

3657
02:34:23,600 --> 02:34:25,100
我看XX有三个变化

3658
02:34:26,990 --> 02:34:28,160
我已经输入不了了

3659
02:34:43,690 --> 02:34:44,260
第一

3660
02:34:45,490 --> 02:34:46,480
自动的

3661
02:34:49,140 --> 02:34:51,600
自动的那个杯茶

3662
02:34:51,600 --> 02:34:51,930
对

3663
02:34:53,280 --> 02:34:54,870
这什么意思

3664
02:34:54,870 --> 02:34:55,470
同学们

3665
02:34:56,370 --> 02:34:57,570
在ROCK17中

3666
02:34:58,220 --> 02:34:59,240
我还是在这边写吧

3667
02:34:59,900 --> 02:35:02,000
这已经要这里感觉已经要卡死了

3668
02:35:03,200 --> 02:35:04,130
代码写的太多了

3669
02:35:05,890 --> 02:35:06,610
在这里写吧

3670
02:35:07,180 --> 02:35:08,200
在X17

3671
02:35:08,200 --> 02:35:09,850
钟姐我先写个17

3672
02:35:10,540 --> 02:35:11,200
在17里

3673
02:35:11,200 --> 02:35:12,580
假如你在hooks里这么写

3674
02:35:12,580 --> 02:35:14,830
比如说use date

3675
02:35:14,830 --> 02:35:15,070
不

3676
02:35:20,080 --> 02:35:21,130
这是Jess a

3677
02:35:22,230 --> 02:35:24,000
Use the effect

3678
02:35:29,610 --> 02:35:30,030
Effect

3679
02:35:30,030 --> 02:35:35,340
假如你sick

3680
02:35:37,050 --> 02:35:38,310
我这掉了两个户口

3681
02:35:39,210 --> 02:35:39,795
对不对

3682
02:35:39,795 --> 02:35:41,490
我这儿发现不是电脑顾客

3683
02:35:41,490 --> 02:35:42,720
我这儿发起了两次更新

3684
02:35:43,570 --> 02:35:44,590
发现两次更新

3685
02:35:46,170 --> 02:35:47,730
还有对比

3686
02:35:47,730 --> 02:35:48,840
如果是class里面

3687
02:35:49,080 --> 02:35:50,250
假如是class里面

3688
02:35:51,480 --> 02:35:52,200
只是看不懂

3689
02:35:52,200 --> 02:35:52,470
特

3690
02:35:54,900 --> 02:35:55,530
cars里面

3691
02:35:55,530 --> 02:35:57,810
比如我在component

3692
02:36:02,190 --> 02:36:05,280
did mount component in MT

3693
02:36:05,280 --> 02:36:07,980
我通过rest in the state

3694
02:36:08,310 --> 02:36:08,610
这个

3695
02:36:08,730 --> 02:36:10,140
这个应该大家都懂

3696
02:36:10,770 --> 02:36:11,340
大家都懂

3697
02:36:18,380 --> 02:36:18,830
的

3698
02:36:20,640 --> 02:36:21,000
对吧

3699
02:36:21,420 --> 02:36:22,530
如何在卡斯里

3700
02:36:23,140 --> 02:36:23,590
那么

3701
02:36:24,260 --> 02:36:25,400
我第二两次s data

3702
02:36:25,460 --> 02:36:26,720
他会发起一次批处理

3703
02:36:27,110 --> 02:36:28,670
批处理就是只执行一次

3704
02:36:29,480 --> 02:36:30,860
但是在康

3705
02:36:30,860 --> 02:36:33,050
在那个company之间的you the fact

3706
02:36:33,050 --> 02:36:34,130
如果发现两次

3707
02:36:34,920 --> 02:36:36,270
这并不会出

3708
02:36:36,900 --> 02:36:37,890
并不会批处理

3709
02:36:40,320 --> 02:36:42,210
同名这里这里是不会批处理的

3710
02:36:43,360 --> 02:36:45,460
Cook之前一直是不能批出来的

3711
02:36:46,060 --> 02:36:47,770
这个时期也是没办法逼出来的

3712
02:36:48,040 --> 02:36:50,710
这就会发起两次发起两次更新

3713
02:36:51,390 --> 02:36:54,060
她没有没有给你做到PPT这个功能

3714
02:36:55,050 --> 02:36:58,980
之前我如果是我们想让他只发几次怎么办呢

3715
02:36:59,250 --> 02:37:02,250
我们可以引入一个方法叫做

3716
02:37:04,140 --> 02:37:05,010
Based on the data

3717
02:37:06,000 --> 02:37:07,830
我们可以把它包裹在被update里

3718
02:37:07,830 --> 02:37:09,840
这个方法是reg down里面暴露出来的

3719
02:37:11,560 --> 02:37:12,760
Thread大礼包出来

3720
02:37:12,760 --> 02:37:14,260
如果你把它包裹一下

3721
02:37:24,690 --> 02:37:25,680
我给它包裹一下

3722
02:37:26,420 --> 02:37:28,970
那么他是可以匹配的

3723
02:37:28,970 --> 02:37:30,530
这个方法应该在热带里

3724
02:37:38,180 --> 02:37:43,820
这个based updates I is on back up is UN stable base updates

3725
02:37:45,680 --> 02:37:46,610
你直接通过REC的

3726
02:37:46,610 --> 02:37:47,810
当你可以把它调出来

3727
02:37:49,980 --> 02:37:51,180
但你可以把它拿出来用

3728
02:37:52,210 --> 02:37:53,440
因为它默认不平顺

3729
02:37:54,080 --> 02:37:57,830
这个ROM17就是16就有这个问题时期的时候

3730
02:37:58,880 --> 02:37:59,570
也有这个问题

3731
02:37:59,570 --> 02:38:00,680
但他说要解决

3732
02:38:01,010 --> 02:38:01,490
然后呢

3733
02:38:01,490 --> 02:38:03,200
在18里面终于解决了

3734
02:38:03,890 --> 02:38:04,970
就RIGHT18里

3735
02:38:07,600 --> 02:38:08,830
再re acts PA里

3736
02:38:09,400 --> 02:38:10,480
那么我们这么写

3737
02:38:13,040 --> 02:38:13,910
就没问题了

3738
02:38:15,410 --> 02:38:17,780
我们我们这边也就不需要再把它包起来了

3739
02:38:18,880 --> 02:38:19,780
Rex PA ni

3740
02:38:20,660 --> 02:38:21,800
这样写就是正常的

3741
02:38:23,060 --> 02:38:24,470
正常的只发几次

3742
02:38:28,330 --> 02:38:29,830
这才解决了这么一个问题

3743
02:38:36,030 --> 02:38:36,390
嗯

3744
02:38:37,800 --> 02:38:38,700
而且在

3745
02:38:39,720 --> 02:38:40,050
C

3746
02:38:40,050 --> 02:38:42,270
他帽子就是你把它放在system out Li

3747
02:38:46,540 --> 02:38:47,410
嗯

3748
02:38:49,650 --> 02:38:50,550
X写

3749
02:38:50,580 --> 02:38:51,480
假如这样子写

3750
02:38:51,480 --> 02:38:53,340
我把它换一个写法

3751
02:39:19,800 --> 02:39:20,430
也是这样的

3752
02:39:27,320 --> 02:39:28,700
他如果有system out特

3753
02:39:29,150 --> 02:39:30,440
他的批准就失效了

3754
02:39:31,450 --> 02:39:32,260
就会失效

3755
02:39:32,320 --> 02:39:34,180
但是在X18里

3756
02:39:34,690 --> 02:39:37,600
他的这个即使放在cmos里也不会失效

3757
02:39:37,900 --> 02:39:39,310
这个是他新增的功能

3758
02:39:40,320 --> 02:39:42,810
那比如说像一只loading这种事怎么办

3759
02:39:50,200 --> 02:39:53,320
Rack是Rex中直接这样写

3760
02:39:54,190 --> 02:39:55,510
不会被批准吧

3761
02:39:55,690 --> 02:39:56,470
你在这里吗

3762
02:39:57,270 --> 02:39:58,260
你知道这个地方吗

3763
02:40:03,450 --> 02:40:04,050
这里吗

3764
02:40:07,460 --> 02:40:07,880
可以啊

3765
02:40:08,520 --> 02:40:09,720
Class里面是会的

3766
02:40:09,720 --> 02:40:10,560
是会比之类的

3767
02:40:10,890 --> 02:40:12,270
但是你加了四台帽子

3768
02:40:13,170 --> 02:40:14,490
他就不会被批评了

3769
02:40:15,680 --> 02:40:16,370
加三八

3770
02:40:16,370 --> 02:40:18,590
加那个三八的就不会被批次了吗

3771
02:40:21,480 --> 02:40:23,730
然后strikes啪的意思是说

3772
02:40:24,060 --> 02:40:25,350
就算这样子写

3773
02:40:26,100 --> 02:40:27,480
它同样是会被踢出去的

3774
02:40:31,780 --> 02:40:32,290
这个事

3775
02:40:32,560 --> 02:40:34,270
所以他加了一个自动

3776
02:40:34,270 --> 02:40:37,210
我觉得这个最大的作用是在呼市里面

3777
02:40:37,240 --> 02:40:37,750
护士里面

3778
02:40:37,750 --> 02:40:38,260
他现在

3779
02:40:39,070 --> 02:40:40,420
默认自己支持的话

3780
02:40:40,600 --> 02:40:42,760
其实我们还是很方便的

3781
02:40:42,820 --> 02:40:43,570
还是很方便的

3782
02:40:45,080 --> 02:40:45,410
对吧

3783
02:40:45,740 --> 02:40:47,780
这是X吧里有这样的一个更新

3784
02:40:47,780 --> 02:40:52,190
所以所以大家要严格区分REX17和18

3785
02:40:53,090 --> 02:40:54,080
还是很不一样的

3786
02:40:54,530 --> 02:40:55,670
如果面试的时候

3787
02:40:56,670 --> 02:40:59,370
面试官问到了批处理这个问题的时候

3788
02:40:59,980 --> 02:41:03,040
那么大家就可以说我装逼的时候到了

3789
02:41:03,070 --> 02:41:03,430
对吧

3790
02:41:03,910 --> 02:41:06,040
你可以扔了17年怎么怎么样

3791
02:41:07,040 --> 02:41:12,320
那X心里又区分class组件和com和那个方形com的它们的区别

3792
02:41:12,800 --> 02:41:14,240
然后是REC18厘

3793
02:41:14,850 --> 02:41:16,260
都批处理辣对吧

3794
02:41:17,340 --> 02:41:17,880
然后呢

3795
02:41:18,900 --> 02:41:20,520
一般来说就没问题了

3796
02:41:21,000 --> 02:41:22,050
一般来说就没问题

3797
02:41:25,010 --> 02:41:27,110
这自动的Facebook的一个新的话

3798
02:41:27,110 --> 02:41:28,040
我觉得还是挺有用的

3799
02:41:28,430 --> 02:41:30,260
我们直接来看看官方的文档吗

3800
02:41:30,770 --> 02:41:32,210
其实X18

3801
02:41:33,720 --> 02:41:34,230
更新

3802
02:41:34,230 --> 02:41:35,070
反正也不赞同

3803
02:41:47,160 --> 02:41:48,240
她问我咋实现的

3804
02:41:48,240 --> 02:41:49,890
我就懵逼了

3805
02:41:49,890 --> 02:41:50,700
这有啥懵逼的

3806
02:41:51,340 --> 02:41:52,480
她问

3807
02:41:52,480 --> 02:41:53,680
你咋实现的

3808
02:41:56,160 --> 02:41:56,970
你就给他讲

3809
02:41:56,970 --> 02:41:58,200
你就给他讲那个

3810
02:41:59,580 --> 02:42:00,870
你又给俺讲那个

3811
02:42:01,500 --> 02:42:02,580
咱们前面讲的

3812
02:42:03,250 --> 02:42:05,860
咱们前面讲的那个啥

3813
02:42:06,940 --> 02:42:07,810
发个价格

3814
02:42:07,810 --> 02:42:08,830
就是讲发表价格

3815
02:42:08,830 --> 02:42:12,730
为什么为什么come class component你能批处理

3816
02:42:13,980 --> 02:42:16,170
不会让你把逻辑给他写出来的

3817
02:42:17,300 --> 02:42:17,930
但是你要知道

3818
02:42:17,930 --> 02:42:21,290
它就是我们的两个state之所以能够合并吗

3819
02:42:21,920 --> 02:42:25,520
两个C的C的C的合并不就是因为服用了一个fiber嘛

3820
02:42:25,520 --> 02:42:25,910
对不对

3821
02:42:26,660 --> 02:42:27,920
就是前面的一个发背

3822
02:42:27,920 --> 02:42:28,730
后面的复用

3823
02:42:28,880 --> 02:42:32,000
后面的那个更新复用了前面的那个cyber

3824
02:42:32,640 --> 02:42:36,270
而在而在那个呼呼吸就没有这个逻辑

3825
02:42:36,390 --> 02:42:37,620
那当然就不用费用了

3826
02:42:39,530 --> 02:42:40,730
Hose也没有这个逻辑

3827
02:42:40,730 --> 02:42:43,580
然后18年他就加上了这个逻辑

3828
02:42:44,030 --> 02:42:44,870
很简单

3829
02:42:48,610 --> 02:42:49,540
有同学问这个

3830
02:42:49,540 --> 02:42:51,940
我觉得我觉得好吧

3831
02:42:51,940 --> 02:42:55,630
我还是给大家把那个代码找出来看看

3832
02:42:55,630 --> 02:42:57,700
免得真的又懵逼了

3833
02:42:58,520 --> 02:42:59,150
不太好

3834
02:43:04,360 --> 02:43:05,470
为什么17不加

3835
02:43:05,740 --> 02:43:07,420
这个问题我还真可以回答

3836
02:43:08,210 --> 02:43:08,960
17的时候

3837
02:43:08,960 --> 02:43:10,610
他是本来打算是要加的

3838
02:43:11,290 --> 02:43:13,480
严格来说16:13的时候

3839
02:43:13,480 --> 02:43:15,250
当时就有就有人反映了

3840
02:43:15,250 --> 02:43:17,890
就是说为什么hooks里面

3841
02:43:18,500 --> 02:43:19,190
没有

3842
02:43:19,980 --> 02:43:21,630
就是hooks里面没有做批处理

3843
02:43:21,900 --> 02:43:24,960
但是有人说这个功能的话到底要不要加

3844
02:43:25,470 --> 02:43:26,820
然后当时

3845
02:43:27,500 --> 02:43:30,830
当时那个作者就是说会在未来的版本加上

3846
02:43:31,010 --> 02:43:31,760
会在未来的

3847
02:43:31,760 --> 02:43:35,720
就是现在可以大家用背下来做未来的版本

3848
02:43:35,720 --> 02:43:36,500
会把他加上

3849
02:43:36,680 --> 02:43:38,405
但这个未来的版本可能并不在

3850
02:43:38,405 --> 02:43:39,800
他排在17的里面来

3851
02:43:40,990 --> 02:43:41,530
然后呢

3852
02:43:42,100 --> 02:43:43,870
我当时也等了一两个版本

3853
02:43:43,900 --> 02:43:45,040
然后还是没等到

3854
02:43:45,040 --> 02:43:46,150
我都以为他不加了

3855
02:43:46,740 --> 02:43:47,820
然后18的时候

3856
02:43:48,120 --> 02:43:49,380
我看到她把她给加上了

3857
02:43:50,560 --> 02:43:54,040
这样子就是他实际上时期他知道有这么个问题

3858
02:43:54,070 --> 02:43:55,210
但是那个优先级呢

3859
02:43:55,720 --> 02:43:57,430
还没有他做的其他事情那么高

3860
02:43:57,940 --> 02:43:59,770
这个这些问题都很好回答的

3861
02:43:59,830 --> 02:44:01,030
就直接给他吹

3862
02:44:01,780 --> 02:44:03,130
而且这个并不是我吹的

3863
02:44:03,130 --> 02:44:05,290
这个是那个作者自己回复的

3864
02:44:06,390 --> 02:44:07,740
这个自自己回复的

3865
02:44:08,190 --> 02:44:09,480
他其实知道这个问题的

3866
02:44:10,160 --> 02:44:11,570
他是会在未来的版本加上

3867
02:44:12,460 --> 02:44:13,330
不是没想到

3868
02:44:13,690 --> 02:44:14,650
16的时候

3869
02:44:14,710 --> 02:44:17,170
因为这个户口时是16的时候就开发了吗

3870
02:44:18,050 --> 02:44:19,700
是12个的设计开发了

3871
02:44:20,860 --> 02:44:21,370
然后呢

3872
02:44:21,760 --> 02:44:22,390
有这个问题

3873
02:44:22,390 --> 02:44:26,170
17的时候其实就已经有人提过艺术了

3874
02:44:26,740 --> 02:44:27,670
希望能加上

3875
02:44:27,790 --> 02:44:28,630
希望能加上

3876
02:44:28,900 --> 02:44:32,380
但那个时候你你这件事情他肯定有优先级的吗

3877
02:44:32,380 --> 02:44:35,740
如果他认为一个优秀的一个功能的优先级

3878
02:44:35,920 --> 02:44:37,810
一个feature的优先级比这个更高

3879
02:44:37,840 --> 02:44:39,790
那他肯定会做优先级更高的事情

3880
02:44:40,790 --> 02:44:44,870
会遇见更高的实际上时期就像就像那个官方说的

3881
02:44:45,230 --> 02:44:47,360
感觉上是没有什么新的功能迭代

3882
02:44:47,540 --> 02:44:48,800
但其实它内部的

3883
02:44:49,130 --> 02:44:50,960
它内部整合了非常多的逻辑

3884
02:44:51,570 --> 02:44:52,830
区分了非常多的逻辑

3885
02:44:52,830 --> 02:44:54,570
它里面代码都全变了

3886
02:44:55,320 --> 02:45:02,490
所以相当于17道和十七十六到17是一个是一个内部重构的一个版本

3887
02:45:02,490 --> 02:45:03,180
你可以这么理解

3888
02:45:03,760 --> 02:45:06,070
那么这个时候嘉兴功能显然是不太合适的

3889
02:45:07,030 --> 02:45:07,840
那不然的话

3890
02:45:07,840 --> 02:45:10,780
18是不是还得到了升级了之后

3891
02:45:10,900 --> 02:45:14,950
如果是70加上后面是不是还得重新加

3892
02:45:16,680 --> 02:45:17,760
我个人是这么理解的

3893
02:45:18,270 --> 02:45:19,020
我个人这么理解的

3894
02:45:19,020 --> 02:45:19,470
反正

3895
02:45:20,140 --> 02:45:21,220
反正就这么回答吗

3896
02:45:21,760 --> 02:45:22,930
这问题有啥好问的

3897
02:45:22,930 --> 02:45:25,240
问的我一般都不可能会问这些问题

3898
02:45:25,840 --> 02:45:27,880
你就在你就在APP上

3899
02:45:29,330 --> 02:45:30,260
那个gate户散

3900
02:45:30,260 --> 02:45:34,070
然后就找那个他的那个tag的版本就可以找到

3901
02:46:03,310 --> 02:46:04,510
大家不就自带耳机吗

3902
02:46:04,510 --> 02:46:04,870
对吧

3903
02:46:05,630 --> 02:46:07,940
多个多个set的时候

3904
02:46:09,140 --> 02:46:12,770
如果你有一个存在的可怕可诺的

3905
02:46:13,800 --> 02:46:15,690
那么就直接服用他

3906
02:46:16,690 --> 02:46:18,730
不用你发现有的直接费用他

3907
02:46:19,560 --> 02:46:23,040
不过注意同学们这个你说这个逻辑的时候

3908
02:46:23,040 --> 02:46:25,560
我建议你把这个版本号带上

3909
02:46:26,460 --> 02:46:31,470
你如果要如果他问到了你就你要说react多少多少版本里有这个

3910
02:46:31,470 --> 02:46:34,410
他可能跟面试官我育

3911
02:46:34,440 --> 02:46:37,290
我真遇到个有同学反映这样的问题

3912
02:46:37,290 --> 02:46:40,110
就是他说了那个答案他说了

3913
02:46:40,790 --> 02:46:41,720
我我讲的答案

3914
02:46:41,750 --> 02:46:43,100
然后面试更觉得不太对

3915
02:46:43,820 --> 02:46:44,360
然后呢

3916
02:46:44,450 --> 02:46:46,070
同学觉得这怎么回事

3917
02:46:46,070 --> 02:46:47,510
为什么面试官觉得不太对呢

3918
02:46:48,110 --> 02:46:48,620
因为

3919
02:46:49,940 --> 02:46:53,990
它里面的那个版本的升级里面的逻辑有的时候是经常变的

3920
02:46:55,320 --> 02:46:58,350
有的时候实际上变得你RANK17是这个逻辑

3921
02:46:58,650 --> 02:47:00,180
你rock16.8以前

3922
02:47:00,180 --> 02:47:01,620
他他就不是这个逻辑

3923
02:47:02,220 --> 02:47:03,330
这是另外一个逻辑

3924
02:47:03,600 --> 02:47:05,880
所以我建议你要把那个版本号给他

3925
02:47:05,880 --> 02:47:07,860
带上你的ROCK17

3926
02:47:08,560 --> 02:47:09,340
他是这么干的

3927
02:47:09,760 --> 02:47:10,510
他就这么干

3928
02:47:11,560 --> 02:47:12,190
Rock自己

3929
02:47:12,190 --> 02:47:13,990
Rock时期之前的我没有了解

3930
02:47:13,990 --> 02:47:15,310
我只分析了X17

3931
02:47:16,080 --> 02:47:16,650
就行了

3932
02:47:17,530 --> 02:47:18,160
就算跟他

3933
02:47:18,880 --> 02:47:19,540
跟他不一样

3934
02:47:19,540 --> 02:47:20,620
那也不是你的问题

3935
02:47:21,520 --> 02:47:22,750
是真遇到过

3936
02:47:22,990 --> 02:47:23,650
如果是我的话

3937
02:47:23,650 --> 02:47:24,430
我就告诉他

3938
02:47:25,510 --> 02:47:25,960
X

3939
02:47:25,960 --> 02:47:28,240
我我必须要告诉他是哪个版本

3940
02:47:28,910 --> 02:47:30,350
版本号里面是怎么写的

3941
02:47:30,470 --> 02:47:32,390
如果说真的有疑问的话

3942
02:47:32,480 --> 02:47:33,470
那他可以当场查

3943
02:47:34,880 --> 02:47:35,660
他可以打他

3944
02:47:38,100 --> 02:47:40,290
就算理解的不太一样的情况

3945
02:47:40,440 --> 02:47:42,000
有可能是有可能你们两个

3946
02:47:43,230 --> 02:47:44,640
所说的事情都是对的

3947
02:47:44,880 --> 02:47:46,470
只是版本号没对上而已

3948
02:47:47,240 --> 02:47:47,750
理解吗

3949
02:47:49,120 --> 02:47:49,840
这不就是吗

3950
02:47:49,840 --> 02:47:50,320
这就是

3951
02:47:52,060 --> 02:47:54,610
存在从他in directly的吧

3952
02:47:54,610 --> 02:47:57,250
以前他有一个expression expression time

3953
02:47:57,880 --> 02:47:59,350
他那个expression time

3954
02:48:00,920 --> 02:48:03,560
Explosion他在可能在

3955
02:48:05,250 --> 02:48:07,380
25毫秒好像是25毫秒内的

3956
02:48:08,660 --> 02:48:11,900
它会它会自动给你合并成一次批处理来做

3957
02:48:12,680 --> 02:48:13,850
一个expression概念

3958
02:48:13,850 --> 02:48:15,740
但REX7已经没有expression to了

3959
02:48:16,400 --> 02:48:16,940
理解吗

3960
02:48:17,210 --> 02:48:22,850
所以他的逻辑是可能会变得有面试官会把ric的所有历史版的问好问一遍

3961
02:48:23,820 --> 02:48:25,290
一不会的不会的

3962
02:48:26,500 --> 02:48:27,160
不要担心

3963
02:48:27,610 --> 02:48:28,420
没有谁的梦

3964
02:48:28,480 --> 02:48:29,560
没有谁那么无聊

3965
02:48:36,490 --> 02:48:37,900
考研考得远吗

3966
02:48:38,620 --> 02:48:38,980
嗯

3967
02:48:45,050 --> 02:48:46,070
这很简单

3968
02:48:46,070 --> 02:48:46,580
你就

3969
02:48:47,920 --> 02:48:48,670
嗯

3970
02:48:54,160 --> 02:48:54,520
嗯

3971
02:48:55,820 --> 02:48:58,730
这个就是呆会儿呆会儿稍等一下

3972
02:48:59,270 --> 02:49:01,430
就刚刚讲的自动update吗

3973
02:49:01,610 --> 02:49:02,330
自动被气

3974
02:49:03,100 --> 02:49:05,350
自动自动被自动批处理

3975
02:49:05,740 --> 02:49:07,120
来一个全新的API

3976
02:49:07,600 --> 02:49:08,500
它的传染性

3977
02:49:08,500 --> 02:49:10,450
这个star传染性怎么说

3978
02:49:10,720 --> 02:49:11,860
他就是类似于

3979
02:49:12,500 --> 02:49:13,400
先带帽子了

3980
02:49:13,430 --> 02:49:16,610
就如果说你以后在代码里想要区分一个东西

3981
02:49:18,250 --> 02:49:19,420
类似于社团boss

3982
02:49:19,600 --> 02:49:22,420
但是他的直线时机又比他就这么用的

3983
02:49:22,480 --> 02:49:23,590
大家看就这么用的

3984
02:49:26,000 --> 02:49:27,320
它就类似于三帽子

3985
02:49:27,530 --> 02:49:29,630
你就得把它换成C3帽子也能使

3986
02:49:30,420 --> 02:49:31,710
键立马换成CM里面

3987
02:49:32,190 --> 02:49:33,390
在它的直径17

3988
02:49:33,570 --> 02:49:36,300
执行时期在CF之前

3989
02:49:36,600 --> 02:49:38,550
他是同步的这么个区别

3990
02:49:39,290 --> 02:49:39,770
没有机会

3991
02:49:39,770 --> 02:49:42,260
但是它又可以把它给放到

3992
02:49:42,900 --> 02:49:45,840
到这儿我就是想把它和上面这个

3993
02:49:46,640 --> 02:49:48,020
不做一次批处理是吧

3994
02:49:48,020 --> 02:49:49,310
想把它们分开处理

3995
02:49:50,010 --> 02:49:58,380
因为这个set input value这个逻辑是c de value想立刻展示给用户儿这个C的search queen

3996
02:49:59,280 --> 02:50:00,870
并不是要立刻展示给用户的

3997
02:50:01,380 --> 02:50:03,300
所以把它分开处理比较好

3998
02:50:03,390 --> 02:50:04,440
如果一起处理的话

3999
02:50:04,710 --> 02:50:06,690
那么可能还会慢一点给用户展示

4000
02:50:07,200 --> 02:50:08,340
所以大家把它给分开

4001
02:50:08,850 --> 02:50:09,360
分开的话

4002
02:50:09,360 --> 02:50:11,370
那么这个这个就不会

4003
02:50:11,920 --> 02:50:13,330
在批处理里面执行

4004
02:50:14,000 --> 02:50:16,460
所以他加了个SI star的成型

4005
02:50:16,730 --> 02:50:17,570
但你就是没他

4006
02:50:17,570 --> 02:50:19,130
你可以用塞他帽子也能使

4007
02:50:19,130 --> 02:50:19,460
对不对

4008
02:50:19,700 --> 02:50:20,270
也能使

4009
02:50:21,420 --> 02:50:24,810
但是他的直接死机在他们的之前一些

4010
02:50:26,720 --> 02:50:28,160
也是因为他支持了这个嘛

4011
02:50:28,160 --> 02:50:29,090
支持了自动被

4012
02:50:29,090 --> 02:50:30,590
所以就要需要这个

4013
02:50:31,440 --> 02:50:32,940
如果你不自动备齐的话

4014
02:50:32,940 --> 02:50:34,560
因为它默认就不是批处理了

4015
02:50:34,980 --> 02:50:38,610
所以这个的使使用它的场景也不是很多

4016
02:50:39,450 --> 02:50:42,510
以及类似的regular lady的全新SSR架构

4017
02:50:43,530 --> 02:50:44,190
就这三个

4018
02:50:44,190 --> 02:50:47,220
我觉得就这个是比较比较屌的

4019
02:50:47,220 --> 02:50:48,870
我觉得我比较喜欢这个特性

4020
02:50:49,780 --> 02:50:50,260
大家是

4021
02:50:50,860 --> 02:50:52,090
这这几个

4022
02:50:53,940 --> 02:50:55,770
这几个源码的话

4023
02:50:59,450 --> 02:51:00,590
原版的话怎么说

4024
02:51:02,530 --> 02:51:02,980
嗯

4025
02:51:03,740 --> 02:51:04,370
不太好看的

4026
02:51:04,370 --> 02:51:06,710
我们先看一下它的功能是啥吧

4027
02:51:06,710 --> 02:51:07,130
好不好

4028
02:51:07,160 --> 02:51:08,060
先看一下这个功能

4029
02:51:08,480 --> 02:51:09,950
比如这个suspense s2

4030
02:51:11,510 --> 02:51:13,040
这些是什么时候用

4031
02:51:13,040 --> 02:51:14,480
什么时候什么时候说

4032
02:51:14,960 --> 02:51:16,490
就是就问你

4033
02:51:16,490 --> 02:51:18,320
最近react有什么新特性

4034
02:51:18,860 --> 02:51:20,720
如果在一两年前你就打hooks

4035
02:51:20,840 --> 02:51:22,160
因为他就是要问hooks

4036
02:51:22,660 --> 02:51:23,680
如果是这样呢

4037
02:51:23,830 --> 02:51:24,550
比如今年

4038
02:51:26,000 --> 02:51:28,280
React就是那个面试官问题

4039
02:51:29,490 --> 02:51:30,900
Correct有什么新特性

4040
02:51:31,980 --> 02:51:33,180
那你就不能打boss

4041
02:51:33,300 --> 02:51:35,040
他因为已经吃了两年了对不对

4042
02:51:35,700 --> 02:51:36,510
已经两年了

4043
02:51:37,080 --> 02:51:39,240
那你那你可以打四期

4044
02:51:40,080 --> 02:51:41,160
就是X47

4045
02:51:43,800 --> 02:51:45,540
你诚心结识他的转换

4046
02:51:46,770 --> 02:51:47,490
还有什么

4047
02:51:47,520 --> 02:51:52,050
还有事件委托权限的那个事件委托的一个更改

4048
02:51:52,710 --> 02:51:53,910
但这两个都是小菜

4049
02:51:53,940 --> 02:51:55,050
18才是大菜

4050
02:51:55,470 --> 02:51:56,340
比如自动的

4051
02:51:57,200 --> 02:51:59,540
被夏被自动的那个批处理

4052
02:52:00,730 --> 02:52:01,390
很有很有用

4053
02:52:01,390 --> 02:52:01,690
很有

4054
02:52:01,690 --> 02:52:02,350
真的很有用

4055
02:52:02,960 --> 02:52:04,820
然后一个全新的SSR的架构

4056
02:52:05,270 --> 02:52:05,930
这个干嘛呢

4057
02:52:05,930 --> 02:52:07,850
这个很这个我觉得很牛逼

4058
02:52:08,570 --> 02:52:09,920
我看这几幅图就明白了

4059
02:52:09,920 --> 02:52:11,840
我通过这几幅图给大家讲

4060
02:52:12,200 --> 02:52:13,370
比如说S3

4061
02:52:13,370 --> 02:52:14,270
我们大家都知道

4062
02:52:14,270 --> 02:52:15,560
就是直出页面对不对

4063
02:52:15,590 --> 02:52:16,430
直出页面

4064
02:52:18,340 --> 02:52:20,290
就是直接把游戏里面给你返回吗

4065
02:52:20,290 --> 02:52:21,310
直直接出吗

4066
02:52:21,970 --> 02:52:22,720
然后但是呢

4067
02:52:23,110 --> 02:52:24,910
之前都是直接出一个整体

4068
02:52:25,390 --> 02:52:26,860
那假如你页面很复杂

4069
02:52:27,700 --> 02:52:29,860
你直接出一个整体同样会很慢

4070
02:52:30,370 --> 02:52:31,480
那他要怎么办

4071
02:52:31,900 --> 02:52:32,680
那么他可以

4072
02:52:34,360 --> 02:52:36,310
那么他可以一部分一部分地出

4073
02:52:36,950 --> 02:52:40,700
其实就是类似于老人讲的那个什么pipeline那个玩意儿

4074
02:52:41,390 --> 02:52:42,980
他一部分一部分的时候儿

4075
02:52:42,980 --> 02:52:44,600
他怎么一部分一部分的书呢

4076
02:52:44,600 --> 02:52:47,240
就是依赖于suspense he lazy

4077
02:52:48,140 --> 02:52:52,640
Suspense are lazy suspense are lazy之前是不能够在S

4078
02:52:52,640 --> 02:52:54,890
就是在那个服务器上使用的

4079
02:52:55,510 --> 02:52:56,920
但REC18可以

4080
02:52:57,840 --> 02:53:00,390
就suspense away在服务器端使用之后

4081
02:53:00,570 --> 02:53:02,340
那么他就会一块儿一块儿给你出

4082
02:53:03,300 --> 02:53:04,230
一块儿给你说

4083
02:53:04,590 --> 02:53:07,560
那么这块儿就是如果那么这块其实是很有用的

4084
02:53:07,920 --> 02:53:09,360
就假如你一整个页面

4085
02:53:10,560 --> 02:53:11,010
很大

4086
02:53:11,920 --> 02:53:13,660
那么你想让用户优先展示

4087
02:53:13,930 --> 02:53:15,070
优先展示某一块儿

4088
02:53:15,580 --> 02:53:16,870
优先给用户展示某一块儿

4089
02:53:17,410 --> 02:53:19,420
那么你用这个

4090
02:53:20,290 --> 02:53:22,060
Suspense he lazy

4091
02:53:22,600 --> 02:53:23,020
来

4092
02:53:23,020 --> 02:53:24,700
来那个结合SSR

4093
02:53:25,000 --> 02:53:26,440
那么就是非常有用的一个特性

4094
02:53:27,020 --> 02:53:28,100
比如像他说的

4095
02:53:28,580 --> 02:53:29,990
他优先想展示哪块儿

4096
02:53:31,600 --> 02:53:32,170
嗯

4097
02:53:35,600 --> 02:53:36,470
就这样加了

4098
02:53:36,470 --> 02:53:37,760
我有幸在上课

4099
02:53:38,360 --> 02:53:41,060
那么这一块儿我我后面再展示也可以

4100
02:53:43,640 --> 02:53:44,660
后面的展示也可以

4101
02:53:44,660 --> 02:53:46,190
那么它就可以延后展示

4102
02:53:46,820 --> 02:53:47,900
更牛逼的是什么呢

4103
02:53:48,630 --> 02:53:49,320
更牛的是什么

4104
02:53:49,320 --> 02:53:55,020
因为react的SSR大家都明白有一个他的逻辑是什么呢

4105
02:53:55,200 --> 02:53:57,180
他都会先展示一个不能点击的

4106
02:53:57,180 --> 02:53:57,570
对不对

4107
02:53:58,050 --> 02:54:00,870
SSR都会先展示一个不能点击的一个东西

4108
02:54:02,110 --> 02:54:02,830
然后

4109
02:54:05,750 --> 02:54:07,430
不能展示一个不能点击的东西

4110
02:54:07,430 --> 02:54:09,650
然后他慢慢地给他加事件

4111
02:54:10,100 --> 02:54:12,500
就是它用户的观感

4112
02:54:12,680 --> 02:54:13,970
就是眼睛所看到的

4113
02:54:14,300 --> 02:54:15,170
之前出来的

4114
02:54:15,410 --> 02:54:17,210
但是在一个时间段内它是不能点击

4115
02:54:17,210 --> 02:54:18,800
就是可可交互时间

4116
02:54:19,690 --> 02:54:21,520
如果在他的可交付时间之外的话

4117
02:54:21,520 --> 02:54:22,630
他是没办法点击的

4118
02:54:23,970 --> 02:54:24,420
对不对

4119
02:54:24,480 --> 02:54:27,270
那它会慢慢的就就是一个happy的一个过程

4120
02:54:27,270 --> 02:54:28,230
就叫做水化

4121
02:54:28,470 --> 02:54:29,940
这个就是普通SSR

4122
02:54:30,360 --> 02:54:31,860
正常的S2都有这个流程

4123
02:54:31,860 --> 02:54:33,540
就是先给你展示一个

4124
02:54:34,100 --> 02:54:36,260
展示一个相当于静态页面的东西

4125
02:54:36,260 --> 02:54:36,980
你不能点

4126
02:54:37,550 --> 02:54:38,120
然后呢

4127
02:54:38,780 --> 02:54:40,670
等他把世界重新给你注册上之后

4128
02:54:40,670 --> 02:54:41,270
你才能够点

4129
02:54:41,780 --> 02:54:43,550
这个是普通的S就这么干的

4130
02:54:43,940 --> 02:54:47,450
然后333可以让你干什么可以让你

4131
02:54:48,600 --> 02:54:49,440
先展示一部分

4132
02:54:50,580 --> 02:54:51,510
先展示一部分

4133
02:54:52,080 --> 02:54:54,420
然后再展示另外一部分

4134
02:54:54,870 --> 02:54:55,680
而更牛逼的是

4135
02:54:55,680 --> 02:54:57,990
就算你现在处于不可点击的状态

4136
02:54:58,620 --> 02:55:01,560
就是它这个绿色的就表示给她水化嘛

4137
02:55:01,590 --> 02:55:01,800
对吧

4138
02:55:01,800 --> 02:55:04,830
给他水化不不是鬼嘉宾头像不是国家拼

4139
02:55:05,280 --> 02:55:06,900
这他展示的像是国家拼

4140
02:55:07,320 --> 02:55:08,160
但实际上不是

4141
02:55:08,310 --> 02:55:09,330
就相当于是

4142
02:55:09,820 --> 02:55:11,800
正式的内容真正的内容

4143
02:55:12,750 --> 02:55:14,610
这是真正的内容只是

4144
02:55:15,200 --> 02:55:17,750
只是他给你区分了几个模块儿

4145
02:55:17,750 --> 02:55:18,830
这是几个模块而已

4146
02:55:18,830 --> 02:55:19,820
这不是古代片

4147
02:55:20,330 --> 02:55:21,530
他就是真正的内容

4148
02:55:23,610 --> 02:55:24,240
能理解吗

4149
02:55:25,210 --> 02:55:29,500
然后只是说只是真正的内容一开始出来也是没办法点击的

4150
02:55:30,370 --> 02:55:31,240
正常情况下

4151
02:55:31,270 --> 02:55:32,350
那需要等到happy的

4152
02:55:32,350 --> 02:55:32,950
就是水话

4153
02:55:32,950 --> 02:55:33,880
就是给他加事件

4154
02:55:34,270 --> 02:55:36,280
事件给它加上了之后才能点击

4155
02:55:38,100 --> 02:55:38,520
ER

4156
02:55:39,150 --> 02:55:39,540
ER

4157
02:55:40,140 --> 02:55:48,120
他的这个新的这个sus pen SI就是家里the适用于适用于那个S之后

4158
02:55:49,070 --> 02:55:51,980
你看水花的过程也可以就是黑的

4159
02:55:52,250 --> 02:55:54,650
就是水花就是加事件的一个过程

4160
02:55:55,070 --> 02:55:56,210
它也可以分快加

4161
02:55:56,360 --> 02:55:57,110
最关键的是

4162
02:55:57,780 --> 02:55:59,790
大家看就算这个地方没有被加上

4163
02:56:00,920 --> 02:56:01,250
大家看

4164
02:56:01,250 --> 02:56:02,930
如果说如果在这个时候

4165
02:56:03,290 --> 02:56:06,800
我的这个我的这个白的地方是明显不能点击的

4166
02:56:08,470 --> 02:56:10,030
我这个白色明显按

4167
02:56:10,030 --> 02:56:11,230
如果按往常的逻辑

4168
02:56:11,230 --> 02:56:12,670
就是普通的SSR

4169
02:56:13,240 --> 02:56:14,800
这个白色地方是点击不了的

4170
02:56:14,800 --> 02:56:15,220
对不对

4171
02:56:15,700 --> 02:56:16,540
点击了没用

4172
02:56:17,420 --> 02:56:18,500
然后这个就牛逼了

4173
02:56:18,500 --> 02:56:20,570
他会把这个事情给你记住

4174
02:56:20,900 --> 02:56:22,880
就你点这个事情给记住等他

4175
02:56:24,000 --> 02:56:24,990
还觉得之后

4176
02:56:26,060 --> 02:56:27,800
然后他再给你弹出来

4177
02:56:27,800 --> 02:56:28,670
就是会慢一点儿

4178
02:56:28,670 --> 02:56:30,650
但是你的试卷不会丢

4179
02:56:31,320 --> 02:56:33,090
我觉得这个特性特别牛逼

4180
02:56:33,090 --> 02:56:34,530
我特别喜欢这个功能

4181
02:56:34,800 --> 02:56:36,270
然后等他完全损坏了之后

4182
02:56:36,980 --> 02:56:38,180
然后他才会再给你

4183
02:56:40,820 --> 02:56:42,200
把那个时间给执行了

4184
02:56:43,870 --> 02:56:45,670
中文一句叫水化

4185
02:56:46,330 --> 02:56:47,590
中英文叫happy的

4186
02:56:48,620 --> 02:56:49,340
嗨

4187
02:56:50,980 --> 02:56:51,670
Hedge it

4188
02:56:55,430 --> 02:56:56,060
Headed

4189
02:56:57,760 --> 02:56:59,500
翻译过来叫水化

4190
02:56:59,500 --> 02:56:59,950
反正

4191
02:57:01,110 --> 02:57:02,040
很淡很淡的

4192
02:57:06,830 --> 02:57:08,450
他不是故意想延迟的

4193
02:57:08,600 --> 02:57:11,000
他实际上是把那次事件给你追回来了

4194
02:57:12,260 --> 02:57:12,860
法律知识

4195
02:57:12,890 --> 02:57:14,510
如果你是普通的SSR

4196
02:57:15,120 --> 02:57:16,410
在他喝醉的之前

4197
02:57:16,500 --> 02:57:17,700
你是根本点不了的

4198
02:57:18,390 --> 02:57:19,380
这能理解吧

4199
02:57:19,500 --> 02:57:21,270
你没法点点不动

4200
02:57:21,720 --> 02:57:23,490
因为世界都没有没绑定

4201
02:57:25,210 --> 02:57:25,960
那现在可以

4202
02:57:26,580 --> 02:57:28,200
所以我特别喜欢这个特性

4203
02:57:29,200 --> 02:57:30,580
而且我也我也用到了

4204
02:57:30,760 --> 02:57:32,890
我也用到了我那一次

4205
02:57:33,070 --> 02:57:37,930
那一次那个想做一个我我因为我我的页面就有很多suspense

4206
02:57:38,550 --> 02:57:40,530
我就想我thousands不能够在

4207
02:57:41,140 --> 02:57:44,830
不能够在那个那个S3里使用这个有点儿有点儿蛋疼

4208
02:57:46,080 --> 02:57:47,640
然后我就看到了这个

4209
02:57:47,640 --> 02:57:49,710
现在见我就给他用了一把

4210
02:57:50,220 --> 02:57:51,300
真挺爽很爽

4211
02:57:52,310 --> 02:57:53,780
所以这个我觉得特别爽

4212
02:57:53,780 --> 02:57:55,130
你把那个解释清楚就行

4213
02:57:55,700 --> 02:57:56,390
然后这边儿

4214
02:57:57,270 --> 02:57:59,160
一大段很大段的功能

4215
02:57:59,160 --> 02:58:00,360
就是解释这个功能的

4216
02:58:00,420 --> 02:58:01,500
大家下来可以看一下

4217
02:58:02,010 --> 02:58:03,270
这是我觉得X18

4218
02:58:05,620 --> 02:58:06,760
会不会我多吃点接

4219
02:58:06,760 --> 02:58:09,580
那最后的执行还是执行最后一次

4220
02:58:12,160 --> 02:58:14,410
多次点击你多次点击同一个是吗

4221
02:58:16,260 --> 02:58:17,400
这个我倒真没试过

4222
02:58:17,760 --> 02:58:18,780
下来我试试看吧

4223
02:58:19,550 --> 02:58:20,630
这个我倒真没试过

4224
02:58:21,280 --> 02:58:24,040
因为不确定他是不是当作一次还是多次

4225
02:58:25,290 --> 02:58:26,430
我得试试看才知道

4226
02:58:27,580 --> 02:58:29,530
因为这个算是比较新的一个特性的

4227
02:58:30,010 --> 02:58:31,900
新的特性可以了解一下

4228
02:58:31,900 --> 02:58:32,440
可以下载

4229
02:58:32,770 --> 02:58:34,360
也可以自己写个DEMO试一试

4230
02:58:36,220 --> 02:58:36,580
好了

4231
02:58:36,670 --> 02:58:37,870
如果要讲新的新的话

4232
02:58:37,870 --> 02:58:39,220
大概就是这样了

4233
02:58:39,360 --> 02:58:39,690
对吧

4234
02:58:39,720 --> 02:58:40,500
大概就这个样子

4235
02:58:42,220 --> 02:58:44,440
然后我们的代码基本上就讲完了

4236
02:58:45,990 --> 02:58:49,440
逻辑源码就讲的差不多了再回答一个问题

4237
02:58:49,440 --> 02:58:50,250
刚刚有同学说

4238
02:58:51,000 --> 02:58:52,020
不知道怎么调试

4239
02:59:01,660 --> 02:59:02,620
用户误操作

4240
02:59:02,620 --> 02:59:03,460
做一些剪辑

4241
02:59:04,550 --> 02:59:06,650
用户没有用户不可能有误操作

4242
02:59:06,680 --> 02:59:07,670
你用户的每一个

4243
02:59:08,380 --> 02:59:11,080
就是用户会认为自己的操作是误操作嘛

4244
02:59:11,470 --> 02:59:13,810
如果用户认为自己的操作是一个误操作

4245
02:59:14,170 --> 02:59:17,320
那么出来的结果不符合他的预期也是正常的

4246
02:59:18,010 --> 02:59:19,240
用户的每一个操作

4247
02:59:19,240 --> 02:59:21,130
你都要认为他是一个正常的操作

4248
02:59:21,870 --> 02:59:23,760
就是假如说用户真的想点

4249
02:59:23,760 --> 02:59:25,440
就是看到他出来真的想点一下

4250
02:59:26,940 --> 02:59:28,260
但是他真的想点一下

4251
02:59:28,860 --> 02:59:30,300
那这就是一个正常的操作

4252
02:59:30,690 --> 02:59:33,600
后面就应该执行正确的逻辑

4253
02:59:35,120 --> 02:59:36,740
你说的是假如你点N多次

4254
02:59:36,740 --> 02:59:37,040
对吧

4255
02:59:37,040 --> 02:59:37,760
你N多次

4256
02:59:38,120 --> 02:59:41,510
所以这个如果点多就是同时点多次

4257
02:59:41,510 --> 02:59:44,570
这个我确实还不太清楚他到底是怎么发起的

4258
02:59:44,840 --> 02:59:45,680
我现在可以看一下

4259
02:59:46,310 --> 02:59:49,820
但是用户不应该把用户的操作认为是一个误操作

4260
02:59:51,140 --> 02:59:52,400
因为她真的点多次

4261
02:59:52,700 --> 02:59:54,290
对于他来说也合理

4262
02:59:54,960 --> 02:59:55,530
也合理

4263
02:59:57,280 --> 02:59:59,020
如果他认为他不小心点了

4264
02:59:59,110 --> 03:00:00,460
结果弹出一个alert

4265
03:00:01,060 --> 03:00:01,420
那么

4266
03:00:02,250 --> 03:00:04,050
他也应该意识到这是她的

4267
03:00:04,080 --> 03:00:06,690
她不小心点击了之后就发在这个操作

4268
03:00:06,690 --> 03:00:09,000
这这也不算是一个

4269
03:00:09,420 --> 03:00:11,790
就是这个是他所预期的一个误操作

4270
03:00:12,270 --> 03:00:12,990
也不会有问题

4271
03:00:12,990 --> 03:00:13,410
我觉得

4272
03:00:15,010 --> 03:00:15,730
能理解吗

4273
03:00:17,270 --> 03:00:18,590
因为这是他自己操作的吗

4274
03:00:19,450 --> 03:00:21,250
就算真的出了

4275
03:00:21,250 --> 03:00:23,350
就是比如弹那个弹窗

4276
03:00:23,620 --> 03:00:25,000
因为你这个按理说

4277
03:00:25,000 --> 03:00:26,500
因为你这个页面已经出来了

4278
03:00:26,890 --> 03:00:28,450
给用户的感觉就是可怜的

4279
03:00:30,000 --> 03:00:31,200
因为他已经出来了吗

4280
03:00:31,290 --> 03:00:31,920
对于用户来说

4281
03:00:31,920 --> 03:00:33,810
是不是你既然已经出来了

4282
03:00:34,140 --> 03:00:35,040
而且有个八层

4283
03:00:35,250 --> 03:00:36,300
我是不是可以点一下

4284
03:00:36,660 --> 03:00:38,610
那我肯定在用户的角度来说

4285
03:00:38,610 --> 03:00:39,870
不能点才奇怪

4286
03:00:40,320 --> 03:00:41,190
能点不奇怪

4287
03:00:42,050 --> 03:00:43,610
只不过他稍微延迟了一点嘛

4288
03:00:43,610 --> 03:00:45,290
他可能会稍微慢一点点

4289
03:00:46,560 --> 03:00:48,330
那么但至少是能点的

4290
03:00:48,450 --> 03:00:49,080
至少是有

4291
03:00:49,350 --> 03:00:50,520
至少是有交互的

4292
03:00:51,600 --> 03:00:53,010
已经比以前好很多了

4293
03:00:53,220 --> 03:00:53,610
对不对

4294
03:00:56,550 --> 03:00:57,780
然后就是有同学说

4295
03:00:57,780 --> 03:00:59,010
不知道怎么调试

4296
03:00:59,010 --> 03:01:00,180
这个调试很简单

4297
03:01:00,600 --> 03:01:01,380
比如说你就这样

4298
03:01:03,720 --> 03:01:06,300
房德和节日的操作不是页面的逻辑吗

4299
03:01:15,810 --> 03:01:17,940
防抖和节流的操作不是页面的逻辑嘛

4300
03:01:17,970 --> 03:01:18,300
是

4301
03:01:19,020 --> 03:01:19,800
是事业

4302
03:01:19,800 --> 03:01:22,170
一般来说是页面自己写的逻辑

4303
03:01:22,860 --> 03:01:23,940
是因为自己写的逻辑

4304
03:01:23,970 --> 03:01:24,930
只不过不确定

4305
03:01:25,350 --> 03:01:27,510
有点不确定的事你

4306
03:01:28,710 --> 03:01:30,450
你那个他他有没有

4307
03:01:31,020 --> 03:01:32,610
它会不会对这个也做批处理

4308
03:01:32,610 --> 03:01:33,720
这个我不是很确定

4309
03:01:34,760 --> 03:01:36,230
一般来说可能不会做

4310
03:01:37,050 --> 03:01:40,110
一般来说可能不会对几次操作来做

4311
03:01:40,170 --> 03:01:41,310
可能会给用户做

4312
03:01:41,340 --> 03:01:41,760
但是

4313
03:01:42,400 --> 03:01:42,970
没看吗

4314
03:01:43,210 --> 03:01:43,720
这个

4315
03:01:44,320 --> 03:01:45,520
这块我也我也没看

4316
03:01:46,410 --> 03:01:47,250
所以不是很确定

4317
03:01:47,730 --> 03:01:48,300
也没法儿

4318
03:01:48,660 --> 03:01:50,010
但是我猜测应该没有

4319
03:01:50,010 --> 03:01:52,500
我猜测应该点多下会有多少

4320
03:01:53,410 --> 03:01:56,440
我得看一下之后才能有比较准确的回答

4321
03:01:59,340 --> 03:02:01,230
有同学说不知道怎么的bug

4322
03:02:01,830 --> 03:02:03,210
这个就非常简单嘛

4323
03:02:03,630 --> 03:02:04,140
就是

4324
03:02:05,550 --> 03:02:06,450
嗯

4325
03:02:08,980 --> 03:02:09,850
哎呀

4326
03:02:11,900 --> 03:02:12,650
有得买

4327
03:02:14,700 --> 03:02:15,270
没有电吗

4328
03:02:16,710 --> 03:02:17,310
我想想

4329
03:02:28,060 --> 03:02:29,140
嗯

4330
03:02:31,330 --> 03:02:32,440
咋没期待吗

4331
03:02:32,770 --> 03:02:33,400
谁啊

4332
03:02:44,760 --> 03:02:46,770
我看看我以前的电脑能不能合用

4333
03:02:55,460 --> 03:02:56,420
这人呢

4334
03:02:57,840 --> 03:02:58,320
没了

4335
03:03:18,980 --> 03:03:19,790
这个呢

4336
03:03:20,060 --> 03:03:21,290
它应该是可以用的吧

4337
03:03:51,450 --> 03:03:51,900
对吧

4338
03:03:52,570 --> 03:03:53,110
车

4339
03:03:54,230 --> 03:03:56,330
这是老袁之前写了一个DEMO

4340
03:03:59,500 --> 03:04:01,000
再拿来用一下

4341
03:04:02,120 --> 03:04:02,780
比如说

4342
03:04:04,690 --> 03:04:05,440
我这个是

4343
03:04:06,720 --> 03:04:08,760
在普通地方的地方

4344
03:04:10,050 --> 03:04:11,400
这个写写很简单

4345
03:04:11,910 --> 03:04:14,100
只是可能会花点时间

4346
03:04:14,100 --> 03:04:15,060
所以直接用一个

4347
03:04:22,960 --> 03:04:24,070
Compound

4348
03:04:25,220 --> 03:04:26,150
还是邓一八

4349
03:04:27,100 --> 03:04:27,340
那么

4350
03:04:27,340 --> 03:04:28,060
假如

4351
03:04:36,120 --> 03:04:37,530
这是这是一个第八个

4352
03:04:41,660 --> 03:04:43,400
这个调色还是很简单的

4353
03:04:48,570 --> 03:04:49,470
没有人知道

4354
03:05:04,210 --> 03:05:05,170
不是这个图片

4355
03:05:12,220 --> 03:05:13,180
看着我

4356
03:05:13,180 --> 03:05:13,780
直接

4357
03:05:14,910 --> 03:05:15,750
打葛

4358
03:05:20,670 --> 03:05:21,090
开始

4359
03:05:25,210 --> 03:05:26,650
看一下这个C厅

4360
03:05:32,790 --> 03:05:33,720
SACD吗

4361
03:05:37,510 --> 03:05:38,380
这是跟

4362
03:05:39,480 --> 03:05:40,050
然后

4363
03:05:40,880 --> 03:05:41,540
Welcome

4364
03:05:43,980 --> 03:05:44,700
那个

4365
03:06:05,780 --> 03:06:06,950
怎么没提报个数

4366
03:06:07,900 --> 03:06:10,810
六七个

4367
03:06:11,800 --> 03:06:13,210
完了我直接在这里找吧

4368
03:06:16,470 --> 03:06:17,640
我觉得这么一

4369
03:06:18,440 --> 03:06:19,100
第八个

4370
03:06:21,650 --> 03:06:22,160
云达

4371
03:06:26,790 --> 03:06:27,090
好了

4372
03:06:27,420 --> 03:06:28,740
看我们这不就打上了吗

4373
03:06:29,700 --> 03:06:30,630
电视打上了

4374
03:06:32,350 --> 03:06:33,040
来这里

4375
03:06:34,130 --> 03:06:34,640
来了

4376
03:06:34,850 --> 03:06:36,890
但是我这个地方还是些没用

4377
03:06:38,400 --> 03:06:39,000
这些没用

4378
03:06:39,750 --> 03:06:40,020
好

4379
03:06:40,050 --> 03:06:41,220
那我在这里加一个

4380
03:06:45,060 --> 03:06:45,780
component

4381
03:06:49,570 --> 03:06:51,430
A city

4382
03:06:55,840 --> 03:06:56,200
state1

4383
03:07:09,650 --> 03:07:10,160
真的是

4384
03:07:11,080 --> 03:07:11,680
然后

4385
03:07:18,820 --> 03:07:21,280
然后大家看调试就很简单

4386
03:07:21,430 --> 03:07:22,900
比如去找4S的了

4387
03:07:23,350 --> 03:07:24,190
就整这个吗

4388
03:07:25,120 --> 03:07:27,250
这个就是进去进到一个方法

4389
03:07:28,220 --> 03:07:29,690
这个是到下一个断点对吧

4390
03:07:29,870 --> 03:07:30,860
这个是到下一行

4391
03:07:31,280 --> 03:07:32,540
这个是进入到下一

4392
03:07:32,570 --> 03:07:33,620
进入到这个行之内

4393
03:07:34,640 --> 03:07:35,510
我就进来了吗

4394
03:07:36,470 --> 03:07:37,400
进来了之后

4395
03:07:39,100 --> 03:07:39,940
那就找

4396
03:07:43,100 --> 03:07:43,760
那就找人

4397
03:07:43,760 --> 03:07:44,090
然后

4398
03:07:45,360 --> 03:07:46,980
一行一行的调

4399
03:07:47,610 --> 03:07:49,440
他原本叫这个schedule work

4400
03:07:49,740 --> 03:07:55,320
这个就是我们刚刚看这个是这个是10X16.8

4401
03:07:56,190 --> 03:07:57,660
这里面是X9.8

4402
03:07:57,750 --> 03:07:58,710
很早以前的

4403
03:07:59,420 --> 03:08:00,980
现在我们看的是二月17

4404
03:08:01,430 --> 03:08:02,660
他这个schedule work里

4405
03:08:03,110 --> 03:08:04,970
其实就是我们那个schedule work on route

4406
03:08:05,360 --> 03:08:06,680
他也会掉什么

4407
03:08:07,250 --> 03:08:08,630
他也会走到这个地方

4408
03:08:10,810 --> 03:08:11,440
嗯

4409
03:08:12,970 --> 03:08:13,930
他知道

4410
03:08:15,630 --> 03:08:16,980
这个就是刷题调度

4411
03:08:18,380 --> 03:08:19,520
发起调度

4412
03:08:29,330 --> 03:08:31,640
Our stable schedule call back

4413
03:08:34,430 --> 03:08:35,810
Stable schedule back

4414
03:08:36,350 --> 03:08:37,760
啧啧啧的下一个

4415
03:08:51,650 --> 03:08:53,510
在这里进去

4416
03:08:54,310 --> 03:08:55,600
走走走走

4417
03:08:56,520 --> 03:08:58,230
啧啧啧

4418
03:09:03,260 --> 03:09:05,990
这因为我这个还是我这个代码

4419
03:09:06,910 --> 03:09:09,460
和大家看到的可能不太一样

4420
03:09:10,300 --> 03:09:11,020
可能不太一样

4421
03:09:11,020 --> 03:09:14,920
因为它是16.8的这个schedule work

4422
03:09:14,920 --> 03:09:16,600
他在走到school work里

4423
03:09:16,600 --> 03:09:19,360
它就会进入那个什么调度流程

4424
03:09:19,480 --> 03:09:22,420
他会区分是render还是

4425
03:09:23,350 --> 03:09:27,460
就是是那个第一次是那个同步的还是异步的

4426
03:09:28,140 --> 03:09:30,240
那个逻辑的那个G逻辑你去

4427
03:09:30,300 --> 03:09:32,160
但是这逻辑已经全变了

4428
03:09:32,370 --> 03:09:33,120
全改了

4429
03:09:33,870 --> 03:09:35,070
调试的话就这么调

4430
03:09:35,760 --> 03:09:36,930
这条你要是有问题了

4431
03:09:36,930 --> 03:09:39,120
就在某个地方打他一巴掌

4432
03:09:40,800 --> 03:09:43,290
直接再或者直接找个那行代码打断你

4433
03:09:43,680 --> 03:09:44,790
然后调进去就行了

4434
03:09:45,840 --> 03:09:46,440
大概就这样

4435
03:09:47,880 --> 03:09:48,450
理解了吗

4436
03:09:48,480 --> 03:09:49,860
同学们可以知道吗

4437
03:09:54,260 --> 03:09:55,400
天也不早了

4438
03:09:55,940 --> 03:09:57,410
就今天我们讲了

4439
03:09:59,190 --> 03:10:01,590
来个圆满部分就到此为止吧

4440
03:10:03,020 --> 03:10:04,520
今天拖了一个小时

4441
03:10:04,520 --> 03:10:08,660
希望大家能够下来再看看吧

4442
03:10:08,660 --> 03:10:09,290
下来再看看

4443
03:10:09,940 --> 03:10:10,960
这个还是挺难的

4444
03:10:11,950 --> 03:10:12,610
在济南呢

4445
03:10:13,280 --> 03:10:13,940
朋友们

4446
03:10:13,940 --> 03:10:14,690
辛苦了

4447
03:10:15,600 --> 03:10:15,960
拜拜

4448
03:10:17,080 --> 03:10:17,590
下课

4449
03:10:21,380 --> 03:10:22,520
拜拜

