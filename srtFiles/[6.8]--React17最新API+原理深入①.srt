1
00:01:22,590 --> 00:01:23,190
思念

2
00:01:25,910 --> 00:01:26,780
滴答

3
00:01:27,890 --> 00:01:29,600
滴答许

4
00:01:32,090 --> 00:01:32,840
告诉

5
00:01:38,060 --> 00:01:38,510
哒哒

6
00:01:39,620 --> 00:01:40,970
哒哒哒哒

7
00:01:45,790 --> 00:01:47,740
东西嘎洒

8
00:01:48,040 --> 00:01:48,490
Hello

9
00:02:27,450 --> 00:02:28,440
孤独

10
00:02:28,440 --> 00:02:29,280
你该死哪

11
00:02:29,280 --> 00:02:29,940
没多久

12
00:02:45,960 --> 00:02:48,750
梦里的叹息

13
00:03:08,340 --> 00:03:09,000
多么大

14
00:03:17,010 --> 00:03:17,700
希望

15
00:03:40,530 --> 00:03:41,370
吧

16
00:03:53,750 --> 00:03:54,500
一米

17
00:03:57,990 --> 00:03:58,950
伊玛目

18
00:04:05,200 --> 00:04:05,560
Kiss

19
00:04:07,960 --> 00:04:10,690
提莫洛希诺丝的

20
00:04:14,750 --> 00:04:15,950
哒哒哒哒

21
00:04:17,240 --> 00:05:10,100
哒哒哒哒啦

22
00:07:07,180 --> 00:07:08,290
微凉的车

23
00:07:08,290 --> 00:07:10,990
车是扶持八路由

24
00:07:14,290 --> 00:07:15,280
的残酷

25
00:07:15,550 --> 00:07:18,010
一切都为了通往圣堂的路

26
00:07:18,010 --> 00:07:18,790
吹不散

27
00:07:20,650 --> 00:07:21,520
水轻柔

28
00:07:23,770 --> 00:07:26,050
着

29
00:07:28,720 --> 00:07:31,600
我们每天都追着不同的罪

30
00:07:31,810 --> 00:07:34,210
我能决定谁对谁又该要沉睡

31
00:07:34,480 --> 00:07:35,770
争论不能解决

32
00:07:35,770 --> 00:07:42,430
在用我自己的关掉的最唯一的站在前面的人都有最后面无路可退

33
00:07:44,680 --> 00:07:46,000
吃亏就像

34
00:07:47,110 --> 00:07:47,530
深藏

35
00:07:50,860 --> 00:07:52,210
希望我的左手

36
00:07:52,330 --> 00:07:52,990
没关系的

37
00:07:52,990 --> 00:07:54,700
结果他就让我去战场

38
00:07:54,700 --> 00:07:55,090
弱智

39
00:08:03,170 --> 00:08:05,600
等下我们08:05的时候开始

40
00:08:07,910 --> 00:08:09,140
根据以往的经验

41
00:08:09,140 --> 00:08:11,150
八点钟应该来的不是很多

42
00:08:27,560 --> 00:08:28,160
承受

43
00:08:30,020 --> 00:08:30,590
着

44
00:08:33,050 --> 00:08:33,920
这个这个

45
00:08:35,030 --> 00:08:35,720
小说

46
00:08:38,960 --> 00:08:39,170
的

47
00:08:40,610 --> 00:08:41,300
天空

48
00:08:41,300 --> 00:08:41,480
下

49
00:08:46,400 --> 00:08:48,410
着我的双手

50
00:08:48,560 --> 00:08:50,900
一卡一卡

51
00:08:52,640 --> 00:08:53,210
的沙

52
00:09:09,380 --> 00:09:10,670
一朵

53
00:09:26,520 --> 00:09:30,450
最喜欢我的左手美国吃的承诺战场

54
00:09:30,450 --> 00:09:36,690
作为艺人蓝色联盟推动烟花的撒珊序幕

55
00:09:39,360 --> 00:09:39,690
开始

56
00:09:42,090 --> 00:09:42,930
逐渐减少

57
00:09:43,080 --> 00:09:43,650
长春

58
00:09:43,650 --> 00:09:44,670
承载着

59
00:09:45,810 --> 00:09:48,480
整个世界的我们一起来祷告

60
00:09:54,390 --> 00:09:54,660
请

61
00:10:03,300 --> 00:10:03,930
丞相

62
00:10:14,220 --> 00:10:14,760
坠

63
00:10:17,280 --> 00:10:17,640
坠

64
00:10:45,600 --> 00:10:46,020
守

65
00:10:47,040 --> 00:10:47,640
着守

66
00:10:49,500 --> 00:10:50,040
着

67
00:10:54,510 --> 00:10:55,170
说说

68
00:10:56,370 --> 00:10:57,030
感觉

69
00:11:05,550 --> 00:11:10,350
冲上家庭的莎莎这样守着

70
00:11:10,350 --> 00:11:10,740
撒

71
00:11:12,090 --> 00:11:12,570
着

72
00:11:15,660 --> 00:11:16,080
陌生

73
00:11:44,850 --> 00:11:45,900
跟我聊啥呢

74
00:12:29,000 --> 00:12:34,580
迷谷浪刻薄那旮瘩大米

75
00:12:39,970 --> 00:12:40,600
妻子

76
00:12:52,140 --> 00:12:53,190
快乐

77
00:12:54,330 --> 00:12:54,990
度过

78
00:13:06,230 --> 00:13:07,400
何必有我

79
00:13:09,710 --> 00:13:10,850
大哥

80
00:13:21,740 --> 00:13:24,620
一路好地方诺

81
00:13:26,510 --> 00:13:27,620
的日记卡

82
00:13:34,160 --> 00:13:36,740
好自由

83
00:14:22,850 --> 00:14:26,180
But me I know he I want

84
00:14:28,340 --> 00:14:28,580
you

85
00:14:43,340 --> 00:14:45,200
抖的修路

86
00:14:46,580 --> 00:14:47,450
高

87
00:14:49,580 --> 00:14:50,630
比

88
00:14:53,820 --> 00:14:56,880
随花落

89
00:15:01,250 --> 00:15:02,300
咔咔

90
00:15:03,800 --> 00:15:04,220
咔

91
00:15:40,380 --> 00:15:41,340
喋喋不休

92
00:15:51,820 --> 00:15:52,450
同学们

93
00:15:56,500 --> 00:15:56,830
对

94
00:15:56,860 --> 00:15:57,550
第一次见

95
00:15:58,570 --> 00:15:59,800
第一次见同学们

96
00:15:59,800 --> 00:16:01,690
今天我们就开始上

97
00:16:01,690 --> 00:16:03,370
我们正式开始我们的课程了

98
00:16:03,520 --> 00:16:03,880
我们

99
00:16:06,240 --> 00:16:06,510
对

100
00:16:06,510 --> 00:16:08,010
我姓何

101
00:16:09,070 --> 00:16:09,430
大家好

102
00:16:09,430 --> 00:16:10,060
我姓何

103
00:16:10,060 --> 00:16:11,560
大家可以叫我何老师

104
00:16:11,890 --> 00:16:16,180
那我主要是给大家讲那个react的源码系列

105
00:16:16,450 --> 00:16:17,770
一共有三节课

106
00:16:18,250 --> 00:16:19,840
然后今天报了三节

107
00:16:19,840 --> 00:16:21,850
然后还有周天有两节

108
00:16:21,850 --> 00:16:22,870
然后一共三节课

109
00:16:23,230 --> 00:16:25,870
我们会讲到哪部分呢

110
00:16:25,990 --> 00:16:27,520
我们会讲大概会讲

111
00:16:29,230 --> 00:16:30,520
大概会讲到

112
00:16:33,950 --> 00:16:36,950
一个是其实会讲到整个Rex的那个

113
00:16:37,280 --> 00:16:39,860
你会讲怎么学习源码

114
00:16:40,040 --> 00:16:40,760
然后呢

115
00:16:40,760 --> 00:16:43,460
React它里面的价格的眼镜

116
00:16:43,700 --> 00:16:45,680
以及他现在REACT17

117
00:16:45,680 --> 00:16:47,030
我主要是

118
00:16:47,030 --> 00:16:51,560
基于之前REACT17来分析的他的三大块

119
00:16:51,560 --> 00:16:53,090
三大块结构怎么样

120
00:16:53,090 --> 00:16:55,520
然后最后会给大家讲一下

121
00:16:55,520 --> 00:16:56,810
就是REX18

122
00:16:56,810 --> 00:16:58,340
然后带来一些新的变化

123
00:16:58,700 --> 00:17:02,060
以及还有一些常用的一些面试题

124
00:17:02,090 --> 00:17:04,460
就是常用的he right相关的一些面试题

125
00:17:04,910 --> 00:17:09,860
会给大家做一定程度的那个就是这是之前班主任老师

126
00:17:09,860 --> 00:17:11,660
然后收集了一波

127
00:17:11,960 --> 00:17:13,310
就是正经的

128
00:17:13,310 --> 00:17:15,380
就是在大厂面试问到的

129
00:17:15,650 --> 00:17:16,910
经常问到的一些题目

130
00:17:16,910 --> 00:17:19,430
也可以给大家做一些那个归纳

131
00:17:20,430 --> 00:17:21,600
我我是四川的

132
00:17:22,140 --> 00:17:23,610
我四川的现在在北京

133
00:17:25,040 --> 00:17:26,210
老家在四川那边

134
00:17:27,350 --> 00:17:29,030
老家是那个好

135
00:17:29,030 --> 00:17:33,470
我们先来看一下那个rap的源码源码吧

136
00:17:33,470 --> 00:17:37,940
这个是我下载的网上的RIGHT17.0.0

137
00:17:38,990 --> 00:17:42,260
然后这个版本就是这个版本的源码

138
00:17:42,530 --> 00:17:44,210
其实我们可以看一下它的源码

139
00:17:44,210 --> 00:17:45,020
如果你看

140
00:17:45,590 --> 00:17:48,110
你看一个rock的源码

141
00:17:48,260 --> 00:17:49,940
一个那个开元的一个框架

142
00:17:49,970 --> 00:17:51,620
如果它里面有很多东西的话

143
00:17:51,620 --> 00:17:53,000
基本上都是这种结构

144
00:17:53,300 --> 00:17:54,050
基本都是几个

145
00:17:54,050 --> 00:17:56,060
如果你在你们公司里

146
00:17:56,510 --> 00:17:57,500
如果说

147
00:17:57,500 --> 00:17:58,850
你们也想发布一些包

148
00:17:58,850 --> 00:18:01,220
然后到NPM上发布包

149
00:18:01,220 --> 00:18:01,760
NPM上

150
00:18:01,760 --> 00:18:05,180
那么那么你可能有一个一类的包

151
00:18:05,180 --> 00:18:05,510
对吧

152
00:18:05,630 --> 00:18:07,340
你发不不可能只发布一个包

153
00:18:07,400 --> 00:18:10,130
其实也都是用这种结构

154
00:18:10,400 --> 00:18:11,270
比如外边儿

155
00:18:12,140 --> 00:18:14,810
外边儿有一些那个文件

156
00:18:14,810 --> 00:18:16,850
比如说这里向他这里很多

157
00:18:16,880 --> 00:18:18,770
不过他这里像yes

158
00:18:19,190 --> 00:18:21,980
Yes ignore get e nor这些都是必须的吗

159
00:18:22,460 --> 00:18:23,660
他这里还有像

160
00:18:26,190 --> 00:18:26,970
我看看

161
00:18:27,030 --> 00:18:28,530
这个是背包

162
00:18:28,530 --> 00:18:30,900
这个danger danger danger fell

163
00:18:30,900 --> 00:18:32,820
这个danger fear就是来

164
00:18:32,820 --> 00:18:37,020
他是在那个C上来去执行你要检查的某些东西

165
00:18:37,050 --> 00:18:39,330
如果如果你的检查不通过的话

166
00:18:39,330 --> 00:18:40,890
那么他就不会通过

167
00:18:40,920 --> 00:18:41,970
那么就会给你打过去

168
00:18:41,970 --> 00:18:43,890
提交上就不能提交成功

169
00:18:44,340 --> 00:18:47,430
等这些塞的检查检查下

170
00:18:47,730 --> 00:18:50,820
然后一般script这里边儿是拿来放什么

171
00:18:50,820 --> 00:18:51,510
拿来放

172
00:18:51,690 --> 00:18:54,210
我们用来打包构建相关的东西

173
00:18:54,480 --> 00:18:57,060
一般用一个文件夹叫做script发

174
00:18:57,660 --> 00:18:59,520
大体的话大概然后我们

175
00:18:59,550 --> 00:19:00,570
然后我们的罗

176
00:19:01,150 --> 00:19:02,200
我们的安全包

177
00:19:02,230 --> 00:19:04,660
然后会放在packages下面

178
00:19:05,230 --> 00:19:08,140
大家看这个package package下面我们可以看到一些熟悉的

179
00:19:08,140 --> 00:19:11,050
除了我们经常熟悉的lac之外

180
00:19:11,720 --> 00:19:16,040
然后你看还有REC的开始第一位臭写在里边

181
00:19:16,340 --> 00:19:18,950
所以他每一次每一个都可以把它

182
00:19:19,190 --> 00:19:21,680
应该都是可以把它打造成一个恩平包的

183
00:19:22,190 --> 00:19:24,950
大家看每一个都其实都是可以打造成一个面包的

184
00:19:25,460 --> 00:19:26,930
所以这个pacs下

185
00:19:26,960 --> 00:19:30,020
它相当于是N多个恩平分包的一种结合

186
00:19:30,740 --> 00:19:32,600
一种就是放在同一个仓库里

187
00:19:33,280 --> 00:19:34,450
放在同一个仓库

188
00:19:34,540 --> 00:19:37,600
然后还有他应该是用

189
00:19:39,640 --> 00:19:40,810
真的没有用那个

190
00:19:42,710 --> 00:19:42,980
好

191
00:19:43,370 --> 00:19:44,870
所以我们的源码部分的话

192
00:19:44,900 --> 00:19:46,310
大概都在package下面儿

193
00:19:46,310 --> 00:19:48,680
我们今天也肯定也看不了这么多

194
00:19:48,800 --> 00:19:49,700
肯定看不了这么多

195
00:19:49,700 --> 00:19:51,410
所有的我们会看react

196
00:19:52,010 --> 00:19:53,060
然后write down

197
00:19:54,070 --> 00:19:55,420
以及he right

198
00:19:55,420 --> 00:19:56,530
但他会依赖什么

199
00:19:56,530 --> 00:19:59,080
它会依赖这个schedule里面的东西

200
00:19:59,530 --> 00:20:01,450
Schedule就是我们的调度器

201
00:20:01,930 --> 00:20:07,030
调度器REC的REC前期的就是它有一部分的逻辑

202
00:20:07,030 --> 00:20:08,710
它是放在skater里面呢

203
00:20:08,710 --> 00:20:10,240
我们也是

204
00:20:10,240 --> 00:20:11,560
随时会用了

205
00:20:12,100 --> 00:20:18,160
还有这边大家还可以看到其他像这个relative render relative没有在这里面

206
00:20:18,160 --> 00:20:21,700
但是有个relative and or还是wreck to re consider

207
00:20:21,970 --> 00:20:24,280
这个后面都会给大家提到一嘴

208
00:20:24,940 --> 00:20:25,510
提到一嘴

209
00:20:25,540 --> 00:20:31,240
其实它在我们进行代码的分析当中就会涉及到re consider和这个schedule or

210
00:20:31,660 --> 00:20:33,490
这两块其实还是蛮重要的

211
00:20:33,490 --> 00:20:34,540
到时候给大家提

212
00:20:34,750 --> 00:20:39,190
以及这个react native render也会给大家提一提

213
00:20:40,100 --> 00:20:43,760
这就是我我们及我们所要讲的内容

214
00:20:44,090 --> 00:20:46,580
然后之前有很多同学

215
00:20:46,580 --> 00:20:47,600
然后就有疑问

216
00:20:47,600 --> 00:20:52,430
就是比如他们就问就是就到底要怎样才能

217
00:20:52,550 --> 00:20:53,780
到底要怎样学习源码

218
00:20:53,810 --> 00:20:54,590
因为源码的话

219
00:20:54,590 --> 00:20:55,850
一般学习比较枯燥

220
00:20:56,150 --> 00:20:57,260
而且也比较困难

221
00:20:57,530 --> 00:20:58,070
所以

222
00:20:58,660 --> 00:21:03,730
所以有必要给大家先做一个这个如何看源码的这样一个讲解

223
00:21:04,150 --> 00:21:04,900
你要看源码

224
00:21:04,900 --> 00:21:08,170
首先第一个要点的做源码分析

225
00:21:08,620 --> 00:21:10,000
其实确实是有点儿

226
00:21:10,700 --> 00:21:12,110
相较之于使用来说

227
00:21:12,110 --> 00:21:13,250
确实是会比较难一点

228
00:21:13,280 --> 00:21:14,840
但是为什么要做圆满分析呢

229
00:21:15,260 --> 00:21:16,610
因为有的时候比如

230
00:21:17,250 --> 00:21:20,880
有的时候你在生产环境下或者开发环境下

231
00:21:20,880 --> 00:21:22,410
如果你遇到某一个问题

232
00:21:22,920 --> 00:21:24,030
遇到了某个问题

233
00:21:24,060 --> 00:21:28,680
然后网上又没有现成的答案可以去帮你解答的时候

234
00:21:29,040 --> 00:21:30,300
你就只剩下一条路

235
00:21:30,330 --> 00:21:32,460
那就是看它的源码到底是怎么样写的

236
00:21:32,700 --> 00:21:37,050
因为我们前端有有那个NBNNPM仓库

237
00:21:37,470 --> 00:21:40,290
大家平时不用恩平包肯定是不可能的

238
00:21:40,920 --> 00:21:41,400
那么

239
00:21:42,060 --> 00:21:44,010
或多或少都会用到恩平包

240
00:21:44,700 --> 00:21:45,990
那么你要是遇到

241
00:21:45,990 --> 00:21:47,610
你要是遇到有一两个NB吧

242
00:21:47,610 --> 00:21:50,520
正好正好出现了某些问题

243
00:21:50,790 --> 00:21:53,490
而这些问题就是别人所没有遇到过的

244
00:21:53,550 --> 00:21:54,810
那么这个时候怎么办呢

245
00:21:55,380 --> 00:21:57,630
他们就只有通过阅读源码来解决

246
00:21:57,720 --> 00:22:00,420
阅读源码然后找到出错的位置

247
00:22:00,780 --> 00:22:04,170
或者找到运行就是不正常的位置

248
00:22:04,470 --> 00:22:06,060
然后来调试

249
00:22:06,480 --> 00:22:07,500
然后来找到

250
00:22:08,530 --> 00:22:10,720
然后才找到就是具体定位到哪个地方

251
00:22:10,720 --> 00:22:13,540
或者是你到底是你的写法不对

252
00:22:13,570 --> 00:22:14,890
如果是你的写法不对的话

253
00:22:15,160 --> 00:22:17,050
那么你可以改变自己的写法

254
00:22:17,530 --> 00:22:19,120
那么更有可能的是

255
00:22:19,450 --> 00:22:22,270
可能就是这个包里面有一个bug被你给碰上了

256
00:22:22,820 --> 00:22:25,370
那么那么你还要提个eater

257
00:22:25,400 --> 00:22:26,030
提个issue

258
00:22:26,030 --> 00:22:28,760
然后给那个报的作者呢

259
00:22:28,760 --> 00:22:29,870
这个这个

260
00:22:29,900 --> 00:22:32,330
所以阅读源码其实对于前端来说

261
00:22:32,330 --> 00:22:33,950
其实是以下

262
00:22:33,950 --> 00:22:34,910
对于高级

263
00:22:35,120 --> 00:22:36,380
高级前端工程师来说

264
00:22:36,380 --> 00:22:38,420
是一项必备的一项技能

265
00:22:39,260 --> 00:22:40,310
必备的一项技能

266
00:22:40,490 --> 00:22:41,810
你不能够排斥这个

267
00:22:41,990 --> 00:22:42,770
不能够排斥

268
00:22:42,770 --> 00:22:43,550
也不能够

269
00:22:44,150 --> 00:22:45,110
就是抵触

270
00:22:45,140 --> 00:22:47,720
抵触这个有之前又遇到有同学说

271
00:22:47,720 --> 00:22:48,980
那我为什么要学习源码

272
00:22:48,980 --> 00:22:51,560
我用rap的感觉用的已经挺溜的了

273
00:22:51,890 --> 00:22:53,240
那是因为你没有遇到问题

274
00:22:53,420 --> 00:22:56,270
你如果真的遇到别人也从来没有遇到过的问题

275
00:22:56,960 --> 00:23:00,290
那么你就会如果如果真的遇到了

276
00:23:00,320 --> 00:23:03,860
那么你其实就很难很难解决这个问题了

277
00:23:05,060 --> 00:23:06,080
要能解决这个问题

278
00:23:06,080 --> 00:23:10,970
所以这个是我们阅读源码的一个非常重要的一个一个原因

279
00:23:11,730 --> 00:23:13,470
就比如我前几次遇到的

280
00:23:13,470 --> 00:23:16,020
就是我们在定位rocked

281
00:23:16,260 --> 00:23:17,100
如果写的不好

282
00:23:17,100 --> 00:23:17,640
不好的话

283
00:23:17,640 --> 00:23:19,650
可能有的时候会出现新的问题

284
00:23:20,310 --> 00:23:23,250
那么那么你要定位到底是哪个组件

285
00:23:23,250 --> 00:23:24,840
或者说是哪一部

286
00:23:24,870 --> 00:23:26,700
出现了怎样大的性能开销

287
00:23:27,060 --> 00:23:28,050
那么你要去分析

288
00:23:28,050 --> 00:23:29,700
你就得干什么分析

289
00:23:29,700 --> 00:23:31,590
一般一般这个分析都要

290
00:23:32,870 --> 00:23:35,810
这是通过我们的performance分析性能

291
00:23:36,170 --> 00:23:37,700
分析性能的时候你会发现什么

292
00:23:37,700 --> 00:23:38,870
你会发现这里面有

293
00:23:39,650 --> 00:23:41,330
你会发现这里有

294
00:23:44,070 --> 00:23:47,070
这里有很多就是react源码相关的东西

295
00:23:48,390 --> 00:23:49,320
正好也看

296
00:23:52,240 --> 00:23:53,080
我没有运气

297
00:23:54,180 --> 00:23:54,870
我没力气

298
00:23:58,330 --> 00:23:59,680
如果说你这样分析的话

299
00:23:59,740 --> 00:24:01,870
他的这个为他在这些位置上

300
00:24:02,440 --> 00:24:03,460
它会出现一个什么呢

301
00:24:03,460 --> 00:24:04,270
每一个函数

302
00:24:04,270 --> 00:24:04,840
比如你

303
00:24:05,380 --> 00:24:06,580
比如这这一段

304
00:24:06,580 --> 00:24:09,280
然后是某个函数调用的战的时长

305
00:24:09,310 --> 00:24:10,720
这段是某个函数站的时长

306
00:24:11,170 --> 00:24:13,510
而你在wrecked如果用red开发

307
00:24:13,510 --> 00:24:17,200
你就你就发现它有很多食材都是right内部的鸽子

308
00:24:17,350 --> 00:24:18,730
内部的函数给占据的

309
00:24:19,180 --> 00:24:22,960
那么你要分析他到底是具体某一个地方

310
00:24:22,960 --> 00:24:23,770
有新的开销

311
00:24:23,770 --> 00:24:24,610
有新的问题

312
00:24:24,640 --> 00:24:27,640
你怎样才能顺藤摸瓜的找到那个组件

313
00:24:27,970 --> 00:24:29,110
或者找到那个位置

314
00:24:29,320 --> 00:24:29,950
那么你

315
00:24:30,440 --> 00:24:32,480
如果懂表演相关的源码

316
00:24:32,480 --> 00:24:35,360
那么其实找起来的话也会比较快

317
00:24:35,480 --> 00:24:36,110
也会比较快

318
00:24:36,110 --> 00:24:37,820
这就是我们要学习源码的理由

319
00:24:38,540 --> 00:24:39,680
那么我们怎样学习呢

320
00:24:40,100 --> 00:24:41,990
你首先要看源码的话

321
00:24:42,260 --> 00:24:46,340
我觉得第一件事情就是你首先你首先得是他的用户

322
00:24:46,370 --> 00:24:48,170
比如你是re

323
00:24:48,170 --> 00:24:49,550
你要看red的源码

324
00:24:50,460 --> 00:24:53,190
那么大家首先需要掌握的就是它的API

325
00:24:53,820 --> 00:24:55,710
就是他那边我们没有办法

326
00:24:55,710 --> 00:24:57,990
就是一行代码一行代码

327
00:24:57,990 --> 00:24:58,590
一行代码

328
00:24:58,590 --> 00:24:59,640
就是说

329
00:24:59,640 --> 00:25:00,750
就是没有这么看源码的

330
00:25:00,750 --> 00:25:03,420
就是从这儿歌有的同学这么看

331
00:25:03,420 --> 00:25:05,430
原版的从这儿第一行是什么

332
00:25:05,610 --> 00:25:08,040
然后一直从里面找找找

333
00:25:08,460 --> 00:25:09,060
然后

334
00:25:09,650 --> 00:25:10,550
一行一行的看

335
00:25:10,580 --> 00:25:12,260
这种是绝对不行的

336
00:25:12,350 --> 00:25:13,100
这是绝对不行的

337
00:25:13,100 --> 00:25:14,780
特别是像like这种大库

338
00:25:15,110 --> 00:25:17,120
他源代码实在是太多了

339
00:25:17,510 --> 00:25:20,810
而且有很多的功能是经常缠绕在一起的

340
00:25:21,050 --> 00:25:22,310
经常缠绕在一起

341
00:25:22,460 --> 00:25:26,240
你很难就是通过一行一行代码去把它给读出来

342
00:25:26,960 --> 00:25:29,000
而有些裤子可以有些不可以

343
00:25:29,000 --> 00:25:32,180
比如说之前未向web1.0的时候

344
00:25:32,750 --> 00:25:34,100
向web1.0的时候

345
00:25:34,400 --> 00:25:37,670
它那个功能我当时就把他原版扒下来看了一下

346
00:25:38,300 --> 00:25:39,800
然后

347
00:25:39,830 --> 00:25:42,320
基本上你可以一行一行的往下看也没问题

348
00:25:42,500 --> 00:25:45,530
但是这种即使是一些小的库里

349
00:25:45,530 --> 00:25:47,480
一行一行看下来可能

350
00:25:47,960 --> 00:25:49,730
有一些细微的地方你还是不明白

351
00:25:49,760 --> 00:25:51,800
这种时候就得调试运行的来看

352
00:25:52,280 --> 00:25:53,540
所以第一件事

353
00:25:53,540 --> 00:25:55,670
如果建议大家看原版的时候

354
00:25:55,670 --> 00:25:58,190
第一首先你肯定要知道他是哪个API

355
00:25:58,190 --> 00:26:00,680
你要掌握哪个X哪个API

356
00:26:01,190 --> 00:26:02,630
然后你掌握了那个API

357
00:26:02,960 --> 00:26:04,640
就是你学会用了这个APP

358
00:26:04,640 --> 00:26:06,590
你至少知道他是干什么的

359
00:26:06,920 --> 00:26:11,090
然后你就来针对性的看这一个地方

360
00:26:11,150 --> 00:26:12,110
看这一个位置

361
00:26:13,270 --> 00:26:14,140
站在一个位置

362
00:26:15,310 --> 00:26:16,600
而如果你还不明白的话

363
00:26:16,600 --> 00:26:18,460
我们其实通过

364
00:26:18,460 --> 00:26:20,440
Chrome的这种的bug的形式

365
00:26:20,440 --> 00:26:23,440
我们实际上是可以通过断点然后打进去的

366
00:26:23,860 --> 00:26:24,940
比如我们city state

367
00:26:25,060 --> 00:26:25,360
对吧

368
00:26:25,360 --> 00:26:26,410
假如一个city state

369
00:26:27,160 --> 00:26:28,510
我们我们

370
00:26:29,060 --> 00:26:34,070
我们的开发者所写到的调用的代码就是city state

371
00:26:34,280 --> 00:26:35,900
它里边到底怎么运行的

372
00:26:35,930 --> 00:26:37,580
那么你可以跟进去

373
00:26:37,580 --> 00:26:40,070
一个一个的来的bug的bug

374
00:26:40,460 --> 00:26:42,200
那么这是第二步

375
00:26:42,230 --> 00:26:43,370
如果你是第八个

376
00:26:43,370 --> 00:26:46,070
不明白的时候要学会抓大放小

377
00:26:46,370 --> 00:26:50,090
因为像react和其他的酷

378
00:26:50,720 --> 00:26:54,860
一喝鸡巴喝加速相比其实算是一个比较庞大的一个类一个内裤了

379
00:26:55,310 --> 00:26:56,060
它里面的逻辑

380
00:26:56,060 --> 00:26:58,460
比如说sight的逻辑就很多就很多

381
00:26:58,490 --> 00:26:59,420
你要学会取舍

382
00:26:59,420 --> 00:27:01,070
就是她和你

383
00:27:01,070 --> 00:27:02,540
和你想关注的那份

384
00:27:02,540 --> 00:27:05,030
比如你想关注说他为什么

385
00:27:05,030 --> 00:27:06,350
我给他写的CC的

386
00:27:06,350 --> 00:27:07,040
他没有粒

387
00:27:07,130 --> 00:27:08,210
他没有立马更新

388
00:27:08,480 --> 00:27:09,020
你想

389
00:27:09,520 --> 00:27:10,600
找的是这个问题

390
00:27:11,230 --> 00:27:14,380
那么其他的你可以暂时先把他给忽略掉

391
00:27:14,710 --> 00:27:16,030
那么至关主要的部分

392
00:27:16,210 --> 00:27:17,770
我们把主要的作用先看明白

393
00:27:18,520 --> 00:27:19,120
然后

394
00:27:19,760 --> 00:27:21,500
先明白一个函数是做什么的

395
00:27:21,530 --> 00:27:24,320
就是如果说你的一个函数

396
00:27:24,530 --> 00:27:25,730
我可以举个例子

397
00:27:26,570 --> 00:27:27,410
比如举个例子

398
00:27:27,410 --> 00:27:28,310
比如像

399
00:27:30,100 --> 00:27:30,550
Render

400
00:27:35,040 --> 00:27:35,910
就是这个函数

401
00:27:38,110 --> 00:27:39,670
这里面其实就掉了很多

402
00:27:42,170 --> 00:27:44,150
里边儿又掉了很多逻辑

403
00:27:44,150 --> 00:27:52,340
它里面皮特update a container我们看到有有两有两个分支

404
00:27:53,170 --> 00:27:53,380
对啊

405
00:27:53,380 --> 00:27:54,250
我们分析的时候

406
00:27:54,250 --> 00:27:57,460
比如我们要知道这个方法到底干了什么

407
00:27:57,460 --> 00:28:01,390
我们就可以通过先检查主要分支来看

408
00:28:01,660 --> 00:28:02,920
比如这两个分支

409
00:28:03,010 --> 00:28:05,200
第一个分支就是

410
00:28:05,200 --> 00:28:07,390
当他这个其实很好看懂

411
00:28:07,570 --> 00:28:09,070
当他那个room存在的时候

412
00:28:09,070 --> 00:28:11,110
就是如routes

413
00:28:11,710 --> 00:28:12,520
不存在的时候

414
00:28:12,550 --> 00:28:14,380
刚开始入的不存在的

415
00:28:14,380 --> 00:28:15,070
不存在呢

416
00:28:15,070 --> 00:28:17,680
也就是说他之前从来没有被注册过

417
00:28:18,400 --> 00:28:18,730
对吧

418
00:28:18,760 --> 00:28:20,260
没有被注册过就走这个分子

419
00:28:20,260 --> 00:28:21,910
如果他已经被注册过了

420
00:28:22,210 --> 00:28:23,320
就是下面这个分子

421
00:28:24,130 --> 00:28:26,620
所以它区分了两种场景而已

422
00:28:26,620 --> 00:28:28,180
如果没有被注册过的话

423
00:28:28,210 --> 00:28:31,120
他给这个地方包了一个an based update

424
00:28:31,870 --> 00:28:33,250
有点儿有点儿不同了

425
00:28:33,580 --> 00:28:35,260
而如果已经注册过的话

426
00:28:35,590 --> 00:28:40,060
他并不会给他包上一个叫做update update这个东西

427
00:28:40,600 --> 00:28:43,450
这个东西我们只好通过找他的不同可以找到

428
00:28:43,450 --> 00:28:45,280
那么我们接下来就要分析

429
00:28:45,280 --> 00:28:45,940
为什么

430
00:28:46,270 --> 00:28:49,000
为什么这个这么一个区别

431
00:28:49,420 --> 00:28:50,740
昂被消费者是干什么的呢

432
00:28:50,740 --> 00:28:53,230
我们你再通过其他地方找就看到

433
00:28:53,230 --> 00:28:55,150
原来是on based的

434
00:28:55,150 --> 00:28:57,130
原来是指的是不批处理

435
00:28:57,190 --> 00:28:59,110
然后用最高优先级把它

436
00:29:00,000 --> 00:29:00,330
嗯

437
00:29:00,990 --> 00:29:03,630
渲染出来可能现在好一些吗

438
00:29:06,460 --> 00:29:07,570
现在能看到吗

439
00:29:14,620 --> 00:29:15,370
现在呢

440
00:29:15,400 --> 00:29:16,330
我再放大点

441
00:29:19,870 --> 00:29:20,170
好

442
00:29:20,770 --> 00:29:22,150
然后我们再通过其他分析

443
00:29:22,150 --> 00:29:23,650
但是这个分析是我分析的

444
00:29:24,040 --> 00:29:25,930
不是大家分析的

445
00:29:25,930 --> 00:29:27,790
不是大家分析的

446
00:29:27,820 --> 00:29:31,660
通过比如查找他的那个代码逻辑可以直接得到

447
00:29:31,660 --> 00:29:35,440
但是这个方法在react里用的还是挺挺多的

448
00:29:35,440 --> 00:29:36,370
内部用的还是挺多的

449
00:29:36,370 --> 00:29:38,170
我们也其实也可以外边儿掉

450
00:29:38,560 --> 00:29:41,140
他的意思是不期望不作批处理

451
00:29:41,410 --> 00:29:43,600
然后立刻就有最高优先级渲染出来

452
00:29:44,380 --> 00:29:47,140
然后所以就给他包了一个on based update

453
00:29:47,850 --> 00:29:50,250
这儿有个概念叫做批处理

454
00:29:50,400 --> 00:29:51,360
什么是批处理

455
00:29:51,570 --> 00:29:52,200
比如说

456
00:29:52,880 --> 00:29:53,540
比如这里

457
00:29:54,180 --> 00:29:56,100
我掉了一个this date

458
00:29:56,580 --> 00:29:58,740
同时又掉了一个this date

459
00:30:00,170 --> 00:30:01,670
我这儿同时掉了两个

460
00:30:01,700 --> 00:30:04,700
就是就是从上到下掉了两个

461
00:30:04,970 --> 00:30:06,350
那么在react里

462
00:30:06,920 --> 00:30:09,530
在react如果它是发生在生命周期内的

463
00:30:10,010 --> 00:30:12,440
如果假如他是component did mount

464
00:30:12,440 --> 00:30:13,610
我写全一点

465
00:30:24,110 --> 00:30:26,300
如果他是在component did mount类

466
00:30:26,720 --> 00:30:29,960
那么虽然我掉了两次c EST

467
00:30:30,170 --> 00:30:32,180
但实际上它只会执行一次

468
00:30:32,210 --> 00:30:34,280
它内部只会执行一次更新

469
00:30:34,850 --> 00:30:36,350
它的更新只会执行一次

470
00:30:36,560 --> 00:30:40,910
所以我们就认为他的J两次发起

471
00:30:40,910 --> 00:30:42,140
两次发起的更新

472
00:30:42,230 --> 00:30:44,270
然后被做成了一个批次的一个处理

473
00:30:44,300 --> 00:30:46,220
所以叫做批处理耳

474
00:30:46,820 --> 00:30:47,750
这时毫无疑问

475
00:30:47,750 --> 00:30:49,490
做这个PPT的作用是干啥

476
00:30:49,520 --> 00:30:50,660
肯定是为了优化性能

477
00:30:50,660 --> 00:30:50,930
对吧

478
00:30:51,110 --> 00:30:52,220
如果你一次

479
00:30:52,640 --> 00:30:55,310
你比如说掉了三次、四次、五次

480
00:30:55,580 --> 00:30:58,520
那么你每次比如每设一个赛特

481
00:30:58,520 --> 00:30:59,060
赛特

482
00:30:59,180 --> 00:31:00,950
然后你内部都发几次更新

483
00:31:00,950 --> 00:31:03,290
那我们的JS的损耗其实是挺大的

484
00:31:03,620 --> 00:31:04,820
特别是什么呢

485
00:31:04,820 --> 00:31:08,390
特别是你的rock的组建的组建速特别庞大的时候

486
00:31:08,570 --> 00:31:10,700
那么他这个开销其实是非常恐怖的

487
00:31:11,270 --> 00:31:12,800
所以这就叫一个p react

488
00:31:12,800 --> 00:31:14,240
有一个批处理的优化

489
00:31:14,600 --> 00:31:17,570
而这他on based on data

490
00:31:18,260 --> 00:31:20,480
这指的是不是批处理的一个

491
00:31:20,480 --> 00:31:21,860
不是批处理的一个优化

492
00:31:22,430 --> 00:31:24,410
那么有同学就搞不懂了

493
00:31:24,410 --> 00:31:28,850
就说老师既然说批处理是对性能的一个优化

494
00:31:28,880 --> 00:31:31,190
那么这为什么还要专门写作

495
00:31:31,430 --> 00:31:32,210
不是批处理

496
00:31:32,690 --> 00:31:34,040
其实认真一想

497
00:31:34,100 --> 00:31:36,170
老师当时也是认真想了三秒钟

498
00:31:36,200 --> 00:31:37,010
然后想明白了

499
00:31:37,130 --> 00:31:37,640
为什么呢

500
00:31:37,790 --> 00:31:40,760
因为如果进了这个分支说明什么

501
00:31:40,760 --> 00:31:45,050
说明他之前从来没有被渲染过精致分支是从哪儿来的呢

502
00:31:45,080 --> 00:31:45,650
是从

503
00:31:46,320 --> 00:31:47,250
这个市场

504
00:31:48,680 --> 00:31:49,400
Fracture

505
00:31:51,800 --> 00:31:52,730
当地render

506
00:31:54,540 --> 00:31:54,990
对吧

507
00:31:55,020 --> 00:31:59,220
这个我肯定必必须会用到这个函数的REC的render

508
00:31:59,220 --> 00:32:00,870
第一次的时候他就走到这儿来了

509
00:32:01,020 --> 00:32:03,120
然后给他做一个on based on a date

510
00:32:04,090 --> 00:32:04,810
也就是说

511
00:32:04,960 --> 00:32:07,900
因为我们页面上现在大家要理解一下

512
00:32:07,930 --> 00:32:09,580
现在我们页面上什么都没有

513
00:32:10,500 --> 00:32:12,360
因为我我才刚开始调嘛

514
00:32:12,360 --> 00:32:12,630
对吧

515
00:32:12,630 --> 00:32:13,800
我刚刚开始掉

516
00:32:13,920 --> 00:32:15,660
我的页面上现在是什么都没有

517
00:32:15,660 --> 00:32:17,010
我现在期望的什么

518
00:32:17,010 --> 00:32:19,920
期望的是我的页面上赶紧把东西给渲染出来

519
00:32:20,370 --> 00:32:20,910
我不管

520
00:32:20,910 --> 00:32:22,710
所以我需要我的这个

521
00:32:23,760 --> 00:32:24,690
Render

522
00:32:24,750 --> 00:32:27,960
我的这一次更新一定要是不等的不等

523
00:32:27,960 --> 00:32:30,900
其他剩下的更新我一定要

524
00:32:30,900 --> 00:32:32,220
这次更新一定要最快

525
00:32:32,550 --> 00:32:33,240
一定要最快

526
00:32:33,240 --> 00:32:35,670
所以他给他加了一个ion based update

527
00:32:36,030 --> 00:32:36,570
也就是

528
00:32:37,520 --> 00:32:39,200
也就是我这个

529
00:32:39,200 --> 00:32:40,370
确实REC的内部

530
00:32:40,700 --> 00:32:43,460
它很多地方它默认给你做了自动的批处理

531
00:32:43,520 --> 00:32:47,450
但是但是对于我让点render这一次来说

532
00:32:47,480 --> 00:32:48,680
这第一次来说

533
00:32:48,740 --> 00:32:50,960
我希望他步骤这个批处理的逻辑

534
00:32:51,290 --> 00:32:52,730
我希望它最快的渲染出来

535
00:32:55,880 --> 00:32:56,510
能听懂吗

536
00:32:56,510 --> 00:32:57,410
听懂了的话

537
00:32:58,110 --> 00:32:59,430
同学如果懂了的话

538
00:32:59,430 --> 00:33:00,450
就回答一个一

539
00:33:03,020 --> 00:33:04,250
不懂就靠一个您

540
00:33:06,630 --> 00:33:06,840
OK

541
00:33:06,840 --> 00:33:08,190
这就是write down

542
00:33:08,670 --> 00:33:12,750
那我们就立刻这个函数的功能我们立刻就明白了

543
00:33:12,750 --> 00:33:14,400
原来他做了分了两步

544
00:33:14,610 --> 00:33:16,050
第一步就是区分了一下

545
00:33:16,050 --> 00:33:16,410
然后呢

546
00:33:16,410 --> 00:33:19,320
区分了一下我到底有没有被渲染

547
00:33:19,440 --> 00:33:20,700
到底有没有注册过

548
00:33:20,940 --> 00:33:22,050
如果注册过了

549
00:33:22,230 --> 00:33:23,640
那么号不用

550
00:33:23,640 --> 00:33:26,250
那么我就给他设一个on based update

551
00:33:26,800 --> 00:33:29,470
然后这里是要让他最快的渲染出来

552
00:33:30,070 --> 00:33:31,750
然后再给他这个after container

553
00:33:31,750 --> 00:33:32,740
因为两个都是相同的

554
00:33:32,740 --> 00:33:36,040
我们可以接下来再去看after container到底是指的什么

555
00:33:36,610 --> 00:33:38,320
那如果他已经被渲染过了之后

556
00:33:38,320 --> 00:33:39,700
那么他就可以做批处理了

557
00:33:39,940 --> 00:33:40,870
这个就没关系了

558
00:33:41,230 --> 00:33:41,500
对吧

559
00:33:41,500 --> 00:33:42,760
我们一个函数

560
00:33:42,760 --> 00:33:44,860
一个函数至少就知道它是什么功能

561
00:33:45,250 --> 00:33:46,480
大概知道什么功能

562
00:33:46,780 --> 00:33:49,630
但是我刚刚其实有很多地方也没有讲完

563
00:33:49,900 --> 00:33:50,230
对吧

564
00:33:50,260 --> 00:33:50,950
比如说这个

565
00:33:51,610 --> 00:33:54,160
像这个回调我就没有说因为原因是啥

566
00:33:54,160 --> 00:33:56,830
其实这个平时看的话

567
00:33:57,740 --> 00:33:59,660
这些都都是不难看懂的逻辑

568
00:33:59,660 --> 00:34:00,470
我们可以

569
00:34:00,500 --> 00:34:03,200
但是他和我们想想要就是了解的逻辑

570
00:34:03,410 --> 00:34:05,870
可能就是不是特别相关的

571
00:34:05,870 --> 00:34:07,460
我们都可以先把它忽略掉

572
00:34:07,730 --> 00:34:09,590
但这可以给大家顺便讲一讲

573
00:34:09,830 --> 00:34:11,630
比如这个container direct

574
00:34:12,160 --> 00:34:14,740
如果这个实际上是一个属性

575
00:34:15,160 --> 00:34:16,240
这个属性值

576
00:34:16,970 --> 00:34:20,210
它实际上就是react router recruit这个属性词

577
00:34:20,360 --> 00:34:22,370
它是挂在down上面的

578
00:34:23,280 --> 00:34:25,110
他是挂着them上面的刀

579
00:34:25,110 --> 00:34:26,280
上面挂着这个属性值

580
00:34:26,280 --> 00:34:29,700
就是比如说我们我们REC的render一般都会

581
00:34:30,380 --> 00:34:33,200
一般除了都是这么写的对不对

582
00:34:33,380 --> 00:34:33,950
然后

583
00:34:37,590 --> 00:34:38,130
APP

584
00:34:38,580 --> 00:34:40,110
比如这个当然APP

585
00:34:40,720 --> 00:34:43,150
这个APP这个氮元素

586
00:34:43,680 --> 00:34:45,330
如果是注册个REC的话

587
00:34:45,330 --> 00:34:46,350
那么他就给他挂载一个

588
00:34:46,350 --> 00:34:48,180
这个挂载了它

589
00:34:48,420 --> 00:34:51,690
然后他再去指向我们整个的REC的数

590
00:34:51,780 --> 00:34:53,550
这就指向整个rock数

591
00:34:53,790 --> 00:34:55,260
就是说也就是说

592
00:34:55,780 --> 00:34:57,310
如果说你不想通过

593
00:34:57,310 --> 00:34:59,290
如果你在外边儿

594
00:35:00,320 --> 00:35:01,520
在外边儿

595
00:35:01,520 --> 00:35:01,730
你

596
00:35:01,730 --> 00:35:02,480
你没有

597
00:35:02,510 --> 00:35:04,310
你不是代码的开发者

598
00:35:04,370 --> 00:35:07,700
你如果想要得到整个react的塑型结构

599
00:35:07,730 --> 00:35:08,990
就是那个树形结构

600
00:35:09,350 --> 00:35:10,640
其实你是可以得到的

601
00:35:10,670 --> 00:35:11,960
你只需要找到它的

602
00:35:12,680 --> 00:35:14,030
通过我们的当

603
00:35:14,920 --> 00:35:16,600
就是我们的档操作

604
00:35:16,630 --> 00:35:18,340
先拿到它的这个元素

605
00:35:18,580 --> 00:35:19,720
然后再拿他的

606
00:35:20,330 --> 00:35:21,020
然后这

607
00:35:21,770 --> 00:35:22,370
Root

608
00:35:22,580 --> 00:35:22,940
对

609
00:35:22,970 --> 00:35:25,220
叫做REC to root container

610
00:35:25,250 --> 00:35:28,970
然后里面再找initial root

611
00:35:29,000 --> 00:35:29,570
然后再找

612
00:35:29,570 --> 00:35:32,660
就可以找到整个reg的罪

613
00:35:33,390 --> 00:35:35,940
最祖先的那个组件

614
00:35:36,120 --> 00:35:36,960
你就可以找到他

615
00:35:36,990 --> 00:35:38,700
然后如果你想更改的话

616
00:35:38,700 --> 00:35:39,420
也可以更改

617
00:35:39,840 --> 00:35:41,370
我记得之前看过一篇文章

618
00:35:41,370 --> 00:35:42,960
就是如果说

619
00:35:43,630 --> 00:35:46,240
如果说你想更改

620
00:35:46,940 --> 00:35:49,070
某一个就是站外的

621
00:35:49,070 --> 00:35:50,870
就是你并不是开发者

622
00:35:50,990 --> 00:35:54,710
你想更改它某一个元拿到他的某个

623
00:35:56,050 --> 00:35:58,390
Correct的某个特性就是某个值

624
00:35:58,420 --> 00:35:59,350
那么你可以怎么做

625
00:35:59,380 --> 00:36:02,530
其实就是就是这样就这样操作

626
00:36:02,950 --> 00:36:04,390
我们可以试一下

627
00:36:04,420 --> 00:36:05,170
就是在

628
00:36:06,170 --> 00:36:07,880
所以这个我看一下他是不是

629
00:36:08,680 --> 00:36:09,430
REC的

630
00:36:09,640 --> 00:36:10,900
我也不知道他是不是REC的

631
00:36:10,960 --> 00:36:11,830
我可以看看

632
00:36:12,880 --> 00:36:14,080
他可能是REC的

633
00:36:14,770 --> 00:36:16,330
但是也不是没有那么肯定

634
00:36:18,040 --> 00:36:19,690
比如这个对吧

635
00:36:20,680 --> 00:36:22,000
我们可以操作一下看看

636
00:36:23,320 --> 00:36:24,130
不一定是

637
00:36:24,130 --> 00:36:25,570
我不知道飞出这个

638
00:36:26,710 --> 00:36:29,710
大哥们的点select

639
00:36:35,920 --> 00:36:37,450
我们有个属性叫什么来着

640
00:36:40,060 --> 00:36:41,590
Raptor root container

641
00:36:47,130 --> 00:36:47,760
找到了

642
00:36:47,790 --> 00:36:48,900
大家看找到了

643
00:36:49,600 --> 00:36:50,080
对不对

644
00:36:51,000 --> 00:36:52,350
我们找到run continue

645
00:36:52,350 --> 00:36:54,540
然后我们再来找她的

646
00:36:59,460 --> 00:37:00,060
大家看

647
00:37:02,360 --> 00:37:03,830
然后再找到当前他的

648
00:37:04,630 --> 00:37:07,990
这个kernel kernel就指的是整个根节点

649
00:37:08,320 --> 00:37:09,160
那这个current

650
00:37:09,160 --> 00:37:12,550
其实这current就是跟我们的react组件的根节点

651
00:37:12,850 --> 00:37:14,380
然后里面就是它整个的组件

652
00:37:15,000 --> 00:37:16,050
我们可以找到这个

653
00:37:16,380 --> 00:37:18,810
但有同学说这个可能也没有

654
00:37:19,230 --> 00:37:20,790
就是看起来这个是没有什么用的

655
00:37:20,790 --> 00:37:22,320
但是当你需要用到它的时候

656
00:37:22,940 --> 00:37:24,710
那么你就会非常感谢

657
00:37:24,710 --> 00:37:26,210
然后你知道有这么一件事情

658
00:37:26,540 --> 00:37:28,700
有这么一件事情

659
00:37:28,760 --> 00:37:29,120
OK

660
00:37:29,120 --> 00:37:30,320
闲话就不多说了

661
00:37:30,410 --> 00:37:32,000
感觉有点扯远了

662
00:37:32,360 --> 00:37:33,140
有点扯远了

663
00:37:33,290 --> 00:37:37,730
即使我们来看源码的这么一个这么一个流程吧

664
00:37:37,820 --> 00:37:38,690
这么一个流程

665
00:37:41,440 --> 00:37:44,140
我回到我们的这这个地方来

666
00:37:48,600 --> 00:37:48,960
好

667
00:37:50,100 --> 00:37:53,130
如果我们看明白一个函数是做什么的

668
00:37:53,130 --> 00:37:54,570
然后再弄具体实现

669
00:37:54,630 --> 00:37:55,500
他就这么搞的

670
00:37:55,860 --> 00:37:57,420
但如果你还看不明白的

671
00:37:57,690 --> 00:38:00,270
其实rock我之前看的时候有的也看不明白

672
00:38:00,540 --> 00:38:04,740
那就可以看right相关的一些英雄或者别的开发者之类的文章

673
00:38:04,920 --> 00:38:06,660
也可以来参照一下

674
00:38:07,020 --> 00:38:10,890
参照一下毕竟就是大家都站在巨人的肩膀之上的

675
00:38:10,950 --> 00:38:11,250
对吧

676
00:38:11,760 --> 00:38:12,630
那么最后

677
00:38:13,330 --> 00:38:15,040
看完了这前五个之后

678
00:38:15,310 --> 00:38:18,160
记住一定要做一些简单的DEMO来刺激的运行

679
00:38:18,610 --> 00:38:21,430
具体来看一看和你所设想的到底是不是一样的

680
00:38:21,880 --> 00:38:23,590
这就是学员的几个步骤

681
00:38:23,920 --> 00:38:24,310
当然

682
00:38:25,130 --> 00:38:27,020
它不仅仅适用于ASP的源码

683
00:38:27,080 --> 00:38:28,250
你可以看任何的源码

684
00:38:28,400 --> 00:38:31,700
比如我其其实如果大家刚入门的话

685
00:38:32,330 --> 00:38:33,110
肯定当当然

686
00:38:33,110 --> 00:38:34,790
但是大家肯定不止刚入门了

687
00:38:35,210 --> 00:38:36,860
有几个源码可以一定要去看一下

688
00:38:36,860 --> 00:38:41,300
比如像lo Li的源码的底细了的原版

689
00:38:41,300 --> 00:38:42,200
你看完了之后

690
00:38:42,290 --> 00:38:44,180
你至少对写一些工具类的方法

691
00:38:44,210 --> 00:38:45,050
函数式编程

692
00:38:45,050 --> 00:38:47,180
然后会有一个比较初步的了解

693
00:38:47,760 --> 00:38:48,780
比较初步的了解

694
00:38:49,050 --> 00:38:50,430
然后你可以看一下wait的

695
00:38:51,180 --> 00:38:51,690
Which的

696
00:38:52,260 --> 00:38:54,990
然后view的对吧

697
00:38:55,260 --> 00:38:56,310
那么REC的

698
00:38:56,310 --> 00:38:58,200
那么今天也给大家也再给大家讲

699
00:38:58,380 --> 00:39:03,300
但是下来的话也得需要大家就是讲肯定三节课

700
00:39:03,300 --> 00:39:04,770
我们只有三节课六个小时

701
00:39:05,430 --> 00:39:08,100
那么要把rap这个东西讲完肯定是不现实的

702
00:39:08,130 --> 00:39:08,640
我们会

703
00:39:08,760 --> 00:39:09,750
但是我会讲什么呢

704
00:39:10,230 --> 00:39:12,030
我也讲到它最重要的几个部分

705
00:39:12,270 --> 00:39:14,340
就是怎么样把它流程给串起来

706
00:39:14,910 --> 00:39:16,230
就是我们一个人

707
00:39:16,230 --> 00:39:17,550
比如像一个人wrecked

708
00:39:17,970 --> 00:39:18,900
它和人一样

709
00:39:18,930 --> 00:39:19,980
它有一个骨架

710
00:39:20,040 --> 00:39:20,370
对吧

711
00:39:20,430 --> 00:39:21,030
他有精

712
00:39:21,030 --> 00:39:21,870
他有他的经脉

713
00:39:21,870 --> 00:39:22,380
有骨头

714
00:39:22,380 --> 00:39:23,130
把它连起来

715
00:39:23,460 --> 00:39:24,960
那么这是最要紧的部分

716
00:39:25,740 --> 00:39:26,160
然后呢

717
00:39:26,160 --> 00:39:28,350
剩下的就是填充他的肌肉那些什么的

718
00:39:28,950 --> 00:39:29,610
所以我们

719
00:39:30,240 --> 00:39:35,910
会讲到会讲到就是他最主要的里面的价格

720
00:39:36,240 --> 00:39:40,680
里面的价格剩下的他很多东西都是可以直接填充在这个价格上的

721
00:39:41,010 --> 00:39:42,060
所以不会讲嘛

722
00:39:42,060 --> 00:39:44,580
它所有的API这个是讲不完的

723
00:39:44,820 --> 00:39:45,600
这个是讲不完的

724
00:39:45,990 --> 00:39:48,870
所以而且这个价格也非常的复杂

725
00:39:49,140 --> 00:39:51,420
需要大家下来的话

726
00:39:51,420 --> 00:39:52,890
继续去看一看

727
00:39:52,920 --> 00:39:53,670
继续看一下

728
00:39:55,360 --> 00:39:55,810
行

729
00:39:56,440 --> 00:39:59,020
学习怎样学习源码就给大家讲到这儿了

730
00:39:59,050 --> 00:40:03,430
那我们来看一下从整体的reactor看是怎么引进过来的

731
00:40:03,790 --> 00:40:04,600
怎么演进的

732
00:40:04,870 --> 00:40:06,850
rap我分了几个篇章

733
00:40:07,060 --> 00:40:07,720
第一个wrecked

734
00:40:07,720 --> 00:40:08,980
以前RACK16

735
00:40:08,980 --> 00:40:11,560
之前X16X17

736
00:40:11,800 --> 00:40:13,780
以及最后还有X8

737
00:40:13,780 --> 00:40:16,690
其实ROCK17和18所讲的东西并不多

738
00:40:16,720 --> 00:40:21,670
绝大部分的话是RACK16做了很多调整

739
00:40:21,850 --> 00:40:24,250
大家应该也有这种感觉

740
00:40:24,250 --> 00:40:25,720
RACK17到18很快

741
00:40:25,750 --> 00:40:28,270
几个月就几个月就从17到18了

742
00:40:28,720 --> 00:40:31,120
但是REACT16到17

743
00:40:31,510 --> 00:40:32,560
最近过了很久

744
00:40:33,240 --> 00:40:34,020
推荐过了很久

745
00:40:34,170 --> 00:40:37,350
所以X16中很多的东西

746
00:40:37,350 --> 00:40:38,790
它的价格也比较难改

747
00:40:39,550 --> 00:40:41,080
价格也比较难改

748
00:40:41,920 --> 00:40:42,940
16到17

749
00:40:43,000 --> 00:40:45,610
很多东西都是比较割裂的

750
00:40:45,640 --> 00:40:46,300
比较割裂

751
00:40:48,040 --> 00:40:49,990
我们现在讲那个ROCK15吧

752
00:40:50,170 --> 00:40:50,680
Rock的

753
00:40:51,440 --> 00:40:55,160
从a开始就是一直到他16之前

754
00:40:55,550 --> 00:40:58,460
他的整体的价格其实可以大概的分为两个部分

755
00:40:59,400 --> 00:41:01,410
第一个部分叫做re consider

756
00:41:01,440 --> 00:41:05,340
第一个部分叫做render render render e

757
00:41:05,900 --> 00:41:07,010
分别是什么

758
00:41:07,040 --> 00:41:07,850
什么作用呢

759
00:41:08,090 --> 00:41:08,630
Re consider

760
00:41:08,630 --> 00:41:12,530
它的作用就是找出具体的变化的组件

761
00:41:12,530 --> 00:41:14,120
比如我掉了一个4S店

762
00:41:14,120 --> 00:41:14,810
City state

763
00:41:15,290 --> 00:41:15,680
对吧

764
00:41:15,680 --> 00:41:17,090
我调了一个distance estate

765
00:41:17,240 --> 00:41:19,490
那么他肯定有某个组件变化了

766
00:41:20,180 --> 00:41:21,440
他肯定有主见变化了

767
00:41:22,190 --> 00:41:25,400
那么我就要找到那个组变化是哪个组件

768
00:41:25,670 --> 00:41:29,720
然后把那个组件做通过做的衣服什么的

769
00:41:30,020 --> 00:41:33,230
最终把这个组件的更新给更新到页面上去

770
00:41:33,680 --> 00:41:37,460
那么以前的react架构整体来讲可以分为两部分

771
00:41:37,910 --> 00:41:38,720
就这两个地方

772
00:41:39,260 --> 00:41:43,310
但是它内部其实rock事物就已经有了批处理的优化

773
00:41:43,490 --> 00:41:44,780
就是就是我们这个

774
00:41:45,200 --> 00:41:49,700
我们执行了两次或者多次system system实际上它只会发起

775
00:41:49,760 --> 00:41:51,470
最终只会发起一次更新

776
00:41:52,000 --> 00:41:53,470
就是在这种场景下

777
00:41:53,770 --> 00:41:54,790
并不是所有的场景

778
00:41:54,790 --> 00:41:56,650
假如你把它放在车身

779
00:41:59,510 --> 00:42:01,640
官方18以上了

780
00:42:01,640 --> 00:42:03,470
我们18

781
00:42:04,580 --> 00:42:07,040
18已经有那个版本了是吧

782
00:42:07,040 --> 00:42:08,750
已经有先行版本了

783
00:42:09,860 --> 00:42:11,120
队友先行版本

784
00:42:11,120 --> 00:42:12,500
你可以看它的先行版本

785
00:42:12,530 --> 00:42:13,700
他还没有正式发布

786
00:42:17,170 --> 00:42:18,040
但是也快了

787
00:42:18,960 --> 00:42:20,130
既然已经发了消息了

788
00:42:20,130 --> 00:42:20,700
那也快了

789
00:42:26,440 --> 00:42:27,940
Right之前就是这样

790
00:42:28,330 --> 00:42:28,930
然后

791
00:42:29,560 --> 00:42:31,060
但是像这种价格

792
00:42:31,060 --> 00:42:33,910
其实大家可以看到一句话讲完的事情

793
00:42:34,330 --> 00:42:36,640
但大体上是一件老话讲的事情

794
00:42:37,120 --> 00:42:38,800
那么他肯定就会有很多问题

795
00:42:39,190 --> 00:42:40,720
童年事实也是如此

796
00:42:41,020 --> 00:42:43,210
这个图我相信大家肯定都已经见过了

797
00:42:43,720 --> 00:42:46,660
这就是REG15的典型的一个更新的一个图

798
00:42:47,240 --> 00:42:49,850
因为RECORD15他就只有两部

799
00:42:49,850 --> 00:42:50,990
一个找出变化的出现

800
00:42:50,990 --> 00:42:52,280
一个把它现在页面上

801
00:42:52,610 --> 00:42:53,000
那么

802
00:42:53,800 --> 00:42:56,170
当你的一个react页面

803
00:42:56,320 --> 00:42:57,760
它的组件特别多的时候

804
00:42:57,760 --> 00:42:59,320
我们肯定有这样的需求

805
00:42:59,770 --> 00:43:02,590
那就是那就是一个react

806
00:43:02,590 --> 00:43:04,030
他有N多个组件

807
00:43:04,060 --> 00:43:05,710
或者你引了很多个包

808
00:43:05,920 --> 00:43:07,810
总之你这个组件是非常的庞大

809
00:43:08,390 --> 00:43:09,620
逐渐出非常的庞大

810
00:43:09,890 --> 00:43:11,960
那么如果你写的不好

811
00:43:12,230 --> 00:43:13,220
就出现这种情况

812
00:43:13,460 --> 00:43:14,420
你一个变化

813
00:43:14,420 --> 00:43:15,230
你一个更新

814
00:43:15,590 --> 00:43:16,160
然后呢

815
00:43:16,280 --> 00:43:18,380
他就一直掉一直掉一直掉一直掉

816
00:43:18,740 --> 00:43:19,760
就掉了这么久

817
00:43:19,760 --> 00:43:21,200
然后都不会想用户

818
00:43:21,290 --> 00:43:23,810
那么对于用户来说是什么样子

819
00:43:23,840 --> 00:43:25,520
就是卡死就是卡顿

820
00:43:26,100 --> 00:43:26,850
卡顿住了

821
00:43:27,210 --> 00:43:28,080
很不流畅

822
00:43:28,380 --> 00:43:29,220
效果很不好

823
00:43:29,640 --> 00:43:32,400
那么这就是一个常常任务

824
00:43:32,580 --> 00:43:35,520
导致主持会阻塞用户会的交互

825
00:43:35,910 --> 00:43:38,370
那么这个是Rex面临一个问题

826
00:43:38,760 --> 00:43:42,870
因此从RANK151直到REC16 rock的团队

827
00:43:42,870 --> 00:43:45,060
然后就对他的价格进行了一个升级

828
00:43:45,240 --> 00:43:47,610
也是X6

829
00:43:47,610 --> 00:43:49,410
现在我们市面上文章

830
00:43:49,500 --> 00:43:52,740
分析也比较多的就是X的fiber价格

831
00:43:53,250 --> 00:43:54,390
她调整了之后

832
00:43:54,630 --> 00:43:57,210
上面的这个图可以做到像下面这个图一样

833
00:43:57,480 --> 00:43:58,590
像下面这个图一样

834
00:43:59,090 --> 00:44:02,900
下面这个图就是和他们的区别在哪里呢

835
00:44:03,710 --> 00:44:06,980
我们看这个比这个水面上水面上

836
00:44:07,790 --> 00:44:09,680
是响应用户的操作

837
00:44:09,860 --> 00:44:10,460
大家看

838
00:44:11,080 --> 00:44:13,360
上面这个图从第一次点击了之后

839
00:44:13,360 --> 00:44:15,190
假如这个点击事件点击之后

840
00:44:15,310 --> 00:44:16,510
一直这么长时间内

841
00:44:16,510 --> 00:44:17,890
用户无论做任何的操作

842
00:44:17,890 --> 00:44:18,790
他都响应不了

843
00:44:19,650 --> 00:44:20,640
而下面这个组

844
00:44:21,090 --> 00:44:22,620
我隔一会儿他会回来

845
00:44:23,350 --> 00:44:26,290
他隔一会儿会回来看一下用户有没有什么操作

846
00:44:26,290 --> 00:44:28,330
隔一会儿回来看用户有什么操作

847
00:44:29,140 --> 00:44:29,620
这样的话

848
00:44:29,620 --> 00:44:32,200
即使是用户后面有新的

849
00:44:32,820 --> 00:44:34,350
有心里有其他的交货

850
00:44:34,560 --> 00:44:36,630
那么我不至于因为是卡死的

851
00:44:37,170 --> 00:44:38,460
因为我不至于是卡死了

852
00:44:38,490 --> 00:44:39,690
那么这是一个优化点

853
00:44:40,340 --> 00:44:41,690
那么第二点就是什么呢

854
00:44:41,900 --> 00:44:44,060
那有同学可能会问呢

855
00:44:45,460 --> 00:44:47,560
就算是他响应用户有什么用呢

856
00:44:47,740 --> 00:44:49,810
因为你的那个长任务还是存在

857
00:44:49,930 --> 00:44:51,790
你那个长任务还是会接着执行

858
00:44:51,790 --> 00:44:52,960
就算响应的用户

859
00:44:53,350 --> 00:44:56,170
那么用户对用户的体验来讲的话

860
00:44:56,320 --> 00:44:57,970
好像也没有特别的提高

861
00:44:58,030 --> 00:44:59,800
对如果单纯从这一点来说

862
00:45:00,340 --> 00:45:01,570
你只是想用户

863
00:45:01,600 --> 00:45:04,630
那么但是你的进程还是被站着的话

864
00:45:04,690 --> 00:45:05,680
那么肯定没有用

865
00:45:06,340 --> 00:45:06,670
对吧

866
00:45:06,700 --> 00:45:12,370
所以react fiber价格大概有两个非常重要的东西

867
00:45:12,760 --> 00:45:16,420
一个就是它的执行义务的

868
00:45:17,190 --> 00:45:19,650
调度任务会在洪洞中进行

869
00:45:20,130 --> 00:45:22,200
这样可以保证不会让用户失去响应

870
00:45:22,680 --> 00:45:23,790
我们那个图

871
00:45:24,410 --> 00:45:25,610
有一个图

872
00:45:25,820 --> 00:45:27,710
这个大家应该都见过

873
00:45:27,710 --> 00:45:29,600
就是那个鼠标呢

874
00:45:31,040 --> 00:45:33,530
这样一个这样一个图

875
00:45:34,480 --> 00:45:35,260
然后

876
00:45:35,970 --> 00:45:38,220
这里是主进程对吧

877
00:45:38,220 --> 00:45:39,060
这里主进程

878
00:45:39,270 --> 00:45:40,140
那后面是

879
00:45:40,910 --> 00:45:43,520
微任务在后面是红任务

880
00:45:44,130 --> 00:45:44,370
对吧

881
00:45:44,370 --> 00:45:45,450
侧面是红任务

882
00:45:45,960 --> 00:45:49,500
那么如果你的主你的主线程一直被占据的话

883
00:45:49,530 --> 00:45:52,830
那么你的你的整个屏幕都是被卡死的状态

884
00:45:54,210 --> 00:45:57,330
但是当你在红任务当中进行

885
00:45:57,360 --> 00:45:59,880
如果你在红任务当中进行这个红任务

886
00:45:59,940 --> 00:46:01,380
红任务当中进行一个任务

887
00:46:01,770 --> 00:46:05,400
那么任务完了之后也会进入下一个

888
00:46:05,700 --> 00:46:06,900
就是下一个周期

889
00:46:07,410 --> 00:46:09,060
的主线程不会被占据

890
00:46:09,060 --> 00:46:09,330
对吧

891
00:46:09,330 --> 00:46:11,310
你的用户还是可以接着操作

892
00:46:11,760 --> 00:46:13,830
然后接着又在下一个活动当中进行

893
00:46:14,040 --> 00:46:14,550
因此

894
00:46:15,650 --> 00:46:16,910
这就可以保证什么呢

895
00:46:16,910 --> 00:46:19,970
可以保证就是我们我们始终不会丢失

896
00:46:19,970 --> 00:46:21,860
要对用户用户的响应

897
00:46:22,220 --> 00:46:23,990
这就是能够回到水面上的原因

898
00:46:24,020 --> 00:46:25,700
因为它是在红豆当中进行的

899
00:46:25,940 --> 00:46:28,820
这是第一个比较重要的一个变化

900
00:46:29,460 --> 00:46:30,270
第二个变化

901
00:46:32,790 --> 00:46:33,690
第二个变化

902
00:46:33,720 --> 00:46:34,860
REC的同时

903
00:46:35,520 --> 00:46:37,770
对所有的更新做了一个优先级的绑定

904
00:46:38,130 --> 00:46:41,220
这就是我们刚刚所提出的那个问题

905
00:46:41,820 --> 00:46:44,760
就算你就算你用户又更新了之后

906
00:46:44,760 --> 00:46:47,520
那就算你用户做了一个新的交互

907
00:46:47,760 --> 00:46:51,660
那我还不是要等上一个任务完成之后

908
00:46:52,120 --> 00:46:55,720
就上次更新完成之后再来做你新的更新吗

909
00:46:55,720 --> 00:46:58,510
那么对用户的体验其实并没有很大的提高

910
00:47:00,000 --> 00:47:00,630
因此

911
00:47:00,840 --> 00:47:02,910
React做了一个优先级的绑定

912
00:47:03,030 --> 00:47:03,780
也就是什么呢

913
00:47:04,020 --> 00:47:09,180
假如说你之前正在更新的实际实际上是一个优先级较低的任务

914
00:47:10,080 --> 00:47:13,230
我们就用优先级这个概念回去和优先级概念

915
00:47:13,500 --> 00:47:18,000
假如说你现在这里尝试的是一个优先级低的任务

916
00:47:18,300 --> 00:47:19,170
优先级的

917
00:47:19,650 --> 00:47:22,380
然后下次用户在这里操作了之后

918
00:47:22,410 --> 00:47:23,670
他操作了一个优先

919
00:47:23,910 --> 00:47:25,500
优先级比较高的一个任务

920
00:47:26,020 --> 00:47:26,740
关于优先级

921
00:47:26,740 --> 00:47:31,330
待会儿会给大家比较详细的讲他现在我们只需要知道优先级

922
00:47:31,600 --> 00:47:34,750
那么他肯定就执行顺序是不一样的

923
00:47:35,620 --> 00:47:38,830
那么我这个新的任务是一个星期

924
00:47:39,340 --> 00:47:40,060
比较高的

925
00:47:40,510 --> 00:47:45,490
那么我这个月就高的任务就可以打断优先级较低的任务

926
00:47:45,700 --> 00:47:46,300
也就是说

927
00:47:46,930 --> 00:47:48,940
如果你后面用户操作了

928
00:47:49,390 --> 00:47:50,110
我们认为

929
00:47:50,660 --> 00:47:51,410
你的优先级高

930
00:47:51,440 --> 00:47:53,480
假如一旦被认定为你的优先级高

931
00:47:54,100 --> 00:47:57,040
那么你这才会优先执行前面这个

932
00:47:57,160 --> 00:47:58,750
如果没有被执行完的话

933
00:47:58,750 --> 00:48:00,700
那么会被会被中断掉

934
00:48:01,210 --> 00:48:01,930
会被中断掉

935
00:48:01,930 --> 00:48:05,380
这样的话用户的体验就会比之前要好很多了

936
00:48:07,020 --> 00:48:07,650
都会更新

937
00:48:07,650 --> 00:48:08,400
能理解为

938
00:48:09,000 --> 00:48:10,920
多个CC的操作吗

939
00:48:12,740 --> 00:48:14,210
可以理解为

940
00:48:14,210 --> 00:48:16,070
它不只是多个实验操作

941
00:48:16,070 --> 00:48:18,200
你有可能是一次

942
00:48:19,100 --> 00:48:20,360
一次system

943
00:48:21,300 --> 00:48:23,490
比如你的一次甚至可以

944
00:48:26,370 --> 00:48:27,270
比如像这种

945
00:48:28,800 --> 00:48:31,320
对于本来是发起了两次CS

946
00:48:31,320 --> 00:48:31,920
对吧

947
00:48:32,100 --> 00:48:35,280
两次CS的他但他实际上只发起一次更新

948
00:48:35,850 --> 00:48:37,230
但它实际上只发起一次更新

949
00:48:37,230 --> 00:48:39,300
它实际上是被批处理的儿

950
00:48:40,820 --> 00:48:41,120
对

951
00:48:41,360 --> 00:48:42,770
而你如果有这

952
00:48:43,010 --> 00:48:45,020
你如果是放在

953
00:48:46,500 --> 00:48:49,050
但是这是一个组件类

954
00:48:49,050 --> 00:48:51,690
如我看一下这个结构

955
00:48:52,110 --> 00:48:52,980
假如这是

956
00:48:53,700 --> 00:48:54,870
A组件对吧

957
00:48:55,080 --> 00:48:57,990
这是B组件这是C组件

958
00:48:59,400 --> 00:49:00,630
第一组建的组建

959
00:49:00,840 --> 00:49:02,730
假如说你这儿有一个更新

960
00:49:03,700 --> 00:49:04,720
这儿有个更新

961
00:49:06,240 --> 00:49:07,050
这儿有更新

962
00:49:07,410 --> 00:49:08,760
我们刚刚这种情况

963
00:49:08,850 --> 00:49:10,530
她是不是在同一个生命周期

964
00:49:10,530 --> 00:49:12,570
同一个组件的生命周期里

965
00:49:13,320 --> 00:49:15,450
那么他肯定就他就直接给你批处理

966
00:49:15,900 --> 00:49:19,260
但是你在不同的组件内发起了不同的任务

967
00:49:19,290 --> 00:49:20,400
发起了不同的更新

968
00:49:20,520 --> 00:49:21,450
那么就有同学说

969
00:49:21,450 --> 00:49:22,680
假如说四个C的

970
00:49:23,220 --> 00:49:24,300
假如这个CS的

971
00:49:24,630 --> 00:49:27,720
那么那么它就是三个不同的任务了

972
00:49:28,110 --> 00:49:29,070
三个不同的任务

973
00:49:29,160 --> 00:49:31,320
至于这些任务还能不能合并

974
00:49:31,440 --> 00:49:34,770
那么其实L还有其他的优化策略

975
00:49:34,920 --> 00:49:36,120
还有其他的优化策略

976
00:49:37,200 --> 00:49:39,240
可以理解为是在不

977
00:49:39,330 --> 00:49:43,320
但是并不是所有的4S店都可以穿

978
00:49:43,860 --> 00:49:47,790
并不是简单的理解为就是多个CS的操作

979
00:49:47,790 --> 00:49:48,810
因为有你

980
00:49:48,810 --> 00:49:52,170
如果在同一个组件的同一个生命周期里

981
00:49:52,170 --> 00:49:53,700
你发起了好几个操作

982
00:49:53,850 --> 00:49:55,590
那么它实际上最终只有一次

983
00:49:55,890 --> 00:49:56,730
只有一个更新

984
00:49:57,450 --> 00:49:58,680
你在不同的组件内

985
00:49:58,950 --> 00:50:00,600
那么他会是多个不同的更新

986
00:50:08,380 --> 00:50:11,050
我们可以看一下我们刚刚讲到的优先级的

987
00:50:11,050 --> 00:50:12,040
讲了两个步骤

988
00:50:12,070 --> 00:50:13,090
讲到两两点

989
00:50:13,120 --> 00:50:15,760
一个是红任务中进行这块儿

990
00:50:15,760 --> 00:50:18,160
这个代码待会我们会在代码中给大家看

991
00:50:18,280 --> 00:50:20,380
会给大家直接分析到那里去

992
00:50:20,860 --> 00:50:22,270
我们现在需要记住两点

993
00:50:22,270 --> 00:50:24,700
一个是它自己会变成这个样子

994
00:50:24,760 --> 00:50:26,290
从上面的图变成下面这个图

995
00:50:26,470 --> 00:50:28,360
就是因为它是在红肉当中调度的

996
00:50:28,360 --> 00:50:30,700
所以不会把主线程给占据

997
00:50:30,700 --> 00:50:31,960
不主线程给占据了

998
00:50:32,050 --> 00:50:33,640
不会一直占据主线程

999
00:50:33,880 --> 00:50:36,010
这样他就有时间去响应用户的操作

1000
00:50:36,250 --> 00:50:38,440
第二由于他对每一个更新

1001
00:50:39,280 --> 00:50:40,840
都有这个优先级的绑定

1002
00:50:40,900 --> 00:50:47,860
那么他就可以在多个更新同时出现的时候中断的优先级的执行高优先级的

1003
00:50:48,190 --> 00:50:52,690
这个就是我们接下来要讲到的schedule模块所要做的事情

1004
00:50:53,540 --> 00:50:57,890
他就是来调度任务的优先级的erf16相比REG15

1005
00:50:57,920 --> 00:51:00,590
他实际上在整体上就多了一块儿

1006
00:51:00,590 --> 00:51:02,960
他在这儿多了一块就是我们的schedule模块

1007
00:51:03,470 --> 00:51:04,790
这个是GK的模块儿

1008
00:51:04,790 --> 00:51:09,260
他是来控制到底哪个任务能够进入下一个流程

1009
00:51:09,260 --> 00:51:11,390
就是来找出逐渐变化的组件

1010
00:51:11,600 --> 00:51:13,490
然后再渲染到页面上

1011
00:51:13,670 --> 00:51:16,190
就说这相当于来了一个把门儿的

1012
00:51:17,310 --> 00:51:18,300
来个把门儿的

1013
00:51:18,360 --> 00:51:20,610
他来控制它来控制

1014
00:51:22,220 --> 00:51:27,260
来控制调度我们进入我们后续后续那个JS流程

1015
00:51:28,370 --> 00:51:29,600
的任务的任务

1016
00:51:29,600 --> 00:51:30,590
任务的多少

1017
00:51:30,620 --> 00:51:32,240
那这些都是可以由它来控制的

1018
00:51:32,390 --> 00:51:34,130
这种schedule要做的事情

1019
00:51:34,700 --> 00:51:36,560
然后我们现在先讲一个

1020
00:51:37,200 --> 00:51:38,100
优先级的概念

1021
00:51:38,310 --> 00:51:39,420
当我们的优先级

1022
00:51:39,630 --> 00:51:42,360
其实这个优先级并不是随意定的

1023
00:51:42,780 --> 00:51:43,770
Rock他把

1024
00:51:44,500 --> 00:51:46,480
他可以大致分为这几类

1025
00:51:46,510 --> 00:51:47,500
大致分为这几类

1026
00:51:48,720 --> 00:51:50,130
生命周期方法

1027
00:51:50,160 --> 00:51:50,520
比如

1028
00:51:52,030 --> 00:51:55,480
这是同步执行的生命周期方法就是同步执行

1029
00:51:55,810 --> 00:51:58,540
然后如果用户的输入这个优先级

1030
00:51:58,540 --> 00:51:59,530
从高到低

1031
00:52:00,040 --> 00:52:01,540
当然内部还不止这几种

1032
00:52:01,720 --> 00:52:03,130
我们可以大致的来说一下

1033
00:52:03,340 --> 00:52:06,730
比如说他是按照用户的这种交互

1034
00:52:06,760 --> 00:52:08,320
就是说用户的最佳体验的

1035
00:52:08,960 --> 00:52:09,620
这种观察

1036
00:52:09,620 --> 00:52:12,050
然后来给你列了几几了

1037
00:52:12,050 --> 00:52:13,910
裂了好几种不同的优先级

1038
00:52:13,910 --> 00:52:15,560
而这个优先级是不需要用户

1039
00:52:15,800 --> 00:52:18,065
是不需要开发者进行操作的

1040
00:52:18,065 --> 00:52:19,970
是rock的内部就给你绑定好了

1041
00:52:20,600 --> 00:52:21,110
比如

1042
00:52:21,830 --> 00:52:22,760
说明这些方法

1043
00:52:22,790 --> 00:52:26,330
那么他认为他的这个优先级是高的收入的用户输入

1044
00:52:26,330 --> 00:52:28,280
比如说你的输入框内输入东西

1045
00:52:28,790 --> 00:52:30,650
这个你的输入框内输入东西

1046
00:52:31,040 --> 00:52:33,110
你是不是期望期望什么

1047
00:52:33,110 --> 00:52:35,330
期望的是立刻就在输入框中显示

1048
00:52:35,330 --> 00:52:36,170
就是这样对不对

1049
00:52:36,650 --> 00:52:38,570
肯定是期望立刻在输入框中显示

1050
00:52:39,080 --> 00:52:42,350
那么他这其实受控的用户输入

1051
00:52:42,380 --> 00:52:45,170
那么它就是一个较高的陷阱儿

1052
00:52:45,170 --> 00:52:49,160
比如像交互事件动画高优先高动画

1053
00:52:49,190 --> 00:52:50,000
比如像动画

1054
00:52:50,300 --> 00:52:52,130
那么它的优先级也也高

1055
00:52:52,130 --> 00:52:54,170
但是他没有用户输入那么高

1056
00:52:54,260 --> 00:52:55,430
其实就区分出来了

1057
00:52:55,850 --> 00:52:56,450
还有其他的

1058
00:52:56,450 --> 00:52:57,620
比如像数据请求

1059
00:52:58,070 --> 00:52:59,870
那么这个项数据请求

1060
00:52:59,870 --> 00:53:03,770
他并不是需要立刻展示出来的

1061
00:53:04,860 --> 00:53:05,580
对于用户来说

1062
00:53:05,580 --> 00:53:07,650
他也有一个简单的预期就是

1063
00:53:08,420 --> 00:53:09,380
一个简单的假如

1064
00:53:09,380 --> 00:53:11,540
这是一个一个搜索框

1065
00:53:12,230 --> 00:53:14,000
他的简单与他的预期肯定是

1066
00:53:14,240 --> 00:53:15,620
那么我输入的东西能攒

1067
00:53:15,650 --> 00:53:18,380
我输入的这些能展示出来

1068
00:53:18,950 --> 00:53:21,800
然后他过一会儿可以展示出来我要搜的内容

1069
00:53:22,070 --> 00:53:22,310
对吧

1070
00:53:22,310 --> 00:53:23,630
这是一个简单的预期

1071
00:53:23,840 --> 00:53:25,610
那么对于用户这个预期来说

1072
00:53:26,000 --> 00:53:30,080
我输入能能立刻反应在表单上的

1073
00:53:30,080 --> 00:53:33,350
这个他肯定是一个高优先级儿

1074
00:53:33,760 --> 00:53:35,230
数据请求他

1075
00:53:35,380 --> 00:53:36,340
他可以接受

1076
00:53:36,340 --> 00:53:37,000
过一会儿

1077
00:53:37,650 --> 00:53:38,550
然后再展示

1078
00:53:38,640 --> 00:53:40,170
那么他的预算就比较低

1079
00:53:40,970 --> 00:53:45,170
所以他是根据这种人机交互的这么一个模型来制定的一个优先级的概念

1080
00:53:45,590 --> 00:53:49,400
当然但是这这个是不需要我们的开发者进行操作的

1081
00:53:49,400 --> 00:53:52,070
我们只需要知道他有这么个东西

1082
00:53:52,490 --> 00:53:53,120
他有这个东西

1083
00:53:53,120 --> 00:53:55,250
而且用这个东西做了一件事情

1084
00:53:55,250 --> 00:53:58,040
就是可以打断的优先级的更新

1085
00:53:58,370 --> 00:54:00,650
我们可以简单的看一个例子

1086
00:54:00,680 --> 00:54:02,180
这是我之前写的例子

1087
00:54:02,510 --> 00:54:04,160
这是一个REC的组件

1088
00:54:04,840 --> 00:54:06,040
REC的组件数

1089
00:54:06,680 --> 00:54:07,970
这个件数大家看

1090
00:54:08,000 --> 00:54:09,500
大家注意这是一个列表

1091
00:54:09,530 --> 00:54:10,640
这是一个双向链表

1092
00:54:12,140 --> 00:54:16,220
每一个REC的节点都称为一个fiber节点

1093
00:54:17,210 --> 00:54:19,010
这个大家会想到它具体的属性

1094
00:54:19,310 --> 00:54:21,680
我们现在可以大致看到它有三个

1095
00:54:21,890 --> 00:54:22,490
第一个是

1096
00:54:23,200 --> 00:54:25,450
他只向一他的一个链表

1097
00:54:25,840 --> 00:54:27,220
一个结点指向翘的

1098
00:54:27,580 --> 00:54:30,700
他一个翘的属性指向下一个节点

1099
00:54:31,280 --> 00:54:32,360
而这个翻倍呢

1100
00:54:32,360 --> 00:54:34,550
它有一个return可以实现他的附件

1101
00:54:35,260 --> 00:54:36,340
他还有一个sub令

1102
00:54:36,340 --> 00:54:37,480
可以直接他的兄弟

1103
00:54:37,480 --> 00:54:40,000
今天这是一个双向的一个链表结构

1104
00:54:40,580 --> 00:54:43,130
这REC的组件数大概就这样

1105
00:54:43,130 --> 00:54:45,830
后面我们还会好几次看到这幅图

1106
00:54:45,860 --> 00:54:48,110
先长个记性当

1107
00:54:48,750 --> 00:54:50,520
这样的一个组件数出现的时候

1108
00:54:50,700 --> 00:54:53,670
我们在失败了第一次假如在spanner发起了一个烟机

1109
00:54:54,350 --> 00:54:55,160
米色的更新

1110
00:54:57,010 --> 00:54:58,450
就在sight嘛

1111
00:54:58,840 --> 00:55:00,220
但是假如优先级不是很高

1112
00:55:00,220 --> 00:55:00,670
VC

1113
00:55:01,370 --> 00:55:04,730
那么紧接着我在这儿发起了一个为a的

1114
00:55:05,610 --> 00:55:06,330
一个外搭

1115
00:55:07,040 --> 00:55:09,290
那么在REACT16我就不卖关子了

1116
00:55:09,290 --> 00:55:10,280
在REACT16里

1117
00:55:10,400 --> 00:55:12,050
他有可能发生两种情况

1118
00:55:12,200 --> 00:55:13,760
第一种就是a和C一起执行

1119
00:55:14,180 --> 00:55:15,650
第二种就是a先执行

1120
00:55:16,400 --> 00:55:17,570
第二个就是a先执行

1121
00:55:17,900 --> 00:55:18,620
然后C

1122
00:55:19,550 --> 00:55:22,340
总之a他一定不会比谁慢

1123
00:55:22,550 --> 00:55:25,460
因为我因为我因为我是紧接着发起的吗

1124
00:55:25,490 --> 00:55:27,800
那就说明说明我们的span

1125
00:55:27,860 --> 00:55:29,630
比如这个CM还没有执行完

1126
00:55:29,630 --> 00:55:29,960
对吧

1127
00:55:30,380 --> 00:55:31,280
我们还没有执行完

1128
00:55:32,080 --> 00:55:32,530
那么

1129
00:55:32,980 --> 00:55:33,580
那么

1130
00:55:34,210 --> 00:55:38,740
我发起了一个优先级更高的一个优先级更高的一次更新

1131
00:55:39,280 --> 00:55:40,360
那么他就会打断他

1132
00:55:40,630 --> 00:55:45,430
他实际上他有可能打断他有可能和他一起执行这个看情况的看情况

1133
00:55:46,900 --> 00:55:50,710
接着假如我又在div里又发现了一个有线GV

1134
00:55:51,510 --> 00:55:52,230
A的更新

1135
00:55:53,820 --> 00:55:56,850
它的更新如果说C备a打断了

1136
00:55:56,850 --> 00:55:57,600
他没有执行

1137
00:55:57,930 --> 00:55:59,790
那么就会发生两种情况

1138
00:55:59,790 --> 00:56:00,480
第一种是

1139
00:56:01,200 --> 00:56:03,840
第一种是随着时间的流逝

1140
00:56:04,110 --> 00:56:05,550
就是讲这个时间轴

1141
00:56:05,700 --> 00:56:06,660
这个时间轴

1142
00:56:07,450 --> 00:56:10,990
我这儿我先先发起的这个更新一下是C对吧

1143
00:56:11,020 --> 00:56:11,560
这个C

1144
00:56:11,980 --> 00:56:15,490
然后我在这发起的一个是一个a

1145
00:56:16,780 --> 00:56:18,580
这个时间轴我在这儿发起的

1146
00:56:18,580 --> 00:56:19,300
一个是

1147
00:56:20,300 --> 00:56:21,740
也是一个圆锥的更新

1148
00:56:23,020 --> 00:56:25,150
那么我发起C的时候

1149
00:56:25,150 --> 00:56:27,040
他没有执行完就遇到了

1150
00:56:27,310 --> 00:56:29,080
就遇到了这个MV的更新

1151
00:56:29,080 --> 00:56:31,000
所以把它打断掉

1152
00:56:31,030 --> 00:56:31,750
那么C

1153
00:56:33,020 --> 00:56:34,130
他就被打断了

1154
00:56:34,950 --> 00:56:36,030
那么a执行完了

1155
00:56:36,030 --> 00:56:37,800
下期下一次我又发起了

1156
00:56:38,100 --> 00:56:40,200
我又在下一个时间段里发起了一个

1157
00:56:41,080 --> 00:56:43,000
为a的游戏优先级

1158
00:56:43,000 --> 00:56:44,080
为a的一次更新

1159
00:56:45,460 --> 00:56:47,650
那么这种情况就发就有两种情况

1160
00:56:47,860 --> 00:56:51,940
第一种是我们的C就是优先级

1161
00:56:52,060 --> 00:56:54,970
优先级它实际上它是和时间有关的

1162
00:56:55,360 --> 00:56:57,310
在rock的优先级是和时间有关的

1163
00:56:58,000 --> 00:57:01,300
比如说我这个优先级它是C

1164
00:57:01,330 --> 00:57:02,890
但是过了一会儿之后

1165
00:57:02,890 --> 00:57:04,840
他的优先级实际上会慢慢升高

1166
00:57:05,110 --> 00:57:07,450
比如过了一会儿他可能就变成a了

1167
00:57:08,020 --> 00:57:09,730
这个我会给大家具体讲的

1168
00:57:10,000 --> 00:57:12,580
只是大家理解就是我们的这个优先级

1169
00:57:12,880 --> 00:57:14,740
它并不是一个简单的一个级别

1170
00:57:14,740 --> 00:57:15,790
一个级别来看呢

1171
00:57:15,940 --> 00:57:17,140
它是通过时间

1172
00:57:17,320 --> 00:57:19,420
它是通过时间来对它进行度量的

1173
00:57:20,290 --> 00:57:22,120
所以我们的优先级

1174
00:57:22,120 --> 00:57:26,320
我这说的C和a都只是一个简单的一个表示

1175
00:57:26,590 --> 00:57:27,700
都只是一个简单的表示

1176
00:57:27,970 --> 00:57:30,430
但这他有可能随着时间的变化

1177
00:57:30,430 --> 00:57:31,180
比如我这个

1178
00:57:31,180 --> 00:57:31,900
过了一会儿

1179
00:57:31,930 --> 00:57:33,130
比如过了一会儿才变

1180
00:57:33,370 --> 00:57:34,270
我才执行

1181
00:57:34,570 --> 00:57:36,100
我才又发起了a的更新

1182
00:57:36,400 --> 00:57:38,920
那么我们我们的这个C它是有可能

1183
00:57:39,530 --> 00:57:41,210
优先级变得很高的

1184
00:57:41,420 --> 00:57:43,190
如果他的优先级变得很高了之后

1185
00:57:43,190 --> 00:57:45,470
他可以和a一起执行也可以

1186
00:57:45,830 --> 00:57:48,740
如果优先级还没有变得比更高

1187
00:57:49,220 --> 00:57:49,670
那么

1188
00:57:50,210 --> 00:57:51,260
还是a线执行

1189
00:57:51,680 --> 00:57:52,760
我这可能有点懵

1190
00:57:52,760 --> 00:57:54,380
我们可以接下来看一下这

1191
00:57:56,030 --> 00:58:01,070
比如通过上面的几个我们的优先级的描述

1192
00:58:01,430 --> 00:58:02,750
在right的函数类

1193
00:58:02,750 --> 00:58:03,950
他就把它分为这几类

1194
00:58:03,980 --> 00:58:05,570
这是rock的逻辑

1195
00:58:05,750 --> 00:58:06,620
X逻辑

1196
00:58:06,800 --> 00:58:15,740
比如这个叫做immediate priority就是立即执行的优先级user blocking priority就是用户交互的normal

1197
00:58:15,890 --> 00:58:18,500
就是一般你正常发起一个更新

1198
00:58:18,500 --> 00:58:19,370
它就是normal

1199
00:58:19,820 --> 00:58:20,960
然后向爱豆

1200
00:58:21,470 --> 00:58:22,580
爱豆和烙

1201
00:58:22,580 --> 00:58:24,050
这都是比较低的优先级的

1202
00:58:24,050 --> 00:58:25,970
一般都是一些动画

1203
00:58:26,240 --> 00:58:28,730
那么他可能会涉及到这两个鱼仙籍

1204
00:58:29,000 --> 00:58:30,320
而预先解释什么呢

1205
00:58:30,320 --> 00:58:32,690
有的同学可能对我刚刚说的说法有点儿懵

1206
00:58:32,990 --> 00:58:35,180
预期实际上在reactor live

1207
00:58:35,180 --> 00:58:37,760
它表述成一个叫做expression time字段

1208
00:58:39,480 --> 00:58:40,980
他比如我这个

1209
00:58:42,160 --> 00:58:43,300
Invited priority

1210
00:58:43,930 --> 00:58:46,870
他的一个他他会对应一个亿

1211
00:58:47,850 --> 00:58:48,690
Expression态

1212
00:58:49,020 --> 00:58:50,340
它对应expression on

1213
00:58:51,540 --> 00:58:54,390
他们对expression he当前时间有关

1214
00:58:54,390 --> 00:58:55,050
比如说

1215
00:58:55,640 --> 00:58:56,780
比如说啊

1216
00:58:56,780 --> 00:58:59,090
我这每一个优先

1217
00:58:59,120 --> 00:58:59,900
每一个优先级

1218
00:58:59,900 --> 00:59:02,810
他们他们会有会给一个固定的时间间隔

1219
00:59:02,840 --> 00:59:03,410
比如我这

1220
00:59:04,070 --> 00:59:06,500
给个100对吧

1221
00:59:06,800 --> 00:59:08,600
然后50

1222
00:59:10,900 --> 00:59:11,620
时

1223
00:59:13,200 --> 00:59:14,700
1111

1224
00:59:14,700 --> 00:59:16,140
这个是固定的时间间隔

1225
00:59:16,470 --> 00:59:18,030
然后我们有一个时间

1226
00:59:18,450 --> 00:59:21,420
然后他的expression time最终会等于它的expression

1227
00:59:21,420 --> 00:59:22,380
在计算的时候

1228
00:59:22,770 --> 00:59:23,820
根据它的优先级

1229
00:59:23,820 --> 00:59:24,270
它会

1230
00:59:25,040 --> 00:59:25,910
计算一个X

1231
00:59:25,910 --> 00:59:26,540
兴叹

1232
00:59:27,050 --> 00:59:27,710
大家注意

1233
00:59:27,770 --> 00:59:29,930
根据优先级这儿有点儿

1234
00:59:29,930 --> 00:59:31,100
这个有点绕的

1235
00:59:32,060 --> 00:59:34,460
根据优先级计算

1236
00:59:35,960 --> 00:59:37,880
一个expression time

1237
00:59:39,130 --> 00:59:41,200
而后续所有优先级的对比

1238
00:59:43,020 --> 00:59:47,070
后续所有优先级的对比

1239
00:59:48,210 --> 00:59:51,240
都是通过expression来对比的

1240
00:59:57,190 --> 01:00:00,580
其实它实际上就是一个时间的一个

1241
01:00:01,360 --> 01:00:01,990
数字

1242
01:00:02,050 --> 01:00:03,130
时间的一个数字

1243
01:00:03,280 --> 01:00:05,110
而对于比如在高于县级

1244
01:00:05,140 --> 01:00:06,460
那么它的速度就比较大

1245
01:00:06,490 --> 01:00:07,210
比如它叫做

1246
01:00:07,660 --> 01:00:10,180
它就会等于Karen踏着Karen叹

1247
01:00:13,670 --> 01:00:14,660
给他加100

1248
01:00:15,260 --> 01:00:16,640
如果是最高优先级

1249
01:00:18,100 --> 01:00:19,450
如果是的优先级

1250
01:00:19,630 --> 01:00:23,530
那么他的ex pressing探他那个任务的experience

1251
01:00:30,680 --> 01:00:31,550
可能就是这样

1252
01:00:32,400 --> 01:00:36,840
这个高约县级的一个分析碳这是高约县级的

1253
01:00:38,160 --> 01:00:39,210
这是第一优先级的

1254
01:00:43,030 --> 01:00:43,630
X16

1255
01:00:43,960 --> 01:00:44,920
就这样的逻辑

1256
01:00:45,190 --> 01:00:47,260
那么高于县级的一个flash he的县级

1257
01:00:47,740 --> 01:00:49,090
他们再进行一个对比的时候

1258
01:00:49,420 --> 01:00:51,790
后续就直接通过express来对比了

1259
01:00:52,420 --> 01:00:54,130
那么那么我刚刚说的那种

1260
01:00:54,130 --> 01:00:56,260
就是它会根据时间的变化

1261
01:00:56,470 --> 01:00:57,340
优先级会变化

1262
01:00:57,340 --> 01:00:58,360
又是什么意思呢

1263
01:00:58,570 --> 01:00:59,260
是什么意思呢

1264
01:00:59,530 --> 01:01:01,270
Rex还有一个逻辑

1265
01:01:01,510 --> 01:01:04,480
这个逻辑就是假如说我的这个expression差

1266
01:01:05,590 --> 01:01:06,910
我的这个character to

1267
01:01:11,600 --> 01:01:12,470
大鱼了

1268
01:01:14,400 --> 01:01:15,180
X变态

1269
01:01:15,840 --> 01:01:17,730
那么就会把这个1000级

1270
01:01:24,110 --> 01:01:25,130
调到最高

1271
01:01:28,140 --> 01:01:28,980
调到最高

1272
01:01:29,750 --> 01:01:31,790
所以说根据时间的变化

1273
01:01:31,790 --> 01:01:33,590
它我们的这个C的优先级

1274
01:01:33,740 --> 01:01:34,670
它是有可能

1275
01:01:34,760 --> 01:01:36,740
他有可能就变成最高的优先级

1276
01:01:36,770 --> 01:01:39,650
最优先执行的这个逻辑是什么原因呢

1277
01:01:39,830 --> 01:01:40,880
这个逻辑的原因就是

1278
01:01:41,660 --> 01:01:44,330
假如我一个的优先级就是刚刚那个C

1279
01:01:44,330 --> 01:01:46,160
我后面一直不停的来a任务

1280
01:01:46,780 --> 01:01:48,850
一直不停地爱着我

1281
01:01:48,850 --> 01:01:50,320
在正式的生产环境

1282
01:01:50,320 --> 01:01:51,250
这种情况肯定有

1283
01:01:51,370 --> 01:01:51,730
对不对

1284
01:01:51,880 --> 01:01:53,020
因为你肯定预料

1285
01:01:53,020 --> 01:01:54,340
预料不到会出现什么场景

1286
01:01:54,640 --> 01:01:55,390
如果

1287
01:01:55,420 --> 01:01:56,740
如果没有这个逻辑的话

1288
01:01:56,740 --> 01:01:57,460
那会出现什么

1289
01:01:57,730 --> 01:02:00,730
我们的C优先级的那个任务永远不会被执行

1290
01:02:00,760 --> 01:02:01,120
对不对

1291
01:02:01,300 --> 01:02:02,290
如果没有这个逻辑

1292
01:02:02,620 --> 01:02:04,660
我们C1星级任务就永远被打断了

1293
01:02:05,260 --> 01:02:06,130
我的假设是什么

1294
01:02:06,130 --> 01:02:08,500
我的假设是假如C发起来之后

1295
01:02:09,000 --> 01:02:11,280
后面一直a一直打他

1296
01:02:11,760 --> 01:02:13,620
那他是不是就永远执行不了了

1297
01:02:13,800 --> 01:02:14,790
那么这个实际上是

1298
01:02:15,390 --> 01:02:17,190
那么这个实际上这不是性能的问题

1299
01:02:17,190 --> 01:02:18,180
而且是一个bug了

1300
01:02:18,690 --> 01:02:20,280
因为我一个任务直接丢了

1301
01:02:20,550 --> 01:02:24,720
所以有一个这么个逻辑是高于星球如果判断

1302
01:02:25,950 --> 01:02:28,020
等级就是判断优先级的高低

1303
01:02:28,020 --> 01:02:30,090
我们直接通过数字的对比就是expression

1304
01:02:30,630 --> 01:02:31,980
而如果我们的

1305
01:02:32,730 --> 01:02:34,980
Can a time大于了你的这个expression

1306
01:02:36,040 --> 01:02:39,190
这意味着这意味着你已经被打断太多次了

1307
01:02:39,190 --> 01:02:43,600
那么我必须要立刻把那个安排把立立刻把这个C相机给执行

1308
01:02:43,630 --> 01:02:44,380
避免掉

1309
01:02:44,650 --> 01:02:46,090
避免掉那个更新

1310
01:02:46,860 --> 01:02:49,350
就至少是算你这个确实也比较低

1311
01:02:49,350 --> 01:02:50,670
但我们也得给你安排上

1312
01:02:50,790 --> 01:02:51,720
不能把你给调了

1313
01:02:52,520 --> 01:02:53,480
所以有各种逻辑

1314
01:02:53,510 --> 01:02:56,630
因此它会随着时间的变化

1315
01:02:56,750 --> 01:02:59,750
我们的这个1700他是会发生变化的这块儿

1316
01:03:00,650 --> 01:03:02,330
逻辑这个大家能理解吗

1317
01:03:02,360 --> 01:03:03,020
如果能理解的话

1318
01:03:03,020 --> 01:03:03,590
可以各一

1319
01:03:03,740 --> 01:03:04,760
不能理解可以零

1320
01:03:15,790 --> 01:03:17,740
刘杨同学杨同学

1321
01:03:17,740 --> 01:03:20,350
有什么地方还不太明白吗

1322
01:03:21,880 --> 01:03:22,960
是哪一块儿不明白

1323
01:03:29,700 --> 01:03:31,290
优先级就是上面这个

1324
01:03:31,290 --> 01:03:32,730
它实际上是指的是优先级

1325
01:03:32,730 --> 01:03:35,100
就是从一开始说函数调的时候

1326
01:03:35,340 --> 01:03:36,960
CAD的时间变成了家了吗

1327
01:03:37,680 --> 01:03:38,520
Carry on time

1328
01:03:39,150 --> 01:03:40,560
但你可以理解为Canton

1329
01:03:40,560 --> 01:03:41,850
就是我们当前的时间

1330
01:03:42,440 --> 01:03:43,640
就是我们当前时间

1331
01:03:43,760 --> 01:03:46,010
根据我们当前时间计算的一个值

1332
01:03:47,360 --> 01:03:48,920
所以他肯定是越变越大的

1333
01:03:51,390 --> 01:03:53,280
我们的时间是不是一分一秒都在走

1334
01:03:53,280 --> 01:03:54,510
让这个canon差

1335
01:03:55,120 --> 01:03:55,570
那么开始呢

1336
01:03:55,570 --> 01:03:57,520
比如我们每次每次

1337
01:03:57,520 --> 01:04:01,900
当每次进入到我们的这个schedule里来的时候

1338
01:04:02,630 --> 01:04:04,100
那么它都会重新计算一次

1339
01:04:04,100 --> 01:04:07,190
Canon上就是每进入一个任务进来的时候

1340
01:04:07,190 --> 01:04:08,930
我们的客人就会重新计算一次

1341
01:04:09,170 --> 01:04:11,480
那么他肯定是会逐渐变化的

1342
01:04:14,510 --> 01:04:15,170
能理解吗

1343
01:04:17,280 --> 01:04:19,320
就是我们这个skater他会不会掉很多次

1344
01:04:19,320 --> 01:04:20,670
比如我有一个于仙姐

1345
01:04:22,640 --> 01:04:22,760
对

1346
01:04:22,760 --> 01:04:23,480
我有一个任务

1347
01:04:23,480 --> 01:04:24,560
他就进来一次

1348
01:04:26,770 --> 01:04:28,660
创建时间到直径的时间差是

1349
01:04:30,190 --> 01:04:31,990
越来越大

1350
01:04:32,560 --> 01:04:32,950
对

1351
01:04:33,310 --> 01:04:33,760
是

1352
01:04:34,920 --> 01:04:35,910
你从创建的时候

1353
01:04:35,910 --> 01:04:37,110
比如你创建的那个

1354
01:04:37,260 --> 01:04:40,020
创建的时候你就会得到一个固定的experience

1355
01:04:40,020 --> 01:04:40,530
对不对

1356
01:04:40,980 --> 01:04:43,290
因为你创建的时候优先级就已经固定了

1357
01:04:43,380 --> 01:04:46,500
就是比如你是哪个优先级就已经知道了

1358
01:04:47,100 --> 01:04:47,880
你在创建的时候

1359
01:04:47,880 --> 01:04:49,980
你的这个expression上就已经固定了

1360
01:04:50,680 --> 01:04:52,420
而你后面再进来的时候

1361
01:04:52,450 --> 01:04:53,800
就你在DOS这儿来

1362
01:04:53,980 --> 01:04:55,420
你这个explained a care

1363
01:04:55,420 --> 01:04:58,300
他却会不停的再往上加

1364
01:05:02,550 --> 01:05:05,520
任务开启时记录expression

1365
01:05:05,520 --> 01:05:07,380
他进行比较的时候用当前时间

1366
01:05:09,010 --> 01:05:09,370
不是

1367
01:05:09,370 --> 01:05:10,840
假如有两个不同的任务

1368
01:05:11,570 --> 01:05:12,830
比如这两个不同的任务

1369
01:05:13,930 --> 01:05:16,420
高于县级和地级县级的吗那么

1370
01:05:17,130 --> 01:05:18,180
那么他会

1371
01:05:18,360 --> 01:05:21,360
那么他会在初始的时候就会给你

1372
01:05:22,160 --> 01:05:23,570
计算好一个expression time

1373
01:05:23,600 --> 01:05:25,190
然后付给你的这个fiber

1374
01:05:25,400 --> 01:05:27,650
那你放一个属性叫做expression碳

1375
01:05:27,830 --> 01:05:28,610
然后呢

1376
01:05:28,610 --> 01:05:30,050
你要比较这两个

1377
01:05:31,060 --> 01:05:31,660
阿德

1378
01:05:31,660 --> 01:05:32,530
优先级的时候

1379
01:05:32,560 --> 01:05:35,350
你就他和她之间进行一个对比就行了

1380
01:05:37,320 --> 01:05:39,660
如果你比较两个任务之间的优先级

1381
01:05:41,420 --> 01:05:43,760
这简单理解就是比较两个任务的优先解决

1382
01:05:43,760 --> 01:05:45,980
就通过他们的explosion它的大小来对比

1383
01:05:48,260 --> 01:05:50,180
但是有一种特殊情况

1384
01:05:50,420 --> 01:05:52,910
即使是假如你的当前时间比

1385
01:05:53,520 --> 01:05:53,850
你的

1386
01:05:53,940 --> 01:05:56,610
如果我们的当前时间都比你的expression太大了

1387
01:05:56,760 --> 01:05:58,800
那么它会自动把你的眼睛给调高

1388
01:05:59,040 --> 01:06:00,090
就是你的expression

1389
01:06:00,090 --> 01:06:01,440
他会给你调的特别大

1390
01:06:02,160 --> 01:06:03,060
让你立刻走

1391
01:06:03,300 --> 01:06:04,230
立刻把你升职

1392
01:06:06,260 --> 01:06:07,550
所以在相互对比的时候

1393
01:06:07,550 --> 01:06:08,480
还是对比的experience

1394
01:06:11,690 --> 01:06:12,020
OK

1395
01:06:12,020 --> 01:06:12,410
好

1396
01:06:12,440 --> 01:06:13,460
接下来走了

1397
01:06:14,810 --> 01:06:15,470
接走了

1398
01:06:15,650 --> 01:06:16,550
其实在调的时候

1399
01:06:16,550 --> 01:06:17,750
比如这里react

1400
01:06:18,110 --> 01:06:23,480
我们在on click是比如在图片上把那个a click那么

1401
01:06:24,400 --> 01:06:27,400
On click撕掉REC的方法

1402
01:06:27,910 --> 01:06:31,000
实际上它就会在一开始就给你设好陷阱

1403
01:06:31,030 --> 01:06:32,530
比如我们APP的时候

1404
01:06:32,590 --> 01:06:34,150
或者说用input的时候

1405
01:06:34,390 --> 01:06:36,880
它就可以通过rang with priority的方式

1406
01:06:37,860 --> 01:06:39,570
然后给你设一个优先级

1407
01:06:39,630 --> 01:06:40,830
这其实就是给你设优先级

1408
01:06:40,830 --> 01:06:42,900
落先给你设好于谦急

1409
01:06:42,900 --> 01:06:44,610
所以说你在哪里钓了

1410
01:06:44,610 --> 01:06:46,620
实际上就是你发起了什么样的更新

1411
01:06:47,880 --> 01:06:49,890
你的优先级一开始就被确定了

1412
01:06:50,430 --> 01:06:51,480
被确定了之后

1413
01:06:51,750 --> 01:06:54,000
那么他就会计算你的X形态

1414
01:06:54,000 --> 01:06:55,350
我们可以看下面的逻辑

1415
01:06:56,650 --> 01:06:58,840
比如这他得到了

1416
01:06:59,050 --> 01:07:02,080
他得到了当前的优先级

1417
01:07:02,140 --> 01:07:02,560
这就是

1418
01:07:03,280 --> 01:07:04,540
得到当前的优先级

1419
01:07:05,180 --> 01:07:06,140
放大点

1420
01:07:09,000 --> 01:07:09,420
嗯

1421
01:07:10,300 --> 01:07:12,730
这个方法这是REC的方法

1422
01:07:12,940 --> 01:07:13,510
我之前

1423
01:07:14,700 --> 01:07:16,020
之前讲的时候

1424
01:07:17,080 --> 01:07:18,100
把这个当下来了

1425
01:07:19,500 --> 01:07:20,490
这就是来

1426
01:07:20,940 --> 01:07:23,610
字面意思就是计算expression为fiber

1427
01:07:23,640 --> 01:07:25,980
计算expression time首先得到

1428
01:07:26,760 --> 01:07:29,400
最大的这个我们的priority

1429
01:07:30,170 --> 01:07:30,830
然后

1430
01:07:32,320 --> 01:07:36,040
如果这里是这里是直接是think这是同步的

1431
01:07:36,720 --> 01:07:41,610
Concurrent model是我们就是right后面更新一个非常重要的一个东西

1432
01:07:41,880 --> 01:07:42,630
看看的model

1433
01:07:42,630 --> 01:07:43,770
它直接同步

1434
01:07:44,340 --> 01:07:46,650
而这里is working is

1435
01:07:47,590 --> 01:07:48,220
Commit ting

1436
01:07:48,520 --> 01:07:51,070
这说明他已经在生命周期内了

1437
01:07:51,370 --> 01:07:52,540
已经在生命周期内了

1438
01:07:52,690 --> 01:07:54,340
所以直接把它复制给她

1439
01:07:54,760 --> 01:07:55,810
因为她已经有了

1440
01:07:56,200 --> 01:07:58,450
然后接下来其实主要指的是这块逻辑

1441
01:07:58,720 --> 01:08:00,640
就是看你的优先级是哪个

1442
01:08:00,760 --> 01:08:02,710
如果你是你的immediate priority

1443
01:08:02,710 --> 01:08:04,090
这个我们刚刚已经看到了

1444
01:08:04,630 --> 01:08:04,930
对吧

1445
01:08:04,930 --> 01:08:06,190
他的优先级是最高的

1446
01:08:06,520 --> 01:08:07,660
那么就

1447
01:08:08,250 --> 01:08:10,530
就把这个SYNC复制给explosion案

1448
01:08:10,620 --> 01:08:12,810
这个think是一个非常大的数字

1449
01:08:13,350 --> 01:08:14,100
他是一个数字

1450
01:08:14,130 --> 01:08:15,660
是一个非常非常大的常量

1451
01:08:16,830 --> 01:08:20,790
他应该是直接等于二的31次方减一

1452
01:08:22,660 --> 01:08:23,590
这么大还不行

1453
01:08:27,020 --> 01:08:28,010
现在行了吗

1454
01:08:34,860 --> 01:08:35,550
好

1455
01:08:42,380 --> 01:08:43,910
这个think他是一个常量

1456
01:08:43,940 --> 01:08:45,830
它就直接等于二的32次方减一

1457
01:08:46,710 --> 01:08:48,990
Write写的它标志什么意思呢

1458
01:08:48,990 --> 01:08:50,550
就是没有什么比他更大了

1459
01:08:50,850 --> 01:08:51,120
对吧

1460
01:08:51,120 --> 01:08:52,140
没有什么比他更大了

1461
01:08:52,140 --> 01:08:55,290
所以要把如果是这个有县级那就立刻送走

1462
01:08:56,080 --> 01:08:58,510
那这个是因为用户交互阻塞的优先级

1463
01:08:58,510 --> 01:09:00,040
那么计算一个变态

1464
01:09:00,660 --> 01:09:02,400
就是normal就是正常的

1465
01:09:02,400 --> 01:09:03,480
一般默认的计算

1466
01:09:04,440 --> 01:09:07,050
他们计算的时候其实都会得到一个这个值

1467
01:09:07,560 --> 01:09:09,840
它会有一个间隔这个

1468
01:09:11,450 --> 01:09:13,190
Beckett赛斯

1469
01:09:13,400 --> 01:09:15,200
这个什么因为我

1470
01:09:15,880 --> 01:09:16,120
没有

1471
01:09:16,270 --> 01:09:20,350
我们之前那个ray下载的X6的不太好找了

1472
01:09:20,410 --> 01:09:21,430
所以没给大家

1473
01:09:21,430 --> 01:09:24,790
实际上实际上如果是诺莫

1474
01:09:26,680 --> 01:09:28,420
He use black king priority

1475
01:09:28,420 --> 01:09:29,890
他们都会掉这个方法

1476
01:09:30,250 --> 01:09:31,060
都会掉这个方法

1477
01:09:31,060 --> 01:09:34,630
但是因为他们的这个back its eyes不一样

1478
01:09:34,630 --> 01:09:36,700
也就是它们的间隔是不一样

1479
01:09:37,430 --> 01:09:39,170
所以兼职不一样

1480
01:09:39,170 --> 01:09:42,650
所以他们的expression差也就也就会不一样

1481
01:09:42,890 --> 01:09:45,770
就算是同时发起的两个不同的任务的一些细节

1482
01:09:45,770 --> 01:09:49,130
那么你们的expression他他就是不一样

1483
01:09:50,150 --> 01:09:50,930
通过它来做的

1484
01:09:50,930 --> 01:09:53,240
所以他这个时候这个实际上就是数字

1485
01:09:53,300 --> 01:09:54,650
就是我刚刚讲的那个逻辑

1486
01:09:55,280 --> 01:10:01,430
就是X16 x16应该是16点儿13以前吧

1487
01:10:01,940 --> 01:10:03,050
那么它都是这个逻辑

1488
01:10:03,050 --> 01:10:08,000
通过expression粲然后来判断这个于青姐通过这两个

1489
01:10:08,440 --> 01:10:11,380
逻辑一个是一个是优先级的绑定

1490
01:10:11,380 --> 01:10:13,060
一个是红任务中执行

1491
01:10:13,270 --> 01:10:17,260
那么我们的forever价格比X15的性能

1492
01:10:17,260 --> 01:10:18,640
那么就好像非常多了

1493
01:10:18,790 --> 01:10:22,150
因为我们的用户至少不会因为一个长任务

1494
01:10:22,150 --> 01:10:23,320
然后就是卡的不行

1495
01:10:23,530 --> 01:10:25,390
卡的不行至少是能够交互的

1496
01:10:25,570 --> 01:10:28,600
就是FAB架构所做的事情

1497
01:10:28,660 --> 01:10:30,910
所这两个主要的事情

1498
01:10:31,330 --> 01:10:32,050
但是呢

1499
01:10:32,350 --> 01:10:33,760
它还是有缺点的

1500
01:10:35,030 --> 01:10:35,930
他还是有缺点

1501
01:10:36,290 --> 01:10:37,430
他的缺点是什么呢

1502
01:10:38,300 --> 01:10:39,560
在ROCK16里

1503
01:10:40,480 --> 01:10:42,310
Expression的大小恒定优先级

1504
01:10:42,310 --> 01:10:43,390
Expression越大

1505
01:10:43,480 --> 01:10:44,530
Expression越大

1506
01:10:44,560 --> 01:10:45,460
优先级越高

1507
01:10:45,880 --> 01:10:47,230
所以高优先级的任务

1508
01:10:48,120 --> 01:10:50,670
那么他肯定会将的无限极的任务给注册掉吗

1509
01:10:51,030 --> 01:10:52,860
这是我们的expression

1510
01:10:52,860 --> 01:10:53,340
它的逻辑

1511
01:10:53,370 --> 01:10:54,480
REC的逻辑

1512
01:10:55,020 --> 01:10:55,530
他有个

1513
01:10:55,530 --> 01:10:56,670
但他有一个

1514
01:10:57,750 --> 01:10:59,220
这上面的调度算法吗

1515
01:10:59,220 --> 01:11:03,690
是但是但是我们会继续会讲到这个schedule具体的逻辑

1516
01:11:04,340 --> 01:11:05,540
肯定不止这么点儿

1517
01:11:06,080 --> 01:11:07,070
肯定不止这么点

1518
01:11:07,250 --> 01:11:09,320
我是说他大概做的

1519
01:11:09,440 --> 01:11:11,720
从宏观层面上来说

1520
01:11:11,750 --> 01:11:13,310
他大概做了这么两件事情

1521
01:11:14,140 --> 01:11:15,520
他大概有这么两个事情

1522
01:11:15,850 --> 01:11:17,230
但是具体的调度逻辑的话

1523
01:11:17,230 --> 01:11:18,880
我们会在schedule继续讲

1524
01:11:19,460 --> 01:11:19,940
好不好

1525
01:11:21,280 --> 01:11:21,730
嗯

1526
01:11:23,630 --> 01:11:26,180
即使是即使是做到了

1527
01:11:26,210 --> 01:11:28,730
我们的X60做到了这样

1528
01:11:30,280 --> 01:11:31,570
其实还是有个缺点

1529
01:11:31,600 --> 01:11:32,260
缺点是

1530
01:11:32,650 --> 01:11:35,740
但这个缺点并不是从RANK16一开始就带来的

1531
01:11:36,040 --> 01:11:37,750
而是随着代码的迭代

1532
01:11:38,080 --> 01:11:40,630
Rock的内部出现了新的东西

1533
01:11:40,720 --> 01:11:42,580
叫做suspense suspense

1534
01:11:42,580 --> 01:11:45,520
不知道大家有没有用过suspense he lay the

1535
01:11:45,850 --> 01:11:50,290
我们可以用suspense he lazy来做我们的动态懒加载

1536
01:11:50,880 --> 01:11:52,830
东南加载而三次

1537
01:11:52,830 --> 01:11:54,360
它实际上就是等待

1538
01:11:54,600 --> 01:11:55,650
等待你的执着

1539
01:11:55,800 --> 01:11:56,700
等待你的

1540
01:11:57,280 --> 01:12:01,690
你的子组件等那个子健那个完全访问回来之后

1541
01:12:01,720 --> 01:12:02,590
他才会展示

1542
01:12:02,860 --> 01:12:04,330
所以它有一个等待的过程

1543
01:12:04,630 --> 01:12:05,860
对于SaaS来说

1544
01:12:05,860 --> 01:12:07,180
它就可以

1545
01:12:07,540 --> 01:12:10,540
它就实际上就出现了一个IO的一个任务

1546
01:12:11,340 --> 01:12:12,600
他是一个IO的任务

1547
01:12:12,750 --> 01:12:14,850
会阻塞的优先级的CPU的任务

1548
01:12:15,240 --> 01:12:17,820
因为suspense之前没有Spence

1549
01:12:18,120 --> 01:12:20,550
那么我们用VX6是没有问题的

1550
01:12:21,120 --> 01:12:22,230
觉得是挺完美的

1551
01:12:22,530 --> 01:12:24,330
但是因为S出现之后

1552
01:12:24,880 --> 01:12:25,600
出现问题了

1553
01:12:27,760 --> 01:12:28,630
出现问题

1554
01:12:29,020 --> 01:12:29,590
问题是什么呢

1555
01:12:29,590 --> 01:12:30,430
我们来看一下这个

1556
01:12:30,970 --> 01:12:31,750
自己看一下这个

1557
01:12:32,740 --> 01:12:33,850
这是官方的DEMO

1558
01:12:36,080 --> 01:12:37,430
好像是官方店吧

1559
01:12:37,820 --> 01:12:39,350
也有点儿有点儿早了

1560
01:12:43,010 --> 01:12:44,240
大致看一下这个逻辑

1561
01:12:44,240 --> 01:12:45,380
大致看一下这个函数

1562
01:12:45,440 --> 01:12:48,080
这是通过Spence包裹起来的一个子组件

1563
01:12:48,770 --> 01:12:49,280
对吧

1564
01:12:49,640 --> 01:12:50,000
然后呢

1565
01:12:50,000 --> 01:12:50,810
这是一个loading

1566
01:12:51,200 --> 01:12:52,850
这个loading这什么意思呢

1567
01:12:52,850 --> 01:12:56,210
就是当我们的子组件还没有回来的时候

1568
01:12:56,240 --> 01:12:57,200
先渲染楼顶

1569
01:12:58,060 --> 01:12:59,470
我们经常有这种情况吗

1570
01:12:59,680 --> 01:13:01,960
经常有这种处理

1571
01:13:01,990 --> 01:13:03,730
比如我们一个查询的查询

1572
01:13:03,730 --> 01:13:06,640
在查询到数据返回之前

1573
01:13:06,640 --> 01:13:07,540
先展示了Lowe的

1574
01:13:07,570 --> 01:13:07,930
对吧

1575
01:13:08,170 --> 01:13:10,570
那么我们的space也可以做得到这样的一件事情

1576
01:13:10,690 --> 01:13:13,120
当我们的APP的宣传之前

1577
01:13:13,360 --> 01:13:15,850
展示一个娄底儿这边做了什么事

1578
01:13:15,850 --> 01:13:17,320
传进了一个S

1579
01:13:17,650 --> 01:13:19,030
这个S是一个值

1580
01:13:19,560 --> 01:13:21,390
这个值会每秒变化

1581
01:13:21,420 --> 01:13:24,060
大家看这会每秒变化对吧

1582
01:13:24,450 --> 01:13:26,100
可是当我们点击click的时候

1583
01:13:27,760 --> 01:13:29,140
当我点击click的时候

1584
01:13:29,960 --> 01:13:31,730
然后我们看看会发生什么事情

1585
01:13:33,890 --> 01:13:34,520
大家看

1586
01:13:34,880 --> 01:13:35,600
棚顶住了

1587
01:13:36,400 --> 01:13:37,840
我们的这个词刚刚没有变

1588
01:13:38,980 --> 01:13:39,430
对不对

1589
01:13:40,340 --> 01:13:42,080
我再再给大家演示一遍

1590
01:13:43,920 --> 01:13:45,030
再看它是不是

1591
01:13:45,860 --> 01:13:46,700
变成50角

1592
01:13:47,000 --> 01:13:48,230
我们的这个值并没有

1593
01:13:49,020 --> 01:13:51,030
我们这个值并没有更新成功

1594
01:13:51,060 --> 01:13:51,780
再来一次

1595
01:13:52,620 --> 01:13:53,970
看他现在每一秒都在变

1596
01:13:54,870 --> 01:13:55,260
不要了

1597
01:13:56,660 --> 01:13:58,280
但实际上它内部的数据是变了

1598
01:13:58,280 --> 01:13:59,150
只是宣传不出来

1599
01:14:00,200 --> 01:14:01,130
这就是原因

1600
01:14:01,130 --> 01:14:03,020
就是因为萨斯把这个阻塞了

1601
01:14:03,820 --> 01:14:04,720
差十分主次了

1602
01:14:05,050 --> 01:14:06,490
又随着rock的迭代

1603
01:14:06,820 --> 01:14:07,690
它的内部

1604
01:14:08,490 --> 01:14:09,840
产生了IO任务

1605
01:14:11,010 --> 01:14:15,900
ER react中的L任务和我们和我们平常所说的那个L并不太一样

1606
01:14:16,050 --> 01:14:18,540
他就是只和Spence机制相关的任务

1607
01:14:19,200 --> 01:14:20,160
他就是L任务

1608
01:14:21,870 --> 01:14:23,430
我之前也不太理解

1609
01:14:23,760 --> 01:14:25,530
但是你记住这句话就理解了

1610
01:14:26,250 --> 01:14:27,930
他就是只和他分是相关的

1611
01:14:29,090 --> 01:14:29,840
你听明白了

1612
01:14:30,580 --> 01:14:34,690
所以如果一个任务会引起30分下子组件抛出任的对象

1613
01:14:34,720 --> 01:14:36,040
那么他就一定是L任务

1614
01:14:36,340 --> 01:14:37,390
他就一定会阻塞

1615
01:14:37,870 --> 01:14:39,160
所以通过sus pen SI

1616
01:14:40,190 --> 01:14:42,830
那么因为它它的这个N任务

1617
01:14:42,830 --> 01:14:44,210
但是他运气还挺高

1618
01:14:44,920 --> 01:14:48,070
所以你有的修建的第一天的任务的时候

1619
01:14:48,100 --> 01:14:49,960
比如我们刚刚那个塞帽子

1620
01:14:49,960 --> 01:14:52,090
明显就是一个低优先级的CPU任务

1621
01:14:52,940 --> 01:14:54,800
因为毕竟我用户并没有操作嘛

1622
01:14:54,800 --> 01:14:55,145
对不对

1623
01:14:55,145 --> 01:14:56,030
我没有操作

1624
01:14:56,720 --> 01:14:57,800
他肯定不是用户

1625
01:14:58,370 --> 01:15:00,260
他肯定不是用户操作那么高的任务

1626
01:15:01,040 --> 01:15:02,150
所以他最多是个normal

1627
01:15:02,540 --> 01:15:03,980
有可能是个吊吊的的

1628
01:15:05,640 --> 01:15:08,910
因此我的高优先级的任务就把他给阻塞了

1629
01:15:09,000 --> 01:15:09,750
就这么个逻辑

1630
01:15:10,600 --> 01:15:11,200
这怎么逻辑

1631
01:15:11,230 --> 01:15:11,800
因此

1632
01:15:11,830 --> 01:15:13,240
原本的expression time

1633
01:15:14,700 --> 01:15:17,520
仅仅通过对比优先级的高低

1634
01:15:18,410 --> 01:15:20,360
那么实际上是解决不了这个问题

1635
01:15:20,390 --> 01:15:21,380
大家能理解这个问题

1636
01:15:21,530 --> 01:15:22,580
能理解这个含义吗

1637
01:15:23,150 --> 01:15:25,760
因为我这个任务的优先级高

1638
01:15:26,330 --> 01:15:27,920
那么按照之前的逻辑来说

1639
01:15:27,920 --> 01:15:29,210
那我就是该阻塞

1640
01:15:29,390 --> 01:15:33,020
但实际上并不是因为因为你是个等待的过程

1641
01:15:33,110 --> 01:15:34,130
也是一个等待的过程

1642
01:15:34,400 --> 01:15:35,870
即使是你优先级高

1643
01:15:36,480 --> 01:15:36,840
那么

1644
01:15:37,260 --> 01:15:38,670
但是你其实啥也没干

1645
01:15:38,670 --> 01:15:39,870
也只是展示一个loading

1646
01:15:40,500 --> 01:15:40,800
对吧

1647
01:15:40,800 --> 01:15:41,850
就只是展示一个loading

1648
01:15:41,850 --> 01:15:42,660
啥也没干

1649
01:15:42,960 --> 01:15:45,630
那我们可不可以先展示地域性学生

1650
01:15:46,020 --> 01:15:47,880
这就是expression time

1651
01:15:48,630 --> 01:15:49,170
Expansion

1652
01:15:49,170 --> 01:15:50,820
他们之前的一个缺点吧

1653
01:15:50,820 --> 01:15:52,830
就是它的优先级

1654
01:15:53,460 --> 01:15:54,810
他把优先级和批处理

1655
01:15:54,810 --> 01:15:58,020
它相当于一起给坐一起给做了之

1656
01:15:58,380 --> 01:16:00,210
比如我有两个a的任务

1657
01:16:00,420 --> 01:16:00,660
对吧

1658
01:16:00,660 --> 01:16:01,800
我有两个任务

1659
01:16:02,070 --> 01:16:02,940
一个C任务

1660
01:16:03,090 --> 01:16:05,790
那么这两个a任务就打包一起一起处理了

1661
01:16:06,480 --> 01:16:10,200
但是也就是说他就只根据大于

1662
01:16:10,200 --> 01:16:11,310
比如说a大于B

1663
01:16:11,520 --> 01:16:12,930
那么a是所有的

1664
01:16:12,930 --> 01:16:13,920
A就可以先处理

1665
01:16:14,580 --> 01:16:18,120
他把优先级和批处理一起做了这两个事情

1666
01:16:18,120 --> 01:16:19,380
他一个事情一起做了

1667
01:16:19,680 --> 01:16:21,840
这种实际上不太好

1668
01:16:21,960 --> 01:16:22,350
对吧

1669
01:16:22,500 --> 01:16:24,450
我们再带我们在平常的开发过程当中

1670
01:16:24,450 --> 01:16:28,770
其实也也会遇到一个字段处理两个功能的情况

1671
01:16:29,960 --> 01:16:31,280
没有扩展的情况下

1672
01:16:31,280 --> 01:16:33,950
他还能他还能够解决问题

1673
01:16:34,280 --> 01:16:35,840
只要需求一个变化

1674
01:16:35,870 --> 01:16:36,290
那么它

1675
01:16:37,300 --> 01:16:38,680
一下子就不能够满足虚

1676
01:16:39,070 --> 01:16:40,000
不能满足需要了

1677
01:16:40,000 --> 01:16:41,500
这个express上也是如此

1678
01:16:41,830 --> 01:16:44,200
他之前是能够很好的完成任务的

1679
01:16:44,740 --> 01:16:47,020
但是出现了任务之后

1680
01:16:47,020 --> 01:16:48,610
他就不能够很好的完成了

1681
01:16:48,970 --> 01:16:50,170
因为他已经处理不了了

1682
01:16:50,590 --> 01:16:51,700
所以rock的

1683
01:16:52,300 --> 01:16:54,190
关于这个处理实际上非常简单

1684
01:16:55,070 --> 01:16:55,700
就是呢

1685
01:16:55,820 --> 01:16:57,200
这就是RAKE17

1686
01:16:57,410 --> 01:16:58,400
然后增加了

1687
01:16:58,850 --> 01:17:00,830
把那个expression太给淘汰了

1688
01:17:01,610 --> 01:17:06,410
变成less less就如果大家觉得expansion但不好理解的话

1689
01:17:06,680 --> 01:17:09,500
这个last可能就更加有一点点的不好理解

1690
01:17:09,770 --> 01:17:11,540
但是我们现在只是有概念

1691
01:17:11,540 --> 01:17:12,290
只是有概念

1692
01:17:12,890 --> 01:17:14,870
具体的话

1693
01:17:16,420 --> 01:17:17,950
面试问的也不多吧

1694
01:17:18,010 --> 01:17:18,970
面试问的也不多

1695
01:17:18,970 --> 01:17:19,720
只能这么说

1696
01:17:20,230 --> 01:17:21,520
只能这么说我们

1697
01:17:21,520 --> 01:17:23,020
但我们还是要先来看看呢

1698
01:17:23,970 --> 01:17:24,960
Less是什么意思

1699
01:17:25,380 --> 01:17:31,500
Less它实际上做的最主要的一个功能就是它把experts探柔和的优先级和批处理

1700
01:17:32,760 --> 01:17:34,200
又见嚼批处理她

1701
01:17:34,200 --> 01:17:35,910
把她给娶她把它给分开了

1702
01:17:37,220 --> 01:17:38,960
他的一个分开了这些

1703
01:17:38,960 --> 01:17:41,690
其次是那是主要的一个功能

1704
01:17:41,720 --> 01:17:44,390
我们来看一下优先烂

1705
01:17:44,810 --> 01:17:47,960
但是里面有两个有两种类型的一种较量

1706
01:17:48,080 --> 01:17:49,130
一种叫lance

1707
01:17:49,700 --> 01:17:54,200
一看就是一看就是一个多一个表单数据表多数嘛

1708
01:17:54,230 --> 01:17:54,470
对吧

1709
01:17:54,470 --> 01:17:57,800
一个表双数烂就表示单个的优先级

1710
01:17:58,280 --> 01:17:59,210
Lance表示

1711
01:18:00,330 --> 01:18:02,310
多个批处理多个优先级

1712
01:18:02,610 --> 01:18:05,760
也就是说我如果只处理一个优先级

1713
01:18:05,760 --> 01:18:06,240
那么

1714
01:18:06,800 --> 01:18:08,510
那么我只占一个

1715
01:18:08,900 --> 01:18:10,550
如果我要处理多个县级

1716
01:18:10,670 --> 01:18:13,280
如果要只占一个县级就烂

1717
01:18:13,640 --> 01:18:14,660
如果要占多个县级

1718
01:18:14,660 --> 01:18:16,160
用尔这个烂

1719
01:18:16,250 --> 01:18:17,990
它的中文含义叫做车道

1720
01:18:18,050 --> 01:18:18,320
就是

1721
01:18:18,320 --> 01:18:18,950
其实就是

1722
01:18:20,420 --> 01:18:21,140
一般这样

1723
01:18:21,800 --> 01:18:23,390
其实我不知道咋翻译了这个

1724
01:18:24,060 --> 01:18:25,110
感觉怎么翻译的不对

1725
01:18:25,110 --> 01:18:26,370
就叫烂扒嚼烂

1726
01:18:26,730 --> 01:18:27,600
但是类比

1727
01:18:27,750 --> 01:18:29,430
国内一般类比把它全

1728
01:18:29,430 --> 01:18:31,740
把它类比成像车库

1729
01:18:32,320 --> 01:18:33,430
车库的这个样子

1730
01:18:33,550 --> 01:18:34,330
就是比如说

1731
01:18:35,500 --> 01:18:37,720
比如说你有一个停车位

1732
01:18:37,930 --> 01:18:38,770
一个停车场

1733
01:18:41,110 --> 01:18:41,650
停车场

1734
01:18:43,860 --> 01:18:44,550
那么

1735
01:18:45,840 --> 01:18:46,860
你的每一个

1736
01:18:47,640 --> 01:18:48,810
这里有好几个位置

1737
01:18:48,840 --> 01:18:49,380
真没

1738
01:18:50,230 --> 01:18:51,280
这有好几个位置

1739
01:18:52,260 --> 01:18:52,650
对吧

1740
01:18:53,580 --> 01:18:54,600
一辆车停一个

1741
01:18:54,600 --> 01:18:56,070
一辆车停一辆车停个

1742
01:18:56,280 --> 01:18:57,540
可以同时停多个

1743
01:18:57,840 --> 01:18:58,890
可以同时停多个

1744
01:18:59,550 --> 01:19:00,660
以前一个分析

1745
01:19:00,660 --> 01:19:01,860
但他就只能停一个

1746
01:19:02,130 --> 01:19:04,620
他就只有一个ERS的话

1747
01:19:04,950 --> 01:19:05,940
就相当于这个车道

1748
01:19:05,940 --> 01:19:07,140
比如一个优先级

1749
01:19:07,940 --> 01:19:10,760
那么他占一个a县级

1750
01:19:10,760 --> 01:19:11,630
他站在这个位置

1751
01:19:13,180 --> 01:19:14,440
第一个县级站在这个位置

1752
01:19:14,920 --> 01:19:16,180
C县级可以站在这个位置

1753
01:19:16,300 --> 01:19:19,840
它就可以把多个相近的优先级

1754
01:19:20,500 --> 01:19:21,010
大家注意

1755
01:19:21,160 --> 01:19:22,510
多个相近的玉娴姐

1756
01:19:22,510 --> 01:19:23,590
那么他的这个任务

1757
01:19:24,380 --> 01:19:27,890
他们他那么他是可以一并把它进行处理掉

1758
01:19:28,370 --> 01:19:29,780
一并进行处理掉了

1759
01:19:30,820 --> 01:19:31,540
就这个样子

1760
01:19:32,470 --> 01:19:33,160
所以

1761
01:19:33,780 --> 01:19:37,590
所以他比相比于相比于expression

1762
01:19:37,590 --> 01:19:38,610
他多了一点什么

1763
01:19:38,610 --> 01:19:39,900
他就可以处理多个

1764
01:19:40,020 --> 01:19:41,310
其他就可以处理多个

1765
01:19:41,820 --> 01:19:42,540
这就是它的

1766
01:19:43,530 --> 01:19:44,100
优势

1767
01:19:44,490 --> 01:19:45,810
但是还挺复杂的

1768
01:19:46,080 --> 01:19:47,370
非常复杂

1769
01:19:47,700 --> 01:19:49,530
我们多少算相近

1770
01:19:50,010 --> 01:19:50,910
下面有代码

1771
01:19:50,940 --> 01:19:51,840
我们直接来看吧

1772
01:19:53,440 --> 01:19:55,120
把这概念讲完了

1773
01:19:56,350 --> 01:19:59,710
S模型使用31位的二进制代表31种可能性

1774
01:19:59,740 --> 01:20:03,190
其实它是用31位二进制代表31种可能性

1775
01:20:03,190 --> 01:20:05,320
就是31个车道

1776
01:20:05,350 --> 01:20:06,640
对他有31个车道

1777
01:20:07,350 --> 01:20:10,470
31个最多可以最多你可以同时

1778
01:20:11,280 --> 01:20:14,250
最终你可以同时更新30个

1779
01:20:15,180 --> 01:20:16,110
30个

1780
01:20:17,390 --> 01:20:18,710
优先级优先级的任务

1781
01:20:19,010 --> 01:20:20,570
这个可以重新更新那么多个

1782
01:20:20,960 --> 01:20:22,340
再多了他就不支持了

1783
01:20:23,030 --> 01:20:24,080
太多了他就不支持了

1784
01:20:24,470 --> 01:20:27,950
所以所以如果有Les的话

1785
01:20:28,100 --> 01:20:30,650
用less来处理我们刚刚所看

1786
01:20:30,650 --> 01:20:32,960
高优先级和低优先级的任务的话

1787
01:20:33,230 --> 01:20:38,210
那么他可以分别给IO任务和CB任务不同的呢

1788
01:20:38,600 --> 01:20:40,010
然后并发地执行就行了

1789
01:20:40,420 --> 01:20:43,360
所以他就是从以前只能执行一个月县级政务

1790
01:20:43,750 --> 01:20:45,460
到同时执行多个月星级任务

1791
01:20:47,340 --> 01:20:49,620
我们来看一下具体的逻辑具体的

1792
01:20:50,580 --> 01:20:51,060
大吗

1793
01:20:51,930 --> 01:20:53,370
比如这里就是一个的士

1794
01:20:54,090 --> 01:20:54,690
发起一个

1795
01:20:54,690 --> 01:20:56,460
比如说我用户操作的一个更新

1796
01:20:56,460 --> 01:20:58,080
发起了一个用户操作更新

1797
01:20:58,530 --> 01:21:00,360
那么它这里会设置一个

1798
01:21:01,120 --> 01:21:01,810
优先级

1799
01:21:02,170 --> 01:21:03,490
这个叫做input

1800
01:21:04,270 --> 01:21:05,950
Continuous lens priority

1801
01:21:06,430 --> 01:21:07,660
这个是车道的一些

1802
01:21:07,660 --> 01:21:09,850
它相比于上面的这几种

1803
01:21:13,170 --> 01:21:15,840
下面我们可以看到有五种优先级对不对

1804
01:21:15,840 --> 01:21:17,370
有五种优先级

1805
01:21:17,760 --> 01:21:20,070
那么它区分的更加详细

1806
01:21:21,090 --> 01:21:22,230
他确实更加详细

1807
01:21:22,260 --> 01:21:24,510
但是我其实你只要看到input

1808
01:21:24,510 --> 01:21:26,400
反正是跟输入相关的

1809
01:21:26,400 --> 01:21:27,330
是跟输入相关的

1810
01:21:27,330 --> 01:21:28,920
他是输入相关的优先级

1811
01:21:29,660 --> 01:21:30,890
然后下边儿

1812
01:21:33,170 --> 01:21:35,420
通过设置的这个优先级

1813
01:21:35,780 --> 01:21:39,830
然后他就给它探测到去给他站车到这里就是占车道的逻辑

1814
01:21:40,250 --> 01:21:42,260
这就是输入的1700

1815
01:21:42,880 --> 01:21:44,140
如果是同步的

1816
01:21:44,200 --> 01:21:45,550
大家看这是烂不是烂

1817
01:21:46,270 --> 01:21:46,930
烂的话

1818
01:21:46,960 --> 01:21:48,820
那就是运气非常高

1819
01:21:49,300 --> 01:21:50,410
如果是同步的

1820
01:21:50,680 --> 01:21:52,540
或者是批次批量同步的

1821
01:21:52,900 --> 01:21:54,670
那么他就直接把他送走

1822
01:21:54,670 --> 01:21:56,200
这就是优先级很高的

1823
01:21:56,470 --> 01:21:59,350
那么就不需要做后面的递归操作了

1824
01:21:59,710 --> 01:22:01,240
就是只占一个就够了

1825
01:22:01,760 --> 01:22:02,720
只占一个就够了

1826
01:22:02,720 --> 01:22:03,830
就不用粘太多

1827
01:22:03,830 --> 01:22:05,060
因为它优先级很高嘛

1828
01:22:05,240 --> 01:22:09,980
他就类似于我们刚刚的这个1IMMEDIATE priority一样

1829
01:22:10,750 --> 01:22:12,220
这个这个优先级

1830
01:22:12,460 --> 01:22:16,180
这个RANK17的这个think烂和X6的

1831
01:22:16,180 --> 01:22:18,580
我刚刚讲到的立即处理的一些

1832
01:22:18,580 --> 01:22:20,830
就是image的priority是一样的

1833
01:22:26,530 --> 01:22:27,670
这个星级是一样的

1834
01:22:27,760 --> 01:22:28,420
特别高

1835
01:22:28,900 --> 01:22:30,400
那么只要出现了这个优先级

1836
01:22:30,400 --> 01:22:30,790
那么

1837
01:22:31,580 --> 01:22:33,620
那么它就是会被最优先执行的

1838
01:22:34,160 --> 01:22:36,170
这个逻辑还还好说

1839
01:22:36,170 --> 01:22:36,470
对吧

1840
01:22:36,500 --> 01:22:40,310
还好说下面假如说你遇到了这个input description re

1841
01:22:41,420 --> 01:22:42,680
Input continuous re

1842
01:22:43,040 --> 01:22:44,600
那么我们看代码

1843
01:22:46,960 --> 01:22:49,690
就需要看一下源码

1844
01:23:03,780 --> 01:23:04,920
这大家看

1845
01:23:09,040 --> 01:23:10,900
他们都是时间都是二进制的

1846
01:23:11,050 --> 01:23:12,580
通过二进制来表示的

1847
01:23:13,030 --> 01:23:14,230
通过二进制来表示的

1848
01:23:14,530 --> 01:23:15,370
像这个

1849
01:23:16,150 --> 01:23:19,510
Input continues烂那么

1850
01:23:20,150 --> 01:23:23,420
这每一个大家可以把它想象成停车场的停车位

1851
01:23:24,020 --> 01:23:28,640
零的话就不是他的一的话就是他的为相相当于这个

1852
01:23:29,660 --> 01:23:32,360
Input Dis input Dis credit line

1853
01:23:32,720 --> 01:23:34,790
那么它是从这儿开始的

1854
01:23:35,210 --> 01:23:36,590
它是可以有两个

1855
01:23:36,830 --> 01:23:37,520
有两个

1856
01:23:37,880 --> 01:23:38,810
如果这个

1857
01:23:39,820 --> 01:23:44,470
他这两个位置都被这就是它这可以停放两个优先级的任务

1858
01:23:45,040 --> 01:23:46,300
如果这样不够的话

1859
01:23:46,300 --> 01:23:47,230
他可以去借

1860
01:23:47,350 --> 01:23:53,050
就是他会去继续找剩下的就是这个一再去找后面的一

1861
01:23:53,350 --> 01:23:54,970
但最终他是要连续的

1862
01:23:54,970 --> 01:23:56,920
他会他必须要连续的放

1863
01:23:57,250 --> 01:23:58,210
连续的放在一起

1864
01:23:58,210 --> 01:23:59,680
然后把这几个连续的一星期

1865
01:24:00,480 --> 01:24:02,610
拿去做一次

1866
01:24:02,970 --> 01:24:04,290
拿去做一次更新

1867
01:24:06,720 --> 01:24:07,350
有点儿

1868
01:24:07,960 --> 01:24:08,650
这可能

1869
01:24:09,300 --> 01:24:10,050
有点难

1870
01:24:10,080 --> 01:24:10,620
有点难

1871
01:24:11,040 --> 01:24:12,210
我再给大家

1872
01:24:12,720 --> 01:24:14,280
我再给大家捋一捋

1873
01:24:16,450 --> 01:24:17,350
再给大家捋一捋

1874
01:24:17,470 --> 01:24:17,980
首先

1875
01:24:17,980 --> 01:24:20,560
烂lines相比于

1876
01:24:21,280 --> 01:24:24,010
Expression碳相比于expression碳的模型

1877
01:24:24,400 --> 01:24:25,540
那么它可以

1878
01:24:26,300 --> 01:24:28,730
它可以放多个优先级的任务都可以

1879
01:24:28,730 --> 01:24:30,500
不同优先级的任务他都可以放

1880
01:24:30,770 --> 01:24:31,460
他都可以放

1881
01:24:31,670 --> 01:24:32,660
那比如说我们

1882
01:24:33,300 --> 01:24:34,260
从这里开始

1883
01:24:34,890 --> 01:24:36,060
发起了两次更新

1884
01:24:36,090 --> 01:24:37,140
我觉得发起两次更新

1885
01:24:37,140 --> 01:24:37,950
我们一起来看吧

1886
01:24:38,100 --> 01:24:39,990
这是第一次更新

1887
01:24:39,990 --> 01:24:41,280
这是我之前写的逻辑

1888
01:24:41,700 --> 01:24:44,280
假如他走到了这个就是和用户操作有关的

1889
01:24:44,970 --> 01:24:45,570
那么

1890
01:24:47,350 --> 01:24:52,060
第一次我们看到它是这个input description LAN priority

1891
01:24:52,090 --> 01:24:54,550
那么他指的是input的

1892
01:24:57,190 --> 01:24:58,450
那么第一次更新

1893
01:24:59,120 --> 01:25:00,560
他就会找到

1894
01:25:00,560 --> 01:25:02,450
他就把这个先放在这个位置

1895
01:25:03,380 --> 01:25:04,430
他就放在这个位置

1896
01:25:05,240 --> 01:25:06,380
下一次更新

1897
01:25:06,410 --> 01:25:08,240
第二次更新就会继续往前走

1898
01:25:08,240 --> 01:25:09,920
放这个位置

1899
01:25:10,580 --> 01:25:12,710
优先级的高低是从后往前看的

1900
01:25:13,250 --> 01:25:14,690
比如这个就是最高的

1901
01:25:14,960 --> 01:25:16,010
我们的signal吗

1902
01:25:16,130 --> 01:25:18,320
Signal这个就是这个

1903
01:25:18,320 --> 01:25:22,070
它就把它放放在这个位置的优先级是最高的

1904
01:25:22,640 --> 01:25:23,060
ER

1905
01:25:24,420 --> 01:25:26,550
中途的这个

1906
01:25:26,580 --> 01:25:28,110
就是从从右到左

1907
01:25:28,110 --> 01:25:30,660
从右到左是由高到低的这个顺序

1908
01:25:31,230 --> 01:25:33,870
我们因为它是用用户的操作

1909
01:25:33,870 --> 01:25:37,140
所以他不会占据我们前面的这两个signal的东西

1910
01:25:37,530 --> 01:25:39,180
他不会占据这两个

1911
01:25:39,180 --> 01:25:40,350
它就会占据他自己的

1912
01:25:40,920 --> 01:25:46,230
这里其实也也就隐隐的有一个有一个优先级对比的关系

1913
01:25:46,230 --> 01:25:47,250
其实已经出来了

1914
01:25:47,250 --> 01:25:47,640
同学们

1915
01:25:48,420 --> 01:25:49,770
云姐的对比关系已经出来了

1916
01:25:49,770 --> 01:25:51,900
比如这两个是最高的

1917
01:25:52,520 --> 01:25:52,970
对吧

1918
01:25:53,240 --> 01:25:53,810
然后

1919
01:25:55,160 --> 01:25:57,140
中间的input相关的

1920
01:25:57,140 --> 01:25:58,940
那么从就从这儿开始看

1921
01:25:58,940 --> 01:26:01,610
是不是从这开始可能会占好几个

1922
01:26:01,610 --> 01:26:03,740
大家看有哪几个是硬铺的

1923
01:26:04,100 --> 01:26:06,020
一直到这里吧

1924
01:26:06,230 --> 01:26:06,470
对吧

1925
01:26:06,470 --> 01:26:07,070
一直到这里

1926
01:26:07,400 --> 01:26:08,060
这个冷战

1927
01:26:08,060 --> 01:26:09,560
那么这些就是相近的

1928
01:26:09,830 --> 01:26:10,730
这就是相近的

1929
01:26:12,990 --> 01:26:13,920
然后这我们看

1930
01:26:14,250 --> 01:26:16,230
如果这没有了

1931
01:26:16,230 --> 01:26:17,400
占据逻辑就是

1932
01:26:18,190 --> 01:26:18,910
大体的逻辑

1933
01:26:18,910 --> 01:26:20,980
我们大体逻辑就是我刚刚讲的那样

1934
01:26:21,070 --> 01:26:22,000
如果没有了

1935
01:26:22,210 --> 01:26:22,420
对吧

1936
01:26:22,420 --> 01:26:23,560
他又去找下面

1937
01:26:23,590 --> 01:26:26,110
就是这本来是described烂

1938
01:26:26,290 --> 01:26:27,970
现在还去找continuous line

1939
01:26:28,000 --> 01:26:29,680
就是又到下面来了

1940
01:26:29,920 --> 01:26:32,080
下面来了他就又去找continues烂

1941
01:26:32,740 --> 01:26:33,880
然后他就找地方呢

1942
01:26:33,880 --> 01:26:35,710
就是一直往后找

1943
01:26:35,740 --> 01:26:36,280
一直往后找

1944
01:26:36,280 --> 01:26:37,690
假如你有那么多要更新的

1945
01:26:37,690 --> 01:26:38,560
他就一直往后找

1946
01:26:40,490 --> 01:26:42,320
第一次最高限制

1947
01:26:46,230 --> 01:26:46,830
啥意思

1948
01:26:51,020 --> 01:26:51,620
不是啊

1949
01:26:51,710 --> 01:26:52,130
不是

1950
01:26:59,630 --> 01:27:00,380
啥呀

1951
01:27:00,950 --> 01:27:01,820
你说这个吗

1952
01:27:03,320 --> 01:27:06,590
你不管你别管这个好吧

1953
01:27:07,610 --> 01:27:09,080
看瓢了

1954
01:27:09,950 --> 01:27:11,030
对看漂了吧

1955
01:27:11,360 --> 01:27:12,950
所以这个算的更新逻辑

1956
01:27:14,640 --> 01:27:15,540
大概就是这样的

1957
01:27:15,690 --> 01:27:16,050
对

1958
01:27:16,080 --> 01:27:17,190
右边儿看最高级

1959
01:27:17,670 --> 01:27:18,540
一边儿看最高级

1960
01:27:19,180 --> 01:27:20,650
而且我们也要看名字

1961
01:27:20,950 --> 01:27:22,120
你不看名字不行

1962
01:27:22,150 --> 01:27:23,080
比如像这种think

1963
01:27:23,560 --> 01:27:25,390
一看到它就知道它是最高级的

1964
01:27:25,660 --> 01:27:27,520
但是我们会看具体逻辑的

1965
01:27:27,970 --> 01:27:28,810
会看具体逻辑的

1966
01:27:29,170 --> 01:27:30,280
还有这个计算

1967
01:27:30,280 --> 01:27:31,870
我不确定大家想不想看

1968
01:27:32,520 --> 01:27:35,700
因为之前这个计算把大家搞得非常的难受

1969
01:27:35,700 --> 01:27:36,720
我们可以试一试

1970
01:27:36,900 --> 01:27:37,560
可以试一试

1971
01:27:38,430 --> 01:27:39,870
计算逻辑是这样的

1972
01:27:40,110 --> 01:27:41,250
它是通过

1973
01:27:41,280 --> 01:27:43,320
因为这条都是通过二进制来表示的

1974
01:27:43,560 --> 01:27:47,490
ER red内部像这种二进制的计算非常多

1975
01:27:47,490 --> 01:27:49,680
就是按位运算非常的多

1976
01:27:50,340 --> 01:27:53,760
那么之前我们就可以挨个挨个来掰扯

1977
01:27:53,910 --> 01:27:55,350
就是第一个有同学说

1978
01:27:55,860 --> 01:27:56,730
同学就想问

1979
01:27:58,020 --> 01:27:59,760
老师你说他是从右到左占的

1980
01:27:59,790 --> 01:28:02,670
那我想知道他到底是怎么样从一个大作战的

1981
01:28:03,060 --> 01:28:03,360
对吧

1982
01:28:03,630 --> 01:28:05,760
他这是怎么他的写法

1983
01:28:05,790 --> 01:28:06,720
这个二进制的写法

1984
01:28:06,720 --> 01:28:07,740
因为不知道吗

1985
01:28:08,070 --> 01:28:09,000
因为你不知道吗

1986
01:28:09,600 --> 01:28:12,900
所以所以他是怎么从一到这站着呢

1987
01:28:12,900 --> 01:28:14,970
其实这块儿是非常精妙的

1988
01:28:14,970 --> 01:28:16,200
其实是很精妙的

1989
01:28:16,380 --> 01:28:18,450
我们来看一下外plans

1990
01:28:18,960 --> 01:28:21,030
Web是指的是当前的遇仙记

1991
01:28:21,510 --> 01:28:23,250
同学们当前要更新哪些印记

1992
01:28:23,250 --> 01:28:25,260
如果你之前一个任务也没有

1993
01:28:25,410 --> 01:28:26,670
那么他肯定全是零

1994
01:28:26,910 --> 01:28:27,780
这个能理解吗

1995
01:28:28,080 --> 01:28:29,460
因为我一个任务都没有吗

1996
01:28:29,460 --> 01:28:30,480
我肯定全是零

1997
01:28:30,660 --> 01:28:31,140
对不对

1998
01:28:31,350 --> 01:28:32,040
因为我

1999
01:28:32,160 --> 01:28:34,470
然后之前的全是零吗

2000
01:28:34,650 --> 01:28:35,970
然后当走到这里的时候

2001
01:28:35,970 --> 01:28:37,200
我现在要占一个位置

2002
01:28:37,680 --> 01:28:38,070
对不对

2003
01:28:38,980 --> 01:28:42,190
那么就是通过这个来通过这个来计算

2004
01:28:42,910 --> 01:28:45,130
这2万他本来全是零

2005
01:28:45,950 --> 01:28:46,400
然后呢

2006
01:28:46,400 --> 01:28:48,290
他给他取了一个飞

2007
01:28:48,710 --> 01:28:48,950
对吧

2008
01:28:48,950 --> 01:28:50,210
飞的话就变成一了

2009
01:28:50,210 --> 01:28:50,630
对不对

2010
01:28:50,870 --> 01:28:51,920
直接就变成了他

2011
01:28:54,320 --> 01:28:58,160
这是二进制的运算这个二进制的运算大家

2012
01:28:59,300 --> 01:28:59,900
看一看吧

2013
01:28:59,930 --> 01:29:00,800
还是有好处的

2014
01:29:02,230 --> 01:29:07,270
他就要做到非非wap烂就变成了这个样子了

2015
01:29:07,930 --> 01:29:09,340
然后input description

2016
01:29:09,670 --> 01:29:10,750
那我们刚刚看过

2017
01:29:10,750 --> 01:29:11,770
我们刚看过他了

2018
01:29:11,770 --> 01:29:13,540
我们看过她长这样

2019
01:29:13,540 --> 01:29:14,530
它是一个常量嘛

2020
01:29:14,620 --> 01:29:15,070
对不对

2021
01:29:16,240 --> 01:29:20,410
他和他他他是进行了一个羽羽的操作

2022
01:29:20,410 --> 01:29:21,370
就是安慰语

2023
01:29:25,220 --> 01:29:27,560
安慰于大家怎么安慰

2024
01:29:28,130 --> 01:29:29,120
安慰语的话

2025
01:29:29,810 --> 01:29:31,760
当两个都是一的时候

2026
01:29:31,760 --> 01:29:33,770
才是一安慰语

2027
01:29:33,980 --> 01:29:35,150
这个应该会吧

2028
01:29:35,600 --> 01:29:36,440
都是一

2029
01:29:40,290 --> 01:29:41,040
31

2030
01:29:45,080 --> 01:29:46,640
只要有一个是零的话就

2031
01:29:47,670 --> 01:29:48,450
就不是一了

2032
01:29:48,720 --> 01:29:51,060
所以所以他这儿

2033
01:29:51,600 --> 01:29:52,470
通过

2034
01:29:53,560 --> 01:29:54,280
这个

2035
01:29:55,350 --> 01:29:55,950
嗯

2036
01:29:57,310 --> 01:29:59,890
非web烂和这个input input re

2037
01:30:00,490 --> 01:30:02,740
那么它们两个进行一个安慰语之后

2038
01:30:02,740 --> 01:30:04,420
他只会得到这两个词

2039
01:30:04,420 --> 01:30:04,810
对不对

2040
01:30:05,440 --> 01:30:06,700
只有这两个还是一

2041
01:30:06,760 --> 01:30:09,610
也就是说他得到了最后这个结果还是两个一

2042
01:30:10,580 --> 01:30:11,510
就是这两个一

2043
01:30:11,690 --> 01:30:13,310
然后再通过这个PK

2044
01:30:15,210 --> 01:30:16,260
我直接把它拷过来

2045
01:30:16,470 --> 01:30:20,040
我先把它拷过来批克every难在这里

2046
01:30:20,250 --> 01:30:20,880
在下面

2047
01:30:21,560 --> 01:30:23,600
最后他会他会通过他

2048
01:30:24,830 --> 01:30:25,760
通过这个方法

2049
01:30:26,710 --> 01:30:28,480
也就是说我们本来是这个值

2050
01:30:28,900 --> 01:30:32,110
那么它能通过烂安富烂

2051
01:30:32,860 --> 01:30:33,790
最后得到的

2052
01:30:33,790 --> 01:30:36,490
就最后能够拿到这个这个位置

2053
01:30:36,610 --> 01:30:38,230
这就是稍微比较复杂一点

2054
01:30:38,260 --> 01:30:39,550
所以我说非常精妙

2055
01:30:39,910 --> 01:30:41,080
他拿到这个结果

2056
01:30:41,440 --> 01:30:42,490
烂我们肯定知道

2057
01:30:42,490 --> 01:30:43,660
那么富烂是什么呢

2058
01:30:44,050 --> 01:30:47,650
赋滥这要涉及到一个原码和原码

2059
01:30:47,650 --> 01:30:49,360
反码和补码的一个关系

2060
01:30:49,880 --> 01:30:51,860
源码就是这个Lam

2061
01:30:51,920 --> 01:30:52,820
这就是她的

2062
01:30:53,770 --> 01:30:55,210
他的那个烂赴烂

2063
01:30:55,210 --> 01:30:56,080
它的源码是

2064
01:30:56,950 --> 01:30:59,680
驸马赋值就是在第一个位置

2065
01:31:00,440 --> 01:31:03,140
标致的是他的那个到底是正数还是负数

2066
01:31:03,320 --> 01:31:04,760
所以因为他是负的

2067
01:31:04,790 --> 01:31:05,930
所以他就变成了一

2068
01:31:06,140 --> 01:31:07,100
这个是它的源码

2069
01:31:07,130 --> 01:31:09,530
这是腐烂的源码儿

2070
01:31:10,520 --> 01:31:13,580
它的源码在计算的时候还要变成他的补码

2071
01:31:13,760 --> 01:31:15,050
然后原码的反码呢

2072
01:31:15,050 --> 01:31:15,770
自然就是

2073
01:31:16,740 --> 01:31:19,770
把零变一变零补满的话要加衣

2074
01:31:20,430 --> 01:31:21,990
本来就是这个是砝码

2075
01:31:22,200 --> 01:31:26,040
砝码再加一一加一变成000

2076
01:31:26,250 --> 01:31:27,270
这个一加一变零

2077
01:31:27,630 --> 01:31:29,700
然后又进位加1000

2078
01:31:29,730 --> 01:31:32,430
所以这几个就全变零了

2079
01:31:32,460 --> 01:31:34,650
而这里我们想要的这个值变成了一

2080
01:31:34,800 --> 01:31:35,910
所以他娶到了

2081
01:31:36,420 --> 01:31:38,040
他娶到了我们想要的这个结果

2082
01:31:38,220 --> 01:31:39,180
这大家能理解吗

2083
01:31:39,900 --> 01:31:40,680
大家能理解吗

2084
01:31:49,110 --> 01:31:49,920
好的

2085
01:31:49,920 --> 01:31:51,510
同学们理解能力很强

2086
01:31:51,510 --> 01:31:53,280
我上次讲这把他都讲蒙了

2087
01:31:55,520 --> 01:31:56,930
大家理解能力非常棒

2088
01:31:57,800 --> 01:31:58,340
棒棒的

2089
01:31:59,240 --> 01:32:01,580
所以他就拿到了通过他的

2090
01:32:02,880 --> 01:32:05,970
烂和他和他的那个反码

2091
01:32:06,000 --> 01:32:13,620
和他的那个反码的一个与他直接就从从倒着倒着往前就得到了那个一的这个位置

2092
01:32:14,010 --> 01:32:15,000
得到这个一的位置

2093
01:32:15,000 --> 01:32:19,920
所以他首先所以他第一次那么他就拿到了

2094
01:32:19,980 --> 01:32:22,020
他想要拿到从后往前的这个位置

2095
01:32:22,050 --> 01:32:22,710
他拿到了

2096
01:32:23,370 --> 01:32:24,540
然后第二个

2097
01:32:24,570 --> 01:32:25,770
假如第二个更新来了

2098
01:32:25,800 --> 01:32:27,060
我们现在已经有一个一了

2099
01:32:27,060 --> 01:32:27,390
对不对

2100
01:32:27,420 --> 01:32:28,350
现在已经有一了

2101
01:32:29,690 --> 01:32:30,320
第二次更新

2102
01:32:30,320 --> 01:32:31,280
现在已经有一了

2103
01:32:31,700 --> 01:32:35,870
那么他的富烂就变成这是不是变成

2104
01:32:35,870 --> 01:32:37,580
写错了这个一

2105
01:32:41,490 --> 01:32:42,270
然后他到

2106
01:32:42,920 --> 01:32:45,140
波浪线这个直接取砝码

2107
01:32:45,350 --> 01:32:45,980
这是什么

2108
01:32:46,940 --> 01:32:48,200
这就变成零了是不是

2109
01:32:48,710 --> 01:32:50,570
然后雨的时候

2110
01:32:50,630 --> 01:32:51,500
大家看鱼的时候

2111
01:32:51,500 --> 01:32:54,320
他就只他就把之前已经占据的那一位

2112
01:32:54,320 --> 01:32:55,460
他就已经过滤掉了

2113
01:32:56,120 --> 01:32:57,440
然后再通过刚刚那个流程

2114
01:32:57,440 --> 01:32:58,970
他就又会去到这个位置

2115
01:32:59,120 --> 01:33:01,520
因为他现在在和他对比的时候

2116
01:33:01,730 --> 01:33:02,690
它是不是就变

2117
01:33:03,470 --> 01:33:05,240
它是不是就变成了这个啦

2118
01:33:05,990 --> 01:33:09,830
是不是就变成这个这个再拿下来做处理

2119
01:33:11,910 --> 01:33:12,960
拿下来做处理

2120
01:33:13,170 --> 01:33:15,330
那么他最终还是能找到这个位置

2121
01:33:16,040 --> 01:33:18,230
所以这个就是他出

2122
01:33:18,290 --> 01:33:20,510
你看他其实写法其实写的非常简单

2123
01:33:21,530 --> 01:33:22,550
一个

2124
01:33:26,820 --> 01:33:27,120
对

2125
01:33:27,480 --> 01:33:28,710
确实是写得很精妙

2126
01:33:28,950 --> 01:33:30,840
你如果不仔细的去思考的话

2127
01:33:31,290 --> 01:33:32,580
你可能看不懂这段代码

2128
01:33:32,580 --> 01:33:33,000
主要是

2129
01:33:34,110 --> 01:33:34,470
对吧

2130
01:33:34,500 --> 01:33:36,240
你如果不仔细的去思考

2131
01:33:36,270 --> 01:33:41,400
然后仔仔细细的把他的把他的原码反码补码给计算一遍的话

2132
01:33:42,020 --> 01:33:44,030
你可能看不懂这段代码

2133
01:33:44,030 --> 01:33:45,650
就是不知道还是不知道为什么

2134
01:33:45,650 --> 01:33:48,290
就之前有同学就很看不懂这个代码

2135
01:33:48,290 --> 01:33:52,160
就是原因就是他知道我讲的是从后面往前找

2136
01:33:52,490 --> 01:33:55,910
但是为什么这种代码就能够实现从后面往前找

2137
01:33:56,440 --> 01:33:56,980
不明白

2138
01:33:57,820 --> 01:33:59,410
这就是这张代码的精妙之处

2139
01:33:59,410 --> 01:34:00,340
实际上非常

2140
01:34:00,520 --> 01:34:01,960
实际上他写的非常简单

2141
01:34:01,960 --> 01:34:03,190
几几下就写完了

2142
01:34:04,850 --> 01:34:08,450
这这一行这一行写完了对吧

2143
01:34:08,750 --> 01:34:10,280
如果说后面大家

2144
01:34:10,990 --> 01:34:12,010
有类似这种

2145
01:34:12,660 --> 01:34:13,980
想也想这么处理吧

2146
01:34:13,980 --> 01:34:19,770
其实black一发你就发现你只需要两行代码就实现了这个功能非常强非常强

2147
01:34:19,770 --> 01:34:21,660
而且安慰安慰运算的话

2148
01:34:21,660 --> 01:34:23,340
它的性能的话也是非常好的

2149
01:34:24,760 --> 01:34:25,420
非常好的

2150
01:34:26,310 --> 01:34:27,210
这就是

2151
01:34:28,320 --> 01:34:28,950
赖斯

2152
01:34:29,190 --> 01:34:30,150
这样差不多了

2153
01:34:30,960 --> 01:34:32,280
那次大概就差不多了

2154
01:34:33,140 --> 01:34:33,350
好

2155
01:34:33,350 --> 01:34:35,030
那我们再来回顾一下

2156
01:34:35,330 --> 01:34:37,640
当然还没有讲完

2157
01:34:37,640 --> 01:34:39,710
再来回顾一下我们的react时期

2158
01:34:39,800 --> 01:34:41,870
他通过lance扩展了expression time

2159
01:34:41,900 --> 01:34:43,010
相当于是扩展了吗

2160
01:34:43,280 --> 01:34:45,410
因为expression time他满足不了

2161
01:34:45,940 --> 01:34:49,150
我们的内部生存在的L任务

2162
01:34:49,390 --> 01:34:50,200
什么任务

2163
01:34:50,200 --> 01:34:52,240
就是有suspense机制相关的任务

2164
01:34:53,080 --> 01:34:53,680
因此

2165
01:34:54,010 --> 01:34:58,780
它不能够有效的区分高于县级IO任务和低线级的CPU任务之间的组织关系

2166
01:34:59,020 --> 01:35:00,160
所以他必须

2167
01:35:00,830 --> 01:35:01,550
他通过

2168
01:35:02,870 --> 01:35:03,590
来解决

2169
01:35:03,590 --> 01:35:05,330
就是可以同时发起多个任务的

2170
01:35:05,480 --> 01:35:06,710
可以同时更新

2171
01:35:06,770 --> 01:35:07,460
不是同时发起

2172
01:35:07,460 --> 01:35:07,940
我说错了

2173
01:35:08,240 --> 01:35:11,180
同时更新多个任务的一种机制就是nice

2174
01:35:11,570 --> 01:35:14,180
所以把之前的expression给淘汰了

2175
01:35:16,170 --> 01:35:18,570
因此如果大家看市面上一些文章

2176
01:35:18,570 --> 01:35:20,370
有的是expression time

2177
01:35:20,580 --> 01:35:21,450
有的是lance

2178
01:35:21,870 --> 01:35:22,350
不要怀疑

2179
01:35:22,350 --> 01:35:23,790
他们只是版本不同而已

2180
01:35:23,820 --> 01:35:24,840
他们只是版本不同而已

2181
01:35:24,960 --> 01:35:27,240
ER rand毫无疑问是更加先进的

2182
01:35:29,240 --> 01:35:29,600
对

2183
01:35:29,660 --> 01:35:31,130
毫无疑问是更加先进的

2184
01:35:33,070 --> 01:35:34,390
这就是rock时期

2185
01:35:34,420 --> 01:35:36,190
就是整体的架构的演进

2186
01:35:36,460 --> 01:35:38,860
我们可以就差不多演进到这里了

2187
01:35:39,470 --> 01:35:39,680
对

2188
01:35:39,680 --> 01:35:41,360
眼睛在这里就是fiber价格

2189
01:35:41,390 --> 01:35:43,580
我们还是说fiber价格

2190
01:35:43,580 --> 01:35:44,210
它多了一

2191
01:35:44,240 --> 01:35:46,760
她比Rose的食物多了一个东西

2192
01:35:47,060 --> 01:35:47,930
就是schedule

2193
01:35:47,930 --> 01:35:49,190
这个过程叫调度器

2194
01:35:49,460 --> 01:35:51,260
调度器调度哪些任务

2195
01:35:51,260 --> 01:35:53,090
再换掉的哪些任务

2196
01:35:53,120 --> 01:35:57,200
然后可以进行接下接下来的更新

2197
01:35:57,470 --> 01:35:59,420
这么判断优先级

2198
01:35:59,420 --> 01:36:01,190
那么都是在调度器中间完整的

2199
01:36:01,310 --> 01:36:03,200
今天我们会把调度器讲话

2200
01:36:04,330 --> 01:36:04,630
OK

2201
01:36:04,630 --> 01:36:08,260
大家一口气讲了一个半小时

2202
01:36:08,530 --> 01:36:10,090
大家先休息五分钟吧

2203
01:36:10,090 --> 01:36:11,770
这次休息五分钟

2204
01:36:11,770 --> 01:36:12,280
喝点水

2205
01:36:13,170 --> 01:36:14,760
然后快速把它讲完了

2206
01:36:22,840 --> 01:36:23,110
老师

2207
01:36:23,110 --> 01:36:24,970
我明白了那优先级对比

2208
01:36:24,970 --> 01:36:28,300
但是还是没明白怎么解决express的那个DEMO的问题

2209
01:36:41,040 --> 01:36:42,060
嗯

2210
01:36:43,980 --> 01:36:44,640
怎么说呢

2211
01:36:46,200 --> 01:36:46,680
嗯

2212
01:36:47,630 --> 01:36:49,310
首先首先那个DEMO

2213
01:36:49,820 --> 01:36:52,250
所以那个DEMO如果你升级了之后

2214
01:36:52,250 --> 01:36:54,020
它实际上不需要你改

2215
01:36:54,350 --> 01:36:55,430
其实他不需要你改

2216
01:36:56,140 --> 01:36:58,870
这个问题的话是需要rack自己来

2217
01:36:58,900 --> 01:37:01,060
他是通过REACT17

2218
01:37:01,630 --> 01:37:04,270
他会他内部他肯定自己自己来做

2219
01:37:04,270 --> 01:37:05,950
自己来自己来做

2220
01:37:06,100 --> 01:37:06,580
然后

2221
01:37:07,280 --> 01:37:08,270
解决这个问题的话

2222
01:37:08,270 --> 01:37:10,460
也会逻辑其实就是

2223
01:37:11,570 --> 01:37:12,410
逻辑是什么呢

2224
01:37:12,680 --> 01:37:15,920
他在处理那个问题之所以出现的原因吧

2225
01:37:15,980 --> 01:37:17,390
这个问题只出现的原因

2226
01:37:17,900 --> 01:37:18,710
刚刚也讲了

2227
01:37:18,710 --> 01:37:19,190
是

2228
01:37:20,420 --> 01:37:23,060
是4S的那个任务

2229
01:37:23,180 --> 01:37:23,540
对吧

2230
01:37:24,020 --> 01:37:27,800
S的那个任务因为一直处在那个进程当中

2231
01:37:28,500 --> 01:37:36,360
然后你的那个system out不是他妈set interval所发行的任务优先级较低

2232
01:37:36,360 --> 01:37:37,470
就把他给阻塞了

2233
01:37:37,590 --> 01:37:38,940
这个是他出现的原因

2234
01:37:39,090 --> 01:37:39,450
对不对

2235
01:37:40,080 --> 01:37:41,100
这是它出现的原因

2236
01:37:41,250 --> 01:37:42,720
但其实并不是

2237
01:37:45,450 --> 01:37:48,540
但其实并不是他完全没有资源去做这样一件事情

2238
01:37:48,540 --> 01:37:50,100
只是rap的内部

2239
01:37:50,340 --> 01:37:55,110
因为她有高纤高优先级的任务和和低优先级任务

2240
01:37:55,110 --> 01:38:00,210
他们的这个express的对比就会导致就是那个并不是卡死了

2241
01:38:00,360 --> 01:38:02,400
同学们必须要这么理解就是

2242
01:38:03,340 --> 01:38:04,870
浏览器其实没有卡死

2243
01:38:04,870 --> 01:38:06,220
但是感觉像是卡死了

2244
01:38:07,160 --> 01:38:07,970
懂这个意思吗

2245
01:38:08,480 --> 01:38:13,610
因为因为你的那个的信息任务一直通过expression time一直轮不到他执行

2246
01:38:14,340 --> 01:38:15,150
轮不到它

2247
01:38:15,450 --> 01:38:18,030
因为我们的高级任务还在执行中呢

2248
01:38:18,360 --> 01:38:19,410
轮不到他执行

2249
01:38:19,830 --> 01:38:21,390
所以看起来像卡死

2250
01:38:21,390 --> 01:38:22,950
但是并不是我们正常的

2251
01:38:22,950 --> 01:38:26,940
就是我们结实主主主线程一直在执行

2252
01:38:26,940 --> 01:38:28,710
导致导致没有

2253
01:38:29,340 --> 01:38:32,700
就导致就是后续完全完全执行不了那种情况

2254
01:38:32,940 --> 01:38:34,170
他其实并没有卡死

2255
01:38:36,040 --> 01:38:37,750
而只是看起来主持

2256
01:38:37,930 --> 01:38:39,190
看起来用户主色

2257
01:38:39,610 --> 01:38:40,300
因为什么呢

2258
01:38:40,300 --> 01:38:43,480
因为我们刚刚讲到他通过express来对比吗

2259
01:38:44,080 --> 01:38:50,020
而我们的的县级的express就有在高度县级任务执行完之前

2260
01:38:50,020 --> 01:38:51,190
他就永远执行不了

2261
01:38:53,140 --> 01:38:54,100
他就执行不了

2262
01:38:54,780 --> 01:38:56,850
但是我们浏览器实际上还是有资源的

2263
01:38:57,450 --> 01:38:59,670
所以如果通过lance的话呢

2264
01:38:59,700 --> 01:39:02,040
那么他解决方案就非常简单了

2265
01:39:02,250 --> 01:39:03,450
就是你

2266
01:39:04,110 --> 01:39:06,120
高县加IO任务你是一个烂

2267
01:39:06,480 --> 01:39:08,670
那么我的CPU任务再战一个烂

2268
01:39:09,450 --> 01:39:10,950
大家都有美好的未来

2269
01:39:11,640 --> 01:39:11,880
对吧

2270
01:39:11,880 --> 01:39:13,770
我其实那个时候CPU是有任务

2271
01:39:13,920 --> 01:39:16,890
就是我那个时候实际上是有资源的

2272
01:39:16,890 --> 01:39:17,850
那些是有资源的

2273
01:39:18,030 --> 01:39:19,050
他是可以执行的

2274
01:39:19,290 --> 01:39:20,520
它是可以执行其他任务的

2275
01:39:20,910 --> 01:39:22,380
并不是真正的死掉

2276
01:39:24,960 --> 01:39:25,680
他只要把它

2277
01:39:25,680 --> 01:39:28,350
只要没把他给这个对比

2278
01:39:28,470 --> 01:39:29,670
只要能够通过

2279
01:39:29,700 --> 01:39:31,470
那么我们的那个任务就是可以执行的

2280
01:39:32,220 --> 01:39:34,350
所以同学可能有的时候

2281
01:39:35,560 --> 01:39:39,520
可能可能那有点迷惑的就是你以为他浏览器这个真的死掉了

2282
01:39:39,550 --> 01:39:40,630
那肯定没办法

2283
01:39:41,650 --> 01:39:43,060
如果浏览器真的被你给

2284
01:39:43,300 --> 01:39:44,320
比如一个结石

2285
01:39:44,830 --> 01:39:45,850
你的结石一个函数

2286
01:39:45,850 --> 01:39:47,380
你真的要执行一分钟

2287
01:39:49,060 --> 01:39:50,230
那就真的没办法

2288
01:39:50,230 --> 01:39:51,340
那确实解决不了

2289
01:39:52,270 --> 01:39:56,230
但实际上浏览器那个时候还是有还还是有资源的

2290
01:39:56,350 --> 01:39:57,340
他只是轮不到他

2291
01:39:58,660 --> 01:39:59,890
所以看起来像是死了

2292
01:39:59,890 --> 01:40:00,790
实际上没有死

2293
01:40:24,240 --> 01:40:26,520
我发现群里有两个刘洋同学是吧

2294
01:40:33,590 --> 01:40:34,430
你们见过面吗

2295
01:40:34,430 --> 01:40:35,840
有线下课吗这次

2296
01:40:46,220 --> 01:40:48,260
我那期的时候也有两个

2297
01:40:48,530 --> 01:40:49,400
也有两个

2298
01:40:50,440 --> 01:40:51,850
男刘洋给刘洋

2299
01:40:52,580 --> 01:40:53,900
有两个聪明的同学

2300
01:40:54,910 --> 01:40:55,930
都是现实

2301
01:40:58,150 --> 01:40:58,450
好的

2302
01:40:59,120 --> 01:41:00,350
这些学员还挺多的

2303
01:41:01,010 --> 01:41:02,600
所以排几点都是专业点吗

2304
01:41:02,750 --> 01:41:03,170
是的

2305
01:41:05,540 --> 01:41:07,430
南流北行

2306
01:41:07,760 --> 01:41:08,510
我们开始了

2307
01:41:08,510 --> 01:41:11,810
继续开始不不过度耽搁大家时间

2308
01:41:12,770 --> 01:41:14,330
然后我们就要三个模块

2309
01:41:14,330 --> 01:41:17,090
我们我们会搭个字看一下

2310
01:41:17,980 --> 01:41:19,540
Schedule or是调度器

2311
01:41:19,570 --> 01:41:20,920
它的主要任务是什么

2312
01:41:21,310 --> 01:41:22,750
就是调度任务的优先级

2313
01:41:22,750 --> 01:41:24,790
控制哪些任务优先进入recovery

2314
01:41:25,720 --> 01:41:27,940
那么接下来有一个叫做re considered

2315
01:41:27,940 --> 01:41:28,690
他是干什么的

2316
01:41:29,020 --> 01:41:30,280
负责构建February

2317
01:41:30,280 --> 01:41:31,420
找出变化的组件

2318
01:41:31,750 --> 01:41:33,250
标注组建的变化

2319
01:41:33,790 --> 01:41:36,400
也就是我们必须要先调度哪个任务

2320
01:41:36,880 --> 01:41:38,860
然后再具体去执行一个任务

2321
01:41:38,860 --> 01:41:39,880
就是构建February

2322
01:41:40,030 --> 01:41:41,950
抓住主线到最后

2323
01:41:43,990 --> 01:41:44,500
这不完了

2324
01:41:44,500 --> 01:41:45,790
之后还有一个render阶段

2325
01:41:45,790 --> 01:41:47,470
也可以称之为康威的阶段

2326
01:41:50,040 --> 01:41:52,260
负责将变化的组建渲染到页面上

2327
01:41:52,290 --> 01:41:54,120
其实整体来说

2328
01:41:54,820 --> 01:41:57,250
整体的架构分为就分为这三个大的

2329
01:41:57,250 --> 01:41:58,420
三个大的模块

2330
01:41:58,570 --> 01:42:00,280
你可以把它分成三个大的模块

2331
01:42:00,820 --> 01:42:01,810
我们先来看第一个

2332
01:42:02,020 --> 01:42:02,950
调动这么多县级了

2333
01:42:02,950 --> 01:42:04,630
我们就看这个优先级就好了

2334
01:42:05,450 --> 01:42:08,330
这个已经前面已经搬到前面给大家讲过了

2335
01:42:08,330 --> 01:42:08,870
就不讲了

2336
01:42:09,140 --> 01:42:11,600
我们先看一下大致的调度逻辑

2337
01:42:11,990 --> 01:42:13,040
要看大致的调度逻辑

2338
01:42:13,040 --> 01:42:16,490
我们先来看一下我们的一个final的一个节点

2339
01:42:17,420 --> 01:42:18,440
散落的节点

2340
01:42:19,120 --> 01:42:19,630
嗯

2341
01:42:20,890 --> 01:42:22,330
有同学刚刚已经问了

2342
01:42:22,330 --> 01:42:25,180
我们现在正式来看一下每一个

2343
01:42:25,300 --> 01:42:26,800
首先在rock里面

2344
01:42:27,160 --> 01:42:29,890
在rock里面它每一个节点都是一个final的

2345
01:42:29,920 --> 01:42:31,210
都会把它作为一个L的

2346
01:42:32,410 --> 01:42:35,170
它既可以是一个真实的DOM节点

2347
01:42:35,320 --> 01:42:36,730
它既可以标注一个真实的节点

2348
01:42:36,730 --> 01:42:37,960
也可以标注我们的主见

2349
01:42:38,230 --> 01:42:38,980
都没有问题

2350
01:42:39,520 --> 01:42:40,750
都是犯了的呢

2351
01:42:40,750 --> 01:42:43,000
我们看一下它有很多的属性

2352
01:42:43,660 --> 01:42:45,340
大家可以看到它的属性非常的多

2353
01:42:45,520 --> 01:42:47,860
但是有几个是比较重要的

2354
01:42:47,860 --> 01:42:51,850
我们可以比如tag tag标志是对应的属性的类型

2355
01:42:52,120 --> 01:42:55,120
你到底是比如我们组建可能是function的

2356
01:42:55,120 --> 01:42:58,840
可能是class是host the fragment portal等等

2357
01:43:00,050 --> 01:43:02,660
这些都是就是rock的好几种类型

2358
01:43:03,110 --> 01:43:05,840
以及你可能就是真真正的一个当元素

2359
01:43:06,230 --> 01:43:08,210
一个档一个档真真实的DOM节点

2360
01:43:08,390 --> 01:43:10,970
那么同时通过这个tag来标志

2361
01:43:11,360 --> 01:43:12,950
为什么要标注这个榻呢

2362
01:43:13,600 --> 01:43:17,440
最大的原因是不同的节点他处理的逻辑是不一样的

2363
01:43:17,680 --> 01:43:19,000
所以他要标记一下

2364
01:43:19,790 --> 01:43:22,790
K这个K应该大家都听到过

2365
01:43:22,820 --> 01:43:23,600
都听过K

2366
01:43:23,600 --> 01:43:26,030
那肯定是标准这个节点的微信

2367
01:43:26,680 --> 01:43:27,670
那么通过这个case

2368
01:43:27,670 --> 01:43:29,290
他实际上是非常有作用的

2369
01:43:29,560 --> 01:43:31,660
后面我们看在dif那一节

2370
01:43:31,900 --> 01:43:35,200
我们可以看到通过K值他们来做的事

2371
01:43:35,200 --> 01:43:36,580
会通过case来做diff

2372
01:43:36,640 --> 01:43:38,920
因此我们一般上来通过

2373
01:43:39,700 --> 01:43:41,440
一般上一般来说

2374
01:43:41,470 --> 01:43:43,540
如果我们要

2375
01:43:44,020 --> 01:43:45,940
对于我们我们的那个数组吗

2376
01:43:45,940 --> 01:43:47,050
一个县的一个数组

2377
01:43:47,440 --> 01:43:49,480
那么都会给他打上一个标志性的K

2378
01:43:49,660 --> 01:43:49,990
对不对

2379
01:43:49,990 --> 01:43:58,210
打一个标志性的K的原因就是他有可能会导致有可能会复用那个组建这个case必须要全剧唯一

2380
01:43:58,800 --> 01:44:00,510
必须要全剧全剧唯一

2381
01:44:01,410 --> 01:44:02,130
然后这个

2382
01:44:04,670 --> 01:44:06,410
Enter type edit APP

2383
01:44:06,590 --> 01:44:09,020
它指的就是你的这个元素的类型

2384
01:44:09,830 --> 01:44:10,880
这还有个tap

2385
01:44:11,060 --> 01:44:14,060
这个tap可能更加的形象一些

2386
01:44:14,420 --> 01:44:16,640
他就是对于function component来说

2387
01:44:16,640 --> 01:44:20,210
子函数对class component和子class

2388
01:44:20,880 --> 01:44:22,710
对host cover的指弹节点

2389
01:44:22,710 --> 01:44:24,330
它指的东西都不一样

2390
01:44:24,930 --> 01:44:29,940
然后这个stayed not后面其实我们会详细介绍这个属性

2391
01:44:29,940 --> 01:44:34,230
后面这几个属性都会详细介绍斯诺的他实际上

2392
01:44:34,230 --> 01:44:36,720
它会储存我们对应真实的这种节点

2393
01:44:36,750 --> 01:44:39,270
实际上假如我们这个是个低微

2394
01:44:39,480 --> 01:44:41,280
那么他会得到

2395
01:44:41,280 --> 01:44:46,110
他最后会渲染会只会计算好它是一个div的东西

2396
01:44:46,520 --> 01:44:47,480
然后把它存到这儿

2397
01:44:47,630 --> 01:44:48,380
暂时先不动

2398
01:44:48,470 --> 01:44:49,610
就是存储在这里

2399
01:44:50,570 --> 01:44:51,680
存储真实阶段

2400
01:44:51,680 --> 01:44:53,840
它叫做斯诺的这么个属性

2401
01:44:54,110 --> 01:44:55,520
当然这是为了优化考虑

2402
01:44:55,790 --> 01:44:56,660
后面会讲到

2403
01:44:57,080 --> 01:44:59,150
然后这就这三个属性

2404
01:44:59,390 --> 01:45:00,650
我们刚刚已经看到过了

2405
01:45:01,540 --> 01:45:02,320
非常重要

2406
01:45:02,940 --> 01:45:04,410
它就是用来连接其他cyber

2407
01:45:04,410 --> 01:45:06,240
形成cyber数February

2408
01:45:07,020 --> 01:45:07,980
通过这三个节点

2409
01:45:07,980 --> 01:45:10,140
我们就我们的整个发飙的

2410
01:45:10,140 --> 01:45:12,090
看起来就像一个真正的数一样

2411
01:45:12,120 --> 01:45:13,710
但实际上又不一样

2412
01:45:13,740 --> 01:45:15,630
因为它完全是属于列表结构

2413
01:45:16,080 --> 01:45:17,190
完全属于列表结构

2414
01:45:17,670 --> 01:45:21,000
我有每一个tab键都有这三条

2415
01:45:21,300 --> 01:45:23,610
这三个分别指向三个不同的

2416
01:45:24,610 --> 01:45:25,990
一个是父节点

2417
01:45:26,230 --> 01:45:27,250
一个是子节点

2418
01:45:27,550 --> 01:45:29,020
一个是兄弟结点

2419
01:45:29,680 --> 01:45:33,010
然后这样构成一个构成一个完整的一个竖

2420
01:45:33,640 --> 01:45:34,480
一个完整一个数

2421
01:45:34,990 --> 01:45:39,160
那同学有同之前有同学就问这种老师为啥要用

2422
01:45:39,840 --> 01:45:41,010
为啥要用链表

2423
01:45:41,220 --> 01:45:41,460
对啊

2424
01:45:41,460 --> 01:45:42,150
为啥用链表

2425
01:45:42,450 --> 01:45:46,380
链表对比数组来说最大的一个好处是什么呢

2426
01:45:46,920 --> 01:45:49,410
最大的一个好处是可以很轻松的被打断

2427
01:45:50,110 --> 01:45:53,020
比如说我一个执行到了翘的某个地

2428
01:45:53,020 --> 01:45:54,850
翘的节点现在我被打断了

2429
01:45:55,000 --> 01:45:57,940
那我只需要把翘的这个节点复制给一个属性

2430
01:45:58,690 --> 01:45:59,320
就可以了

2431
01:45:59,500 --> 01:46:01,450
下一次我在恢复的时候

2432
01:46:01,540 --> 01:46:03,640
那么我可以直接通拿到那个属性

2433
01:46:03,640 --> 01:46:05,290
然后就恢复到之前的那个节点

2434
01:46:05,710 --> 01:46:06,010
对

2435
01:46:07,280 --> 01:46:07,730
同学说

2436
01:46:07,730 --> 01:46:08,060
没错

2437
01:46:08,060 --> 01:46:08,750
可以这样提

2438
01:46:10,280 --> 01:46:11,750
因此它是因此

2439
01:46:12,170 --> 01:46:14,900
因此wrecked实际上REACT16之前

2440
01:46:14,900 --> 01:46:15,980
他并不是链表

2441
01:46:16,690 --> 01:46:18,400
就是因为要做这个范儿价格

2442
01:46:18,400 --> 01:46:21,070
然后他连整个的结构都给调了

2443
01:46:21,520 --> 01:46:22,900
结构都给调成列表了

2444
01:46:23,520 --> 01:46:26,430
而且我们它它不光是整个发展趋势列表

2445
01:46:26,430 --> 01:46:28,110
它里面像副作用

2446
01:46:28,110 --> 01:46:28,590
像什么

2447
01:46:28,590 --> 01:46:31,410
它都全部都是用列表的形式非常统一

2448
01:46:31,830 --> 01:46:36,570
所以所以链表结构大家也可以了解一下

2449
01:46:36,600 --> 01:46:38,610
反正就是一条一条的链条嘛

2450
01:46:38,640 --> 01:46:38,940
对吧

2451
01:46:39,270 --> 01:46:40,350
还是比较弄得好

2452
01:46:40,350 --> 01:46:45,870
弄得然后pending props member of props props相关的一个是新的

2453
01:46:45,870 --> 01:46:46,620
一个是老的

2454
01:46:47,200 --> 01:46:47,470
对吧

2455
01:46:47,830 --> 01:46:50,320
然后是memories date这个

2456
01:46:50,680 --> 01:46:52,270
这个属性是来锤hooks

2457
01:46:52,690 --> 01:46:53,440
纯hooks

2458
01:46:53,530 --> 01:46:56,530
后面hooks那张我们会讲到

2459
01:46:56,530 --> 01:46:57,700
这个属性比较重要

2460
01:46:57,970 --> 01:46:58,780
叫flex

2461
01:46:58,810 --> 01:47:00,370
之前他叫city if X

2462
01:47:00,670 --> 01:47:01,330
它是什么呢

2463
01:47:01,360 --> 01:47:05,050
他来标记你的跟你的你的这个更新的类型

2464
01:47:05,320 --> 01:47:06,100
就假如

2465
01:47:06,900 --> 01:47:08,130
你的这个节点被删了

2466
01:47:08,550 --> 01:47:09,420
它并不会

2467
01:47:09,780 --> 01:47:11,490
它并不会在re consider哩

2468
01:47:12,370 --> 01:47:13,570
就直接把你给删掉

2469
01:47:13,840 --> 01:47:16,300
他而是先给你标记一个类型

2470
01:47:17,150 --> 01:47:18,080
把这个标记上

2471
01:47:18,500 --> 01:47:19,100
然后呢

2472
01:47:19,250 --> 01:47:22,490
最后从衣橱里到render这个函数

2473
01:47:22,490 --> 01:47:24,170
也是就是这个不是函数

2474
01:47:24,290 --> 01:47:25,430
在render这个阶段

2475
01:47:25,760 --> 01:47:27,830
然后来把你的

2476
01:47:28,480 --> 01:47:30,280
当变化更新到页面上去

2477
01:47:30,880 --> 01:47:32,410
因此他就先打上一个标记

2478
01:47:32,890 --> 01:47:34,330
他为什么不直接更新呢

2479
01:47:34,570 --> 01:47:39,340
原因是因为我们所有的更新其实都是跟当有关的

2480
01:47:39,340 --> 01:47:39,640
对不对

2481
01:47:39,640 --> 01:47:41,950
跟当节点跟档操作是有关的

2482
01:47:42,400 --> 01:47:45,580
你如果一个更新你就立刻把他给

2483
01:47:45,760 --> 01:47:48,430
就是一个更新你就立刻把它给更新的大幕上

2484
01:47:49,000 --> 01:47:50,590
但操作是非常昂贵的

2485
01:47:50,620 --> 01:47:53,020
那么热的性能肯定会急剧的下降

2486
01:47:53,320 --> 01:47:53,740
一直

2487
01:47:54,400 --> 01:47:55,600
他林跃是什么呢

2488
01:47:55,600 --> 01:47:56,230
您阅示

2489
01:47:57,300 --> 01:47:59,220
宁愿是把你给聚合在一起

2490
01:47:59,610 --> 01:48:01,350
最后找一个统一的时机

2491
01:48:01,380 --> 01:48:01,680
对不对

2492
01:48:01,680 --> 01:48:04,650
找一个统一的时机把你一一股脑给处理掉

2493
01:48:05,310 --> 01:48:07,320
因此他在这里的时候

2494
01:48:07,560 --> 01:48:08,760
他在前面部分

2495
01:48:08,910 --> 01:48:10,740
即使是他已经计算好了

2496
01:48:10,770 --> 01:48:13,860
就是当地否这些东西他已经计算好了

2497
01:48:14,160 --> 01:48:15,060
但是他并不动

2498
01:48:15,150 --> 01:48:16,200
它只是给你存着

2499
01:48:16,560 --> 01:48:18,300
包括像咱们这个赛诺

2500
01:48:18,720 --> 01:48:20,880
他的真实的DOM节点都给你算好了

2501
01:48:21,580 --> 01:48:23,890
都给你都给你准备好了

2502
01:48:23,980 --> 01:48:26,530
但是还是不会立刻给他填上去

2503
01:48:26,980 --> 01:48:28,360
而是先存起来

2504
01:48:28,660 --> 01:48:30,130
存起来之后等到

2505
01:48:30,730 --> 01:48:33,520
最后的这个扔扔的阶段的时候

2506
01:48:33,550 --> 01:48:35,470
在一股脑给你弄上去

2507
01:48:37,080 --> 01:48:37,590
对呀

2508
01:48:37,890 --> 01:48:39,840
人家当中对他肯定是

2509
01:48:40,230 --> 01:48:42,150
但是它不是接客的

2510
01:48:42,450 --> 01:48:43,980
肯定不是接口的API

2511
01:48:44,570 --> 01:48:46,520
他就直接利用浏览器原生的API

2512
01:48:46,550 --> 01:48:47,900
比如create element啊

2513
01:48:48,650 --> 01:48:49,040
对吧

2514
01:48:49,130 --> 01:48:49,640
像这种

2515
01:48:53,280 --> 01:48:57,090
最终真实操作当肯定都是通过浏览器的API吗

2516
01:48:58,530 --> 01:49:02,190
这个less对我们找到了less这个蓝色

2517
01:49:02,550 --> 01:49:05,940
我刚刚如果大家觉得还想对它有详细的了解的话

2518
01:49:05,940 --> 01:49:07,170
可以看一下这个PR

2519
01:49:07,200 --> 01:49:09,810
下来下我把这个链接分享给文档

2520
01:49:09,810 --> 01:49:10,500
分享给大家

2521
01:49:11,460 --> 01:49:12,540
可以看下这个PR

2522
01:49:12,540 --> 01:49:14,940
这个就是当时lies刚出来的时候

2523
01:49:15,090 --> 01:49:16,860
很多人不知道这个是干什么的

2524
01:49:17,840 --> 01:49:19,130
很多人不知道这是干什么的

2525
01:49:19,190 --> 01:49:22,250
于是哀作者加了一个

2526
01:49:22,760 --> 01:49:24,920
通过一个PR

2527
01:49:24,920 --> 01:49:25,910
一个request

2528
01:49:26,270 --> 01:49:29,750
然后解释向开发者解释了一下这个问题

2529
01:49:30,140 --> 01:49:33,500
以及就是为什么会把它升级成蓝色

2530
01:49:33,710 --> 01:49:35,270
你说现在怎么解决不了的问题

2531
01:49:35,570 --> 01:49:38,480
大家其实这个比我刚刚讲的可能会详细一点点

2532
01:49:38,930 --> 01:49:40,520
英文好的大家可以看一下

2533
01:49:41,240 --> 01:49:41,690
这个呢

2534
01:49:41,690 --> 01:49:42,890
就是我刚刚讲的那个了

2535
01:49:43,310 --> 01:49:45,170
然后这个outlet也比较重要

2536
01:49:45,200 --> 01:49:47,510
他是指向一个叫做work in progress travel的

2537
01:49:48,160 --> 01:49:50,890
纸箱的其实是他上一次构建的一个发布的镜像

2538
01:49:51,640 --> 01:49:52,840
这个也挺重要的

2539
01:49:52,840 --> 01:49:55,360
后面我们会详细的利用的

2540
01:49:56,120 --> 01:50:00,950
我打黄色标记的这个就是我们这次需要大家就是

2541
01:50:00,950 --> 01:50:02,180
稍微眼熟一点的比较

2542
01:50:02,180 --> 01:50:05,420
Said nod returned childs play flex

2543
01:50:06,210 --> 01:50:07,470
Outlet

2544
01:50:07,690 --> 01:50:09,190
Outlet需要大家眼熟一点

2545
01:50:09,190 --> 01:50:12,340
后面因为我们讲整个价格的时候会用到它

2546
01:50:12,490 --> 01:50:13,030
用到它

2547
01:50:14,070 --> 01:50:14,490
好

2548
01:50:14,910 --> 01:50:16,350
这是一个fiber节点

2549
01:50:16,380 --> 01:50:17,190
大概就长这样

2550
01:50:17,550 --> 01:50:20,070
那么fiber节点我们也大概这个属性

2551
01:50:20,520 --> 01:50:22,470
然后我们再来看我们刚刚那幅图

2552
01:50:22,500 --> 01:50:24,300
这个一个分节点

2553
01:50:24,300 --> 01:50:25,500
分节点加起来

2554
01:50:26,420 --> 01:50:28,970
连接起来这就像是一棵树了

2555
01:50:28,970 --> 01:50:29,300
对不对

2556
01:50:29,360 --> 01:50:30,680
像是一颗简单的树了

2557
01:50:31,010 --> 01:50:31,670
这种节点

2558
01:50:31,670 --> 01:50:33,620
因为我们的链表非常容易中断

2559
01:50:33,620 --> 01:50:34,880
所以它是用列表的形式

2560
01:50:35,570 --> 01:50:37,130
它通过跳的对吧

2561
01:50:37,580 --> 01:50:38,600
就这事说不定

2562
01:50:39,180 --> 01:50:41,820
然后瑞特这三个属性值

2563
01:50:41,850 --> 01:50:43,860
然后连成一个完整的一个family tree

2564
01:50:45,670 --> 01:50:47,500
整个发票退大概就长这样

2565
01:50:47,560 --> 01:50:49,750
那我们来看一下大致的调度逻辑

2566
01:50:50,080 --> 01:50:51,760
因为因为这个

2567
01:50:52,340 --> 01:50:54,050
因为它的每一个模块儿

2568
01:50:54,870 --> 01:50:56,310
逻辑都非常的复杂

2569
01:50:56,790 --> 01:50:58,830
之前刚开始讲的时候

2570
01:50:59,340 --> 01:51:01,740
前面的同学就不太能听明白

2571
01:51:02,370 --> 01:51:04,140
所以我整理了一下

2572
01:51:04,140 --> 01:51:06,750
把他们大致的逻辑

2573
01:51:07,820 --> 01:51:08,660
先写在前面

2574
01:51:08,660 --> 01:51:09,710
我们先给他过一遍

2575
01:51:10,100 --> 01:51:11,150
然后下来

2576
01:51:11,150 --> 01:51:14,030
剩下的话我们再来继续来过他这个具体的代码

2577
01:51:14,660 --> 01:51:16,460
具体的代码就是非常的就是方便

2578
01:51:16,460 --> 01:51:17,810
就是逻辑非常清晰

2579
01:51:18,080 --> 01:51:19,730
之前我们直接在代码里跳

2580
01:51:19,760 --> 01:51:21,590
就从这从代码里看

2581
01:51:21,890 --> 01:51:23,900
大家可能会代码里看会比较带感

2582
01:51:23,900 --> 01:51:24,260
对吧

2583
01:51:24,590 --> 01:51:25,130
但是

2584
01:51:25,800 --> 01:51:27,420
之前有同学反映就是什么呢

2585
01:51:27,720 --> 01:51:28,770
跳过来跳过去

2586
01:51:28,800 --> 01:51:31,380
就是经常在各个函数之间进行切换

2587
01:51:31,560 --> 01:51:34,230
那么很多同学就因此而绕晕

2588
01:51:34,500 --> 01:51:35,820
因此然后就被绕晕了

2589
01:51:35,820 --> 01:51:36,600
然后就不行

2590
01:51:37,320 --> 01:51:39,450
所以我们就先把

2591
01:51:41,250 --> 01:51:42,900
大致逻辑给大家整理了出来

2592
01:51:43,290 --> 01:51:43,890
整理了出来

2593
01:51:43,890 --> 01:51:47,070
然后我摘出来了非常关键的代码

2594
01:51:47,370 --> 01:51:48,960
关键代码我都摘出来了

2595
01:51:49,560 --> 01:51:52,950
然后一些一些和这个主流程无关的代码

2596
01:51:52,950 --> 01:51:54,210
我就暂时省略掉

2597
01:51:54,860 --> 01:51:55,550
暂时省略掉

2598
01:51:55,970 --> 01:51:58,910
如果大家以后看就直接看这个源码里边儿

2599
01:51:58,910 --> 01:52:01,040
可能会发现和他并不完全一样

2600
01:52:01,040 --> 01:52:03,830
就是因为有部分的代码是舍弃掉的

2601
01:52:04,310 --> 01:52:05,300
他当然也是有用的

2602
01:52:05,300 --> 01:52:06,650
但是和这个流程无关

2603
01:52:06,800 --> 01:52:08,150
不然的话我们肯定看不完

2604
01:52:09,220 --> 01:52:10,420
对会分享给大家

2605
01:52:12,260 --> 01:52:15,890
所以我们先看一下这个大致的逻辑是这样的

2606
01:52:16,190 --> 01:52:18,800
首先他根据优先级区分是同步和异步

2607
01:52:19,490 --> 01:52:20,720
同步和异步的任务

2608
01:52:21,760 --> 01:52:24,100
我们把一个更新一成为一个任务

2609
01:52:24,100 --> 01:52:25,390
一次更新成为一个任务

2610
01:52:25,720 --> 01:52:27,550
根据县级区分同步和异步的

2611
01:52:28,380 --> 01:52:29,040
同步的

2612
01:52:29,670 --> 01:52:31,860
就立刻同步执行的主线程执行

2613
01:52:32,280 --> 01:52:34,050
大家现在先先跟我过一遍

2614
01:52:35,150 --> 01:52:35,750
有印象

2615
01:52:35,750 --> 01:52:36,200
有印象

2616
01:52:36,200 --> 01:52:37,400
我们待会会讲

2617
01:52:37,400 --> 01:52:38,510
讲完了大家就明白了

2618
01:52:38,930 --> 01:52:41,180
先去区分同步异步同步

2619
01:52:41,880 --> 01:52:43,140
任务立刻同步执行

2620
01:52:43,290 --> 01:52:45,450
他的主线程执行最快渲染出来

2621
01:52:45,540 --> 01:52:47,100
如果是义务的任务

2622
01:52:47,490 --> 01:52:49,080
他就会在红任务里执行

2623
01:52:49,700 --> 01:52:50,840
这还是挺重要的

2624
01:52:51,380 --> 01:52:53,240
儿童什么是同步任务呢

2625
01:52:53,540 --> 01:52:56,330
也就是一开始我给大家讲的render的时候

2626
01:52:57,170 --> 01:52:58,550
当热点render

2627
01:52:58,610 --> 01:53:00,950
因为这个是要最快渲染出来

2628
01:53:00,950 --> 01:53:02,090
因为因为还是白的嘛

2629
01:53:02,360 --> 01:53:03,830
所以它就会走同步任务

2630
01:53:04,010 --> 01:53:05,600
它是会放在on based update

2631
01:53:05,600 --> 01:53:06,440
我们也看过了

2632
01:53:06,920 --> 01:53:09,800
放在on based update这么一个函数列

2633
01:53:10,070 --> 01:53:12,260
然后他会去给他标记一个同步的东西

2634
01:53:12,900 --> 01:53:16,380
那么他最终是在主线程执行的这个就是

2635
01:53:17,270 --> 01:53:17,840
不会等

2636
01:53:17,960 --> 01:53:18,500
不会等

2637
01:53:19,650 --> 01:53:21,630
而且而且有可能是会阻塞

2638
01:53:23,120 --> 01:53:25,130
主线程就是right的render

2639
01:53:25,190 --> 01:53:26,690
他是有可能是会诅咒的

2640
01:53:27,570 --> 01:53:30,330
如果你的你的那个档次非常大的话

2641
01:53:31,240 --> 01:53:32,140
都是非常大的

2642
01:53:32,840 --> 01:53:33,530
他就注册

2643
01:53:34,420 --> 01:53:35,290
这是第一个

2644
01:53:35,440 --> 01:53:36,400
这是第一个步骤

2645
01:53:36,550 --> 01:53:37,930
区分同步、异步

2646
01:53:38,470 --> 01:53:43,150
第二个步骤得到expression expression X等于current和timeout

2647
01:53:44,180 --> 01:53:45,290
计算得到XX

2648
01:53:45,290 --> 01:53:45,860
然后对比

2649
01:53:45,860 --> 01:53:46,970
Start he can to

2650
01:53:47,300 --> 01:53:49,670
将任务又分为及时的和岩石的

2651
01:53:49,940 --> 01:53:51,920
英语的任务他可能是岩石的

2652
01:53:51,920 --> 01:53:52,970
就是啊

2653
01:53:52,970 --> 01:53:54,050
要过一会儿才执行

2654
01:53:54,900 --> 01:53:57,450
有的任务是当前就近调度的

2655
01:53:57,750 --> 01:53:59,040
就是即时和延时

2656
01:53:59,780 --> 01:54:01,190
分为即时任务、岩石任务

2657
01:54:01,640 --> 01:54:03,800
及时任务的话就当即执行调度

2658
01:54:04,070 --> 01:54:07,610
及时任务的话需要等到care的碳大于等于四大灿

2659
01:54:08,280 --> 01:54:09,300
才会自行调座

2660
01:54:10,820 --> 01:54:12,020
只因为有

2661
01:54:12,020 --> 01:54:13,430
既然有GCS的区别

2662
01:54:13,880 --> 01:54:16,040
那么区分它的就是这个沙滩

2663
01:54:16,160 --> 01:54:17,990
沙滩如果是即时任务

2664
01:54:17,990 --> 01:54:19,820
它的start就是等于勘探

2665
01:54:20,600 --> 01:54:21,440
如果是以S任务

2666
01:54:21,440 --> 01:54:23,570
他的是大踏会比特大

2667
01:54:24,270 --> 01:54:25,710
所以他判断通过盼

2668
01:54:25,710 --> 01:54:30,750
Can a current time判断大于等于了沙滩的时候才会执行

2669
01:54:30,750 --> 01:54:31,380
否则就等

2670
01:54:32,700 --> 01:54:35,610
我们每执行一次即时执行即时任务

2671
01:54:35,790 --> 01:54:38,370
就会去判断是否有延时任务

2672
01:54:38,370 --> 01:54:39,720
到了该执行的时候

2673
01:54:39,930 --> 01:54:40,590
如果是

2674
01:54:40,830 --> 01:54:42,420
就把岩石任务相当于

2675
01:54:43,070 --> 01:54:44,000
拿过来执行

2676
01:54:44,730 --> 01:54:44,940
对

2677
01:54:44,940 --> 01:54:46,530
这个是调度逻辑

2678
01:54:46,710 --> 01:54:49,890
然后每一批任务的执行都会在不同的红任务中

2679
01:54:50,130 --> 01:54:53,160
他是不会阻塞用页面用户的交互的

2680
01:54:54,410 --> 01:54:57,050
这个大概

2681
01:54:57,920 --> 01:55:00,740
Stay就是大概这么欺负我们具体来看

2682
01:55:01,560 --> 01:55:02,430
我们继续来看

2683
01:55:03,000 --> 01:55:05,400
这是为了给大家

2684
01:55:05,640 --> 01:55:07,560
给大家一个更清晰的一个东西

2685
01:55:07,920 --> 01:55:10,920
所以我提前在这里写好了一些基本的概念

2686
01:55:11,340 --> 01:55:13,200
基本概念比如这个signal

2687
01:55:13,900 --> 01:55:15,580
他指的是同步的优先级

2688
01:55:15,910 --> 01:55:18,340
这个优先级最高同步处理

2689
01:55:18,400 --> 01:55:20,290
同步处理就think这个think

2690
01:55:20,290 --> 01:55:21,880
那肯定就是think的道理

2691
01:55:22,940 --> 01:55:25,490
这个字段叫做execution context

2692
01:55:25,580 --> 01:55:28,220
因为record这种变得非常的多

2693
01:55:28,730 --> 01:55:29,960
这个我认为是比较重要的

2694
01:55:29,960 --> 01:55:31,610
我认为比较重要的

2695
01:55:32,680 --> 01:55:34,060
所以大拿出来说一下

2696
01:55:34,060 --> 01:55:35,410
大家印象更深刻

2697
01:55:35,920 --> 01:55:37,660
他其实他其实就是什么呢

2698
01:55:37,660 --> 01:55:39,280
他就是来标志

2699
01:55:40,000 --> 01:55:42,880
他就是为了区分你这个任务到底进行到哪儿了

2700
01:55:43,820 --> 01:55:46,400
你的任务到你的任务进行到哪个阶段了

2701
01:55:46,400 --> 01:55:49,070
因为rock的整个处理周期会比会比较长

2702
01:55:49,550 --> 01:55:55,760
而他经常需要同他经常需要来判断这个判断你到底执行到哪一步了

2703
01:55:56,090 --> 01:55:58,190
因为他会涉及到打断的逻辑

2704
01:55:58,700 --> 01:56:01,460
比如我一个C任务现在要执行

2705
01:56:01,850 --> 01:56:03,440
那么我一个a任务进来了

2706
01:56:03,560 --> 01:56:06,800
那么它要判断你前面那个任务执行到哪个阶段了

2707
01:56:06,920 --> 01:56:08,450
如果他已经执行到

2708
01:56:08,570 --> 01:56:10,580
假如他已经执行了后面这个render了

2709
01:56:11,740 --> 01:56:14,020
就这个render这个阶段就已经马上要渲染了

2710
01:56:14,380 --> 01:56:14,890
那么

2711
01:56:16,290 --> 01:56:17,370
那么我就不打算了

2712
01:56:17,640 --> 01:56:19,440
因为他已经已经要渲染了

2713
01:56:19,440 --> 01:56:20,670
这个时候就不好打了

2714
01:56:20,850 --> 01:56:21,990
如果他还在之前

2715
01:56:21,990 --> 01:56:22,710
比如还在

2716
01:56:23,430 --> 01:56:24,900
就是还在进行当地府

2717
01:56:25,140 --> 01:56:26,610
那么实际上是可以达到的

2718
01:56:27,150 --> 01:56:30,210
因此这个execution context

2719
01:56:31,550 --> 01:56:33,200
这个东西可以拿来判断

2720
01:56:33,200 --> 01:56:35,750
非常多的东西就在判断到哪个阶段

2721
01:56:36,050 --> 01:56:36,740
到哪个阶段

2722
01:56:36,740 --> 01:56:37,910
而且它还可以有多个

2723
01:56:38,650 --> 01:56:40,540
因此他可能存在多种

2724
01:56:41,110 --> 01:56:42,700
可能存在多种有同学

2725
01:56:43,410 --> 01:56:44,250
就很迷糊

2726
01:56:44,850 --> 01:56:46,290
这个怎么可以存在多种

2727
01:56:46,290 --> 01:56:49,350
比如说一个函数里还能同时存在两个函数猪吗

2728
01:56:49,710 --> 01:56:50,160
是这样

2729
01:56:50,550 --> 01:56:52,320
假如它存在一个函数a对吧

2730
01:56:52,500 --> 01:56:53,250
在存在一个

2731
01:56:54,750 --> 01:56:56,910
芳心

2732
01:56:58,020 --> 01:56:59,160
然后放心里

2733
01:57:00,000 --> 01:57:01,260
然后掉了

2734
01:57:03,010 --> 01:57:04,120
放心B

2735
01:57:06,560 --> 01:57:08,660
放心哔哩又掉了放心C

2736
01:57:14,060 --> 01:57:14,480
XKC

2737
01:57:14,510 --> 01:57:15,380
假如这种情况

2738
01:57:15,740 --> 01:57:18,770
那么有的时候我需要判断她在a中

2739
01:57:18,800 --> 01:57:20,450
有的时候需要判断它在C中

2740
01:57:21,220 --> 01:57:23,590
所以那么我这两个都不能丢

2741
01:57:23,770 --> 01:57:24,820
因为否则的话

2742
01:57:24,850 --> 01:57:26,800
那么我还需要增加其他的变量

2743
01:57:27,250 --> 01:57:30,280
还要增加其他的变量来判断损失变量对不对

2744
01:57:30,370 --> 01:57:31,180
稍微变凉吗

2745
01:57:31,480 --> 01:57:34,090
要判断在a中在C中在B中

2746
01:57:35,180 --> 01:57:37,250
那么我如果

2747
01:57:38,000 --> 01:57:39,020
没有多种的话

2748
01:57:39,200 --> 01:57:40,580
如果这个字都没有多种的话

2749
01:57:40,790 --> 01:57:43,310
那么我需要增加好几个字段来区分

2750
01:57:43,400 --> 01:57:44,030
来做处理

2751
01:57:44,680 --> 01:57:46,780
因此这个execution context大家看

2752
01:57:47,260 --> 01:57:48,010
非常荣幸

2753
01:57:48,070 --> 01:57:49,960
他也是一个二进制的

2754
01:57:50,530 --> 01:57:51,550
他也是一个二进制

2755
01:57:51,550 --> 01:57:53,800
分别来标志几种不同的上下文

2756
01:57:54,370 --> 01:57:55,420
几种不同的上下文

2757
01:57:55,420 --> 01:57:56,485
他有可能是

2758
01:57:56,485 --> 01:57:58,540
他有可能是多种

2759
01:57:58,540 --> 01:57:59,470
有可能是三种

2760
01:58:00,510 --> 01:58:01,350
多种和单总

2761
01:58:01,380 --> 01:58:02,310
反正他也是一个

2762
01:58:02,580 --> 01:58:04,890
但他通过这个二进制的

2763
01:58:05,430 --> 01:58:06,960
就像刚刚的车道一样

2764
01:58:07,200 --> 01:58:08,850
那么如果它是多种的话

2765
01:58:08,850 --> 01:58:09,210
对不对

2766
01:58:09,210 --> 01:58:10,530
他就肯定是这种形式

2767
01:58:12,010 --> 01:58:13,390
然后区分的话也很好

2768
01:58:13,540 --> 01:58:15,940
区分的话二进制也会很好区分

2769
01:58:16,540 --> 01:58:21,100
而注册它添加exchange contacts

2770
01:58:21,100 --> 01:58:22,300
这个是我拿出来的

2771
01:58:22,300 --> 01:58:23,830
就是比较

2772
01:58:24,720 --> 01:58:25,380
典型啊

2773
01:58:25,680 --> 01:58:27,360
比如在这个render red里

2774
01:58:28,630 --> 01:58:30,550
他就或一下对不对对吧

2775
01:58:31,200 --> 01:58:32,730
这个execution context

2776
01:58:32,730 --> 01:58:33,570
这个是一个

2777
01:58:34,290 --> 01:58:35,460
B包的一个变量

2778
01:58:35,790 --> 01:58:36,720
那么大概或一下

2779
01:58:36,720 --> 01:58:37,770
是不是就把它的值

2780
01:58:38,650 --> 01:58:39,430
给加上了

2781
01:58:39,910 --> 01:58:40,510
然后呢

2782
01:58:40,900 --> 01:58:43,180
就是在执行这个真正的函数体之前

2783
01:58:43,630 --> 01:58:44,650
他把他给货一下

2784
01:58:45,460 --> 01:58:46,630
换一下就是标志

2785
01:58:46,690 --> 01:58:50,560
他把他把这个render con tax加到了excuse me contacts里

2786
01:58:51,070 --> 01:58:53,110
让它执行完了之后再恢复原样

2787
01:58:53,290 --> 01:58:54,370
这个大家能理解吗

2788
01:58:54,490 --> 01:58:55,960
就这行代码大家能理解吗

2789
01:58:56,320 --> 01:58:57,310
能理解扣个一

2790
01:58:58,160 --> 01:58:59,180
祝你姐开个年

2791
01:59:03,110 --> 01:59:05,570
在执行这个货吗

2792
01:59:05,630 --> 01:59:08,090
好行不太理解或

2793
01:59:08,760 --> 01:59:09,330
像刚刚说的

2794
01:59:09,330 --> 01:59:10,800
比如这个excuse me contacts

2795
01:59:10,800 --> 01:59:12,330
假如他刚开始是零

2796
01:59:13,020 --> 01:59:13,440
对吧

2797
01:59:13,530 --> 01:59:15,690
你刚开始肯定没有上下文吗

2798
01:59:16,050 --> 01:59:18,780
现在我要或上一个render context

2799
01:59:22,290 --> 01:59:23,130
嚯上了之后

2800
01:59:23,130 --> 01:59:24,780
货肯定是只要有一个一

2801
01:59:24,780 --> 01:59:25,350
对吧

2802
01:59:25,350 --> 01:59:26,250
只要有一个一

2803
01:59:26,460 --> 01:59:27,570
那么它就会变成一

2804
01:59:27,810 --> 01:59:28,980
那么它的结果是什么

2805
01:59:28,980 --> 01:59:29,910
结果就变成了

2806
01:59:31,860 --> 01:59:32,340
这样啊

2807
01:59:32,610 --> 01:59:34,290
假如他还要假如这个

2808
01:59:34,290 --> 01:59:37,950
现在他这边execution context现在就成了他

2809
01:59:41,500 --> 01:59:42,100
对不对

2810
01:59:43,000 --> 01:59:43,690
然后第二次

2811
01:59:43,690 --> 01:59:46,600
假如我要或一下又要进入

2812
01:59:46,600 --> 01:59:47,800
com的contact了

2813
01:59:48,040 --> 01:59:48,610
那么他

2814
01:59:52,840 --> 01:59:53,140
哎呀

2815
01:59:54,880 --> 01:59:55,450
再错

2816
01:59:58,080 --> 02:00:00,540
这样他在或一下就变成两个亿了

2817
02:00:01,830 --> 02:00:03,030
对变成两个亿了

2818
02:00:04,860 --> 02:00:05,310
嗯

2819
02:00:06,580 --> 02:00:08,380
这样子

2820
02:00:08,770 --> 02:00:09,670
对于他的来讲

2821
02:00:09,670 --> 02:00:10,870
他就已经能够

2822
02:00:11,470 --> 02:00:12,880
他就已经能够区分

2823
02:00:12,910 --> 02:00:16,510
已经能够区分到底是在哪个函数之内

2824
02:00:16,660 --> 02:00:18,880
就在哪种上下文里边儿

2825
02:00:18,880 --> 02:00:22,210
在它在执行这个函数之前调到他

2826
02:00:22,510 --> 02:00:25,330
而在执行函数执行完了之后就把它给去掉

2827
02:00:25,450 --> 02:00:28,150
然后他就他又回到了prime

2828
02:00:28,420 --> 02:00:30,580
就是pre v X q Shun context

2829
02:00:30,970 --> 02:00:32,230
很多逻辑是这么写的

2830
02:00:32,320 --> 02:00:33,160
很多也是这么写的

2831
02:00:33,160 --> 02:00:34,180
给他去掉就行了

2832
02:00:35,080 --> 02:00:36,430
那判断的话就非常简单

2833
02:00:36,430 --> 02:00:36,880
判断的话

2834
02:00:36,880 --> 02:00:38,860
下面其实就是一个判断逻辑

2835
02:00:39,280 --> 02:00:40,720
它就与上

2836
02:00:40,720 --> 02:00:43,750
比如说我要判断我是不是render context

2837
02:00:44,590 --> 02:00:45,400
比如我这里

2838
02:00:45,580 --> 02:00:46,630
比如我刚刚这个

2839
02:00:49,920 --> 02:00:51,510
比如这个in context

2840
02:00:51,510 --> 02:00:53,310
我要判断是不是render context

2841
02:00:53,580 --> 02:00:54,420
它就很简单了

2842
02:00:54,420 --> 02:00:56,370
我自己教他

2843
02:00:58,270 --> 02:00:59,530
鱼对吧

2844
02:01:00,100 --> 02:01:00,880
与上他

2845
02:01:00,910 --> 02:01:01,960
因为与上他的话

2846
02:01:01,960 --> 02:01:02,980
这两个都是一

2847
02:01:03,640 --> 02:01:04,300
然后呢

2848
02:01:04,330 --> 02:01:06,520
不等于no context

2849
02:01:08,300 --> 02:01:09,530
不等于那个context

2850
02:01:09,800 --> 02:01:12,080
那么其实他的逻辑呢

2851
02:01:12,080 --> 02:01:16,460
就相当于在这种常见的逻辑相当于他等于他对不对

2852
02:01:17,560 --> 02:01:22,600
但是他他这个这个代码相比下面的代码一个好处是什么呢

2853
02:01:23,170 --> 02:01:24,610
它的场景会更多

2854
02:01:25,060 --> 02:01:26,680
就是他的处理情况会更多

2855
02:01:26,710 --> 02:01:29,170
下面它就只能处理一种情况儿

2856
02:01:29,170 --> 02:01:32,800
上面这个它可它首先它可以等于不同的值

2857
02:01:32,920 --> 02:01:34,510
第二它可以处理多个值

2858
02:01:35,150 --> 02:01:36,320
它可以处理多个字

2859
02:01:36,800 --> 02:01:39,410
实际上在rock之前

2860
02:01:39,410 --> 02:01:40,220
16:13之前

2861
02:01:40,520 --> 02:01:41,900
她用的就是烧饼变量

2862
02:01:41,960 --> 02:01:42,410
比如

2863
02:01:42,980 --> 02:01:43,850
他没有contact

2864
02:01:43,850 --> 02:01:46,610
它就叫做上面叫做is rendering

2865
02:01:47,770 --> 02:01:50,830
之前就用这个等于true和false就是处

2866
02:01:51,550 --> 02:01:52,510
之前是这么写的

2867
02:01:53,140 --> 02:01:54,970
然后commit就是一只

2868
02:01:56,110 --> 02:01:56,680
competing

2869
02:01:57,190 --> 02:01:57,730
抵触

2870
02:01:58,780 --> 02:02:00,400
他就有很多种这种变量

2871
02:02:01,920 --> 02:02:03,840
后面的时候我在看着

2872
02:02:03,840 --> 02:02:04,380
他就改了

2873
02:02:04,380 --> 02:02:06,090
它就变成了context上下文了

2874
02:02:06,850 --> 02:02:10,180
其实非常他用他那个上下文的话就更加清晰了

2875
02:02:10,450 --> 02:02:11,860
他只需要这一个字段

2876
02:02:12,820 --> 02:02:14,830
然后他可以处理很多很多种的场景

2877
02:02:15,760 --> 02:02:17,050
其实还是很有优势的

2878
02:02:17,440 --> 02:02:18,280
非常有优势的

2879
02:02:18,280 --> 02:02:19,180
大家能理解了吗

2880
02:02:22,630 --> 02:02:23,080
好的

2881
02:02:25,950 --> 02:02:26,520
好

2882
02:02:26,550 --> 02:02:27,930
这就是两个基本概念呢

2883
02:02:27,930 --> 02:02:28,950
我们来看第一步

2884
02:02:29,220 --> 02:02:31,770
其实把这基本概念理解了之后

2885
02:02:31,770 --> 02:02:33,660
我们来看下面的逻辑就非常简单了

2886
02:02:33,840 --> 02:02:37,140
我们来看第一步它会掉到这个

2887
02:02:37,140 --> 02:02:39,090
我们之前看到那个阿飞的container

2888
02:02:39,840 --> 02:02:41,070
它会掉到这个函数

2889
02:02:41,400 --> 02:02:46,950
首先获取当前更新的1000几当N等于当N等于

2890
02:02:47,660 --> 02:02:48,410
Think的时候

2891
02:02:48,410 --> 02:02:50,930
这个烂就是我们当前的优先级吗

2892
02:02:51,380 --> 02:02:53,960
如果这个优先级还等于sig man也是

2893
02:02:54,760 --> 02:02:58,480
也就是优先级最高的同步的那个优先级

2894
02:02:59,460 --> 02:03:00,420
与此同时

2895
02:03:00,930 --> 02:03:04,110
在看立刻就要便立刻就做了一个对比了

2896
02:03:04,110 --> 02:03:04,500
对不对

2897
02:03:05,250 --> 02:03:06,480
Excuse me contacts

2898
02:03:07,320 --> 02:03:17,430
与上一个on base context不等于no text这个的含义就相当于是说execution context等于magic on based context

2899
02:03:18,230 --> 02:03:20,030
这个APP是什么呢

2900
02:03:20,210 --> 02:03:25,010
其实之前也给其实之前已经给大家介绍过了就是

2901
02:03:25,670 --> 02:03:27,050
就是这里的

2902
02:03:41,160 --> 02:03:44,310
就是这个a bitch在这个APP下载

2903
02:03:44,550 --> 02:03:45,750
这个我们不是搜了吗

2904
02:03:46,440 --> 02:03:49,170
当她当她被包裹在这个函数里面

2905
02:03:49,320 --> 02:03:51,630
意思是不不批处理

2906
02:03:51,660 --> 02:03:53,190
以最高1000级宣传出来

2907
02:03:53,520 --> 02:03:55,230
这实际上给他加了一个什么呢

2908
02:03:55,260 --> 02:03:56,340
给他加了一个

2909
02:03:57,000 --> 02:04:00,930
Context the contest就叫做legends on based context

2910
02:04:01,350 --> 02:04:01,890
因此

2911
02:04:02,160 --> 02:04:05,280
如果是第一次走render过来的情况

2912
02:04:05,310 --> 02:04:07,410
第一次rightdown.render过来的情况

2913
02:04:07,680 --> 02:04:10,230
那么他首先赖肯定是sing ly

2914
02:04:10,820 --> 02:04:11,690
那么他

2915
02:04:12,260 --> 02:04:16,490
和他与上肯定等于不等于那个context就是它们两个相等的

2916
02:04:16,970 --> 02:04:17,630
然后呢

2917
02:04:17,780 --> 02:04:20,660
同时它不等于这两个都是任何一个

2918
02:04:21,280 --> 02:04:23,800
现在确实也不等于他之前这么处理

2919
02:04:23,890 --> 02:04:25,300
是因为有很多种情况

2920
02:04:25,480 --> 02:04:27,970
他需要就是不停的来调这个函数

2921
02:04:28,450 --> 02:04:29,740
不停的在这个函数

2922
02:04:30,190 --> 02:04:31,240
大家需要知道的是

2923
02:04:31,240 --> 02:04:32,860
就是render的这个

2924
02:04:33,250 --> 02:04:34,750
这个分支是成立的

2925
02:04:34,870 --> 02:04:38,050
就是on base context有这样

2926
02:04:38,050 --> 02:04:39,550
他也不在这两个里边

2927
02:04:39,730 --> 02:04:40,870
因此他就直

2928
02:04:41,170 --> 02:04:43,630
他就直接走了performance in work on route

2929
02:04:43,690 --> 02:04:44,560
这个函数很重要

2930
02:04:44,590 --> 02:04:47,950
其实走这个函数就进入我们接下来的re consider就成了

2931
02:04:48,310 --> 02:04:52,000
他就直接不不走我们的调度逻辑了

2932
02:04:52,210 --> 02:04:54,610
他就直接去下一个流程去了

2933
02:04:54,610 --> 02:04:56,140
因为他是最优先的码儿

2934
02:04:56,140 --> 02:04:57,370
他也是同步执行的

2935
02:04:57,820 --> 02:04:58,570
它并不会

2936
02:04:58,750 --> 02:05:02,320
它并没有在CML的或者说红任务当中执行

2937
02:05:02,870 --> 02:05:03,380
也就是说

2938
02:05:03,920 --> 02:05:06,230
第一个优先级最高的同步任务

2939
02:05:06,260 --> 02:05:06,860
以及

2940
02:05:07,930 --> 02:05:10,480
当然同时必须是on based on data

2941
02:05:10,960 --> 02:05:11,740
那么他就会

2942
02:05:12,560 --> 02:05:14,060
优先级最高的同步执行

2943
02:05:15,220 --> 02:05:16,960
这就是第一第一个分支

2944
02:05:16,990 --> 02:05:17,890
第一个逻辑分支

2945
02:05:18,650 --> 02:05:19,460
大家能理解吗

2946
02:05:19,460 --> 02:05:20,810
这个能理解扣个一

2947
02:05:21,700 --> 02:05:22,570
应该还行吧

2948
02:05:22,870 --> 02:05:25,480
我们把毕竟把这两个都已经讲了

2949
02:05:28,050 --> 02:05:28,530
OK

2950
02:05:28,860 --> 02:05:30,030
接下来就是一部的

2951
02:05:31,220 --> 02:05:31,820
衣服的

2952
02:05:33,940 --> 02:05:37,120
这个叫做ensure loo ses

2953
02:05:37,120 --> 02:05:38,680
这句包含一不掉的逻辑

2954
02:05:38,680 --> 02:05:41,320
我们来看下面这个函数

2955
02:05:41,320 --> 02:05:43,480
先先看我标黄的这几个

2956
02:05:43,840 --> 02:05:47,320
先看我标黄的这个ensure his schedule

2957
02:05:47,380 --> 02:05:51,130
他首先检查他有没有可诺的这个课呢

2958
02:05:51,130 --> 02:05:52,870
如果我们是第一次进来的时候

2959
02:05:53,320 --> 02:05:54,460
就是第一个任务进来

2960
02:05:54,760 --> 02:05:55,840
那么他肯定是空的

2961
02:05:56,200 --> 02:05:56,770
原因是什么呢

2962
02:05:56,770 --> 02:05:59,890
原因是他在第一个执行完了之后

2963
02:06:00,810 --> 02:06:02,670
第一个执行完了之后才给它赋值

2964
02:06:02,700 --> 02:06:02,970
对吧

2965
02:06:02,970 --> 02:06:05,880
你看root.call back note在这儿复制的

2966
02:06:06,240 --> 02:06:07,560
所以第一个肯定是空的

2967
02:06:07,620 --> 02:06:09,180
这个我们应该也经常写

2968
02:06:09,240 --> 02:06:09,540
对吧

2969
02:06:09,690 --> 02:06:13,920
其实这是一个判断复可以复用的一个逻辑

2970
02:06:13,950 --> 02:06:16,680
如果第一个有了可怕承诺的

2971
02:06:16,680 --> 02:06:18,060
后面我们就复用他

2972
02:06:18,090 --> 02:06:19,380
复用这个可怕的诺的

2973
02:06:19,770 --> 02:06:20,760
这其实也就是

2974
02:06:21,540 --> 02:06:22,260
一个意思

2975
02:06:22,320 --> 02:06:24,990
如果有我们就复用他

2976
02:06:25,080 --> 02:06:26,010
如果没有

2977
02:06:26,010 --> 02:06:27,660
我们就新建

2978
02:06:27,780 --> 02:06:28,620
就新建一个

2979
02:06:29,040 --> 02:06:30,990
而服用它会产生什么效果呢

2980
02:06:30,990 --> 02:06:33,420
我们刚刚不是有这种逻辑吗

2981
02:06:33,420 --> 02:06:36,570
比如同时发起了两次C他妈CNC的

2982
02:06:36,570 --> 02:06:41,760
但是在同一个组件的同一个生命周期里同时发起了两次c EST

2983
02:06:43,460 --> 02:06:46,700
实际上只会产生一次调度

2984
02:06:47,300 --> 02:06:48,230
原因就在这里

2985
02:06:48,290 --> 02:06:49,040
原因就在

2986
02:06:49,070 --> 02:06:51,230
原因就在第一次进来

2987
02:06:51,230 --> 02:06:52,550
比如这个distance EST

2988
02:06:53,370 --> 02:06:54,030
然后

2989
02:06:54,810 --> 02:06:57,840
他exist Co BAC不等于等于

2990
02:06:57,840 --> 02:06:58,680
那等于落

2991
02:06:58,680 --> 02:06:59,970
他走下面的逻辑

2992
02:07:00,180 --> 02:07:00,540
然后呢

2993
02:07:00,540 --> 02:07:02,580
创建了一个可靠的

2994
02:07:03,140 --> 02:07:04,940
当第二个C的进来的时候

2995
02:07:06,160 --> 02:07:07,120
这个存在了

2996
02:07:07,450 --> 02:07:09,460
所以这就直接瑞特了

2997
02:07:09,460 --> 02:07:11,080
大家看这就直接瑞特了

2998
02:07:11,500 --> 02:07:12,880
就不重新发几个吊坠儿

2999
02:07:12,880 --> 02:07:14,290
就复用之前那个

3000
02:07:14,960 --> 02:07:16,130
就复用之前那个

3001
02:07:16,430 --> 02:07:19,280
因此他们就批处理就形成了

3002
02:07:19,880 --> 02:07:21,080
这大家能理解吗

3003
02:07:25,950 --> 02:07:26,550
开个一

3004
02:07:27,560 --> 02:07:27,830
好的

3005
02:07:27,890 --> 02:07:28,730
这个应该没问题

3006
02:07:28,730 --> 02:07:29,630
应该没问题

3007
02:07:31,160 --> 02:07:32,090
嗯

3008
02:07:33,640 --> 02:07:33,880
好

3009
02:07:33,880 --> 02:07:35,110
发起一个新的调度

3010
02:07:35,140 --> 02:07:36,520
然后我们继续来看

3011
02:07:36,850 --> 02:07:39,280
大家看这他把performance work on route

3012
02:07:40,020 --> 02:07:41,370
对是其实就是一个

3013
02:07:41,610 --> 02:07:42,750
其实就是一个缓存吗

3014
02:07:43,550 --> 02:07:46,430
服用之前的复用之前发起的一次更新

3015
02:07:49,020 --> 02:07:50,400
因为你不需要发起很多个

3016
02:07:54,410 --> 02:07:57,320
然后现在这个大家看他把performance work on route

3017
02:07:57,620 --> 02:07:59,480
他把这个方法实际上是传过去了

3018
02:07:59,840 --> 02:08:00,800
传到这个方法

3019
02:08:00,830 --> 02:08:03,410
传到这个schedule back里

3020
02:08:03,410 --> 02:08:04,550
接下来我们进行第二步

3021
02:08:05,460 --> 02:08:07,110
得计算得到expression叹

3022
02:08:08,320 --> 02:08:13,450
Expression X等于X加上看首先看它这个can

3023
02:08:13,450 --> 02:08:15,070
我我之前已经给大家讲过吧

3024
02:08:15,070 --> 02:08:18,760
看着它它实际上是根据当前的这个时间计算得来的

3025
02:08:19,460 --> 02:08:20,180
计算得来的

3026
02:08:21,200 --> 02:08:23,060
当然他肯定不是直接取得这个时间

3027
02:08:23,600 --> 02:08:25,580
但是他和时间是成正相关的

3028
02:08:25,640 --> 02:08:26,750
大家知道这个就行

3029
02:08:27,080 --> 02:08:27,800
然后呢

3030
02:08:28,370 --> 02:08:31,040
这儿根据它是否传进来了有滴泪

3031
02:08:31,590 --> 02:08:32,280
把它分为

3032
02:08:32,760 --> 02:08:34,890
然后把这个坑他家上的累就是什么

3033
02:08:34,890 --> 02:08:35,850
得到了star

3034
02:08:36,810 --> 02:08:37,950
根据started呢

3035
02:08:39,730 --> 02:08:40,660
我们在下边儿

3036
02:08:42,400 --> 02:08:43,540
会计算

3037
02:08:43,690 --> 02:08:47,320
会计算我们的starter he carried进行一个对比

3038
02:08:47,950 --> 02:08:49,120
如果沙滩

3039
02:08:50,310 --> 02:08:52,140
就这个任务这个沙滩一指

3040
02:08:52,140 --> 02:08:53,520
就是我们任务开始的时间

3041
02:08:53,610 --> 02:08:56,310
是我们任务什么时候要进行调度的时间

3042
02:08:56,820 --> 02:08:58,350
当它大于了开始探

3043
02:08:58,530 --> 02:08:59,310
那说明什么

3044
02:08:59,760 --> 02:09:04,410
说明说明你的star比当前时间还远呢

3045
02:09:04,410 --> 02:09:05,850
就是你的当前时间

3046
02:09:06,690 --> 02:09:10,800
当前时间小于就是小于你的任务开始之间

3047
02:09:10,830 --> 02:09:11,190
对不对

3048
02:09:11,430 --> 02:09:12,990
当前时间小于任务开始之间

3049
02:09:13,410 --> 02:09:15,600
那毫无疑问就意味着你的任务还不开始

3050
02:09:16,310 --> 02:09:17,960
所以他把这个放在这里

3051
02:09:17,960 --> 02:09:19,070
叫做time Queenie

3052
02:09:19,370 --> 02:09:20,180
教他们Queenie

3053
02:09:21,340 --> 02:09:22,330
有两个任务列表

3054
02:09:22,330 --> 02:09:23,200
一个教堂queen

3055
02:09:23,320 --> 02:09:26,890
一个叫tasks task queen就是要

3056
02:09:27,040 --> 02:09:27,610
就是要

3057
02:09:27,610 --> 02:09:28,990
就是即使任务

3058
02:09:29,440 --> 02:09:30,880
他们可以就是岩石任务

3059
02:09:31,420 --> 02:09:33,460
因此如果我们当前时间小于了

3060
02:09:36,620 --> 02:09:37,670
啥等一下

3061
02:09:37,700 --> 02:09:40,040
如果当前时间小于了我们的开始时间

3062
02:09:40,070 --> 02:09:41,090
那就还不开始

3063
02:09:42,240 --> 02:09:44,010
所以他就是把它放

3064
02:09:44,010 --> 02:09:45,480
把这个任务就放到岩石中

3065
02:09:46,280 --> 02:09:48,290
不然的话就把它放在即时任务当中

3066
02:09:48,940 --> 02:09:49,600
然后呢

3067
02:09:50,420 --> 02:09:52,610
即使任务大家看原始任务的时候

3068
02:09:52,610 --> 02:09:53,330
他实际上

3069
02:09:54,120 --> 02:09:58,500
这里这里这儿的时候就就不会发起

3070
02:09:58,530 --> 02:09:59,820
就不会发起一次掉落

3071
02:10:00,180 --> 02:10:01,830
就在即使我这里的时候

3072
02:10:02,160 --> 02:10:05,760
他会发起这个会第二个request host go back

3073
02:10:07,880 --> 02:10:09,950
那即使污染当即执行

3074
02:10:10,340 --> 02:10:10,970
但是

3075
02:10:11,700 --> 02:10:14,910
他调这个looks back最后就走到了这里

3076
02:10:14,970 --> 02:10:18,390
Looks back即使任务他是要当地执行的

3077
02:10:18,540 --> 02:10:21,990
但是它和我们前面所说的那个同步的又不太一样

3078
02:10:22,020 --> 02:10:25,290
同步的就真的只是在rap的主线程中执行

3079
02:10:25,620 --> 02:10:26,820
而这里的即时任务

3080
02:10:26,910 --> 02:10:28,050
虽然说是即时任务

3081
02:10:28,320 --> 02:10:28,860
但是

3082
02:10:29,620 --> 02:10:30,370
他也是

3083
02:10:31,770 --> 02:10:33,180
不是在主线程中执行的

3084
02:10:33,180 --> 02:10:34,560
而是在红任务中执行

3085
02:10:34,920 --> 02:10:36,900
这里要给大家讲一个message channel

3086
02:10:37,200 --> 02:10:38,730
这个是浏览器的API

3087
02:10:40,050 --> 02:10:42,570
这个浏览器的API它类似于CS的

3088
02:10:43,160 --> 02:10:43,460
注意啊

3089
02:10:43,460 --> 02:10:44,510
它是类似于三八的

3090
02:10:44,510 --> 02:10:45,680
它是一个宏任务

3091
02:10:45,710 --> 02:10:47,690
同学们它是一个宏任务

3092
02:10:47,930 --> 02:10:50,180
它的它的用法是什么呢

3093
02:10:50,390 --> 02:10:51,200
它的用法是

3094
02:10:51,230 --> 02:10:52,400
比如他有两个point

3095
02:10:52,430 --> 02:10:54,800
一个叫POINT11个POINT2

3096
02:10:55,610 --> 02:10:59,330
它的用法是POINT1发起一个点post

3097
02:10:59,660 --> 02:11:00,410
比如

3098
02:11:03,170 --> 02:11:03,470
嗯

3099
02:11:04,180 --> 02:11:05,110
比如PART1

3100
02:11:06,070 --> 02:11:07,060
在普洱呢

3101
02:11:11,240 --> 02:11:13,790
这咋看还是看吧

3102
02:11:14,830 --> 02:11:17,470
这个PART11个PART2

3103
02:11:17,950 --> 02:11:19,270
比如我这个PART2

3104
02:11:19,330 --> 02:11:21,880
他只要发起一个post message

3105
02:11:22,500 --> 02:11:26,370
那么他就是在红任务中执行另外一个抛投一的安美

3106
02:11:26,370 --> 02:11:26,700
谢谢

3107
02:11:27,770 --> 02:11:29,660
自己比其实画个图吧

3108
02:11:29,690 --> 02:11:30,950
画个图就更容易理解了

3109
02:11:31,340 --> 02:11:31,970
这是POS

3110
02:11:31,970 --> 02:11:32,870
这是PART1

3111
02:11:33,820 --> 02:11:34,690
这是PART2

3112
02:11:35,860 --> 02:11:36,340
这是POS机

3113
02:11:36,340 --> 02:11:37,240
他这是PART2

3114
02:11:37,600 --> 02:11:39,790
当在PART1

3115
02:11:40,590 --> 02:11:41,820
他可以有一个

3116
02:11:42,720 --> 02:11:44,070
On message找他呢

3117
02:11:44,070 --> 02:11:47,310
有一个on message写

3118
02:11:47,310 --> 02:11:48,600
PART2也有一个on message

3119
02:11:52,820 --> 02:11:54,380
如果这儿有个post message

3120
02:11:54,920 --> 02:11:56,720
这个post是一个方法

3121
02:11:57,840 --> 02:11:58,530
他们都有

3122
02:11:59,510 --> 02:12:00,800
这个post message方法

3123
02:12:00,890 --> 02:12:02,930
我在这里发起一个post message

3124
02:12:02,930 --> 02:12:05,060
就是执行一下post message向这样

3125
02:12:06,470 --> 02:12:10,550
那么他会在红任务中执行它的执行另外一个地方的on message

3126
02:12:11,380 --> 02:12:12,700
红色执行这个逻辑

3127
02:12:12,880 --> 02:12:15,280
如果他这儿发几个post message

3128
02:12:15,280 --> 02:12:16,360
那么这也一样

3129
02:12:18,760 --> 02:12:19,570
这是它的作用

3130
02:12:19,570 --> 02:12:20,290
这是它的用法

3131
02:12:20,290 --> 02:12:21,340
这样的用法

3132
02:12:21,850 --> 02:12:23,680
那之前有同学就有疑问就是

3133
02:12:24,300 --> 02:12:26,220
如果说为什么要用

3134
02:12:26,730 --> 02:12:28,830
就是我能理解他是在活动执行

3135
02:12:28,830 --> 02:12:30,930
但是为什么要用post message

3136
02:12:31,080 --> 02:12:33,090
但是为什么要用那个message channel

3137
02:12:33,690 --> 02:12:34,050
对吧

3138
02:12:34,440 --> 02:12:37,140
其实我也仔细想了一下

3139
02:12:37,170 --> 02:12:38,460
官方给的答案是什么

3140
02:12:38,490 --> 02:12:41,040
官方给答案是一个是c Mo的

3141
02:12:41,040 --> 02:12:41,850
有的时候不准

3142
02:12:43,020 --> 02:12:43,680
有的时候不准

3143
02:12:43,680 --> 02:12:44,850
大家这个应该能理解

3144
02:12:45,240 --> 02:12:46,710
这他妈的不太准确

3145
02:12:47,310 --> 02:12:48,165
对不对

3146
02:12:48,165 --> 02:12:51,360
他有的时候你的一个一个任务没执行完

3147
02:12:52,200 --> 02:12:53,070
它并不会

3148
02:12:53,220 --> 02:12:55,140
它并不会就是非常准确的

3149
02:12:55,140 --> 02:12:59,070
然后就执行第2ST channel他的

3150
02:12:59,430 --> 02:13:02,190
他还会在赛他妈的之前执行

3151
02:13:02,220 --> 02:13:03,450
他不在三方了之后

3152
02:13:03,810 --> 02:13:05,610
其实它的准确性是更有保障的

3153
02:13:06,350 --> 02:13:08,600
因此用AC channel比用cmos好

3154
02:13:09,110 --> 02:13:09,860
但是呢

3155
02:13:10,160 --> 02:13:12,500
但是你用摘帽的应该问题不大

3156
02:13:12,800 --> 02:13:14,300
你如果你自己想用的话

3157
02:13:14,510 --> 02:13:16,040
你你会MISS1000龙

3158
02:13:16,040 --> 02:13:16,670
你可以用它

3159
02:13:16,790 --> 02:13:17,600
你不会面签了

3160
02:13:17,600 --> 02:13:20,510
你用其他模特也能实现这样的一个功能

3161
02:13:21,500 --> 02:13:22,280
流程没有懂

3162
02:13:26,540 --> 02:13:28,970
流程刚刚刚刚

3163
02:13:29,950 --> 02:13:30,490
好吧

3164
02:13:30,520 --> 02:13:31,720
再说再说一下

3165
02:13:33,120 --> 02:13:34,620
刚刚去给大家讲流程

3166
02:13:35,300 --> 02:13:36,020
嗯

3167
02:13:39,540 --> 02:13:40,110
点不上

3168
02:13:43,200 --> 02:13:44,220
我怎么画不出来了

3169
02:13:48,590 --> 02:13:49,160
画出来了

3170
02:13:49,820 --> 02:13:52,520
比这次post有两个point吗

3171
02:13:53,150 --> 02:13:55,640
有两个point一个叫POINT1

3172
02:13:56,320 --> 02:13:58,030
有一个二这是破的一

3173
02:13:58,120 --> 02:13:58,900
这是破的二

3174
02:13:59,410 --> 02:14:01,510
它有两个将我们的左手和右手一样

3175
02:14:02,380 --> 02:14:05,650
每一个point上他都有两个方法

3176
02:14:06,600 --> 02:14:08,160
一个叫做on message

3177
02:14:08,640 --> 02:14:09,990
一个叫做post message

3178
02:14:11,360 --> 02:14:12,800
On message post message

3179
02:14:12,800 --> 02:14:14,780
这个是on message

3180
02:14:16,240 --> 02:14:18,790
这是on message post post message

3181
02:14:18,790 --> 02:14:20,140
他们两个并不是割裂的

3182
02:14:20,170 --> 02:14:21,100
它们是一个整体

3183
02:14:21,100 --> 02:14:22,690
你要把它当成一个整体来看

3184
02:14:23,480 --> 02:14:25,040
同学们让这个整体来看

3185
02:14:25,310 --> 02:14:26,180
这是post message

3186
02:14:26,180 --> 02:14:27,170
这也是post message

3187
02:14:27,320 --> 02:14:28,280
然后呢

3188
02:14:28,430 --> 02:14:31,400
Capacity其实就是绑定我们响应的方法

3189
02:14:32,270 --> 02:14:33,500
绑定我们响应的方法

3190
02:14:33,530 --> 02:14:36,440
这就是绑这个方法就是让他自己写的

3191
02:14:36,860 --> 02:14:38,090
然后自己写的一个方法

3192
02:14:39,280 --> 02:14:42,190
而他是他的执行时间在什么时候

3193
02:14:42,430 --> 02:14:43,990
他的执行实际在这里

3194
02:14:44,170 --> 02:14:45,400
比如我这个point

3195
02:14:45,820 --> 02:14:47,290
这个part就是PART2码

3196
02:14:47,590 --> 02:14:49,600
Point发起了一次post message

3197
02:14:49,630 --> 02:14:51,880
假如他发起了一次post message

3198
02:14:52,740 --> 02:14:55,830
一开始如果大家看到这里就不要迷惑

3199
02:14:56,010 --> 02:14:56,640
可能就迷糊了

3200
02:14:56,640 --> 02:14:59,490
就觉得说他发觉不合适没之后就断了

3201
02:14:59,490 --> 02:14:59,760
对吧

3202
02:14:59,760 --> 02:15:00,450
就断了

3203
02:15:00,690 --> 02:15:02,070
因为后面就什么也没有了

3204
02:15:02,680 --> 02:15:04,450
实际上接下来他就会走到哪里

3205
02:15:04,450 --> 02:15:05,800
他会在红任务当中

3206
02:15:05,830 --> 02:15:07,810
注意是在红任务当中

3207
02:15:07,810 --> 02:15:09,340
他就会来到这个函数内

3208
02:15:09,820 --> 02:15:11,560
就调到这个方法里边

3209
02:15:12,470 --> 02:15:17,630
也就是我的POINT2的post message移调

3210
02:15:17,930 --> 02:15:22,820
那么point一个on message就会就会在下一个宏任务当中执行

3211
02:15:23,720 --> 02:15:24,830
这个逻辑能明白吗

3212
02:15:24,980 --> 02:15:25,400
同学

3213
02:15:33,940 --> 02:15:35,080
至于为什么要用它

3214
02:15:35,080 --> 02:15:36,310
我刚刚也讲到了

3215
02:15:36,520 --> 02:15:38,620
那就是他冒的不太准

3216
02:15:39,070 --> 02:15:41,560
而我们的message会在三号之前执行

3217
02:15:42,850 --> 02:15:45,700
所以我们的即使任务就算当即执行

3218
02:15:45,700 --> 02:15:46,930
但是为了不组织因为交互

3219
02:15:46,930 --> 02:15:48,430
因此它会在红任务执行

3220
02:15:48,430 --> 02:15:49,420
它是一个宏任务

3221
02:15:49,870 --> 02:15:55,120
这因为在红任务执行中执行我们的主线程并不会被一直站着

3222
02:15:55,120 --> 02:15:55,510
对不对

3223
02:15:55,720 --> 02:15:57,970
所以才有了我们最上面的那幅图

3224
02:15:58,270 --> 02:16:01,180
他是过一会儿它就会回到用户的交互

3225
02:16:01,420 --> 02:16:03,850
他又会去检查有没有互一会儿

3226
02:16:04,240 --> 02:16:07,120
因为用户因为主线程空着的话

3227
02:16:07,120 --> 02:16:08,410
他才会有响应嘛

3228
02:16:08,440 --> 02:16:08,740
对吧

3229
02:16:09,220 --> 02:16:10,060
他是有响应

3230
02:16:11,820 --> 02:16:12,870
那么即使任务

3231
02:16:13,620 --> 02:16:15,450
说完了岩石任务呢

3232
02:16:15,840 --> 02:16:16,410
盐食物

3233
02:16:16,410 --> 02:16:17,250
它有一个判断

3234
02:16:17,610 --> 02:16:19,350
就是他每执行一个即时任务

3235
02:16:19,380 --> 02:16:20,220
他都会判断

3236
02:16:20,700 --> 02:16:23,040
她就有一个advanced m UR的这么一个方法

3237
02:16:23,460 --> 02:16:24,540
他就会判断

3238
02:16:26,110 --> 02:16:26,980
你的时间

3239
02:16:27,070 --> 02:16:29,590
比如你的时间是否carry

3240
02:16:29,590 --> 02:16:31,480
是否大于等于expression差

3241
02:16:33,320 --> 02:16:33,950
谴责腾讯

3242
02:16:33,950 --> 02:16:34,610
也求一篇

3243
02:16:36,540 --> 02:16:37,170
谁不是呢

3244
02:16:38,500 --> 02:16:39,910
怎么不是

3245
02:16:40,090 --> 02:16:41,650
Post message前段也有的

3246
02:16:42,670 --> 02:16:44,020
前面也有POS机

3247
02:16:44,050 --> 02:16:44,800
比如说

3248
02:16:45,820 --> 02:16:52,060
特别是像I frame I frame和你的父窗口之间的通信就通POSMIS也可以

3249
02:16:52,740 --> 02:16:55,470
就一个属性叫做温度点post message同学

3250
02:16:58,070 --> 02:16:59,780
豌豆店铺什么

3251
02:17:03,200 --> 02:17:03,620
对吧

3252
02:17:03,650 --> 02:17:04,100
还有温度

3253
02:17:04,100 --> 02:17:06,200
点on message其实都是一样的

3254
02:17:09,580 --> 02:17:10,480
这个没有设码

3255
02:17:10,480 --> 02:17:11,230
你可以给他设

3256
02:17:12,200 --> 02:17:12,560
OK

3257
02:17:12,590 --> 02:17:13,640
就先不说这个了

3258
02:17:14,360 --> 02:17:21,470
岩石任务大家看这里就会把他们困境中的第一个拿出来

3259
02:17:21,920 --> 02:17:22,790
拿出来之后

3260
02:17:22,820 --> 02:17:23,690
然后来判断

3261
02:17:24,940 --> 02:17:28,840
如果你的这个start a小于等于KX

3262
02:17:29,350 --> 02:17:30,400
说明什么呢

3263
02:17:30,400 --> 02:17:32,890
说明你的执行时机已经到了

3264
02:17:33,100 --> 02:17:34,630
他就把它从它弹出来

3265
02:17:35,140 --> 02:17:37,300
然后把他加到我们的他这个片段中去

3266
02:17:37,540 --> 02:17:38,650
他每执行一个任务

3267
02:17:38,680 --> 02:17:40,510
他每执行一个task的任务

3268
02:17:40,690 --> 02:17:42,640
他都会掉一个这个方法来检测

3269
02:17:42,970 --> 02:17:46,120
检测你的岩石任务当中有没有要执行的

3270
02:17:46,510 --> 02:17:47,560
有的话就把它拿出来

3271
02:17:47,560 --> 02:17:49,630
拿出来之后就继续去调动

3272
02:17:49,630 --> 02:17:51,250
我们的task品级又回到了

3273
02:17:51,940 --> 02:17:52,900
继续回到这个地方

3274
02:17:52,900 --> 02:17:54,100
因为调入的task

3275
02:17:59,960 --> 02:18:01,850
然后我画了一个草图

3276
02:18:01,940 --> 02:18:02,750
大家看一下

3277
02:18:03,910 --> 02:18:05,770
还有一个书我们的

3278
02:18:06,510 --> 02:18:07,230
Schedule

3279
02:18:07,290 --> 02:18:08,040
他怎么走的

3280
02:18:08,810 --> 02:18:09,140
第一

3281
02:18:09,140 --> 02:18:10,160
他分了两步

3282
02:18:10,890 --> 02:18:11,610
一个寺

3283
02:18:12,490 --> 02:18:14,560
同步任务优先级

3284
02:18:14,590 --> 02:18:15,520
一个其他优先级

3285
02:18:15,700 --> 02:18:19,630
同步优先级同时还是安倍夏被的时候

3286
02:18:19,870 --> 02:18:22,300
一般这种情况都是绕道理论的

3287
02:18:22,870 --> 02:18:25,960
它是直接走入performance in work and

3288
02:18:25,960 --> 02:18:27,130
就是同步掉了

3289
02:18:27,610 --> 02:18:29,320
其他的话他要走一步调度

3290
02:18:29,320 --> 02:18:31,330
也就是说除了上面这种情况

3291
02:18:31,330 --> 02:18:32,680
其他的肯定在

3292
02:18:33,250 --> 02:18:34,510
红色当中运行

3293
02:18:34,630 --> 02:18:35,710
红色当中运行

3294
02:18:37,450 --> 02:18:41,350
ERRA里边儿它实际上是既包括了同步任务和异步任务

3295
02:18:41,950 --> 02:18:43,570
所以如果说有面试关注到这一点

3296
02:18:43,570 --> 02:18:45,820
就是react是同步的还是异步的

3297
02:18:47,030 --> 02:18:47,420
同学

3298
02:18:47,840 --> 02:18:50,000
现在你知道这个问题怎么答的吗

3299
02:18:50,000 --> 02:18:52,370
就是如果有面试官问REC

3300
02:18:52,370 --> 02:18:53,600
它是同步的还是异步的

3301
02:18:53,870 --> 02:18:55,310
CF是同步的还是异步的

3302
02:18:56,900 --> 02:18:59,900
那么这里咱们是怎么答这个区分情况对不对

3303
02:18:59,900 --> 02:19:00,860
区分场景了

3304
02:19:01,610 --> 02:19:03,770
你如果是把它放在update的呢

3305
02:19:03,770 --> 02:19:04,580
他就是同步掉

3306
02:19:05,120 --> 02:19:05,990
你如果不是

3307
02:19:06,020 --> 02:19:06,860
那他就是一不掉

3308
02:19:08,370 --> 02:19:09,660
最近的区分场景

3309
02:19:09,990 --> 02:19:11,790
并不是并没有一个确定

3310
02:19:11,910 --> 02:19:15,240
并没有一个100%的一个固定的答案

3311
02:19:15,810 --> 02:19:17,400
你你得给他分析分析

3312
02:19:17,610 --> 02:19:18,750
什么情况下是同步的

3313
02:19:18,990 --> 02:19:20,070
什么情况下是一部的

3314
02:19:21,010 --> 02:19:22,750
的指认的是同队

3315
02:19:23,020 --> 02:19:26,530
还有就是你这个update是可以拿出来掉的

3316
02:19:27,310 --> 02:19:28,600
就是它是可以导出来的

3317
02:19:29,250 --> 02:19:30,480
你如果把一个state

3318
02:19:30,480 --> 02:19:31,860
假如你就把一个state

3319
02:19:33,340 --> 02:19:35,350
你把一个C的放在了

3320
02:19:37,140 --> 02:19:38,550
比如假如你是这么写的

3321
02:19:47,680 --> 02:19:48,220
对吧

3322
02:19:49,400 --> 02:19:51,980
那它也它也在同步

3323
02:19:52,430 --> 02:19:53,660
但也可以在同步里面

3324
02:19:55,600 --> 02:19:55,960
恰好

3325
02:19:55,960 --> 02:19:57,940
如果你还是在生命周期里面的话

3326
02:20:02,380 --> 02:20:03,580
所以要区分这个

3327
02:20:03,580 --> 02:20:06,310
实际上是没有一个完全固定的答案的

3328
02:20:06,640 --> 02:20:08,530
他既有我们的rock的内部

3329
02:20:08,710 --> 02:20:09,190
怎么答呢

3330
02:20:09,190 --> 02:20:09,970
到时怎么答呢

3331
02:20:10,450 --> 02:20:12,250
原来的内部它是既有同步的任务

3332
02:20:12,250 --> 02:20:14,350
也有义务的任务的同步的任务

3333
02:20:14,710 --> 02:20:16,660
那么当它是同步的优先级

3334
02:20:16,930 --> 02:20:19,090
以及是安倍下部队的时候

3335
02:20:19,420 --> 02:20:19,900
大

3336
02:20:20,440 --> 02:20:21,790
然后他会走

3337
02:20:22,760 --> 02:20:23,660
他会走同步

3338
02:20:24,640 --> 02:20:27,430
大约的话就是write down点润的第一次调的时候

3339
02:20:27,430 --> 02:20:28,480
那么他肯定是同步的

3340
02:20:28,780 --> 02:20:31,330
其他的比如CS data c EST

3341
02:20:31,600 --> 02:20:33,280
一般情况下是这个衣服的

3342
02:20:33,460 --> 02:20:34,510
当然有特殊情况

3343
02:20:34,870 --> 02:20:36,700
所以大家就这么回答就行了

3344
02:20:37,720 --> 02:20:38,560
这么回答就行了

3345
02:20:38,800 --> 02:20:40,210
然后其他的一度的话

3346
02:20:40,600 --> 02:20:42,400
他就把他分为了即时和延时

3347
02:20:43,230 --> 02:20:46,350
及时和任务和原始任务当然不管事

3348
02:20:46,350 --> 02:20:48,990
即时延时任务的话就等及时任务的话

3349
02:20:49,320 --> 02:20:52,200
就把它一个一个的放在mes牵扯的回调里

3350
02:20:53,130 --> 02:20:53,880
大家看

3351
02:20:53,970 --> 02:20:59,040
每一个都是放在他并不是放在同一个S1000里地

3352
02:21:00,220 --> 02:21:01,720
同学

3353
02:21:01,720 --> 02:21:03,100
这点儿这点儿在

3354
02:21:05,890 --> 02:21:09,370
比如一个任务他走到了这里

3355
02:21:09,370 --> 02:21:10,570
第一个任务走到了这里

3356
02:21:11,110 --> 02:21:12,250
他是不是放到了

3357
02:21:12,900 --> 02:21:13,680
一个红楼梦

3358
02:21:14,470 --> 02:21:15,640
如果第二个任务在这里

3359
02:21:15,640 --> 02:21:17,860
他会放到下一个宏任务

3360
02:21:18,190 --> 02:21:19,300
是下一个红任务

3361
02:21:19,480 --> 02:21:20,080
能理解吗

3362
02:21:20,530 --> 02:21:21,700
比如说这是一条线

3363
02:21:22,060 --> 02:21:23,350
这是当前的时间

3364
02:21:24,050 --> 02:21:24,980
当前时间线

3365
02:21:26,300 --> 02:21:27,680
这是当前的时间线

3366
02:21:29,170 --> 02:21:31,510
这个是主线长

3367
02:21:31,540 --> 02:21:32,290
这是微任务

3368
02:21:32,290 --> 02:21:33,550
这是红任务对吧

3369
02:21:35,160 --> 02:21:36,240
下一个

3370
02:21:38,560 --> 02:21:41,800
主线程任务红任务

3371
02:21:41,800 --> 02:21:42,970
第一个任务放这儿

3372
02:21:43,620 --> 02:21:44,670
第二个任务放这儿

3373
02:21:45,220 --> 02:21:47,920
第三个任务就一直往下放对吧

3374
02:21:48,250 --> 02:21:50,020
那么他是不是就不会被堵塞了

3375
02:21:50,020 --> 02:21:51,670
这种情况下他就很难被堵塞了

3376
02:21:52,800 --> 02:21:54,660
所以他并不是放在同一个通道

3377
02:21:55,650 --> 02:21:57,030
然后在执行的时候呢

3378
02:21:58,220 --> 02:22:00,650
每次都会掉兑现执行的话是timer

3379
02:22:01,130 --> 02:22:01,760
然后呢

3380
02:22:01,880 --> 02:22:03,260
再添加到他这个空中

3381
02:22:03,680 --> 02:22:06,050
一直一直后面去调查咨询

3382
02:22:07,500 --> 02:22:07,980
这些

3383
02:22:09,400 --> 02:22:10,360
这个是

3384
02:22:11,050 --> 02:22:12,370
咱们的schedule

3385
02:22:14,720 --> 02:22:15,260
Skate

3386
02:22:15,260 --> 02:22:16,400
我们再来回看一下

3387
02:22:16,400 --> 02:22:18,500
回看一下我之前给大家写的

3388
02:22:18,500 --> 02:22:19,430
大家看一下对不对

3389
02:22:20,120 --> 02:22:24,350
比如第一个逻辑是根据优先级区分同步和任务同步

3390
02:22:24,740 --> 02:22:26,540
任务立即同步执行在实践中

3391
02:22:27,200 --> 02:22:27,680
也不怎么

3392
02:22:27,680 --> 02:22:29,270
就是感觉这这红忍不住

3393
02:22:29,960 --> 02:22:31,130
然后呢

3394
02:22:31,130 --> 02:22:33,380
标志性的就是update的

3395
02:22:33,380 --> 02:22:36,260
Update right down典论的之所以特殊

3396
02:22:36,260 --> 02:22:38,090
也是因为他把那个

3397
02:22:38,480 --> 02:22:41,840
也是因为他把他的这个函数放在a sharp的当中的

3398
02:22:42,640 --> 02:22:44,560
就是他之所以比较特殊一点

3399
02:22:44,560 --> 02:22:46,090
就是因为把它放在里面了吗

3400
02:22:48,800 --> 02:22:50,840
所以同步和异步的区分

3401
02:22:51,520 --> 02:22:53,230
第二个就是计算X减X

3402
02:22:54,090 --> 02:22:59,340
然后第三个就是对比star k X把它分为即时和延时任务

3403
02:22:59,610 --> 02:23:01,380
即使任务当即延时任务

3404
02:23:01,380 --> 02:23:04,350
等到慨叹大于四大叹才会调度执行

3405
02:23:05,180 --> 02:23:05,930
然后呢

3406
02:23:06,050 --> 02:23:07,220
在红任务重自己

3407
02:23:08,220 --> 02:23:09,870
不只是要用界面的交互

3408
02:23:10,500 --> 02:23:10,980
对不对

3409
02:23:12,360 --> 02:23:14,310
然后我们再来一遍

3410
02:23:14,700 --> 02:23:15,270
第一个

3411
02:23:15,630 --> 02:23:18,090
这个代码其实非常简单了

3412
02:23:18,180 --> 02:23:20,400
烂等于sig man对吧

3413
02:23:20,700 --> 02:23:25,080
Execution context与3a context不等于context

3414
02:23:25,620 --> 02:23:26,460
然后就

3415
02:23:27,650 --> 02:23:30,530
直接到下一个re consider接上去

3416
02:23:30,950 --> 02:23:32,570
剩下的那么都走一步

3417
02:23:32,690 --> 02:23:33,350
掉入逻辑

3418
02:23:35,040 --> 02:23:36,150
这儿会有一个

3419
02:23:36,780 --> 02:23:38,370
会有一个复用的一个逻辑

3420
02:23:38,550 --> 02:23:41,070
同时就是一个缓存重用他的一个逻辑

3421
02:23:41,340 --> 02:23:44,250
那么我们的连续存在的CS data

3422
02:23:44,940 --> 02:23:48,870
您现在现在就被优化掉了这个这个逻辑

3423
02:23:49,640 --> 02:23:52,880
接下来就是把它放到我们的

3424
02:23:53,620 --> 02:23:57,130
把它放在我们的schedule back就是计算expression to了

3425
02:23:58,480 --> 02:23:59,680
计算XX

3426
02:23:59,710 --> 02:24:00,370
然后呢

3427
02:24:00,700 --> 02:24:03,370
把它区分成不同的任务

3428
02:24:03,400 --> 02:24:04,570
一个是即时任务

3429
02:24:05,020 --> 02:24:06,040
一个岩石任务

3430
02:24:06,890 --> 02:24:07,670
即使任务的话

3431
02:24:07,670 --> 02:24:08,870
那么就发起调度

3432
02:24:08,900 --> 02:24:10,220
原始任务的话就等着

3433
02:24:10,980 --> 02:24:12,030
发起调度之后

3434
02:24:12,480 --> 02:24:14,520
把它通过message channel这儿

3435
02:24:14,520 --> 02:24:16,560
这儿其实信息量还是蛮大的

3436
02:24:17,160 --> 02:24:21,390
因为有很多有很多东西可能带来试试新鲜的玩意儿

3437
02:24:21,660 --> 02:24:22,560
比如说C1000了

3438
02:24:22,560 --> 02:24:24,690
大家下来可以再看看S7000了

3439
02:24:24,690 --> 02:24:25,830
反正是个红任务

3440
02:24:26,320 --> 02:24:30,790
当POINT2的post message发起的时候

3441
02:24:30,970 --> 02:24:34,090
Pet pet1的on message这个回调会执行

3442
02:24:34,880 --> 02:24:36,920
而且在红任务当中执行

3443
02:24:37,160 --> 02:24:37,700
因此

3444
02:24:38,980 --> 02:24:42,580
因此我们就可以做到最上面的这个

3445
02:24:43,570 --> 02:24:47,050
这个像做到这上面的这个效果就是什么呢

3446
02:24:48,420 --> 02:24:49,590
这个上面的这个

3447
02:24:51,040 --> 02:24:52,480
这样子的效果对吧

3448
02:24:53,560 --> 02:24:55,360
这样子效果就是可以实现的

3449
02:24:55,960 --> 02:24:56,650
这个就是

3450
02:24:58,060 --> 02:24:59,200
就是因为他放在了

3451
02:24:59,230 --> 02:25:00,970
放在了每次签到当中执行

3452
02:25:01,000 --> 02:25:03,910
其实这段其实已经删了不少代码了

3453
02:25:04,540 --> 02:25:09,430
原来的时候他还他之前他是通过request idle call back

3454
02:25:09,670 --> 02:25:11,320
如果大家看过一些文章的话

3455
02:25:12,560 --> 02:25:13,040
应该

3456
02:25:13,780 --> 02:25:16,420
会对这个有一些会有一些文章有印象

3457
02:25:16,420 --> 02:25:17,650
他会他会介绍

3458
02:25:17,650 --> 02:25:19,810
就是它是通过request idle call back

3459
02:25:20,640 --> 02:25:22,590
然后在每一天的空闲时间

3460
02:25:22,590 --> 02:25:24,540
他会利用他的空闲时间来执行

3461
02:25:26,940 --> 02:25:27,300
对

3462
02:25:27,570 --> 02:25:28,500
他们说的没错

3463
02:25:28,710 --> 02:25:30,330
但是现在这个代码里没有了

3464
02:25:30,360 --> 02:25:31,800
原因是已经被删掉了

3465
02:25:32,460 --> 02:25:34,410
应该是之前

3466
02:25:34,410 --> 02:25:35,490
我看了一下那个

3467
02:25:36,000 --> 02:25:39,240
别人问他就是外国外有网友问为什么

3468
02:25:39,240 --> 02:25:42,780
就是把那个request that a call back

3469
02:25:43,690 --> 02:25:44,440
给删掉

3470
02:25:44,470 --> 02:25:47,110
他就他觉得首先那个东西

3471
02:25:47,500 --> 02:25:50,290
首先这个东西效果不是特别明显

3472
02:25:50,320 --> 02:25:52,450
其次增大了复杂度

3473
02:25:52,570 --> 02:25:54,430
复杂度显著的增高了

3474
02:25:54,790 --> 02:25:57,400
确实之前那个逻辑看到我也头疼

3475
02:25:57,580 --> 02:25:58,060
我也头疼

3476
02:25:58,060 --> 02:25:59,770
特别麻烦特别麻烦

3477
02:26:00,220 --> 02:26:01,420
所以后面更新的版本

3478
02:26:01,420 --> 02:26:03,130
他已经把那块代码给删掉了

3479
02:26:04,470 --> 02:26:06,480
删掉了就变成现在这样了

3480
02:26:06,480 --> 02:26:08,880
就已经没有通过u CAS I call back来做了

3481
02:26:09,450 --> 02:26:11,910
实际上我们现在所讲的ROC时期

3482
02:26:13,210 --> 02:26:15,580
有一些东西在RIGHT18里也优化

3483
02:26:15,760 --> 02:26:19,360
这个优化的东西我会给大家讲到

3484
02:26:19,480 --> 02:26:20,050
给大家讲到

3485
02:26:20,050 --> 02:26:21,220
但现在还没有涉及到

3486
02:26:22,000 --> 02:26:23,320
只是说这么一嘴

3487
02:26:23,560 --> 02:26:26,890
只是市面上有通过request that call back这样的文章

3488
02:26:27,040 --> 02:26:27,670
我也看过

3489
02:26:28,090 --> 02:26:29,230
他说的确实也对

3490
02:26:29,380 --> 02:26:30,520
但是版本不一样

3491
02:26:31,000 --> 02:26:31,870
但版本不一样

3492
02:26:32,670 --> 02:26:33,840
所以要有信心

3493
02:26:34,290 --> 02:26:35,610
不要不要

3494
02:26:35,670 --> 02:26:36,960
你可以自己去看一下

3495
02:26:36,990 --> 02:26:40,260
可以自己到时候在大门里去看一下

3496
02:26:40,290 --> 02:26:42,720
现在它就已经没有了开赛的卡bug了

3497
02:26:44,630 --> 02:26:45,440
执行了

3498
02:26:46,200 --> 02:26:47,460
执行宏任务

3499
02:26:48,170 --> 02:26:49,730
在红任务里执行任务

3500
02:26:50,090 --> 02:26:53,600
在红任务里执行

3501
02:26:53,600 --> 02:26:56,540
好好那个哇噻

3502
02:26:57,020 --> 02:26:57,920
在红肉里

3503
02:26:58,540 --> 02:27:00,010
执行那个同步的任务

3504
02:27:01,010 --> 02:27:02,540
每一个的每一个执行的时候

3505
02:27:02,540 --> 02:27:04,370
他都会去判断一个俄罗斯timer

3506
02:27:04,430 --> 02:27:10,670
然后他会把他们村里面的原始任务判断她的私探是不是小于当前时间

3507
02:27:10,670 --> 02:27:11,300
如果是的话

3508
02:27:11,300 --> 02:27:12,200
就把它拿出来

3509
02:27:12,590 --> 02:27:14,780
拿出来之后继续去循环

3510
02:27:14,780 --> 02:27:16,130
循环下一个

3511
02:27:16,430 --> 02:27:20,150
循环到下一个活动当中去执行

3512
02:27:20,910 --> 02:27:23,160
这就是整个调度逻辑

3513
02:27:23,160 --> 02:27:23,820
大概就这样

3514
02:27:25,930 --> 02:27:26,560
我们看一下

3515
02:27:26,590 --> 02:27:27,490
再看一下这个图

3516
02:27:29,020 --> 02:27:31,870
为了为了这块逻辑写了很多东西

3517
02:27:31,900 --> 02:27:33,400
同步优先级对吧

3518
02:27:33,430 --> 02:27:36,640
直接掉一部优先级分两个类

3519
02:27:37,280 --> 02:27:37,910
分两个类

3520
02:27:38,060 --> 02:27:39,650
但是他们都会放到她里面去

3521
02:27:40,130 --> 02:27:41,900
每次之前都会先资金要到20

3522
02:27:43,020 --> 02:27:45,150
她又会把它添加到

3523
02:27:45,960 --> 02:27:46,920
这个advance

3524
02:27:47,670 --> 02:27:50,460
就会把他们困中添加到他这个空当中去

3525
02:27:51,400 --> 02:27:53,080
也就是说这个摊位他就等嘛

3526
02:27:53,110 --> 02:27:53,350
对吧

3527
02:27:53,350 --> 02:27:53,860
他就等

3528
02:27:54,800 --> 02:27:56,180
按理说他应该是直接

3529
02:27:56,630 --> 02:27:57,770
不过这个不太会用

3530
02:28:03,990 --> 02:28:04,830
再删了吧

3531
02:28:08,010 --> 02:28:10,440
他实际上是直接把它又放到了他这个片中去

3532
02:28:11,220 --> 02:28:11,760
怎么搞的

3533
02:28:12,340 --> 02:28:14,680
这是actors OK

3534
02:28:14,680 --> 02:28:16,870
今天我们大概讲的内容就这么多

3535
02:28:17,650 --> 02:28:18,430
回顾一下吧

3536
02:28:22,470 --> 02:28:23,670
回顾一下

3537
02:28:24,750 --> 02:28:27,390
首先讲到了极点

3538
02:28:27,900 --> 02:28:30,180
就是价格的这个眼镜15

3539
02:28:31,080 --> 02:28:31,950
他有什么缺点

3540
02:28:32,190 --> 02:28:33,900
有一个长地归他就立刻不行了

3541
02:28:33,900 --> 02:28:34,740
就卡顿住了

3542
02:28:35,220 --> 02:28:35,850
16

3543
02:28:36,940 --> 02:28:38,230
它可以做到这样的效果

3544
02:28:38,940 --> 02:28:42,240
那么它是依赖于它是依赖于两两个方面

3545
02:28:42,270 --> 02:28:45,870
一个是他的调度任务变得在红任务执行

3546
02:28:45,930 --> 02:28:48,840
因此它的主线程并没有被占被完全占据

3547
02:28:49,380 --> 02:28:52,110
第二个是他对更新做了优先级

3548
02:28:52,230 --> 02:28:54,930
因此如果有多个更新同时处理

3549
02:28:55,290 --> 02:28:57,270
那么高优先级会中断的优先级的

3550
02:28:58,870 --> 02:29:03,220
但是rocket时期里又做了扩展原因做了扩展的原因已经说了

3551
02:29:03,220 --> 02:29:08,680
是因为出现了SaaS的这种高优先级IO任务会组成的优先级CPU任务

3552
02:29:08,710 --> 02:29:11,080
同样会出现页面的假死状态

3553
02:29:11,560 --> 02:29:16,270
所以lions它可以同时发起多个优先级

3554
02:29:16,660 --> 02:29:19,420
同时处理多个优先级的任务来解决这个问题

3555
02:29:19,980 --> 02:29:20,940
来解决这个问题

3556
02:29:21,850 --> 02:29:24,310
然后我们这儿看到了一些Les

3557
02:29:24,490 --> 02:29:25,540
就是Les具体的

3558
02:29:27,870 --> 02:29:29,400
Less具体的计算

3559
02:29:29,880 --> 02:29:31,230
还有less具体的计算

3560
02:29:33,290 --> 02:29:34,580
在advance具体的

3561
02:29:37,670 --> 02:29:39,530
Less

3562
02:29:40,930 --> 02:29:41,620
不在这儿吗

3563
02:29:54,480 --> 02:29:56,550
我是刚刚看到的那个我删了吗

3564
02:29:59,000 --> 02:29:59,930
嗯

3565
02:30:04,780 --> 02:30:05,800
就是这个就是这个

3566
02:30:07,060 --> 02:30:09,580
但是具体的计算逻辑这块是安慰的

3567
02:30:09,700 --> 02:30:11,620
这块我们也给大家讲到了

3568
02:30:11,620 --> 02:30:13,690
大家理解的也挺好的

3569
02:30:13,690 --> 02:30:14,890
反正理解的也挺好的

3570
02:30:14,890 --> 02:30:15,790
下来可以再看看

3571
02:30:15,790 --> 02:30:16,960
这非常的精妙

3572
02:30:17,020 --> 02:30:17,710
对安慰

3573
02:30:17,740 --> 02:30:18,430
安慰运算

3574
02:30:18,940 --> 02:30:19,870
这挺精妙的

3575
02:30:19,870 --> 02:30:20,350
我觉得

3576
02:30:21,120 --> 02:30:21,720
然后呢

3577
02:30:22,200 --> 02:30:23,550
他写的

3578
02:30:24,560 --> 02:30:25,580
他写的这个

3579
02:30:26,030 --> 02:30:28,640
这个是发布note节点以及fiber tree

3580
02:30:29,250 --> 02:30:30,480
特别是长什么样子

3581
02:30:30,840 --> 02:30:32,310
然后大致的调度逻辑

3582
02:30:32,700 --> 02:30:33,870
然后给大家讲到了

3583
02:30:33,900 --> 02:30:35,250
以及render

3584
02:30:35,980 --> 02:30:38,770
他和她为什么和其他的不一样

3585
02:30:38,770 --> 02:30:40,000
他为什么同步任务

3586
02:30:40,000 --> 02:30:41,050
其他任务不一样

3587
02:30:41,200 --> 02:30:42,340
这是因为他有那个

3588
02:30:42,340 --> 02:30:42,820
我在想

3589
02:30:43,570 --> 02:30:44,620
其实这是第一块儿

3590
02:30:44,830 --> 02:30:45,880
当我们把最后

3591
02:30:45,880 --> 02:30:49,090
把最后把钱三块全部连起来的时候

3592
02:30:49,840 --> 02:30:52,090
然后到时候在讲话的时候就会发现

3593
02:30:53,020 --> 02:30:53,860
所有的东西

3594
02:30:53,860 --> 02:30:55,570
他们就是他们就是骨骼

3595
02:30:56,050 --> 02:30:58,540
所有东西都是挂着在他们之上的

3596
02:30:59,470 --> 02:31:00,040
如果

3597
02:31:00,310 --> 02:31:01,900
如果说我们不讲这个会发生什么

3598
02:31:01,960 --> 02:31:03,520
假如假如同学们

3599
02:31:03,760 --> 02:31:04,840
假如我直接给大家讲

3600
02:31:04,840 --> 02:31:06,430
护士绝对讲不懂

3601
02:31:06,730 --> 02:31:07,150
为啥

3602
02:31:07,600 --> 02:31:08,680
因为这局

3603
02:31:08,680 --> 02:31:09,430
因为他们的

3604
02:31:09,550 --> 02:31:11,080
因为hooks这块逻辑

3605
02:31:11,230 --> 02:31:13,720
他就是挂在这三块之上的

3606
02:31:13,990 --> 02:31:15,610
如果你不懂这样

3607
02:31:15,610 --> 02:31:18,550
比如consider或者这个

3608
02:31:18,550 --> 02:31:19,270
Render阶段

3609
02:31:19,330 --> 02:31:20,560
这两块儿不明白

3610
02:31:20,890 --> 02:31:22,060
你就hooks

3611
02:31:22,060 --> 02:31:24,370
比如它的代码虽然说比较少

3612
02:31:24,730 --> 02:31:27,730
但是你看不懂他做哪行代码会有什么用

3613
02:31:28,030 --> 02:31:29,860
就是你完全不知道他作用是什么

3614
02:31:30,040 --> 02:31:32,410
这就是react的源码

3615
02:31:32,410 --> 02:31:33,790
看起来比较困难的一点

3616
02:31:34,120 --> 02:31:36,520
就是它的这个联系性特别大

3617
02:31:36,670 --> 02:31:37,510
联系性特别大

3618
02:31:37,510 --> 02:31:39,460
你如果把前面两块儿看不明白

3619
02:31:39,820 --> 02:31:41,230
那么你其他的也就不用看了

3620
02:31:41,440 --> 02:31:42,100
因为看不懂

3621
02:31:42,810 --> 02:31:45,270
他就是虽然说他可能就只有几行代码

3622
02:31:45,630 --> 02:31:50,760
可能讲代码它最后后面会发生的变化确实特别多特别多

3623
02:31:51,210 --> 02:31:52,890
就像我们Thursday to对不对

3624
02:31:52,890 --> 02:31:54,960
C EST他后面也会发生很多的变化

3625
02:31:56,000 --> 02:31:57,080
也会发生很大的变化

3626
02:31:57,080 --> 02:31:57,950
你就不行

3627
02:31:58,860 --> 02:31:59,160
对

3628
02:31:59,340 --> 02:32:01,230
护士太多whose

3629
02:32:01,230 --> 02:32:02,130
但是我们把

3630
02:32:03,430 --> 02:32:04,540
这几块搞明白了

3631
02:32:04,930 --> 02:32:05,890
我们再看hooks

3632
02:32:06,250 --> 02:32:07,090
绝对能明白

3633
02:32:07,360 --> 02:32:07,960
非常能

3634
02:32:08,050 --> 02:32:11,920
绝对能搞明白会比直接讲Linux会简单很多

3635
02:32:13,390 --> 02:32:15,400
种类种类也不是很多

3636
02:32:15,400 --> 02:32:16,360
但我们也讲不完

3637
02:32:18,450 --> 02:32:20,670
会下节课下节课会讲

3638
02:32:21,530 --> 02:32:22,970
下面一个就是re consider

3639
02:32:22,970 --> 02:32:24,320
当地府就在它中间

3640
02:32:24,680 --> 02:32:25,250
它里边儿

3641
02:32:25,850 --> 02:32:27,170
然后和render这两个

3642
02:32:30,550 --> 02:32:31,810
我看一下还有什么问题

3643
02:32:31,930 --> 02:32:34,390
批处理人等待的时间都是什么规定呢

3644
02:32:37,500 --> 02:32:37,950
什么

3645
02:32:39,180 --> 02:32:40,050
你是说

3646
02:32:41,270 --> 02:32:43,100
Petri等待的时间周期

3647
02:32:44,840 --> 02:32:45,680
是这里吗

3648
02:32:50,600 --> 02:32:52,160
可以说这里马晓巴同学

3649
02:32:53,840 --> 02:32:55,910
时钟周期是怎么规定的

3650
02:32:56,000 --> 02:32:57,050
他实际上

3651
02:32:59,970 --> 02:33:00,600
再看

3652
02:33:01,220 --> 02:33:01,760
这儿

3653
02:33:03,230 --> 02:33:05,900
他有一个科诺是周期的

3654
02:33:05,900 --> 02:33:08,120
那个可怕的内就是bug的类

3655
02:33:08,270 --> 02:33:10,100
在rock的时期

3656
02:33:10,100 --> 02:33:11,390
这在rocket时期里

3657
02:33:11,450 --> 02:33:12,440
他这么干他

3658
02:33:13,300 --> 02:33:15,010
他必须在同一个

3659
02:33:15,010 --> 02:33:16,270
她不能再红任务当中

3660
02:33:16,300 --> 02:33:17,860
也不能在cmos里边儿

3661
02:33:18,310 --> 02:33:19,240
它只能在

3662
02:33:20,010 --> 02:33:21,270
喝它放在同一级

3663
02:33:21,720 --> 02:33:22,320
也就是说

3664
02:33:23,040 --> 02:33:25,680
也就是如果说你把假如说这样

3665
02:33:26,710 --> 02:33:28,690
我把它拿出来就是

3666
02:33:30,970 --> 02:33:32,890
set set

3667
02:33:35,170 --> 02:33:35,530
对吧

3668
02:33:35,740 --> 02:33:36,100
那

3669
02:33:40,600 --> 02:33:41,440
这样写的

3670
02:33:42,860 --> 02:33:43,490
他是红

3671
02:33:43,520 --> 02:33:44,810
他那个是批处理的

3672
02:33:45,350 --> 02:33:48,320
但是如果你把它放在system out

3673
02:33:52,400 --> 02:33:55,490
当我们看到它实际上因为三帽子它就会等嘛

3674
02:33:56,240 --> 02:33:56,450
对吧

3675
02:33:56,450 --> 02:33:58,730
就会等到下一个宏任务中

3676
02:33:58,730 --> 02:34:00,590
他就把它放到了下一个宏任务重了

3677
02:34:00,950 --> 02:34:02,900
所以那即使是这样子

3678
02:34:02,900 --> 02:34:04,490
那他就已经不在一起了

3679
02:34:05,280 --> 02:34:05,970
最近不太想

3680
02:34:05,970 --> 02:34:07,590
那么它的批处理就失效了

3681
02:34:08,430 --> 02:34:09,630
放在cmos中

3682
02:34:09,870 --> 02:34:11,100
放在他帽子里

3683
02:34:11,400 --> 02:34:11,880
那么他的

3684
02:34:12,640 --> 02:34:15,310
在ROCK17中的PC是失效的

3685
02:34:15,790 --> 02:34:18,160
但是在REC18中他就不失效了

3686
02:34:18,430 --> 02:34:20,200
这就是17和18的区别

3687
02:34:20,200 --> 02:34:22,930
在18中他对这个情况做了处理

3688
02:34:23,770 --> 02:34:24,820
这人家做了处理

3689
02:34:24,820 --> 02:34:25,300
他就

3690
02:34:25,820 --> 02:34:28,160
又是在一个那个

3691
02:34:29,690 --> 02:34:31,970
时间周期内一个同一个时间周期内

3692
02:34:33,020 --> 02:34:33,980
在rock时期里

3693
02:34:33,980 --> 02:34:36,200
他是他是不同的X8又正常了

3694
02:34:36,980 --> 02:34:39,080
如果说不是在cmos之类的话

3695
02:34:39,110 --> 02:34:39,530
那么

3696
02:34:40,290 --> 02:34:42,540
你就看他的这个fiber节点

3697
02:34:43,050 --> 02:34:45,030
它的fiber节点这个科诺的

3698
02:34:45,570 --> 02:34:47,670
如果他这个科诺的

3699
02:34:49,050 --> 02:34:52,650
同样也是在一个相当于是这样的

3700
02:34:53,160 --> 02:34:54,180
对相当于是

3701
02:34:57,080 --> 02:34:58,190
还是刚刚那个图

3702
02:34:58,490 --> 02:34:59,360
还是刚刚那个图

3703
02:35:00,350 --> 02:35:01,370
他从那儿进来开始

3704
02:35:01,370 --> 02:35:04,070
它首先是一种

3705
02:35:04,130 --> 02:35:05,360
主线程进来的对不对

3706
02:35:05,360 --> 02:35:07,550
他把这个任务放倒

3707
02:35:08,140 --> 02:35:08,950
进来之后

3708
02:35:09,250 --> 02:35:11,140
他把这个任务放到了哪里

3709
02:35:11,140 --> 02:35:11,800
放倒了

3710
02:35:12,460 --> 02:35:12,760
红

3711
02:35:12,760 --> 02:35:13,480
任务当中

3712
02:35:13,720 --> 02:35:14,890
下个任务再进来

3713
02:35:15,580 --> 02:35:17,710
因此如果下一个任务再进来的时候

3714
02:35:18,070 --> 02:35:19,780
因为它还没有被执行嘛

3715
02:35:19,780 --> 02:35:21,370
所以这个课根本还存在

3716
02:35:21,910 --> 02:35:23,170
就这进来一个

3717
02:35:23,770 --> 02:35:24,790
下一个又进来了

3718
02:35:24,910 --> 02:35:25,600
因为红

3719
02:35:25,660 --> 02:35:27,370
因为他吧放在红色当中了

3720
02:35:27,670 --> 02:35:28,930
它是客观工作还存在

3721
02:35:28,930 --> 02:35:30,460
所以他就可以服用

3722
02:35:30,730 --> 02:35:32,530
如果你把它放在C盘猫在里边

3723
02:35:32,860 --> 02:35:33,370
那么

3724
02:35:34,220 --> 02:35:34,640
那么

3725
02:35:35,300 --> 02:35:38,000
当你执行赛模特的时候

3726
02:35:38,030 --> 02:35:39,530
这个红任务就已经执行了

3727
02:35:39,530 --> 02:35:40,280
我刚刚讲过

3728
02:35:40,430 --> 02:35:42,200
他会在三没得之前执行

3729
02:35:42,840 --> 02:35:43,710
山猫之前执行

3730
02:35:43,710 --> 02:35:46,740
所以所以也放在C大猫的里执行

3731
02:35:47,280 --> 02:35:48,210
它就等不到了

3732
02:35:48,270 --> 02:35:49,680
那么下一次他就失效了

3733
02:35:50,450 --> 02:35:54,020
如果说你是在他执行之前

3734
02:35:54,500 --> 02:35:56,330
就在这个红任务执行之前

3735
02:35:56,720 --> 02:35:58,340
一直有新的任务进来

3736
02:35:59,380 --> 02:36:03,790
那么她是会一直在同一个时钟周期内的四个周期内的

3737
02:36:10,720 --> 02:36:11,020
对

3738
02:36:11,020 --> 02:36:12,370
是的是的

3739
02:36:13,040 --> 02:36:16,430
所以但是这个是在class里边儿

3740
02:36:16,880 --> 02:36:17,720
如果是

3741
02:36:18,020 --> 02:36:19,880
如果你是在那个hooks中

3742
02:36:19,910 --> 02:36:20,840
比如hooks中的话

3743
02:36:20,840 --> 02:36:21,440
他就不一样

3744
02:36:21,500 --> 02:36:23,180
X中他没有批处理

3745
02:36:23,660 --> 02:36:26,780
可以hooks中他没有做自动的批处理

3746
02:36:27,410 --> 02:36:30,170
这个我们讲hooks会给大家区分一下

3747
02:36:30,200 --> 02:36:31,490
现在只是给大家说一嘴

3748
02:36:31,790 --> 02:36:32,720
这针对的是啥

3749
02:36:32,720 --> 02:36:34,850
我这写的一直是distance is state

3750
02:36:35,510 --> 02:36:36,440
如果是护士

3751
02:36:36,740 --> 02:36:37,580
比如他通过

3752
02:36:37,850 --> 02:36:39,440
比如说这个name

3753
02:36:39,440 --> 02:36:40,910
比如就算是同一个

3754
02:36:41,630 --> 02:36:44,120
就算是同一个连续的东西

3755
02:36:44,270 --> 02:36:45,530
塞name c的edge

3756
02:36:48,360 --> 02:36:49,560
那么他同样要发

3757
02:36:49,890 --> 02:36:51,570
他同样要发起两次更新

3758
02:36:51,720 --> 02:36:54,930
因为在hooks在17中它是不支持

3759
02:36:55,440 --> 02:36:58,230
在17中它是不支持自动做批处理的

3760
02:36:58,230 --> 02:36:59,040
你得自己做

3761
02:36:59,690 --> 02:37:01,010
你自己做还是不一样

3762
02:37:01,040 --> 02:37:02,150
还是有点不一样的地方

3763
02:37:03,890 --> 02:37:04,670
能明白吗

3764
02:37:08,700 --> 02:37:09,060
行

3765
02:37:09,060 --> 02:37:11,490
今天的内容大概就讲到这儿

3766
02:37:11,820 --> 02:37:12,960
讲了两个小时

3767
02:37:13,050 --> 02:37:13,800
希望大家

3768
02:37:14,400 --> 02:37:18,030
然后后面的话也是周天周天的话我们再见

3769
02:37:18,750 --> 02:37:19,110
再见

3770
02:37:19,110 --> 02:37:19,620
再见吧

3771
02:37:22,560 --> 02:37:23,040
好的

3772
02:37:23,430 --> 02:37:24,480
谢谢同学们

3773
02:37:24,510 --> 02:37:25,020
拜拜

